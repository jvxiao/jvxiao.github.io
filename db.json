{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/fluid.png","path":"img/fluid.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/boot.js","path":"js/boot.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/events.js","path":"js/events.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/plugins.js","path":"js/plugins.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/umami-view.js","path":"js/umami-view.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/drawn.jpg","path":"img/drawn.jpg","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/wild-fire.jpg","path":"img/wild-fire.jpg","modified":0,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/baidu_verify_codeva-fVR3SShMVh.html","path":"baidu_verify_codeva-fVR3SShMVh.html","modified":0,"renderable":0},{"_id":"themes/fluid/source/img/favicon.jpg","path":"img/favicon.jpg","modified":0,"renderable":1},{"_id":"source/imgs/微信云对象存储..png","path":"imgs/微信云对象存储..png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog1/blog2.jpg","path":"imgs/build-blog1/blog2.jpg","modified":0,"renderable":0},{"_id":"source/imgs/build-blog1/blog1.jpg","path":"imgs/build-blog1/blog1.jpg","modified":0,"renderable":0},{"_id":"source/imgs/build-blog1/blog3.jpg","path":"imgs/build-blog1/blog3.jpg","modified":0,"renderable":0},{"_id":"source/imgs/build-blog1/blog4.jpg","path":"imgs/build-blog1/blog4.jpg","modified":0,"renderable":0},{"_id":"source/imgs/build-blog1/blog5.jpg","path":"imgs/build-blog1/blog5.jpg","modified":0,"renderable":0},{"_id":"source/imgs/build-blog1/blog6.jpg","path":"imgs/build-blog1/blog6.jpg","modified":0,"renderable":0},{"_id":"source/imgs/build-blogs2/my-sit.png","path":"imgs/build-blogs2/my-sit.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blogs2/step3.png","path":"imgs/build-blogs2/step3.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blogs2/step1.png","path":"imgs/build-blogs2/step1.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blogs2/step2.png","path":"imgs/build-blogs2/step2.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blogs2/step4.png","path":"imgs/build-blogs2/step4.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blogs2/step5.png","path":"imgs/build-blogs2/step5.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blogs2/step6.png","path":"imgs/build-blogs2/step6.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog1/step1.png","path":"imgs/build-blog1/step1.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/site-generator.png","path":"imgs/build-blog3/site-generator.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/site-generator2.png","path":"imgs/build-blog3/site-generator2.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/Node1.png","path":"imgs/build-blog3/Node1.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/Node2.png","path":"imgs/build-blog3/Node2.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/Node3.png","path":"imgs/build-blog3/Node3.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/Node4.png","path":"imgs/build-blog3/Node4.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/Node5.png","path":"imgs/build-blog3/Node5.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/NodeSite.png","path":"imgs/build-blog3/NodeSite.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/Node-folder.png","path":"imgs/build-blog3/Node-folder.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/step2.png","path":"imgs/build-blog3/step2.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/landscape.png","path":"imgs/build-blog3/landscape.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/environment1.png","path":"imgs/build-blog3/environment1.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/environment2.png","path":"imgs/build-blog3/environment2.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/environment3.png","path":"imgs/build-blog3/environment3.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/environment4.png","path":"imgs/build-blog3/environment4.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/environment5.png","path":"imgs/build-blog3/environment5.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/success.png","path":"imgs/build-blog3/success.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/md2html.png","path":"imgs/build-blog3/md2html.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/hexo.png","path":"imgs/build-blog3/hexo.png","modified":0,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":0,"renderable":0},{"_id":"source/b9845fe647a6579b4eb9925de54a5832.txt","path":"b9845fe647a6579b4eb9925de54a5832.txt","modified":0,"renderable":0},{"_id":"source/BingSiteAuth.xml","path":"BingSiteAuth.xml","modified":0,"renderable":0},{"_id":"source/imgs/build-blog4/actions.png","path":"imgs/build-blog4/actions.png","modified":0,"renderable":0},{"_id":"source/imgs/bad-code/en.jfif","path":"imgs/bad-code/en.jfif","modified":0,"renderable":0}],"Cache":[{"_id":"source/about/index.md","hash":"364ec52c99b2cc1874316e9ae5da6d564fd88671","modified":1750168462433},{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1747930697042},{"_id":"themes/fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1747229156000},{"_id":"themes/fluid/.editorconfig","hash":"b595159772f3ee1ef5e6780ce307270e741cb309","modified":1748000395336},{"_id":"themes/fluid/.gitattributes","hash":"3e00e1fb043438cd820d94ee3dc9ffb6718996f3","modified":1748000395336},{"_id":"themes/fluid/.gitignore","hash":"9ede98b8d9dca802f82f651afb3b0366d69f05f1","modified":1748000395339},{"_id":"themes/fluid/.eslintrc","hash":"3df89453e1f63051fafc90f16a8d83951050e316","modified":1748000395336},{"_id":"themes/fluid/package.json","hash":"fd6756866314aaf4b15d734a83b85aa09aa0b5ed","modified":1748000395362},{"_id":"themes/fluid/README_en.md","hash":"85656f2a23cc5e31420f0118bf5541b6e9f058b6","modified":1748000395341},{"_id":"themes/fluid/languages/en.yml","hash":"415e3403182e1282386f28b9d61343f147519163","modified":1748000395342},{"_id":"themes/fluid/README.md","hash":"b4bb8c50c0ce719b8cb37b7e3a899a9a1322c4fa","modified":1748000395340},{"_id":"themes/fluid/LICENSE","hash":"511e49f0bd8282a0d002c527474da8e1e5add393","modified":1748000395340},{"_id":"themes/fluid/languages/de.yml","hash":"f814263ded504cb4c50a8b66157bdd71f553be1b","modified":1748000395342},{"_id":"themes/fluid/languages/eo.yml","hash":"314b97a7e68093328675acfd308d839b1d772ac9","modified":1748000395342},{"_id":"themes/fluid/languages/es.yml","hash":"0ad94ddf1ca868a67b5b84aed257a30572962210","modified":1748000395343},{"_id":"themes/fluid/_config.yml","hash":"95faa2f6df4187492c4a79b49787811d0f3d2120","modified":1749737033027},{"_id":"themes/fluid/layout/404.ejs","hash":"c49974dcbda02fe720498398e9778826335459c0","modified":1748000395344},{"_id":"themes/fluid/languages/ru.yml","hash":"998112b384b574e0e29c6ea16e4c1ebce1c15a4c","modified":1748000395343},{"_id":"themes/fluid/languages/ja.yml","hash":"65a90f294f6c73245e8250e87d124630ad10b389","modified":1748000395343},{"_id":"themes/fluid/languages/zh-CN.yml","hash":"497b3dea5058f718da225a7a443e916da895ea10","modified":1748000395343},{"_id":"themes/fluid/layout/archive.ejs","hash":"c524ce76747042ec2f9ed8d5025f80e01b462b3b","modified":1748000395359},{"_id":"themes/fluid/languages/zh-HK.yml","hash":"05418d0bca261de386872be65027bf4498758788","modified":1748000395344},{"_id":"themes/fluid/languages/zh-TW.yml","hash":"ded0621e63b1f8b241be21f6e9b52d4f36edbcd0","modified":1748000395344},{"_id":"themes/fluid/layout/categories.ejs","hash":"838a68e210bddfca6d4ba070e1e2f1ca53cb7d06","modified":1748000395360},{"_id":"themes/fluid/layout/category.ejs","hash":"264f68cbf826787e683a30e1377c56c0895c7386","modified":1748000395360},{"_id":"themes/fluid/layout/about.ejs","hash":"2f3ea36713f0fa91d8d61d39fcf9e584372de818","modified":1748000395359},{"_id":"themes/fluid/layout/page.ejs","hash":"8ba210724c023d45a4564415762f3da299bd1d0e","modified":1748000395361},{"_id":"themes/fluid/layout/index.ejs","hash":"dde1f6a27c8d09c38850a691089937f181b6c035","modified":1748000395360},{"_id":"themes/fluid/.github/workflows/cr.yaml","hash":"fc31c7c6692424af1e08cd5e273a5a5814f9c577","modified":1748000395339},{"_id":"themes/fluid/layout/layout.ejs","hash":"d4ffeb7eff398dea154340794bd277f75ddeedef","modified":1748000395361},{"_id":"themes/fluid/layout/tag.ejs","hash":"e87fc58829ea214ac16e8e4f13cd5c389133697b","modified":1748000395362},{"_id":"themes/fluid/layout/links.ejs","hash":"fbed4b3d1e475b3de9d8ce05362abcc658a53408","modified":1748000395361},{"_id":"themes/fluid/.github/workflows/limit.yaml","hash":"bdbdb66da69ab7353b546f02150a6792f4787975","modified":1748000395339},{"_id":"themes/fluid/.github/workflows/publish.yaml","hash":"dcdbe1698a6ee61f741c29ef560f859f66ffa32c","modified":1748000395339},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"7db378613df2b7d13e8c428c006399a879a4a852","modified":1748000395338},{"_id":"themes/fluid/layout/post.ejs","hash":"c8da695dc1b01b715909ae6f1052ccaebdf9db4c","modified":1748000395361},{"_id":"themes/fluid/layout/tags.ejs","hash":"b7c1a6d8fc1097fc16d2300260297013cb692153","modified":1748000395362},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"7d7c1e5a1da6b4f7be6685beb4798ec76d5efd31","modified":1748000395337},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"fea63a9a5c3befd8783705eed09adf1b596a6203","modified":1748000395337},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"5cc30e7b6e7b77c8b40b182ba02a5d93d37d2fc2","modified":1748000395338},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"07e24578c25fcaca94618fd86569887dadf7a276","modified":1748000395338},{"_id":"themes/fluid/layout/_partials/category-chains.ejs","hash":"508254a648d8597e62e4012c8beab44bfa82e904","modified":1748000395345},{"_id":"themes/fluid/layout/_partials/archive-list.ejs","hash":"78c34e32746041f23678669bbadfbede15e4c6d2","modified":1748000395345},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question.md","hash":"102213e5d6790d060c0e26b4a3a7ec744d753c52","modified":1748000395338},{"_id":"themes/fluid/layout/_partials/comments.ejs","hash":"1ce9094faec6204949cdaf604aaf9200787e4218","modified":1748000395346},{"_id":"themes/fluid/layout/_partials/category-list.ejs","hash":"0c14869e15f7dc615c8353765569644238f38f2d","modified":1748000395345},{"_id":"themes/fluid/layout/_partials/footer.ejs","hash":"6bb3335b5486d4bee2ed42f8bef57903066bc234","modified":1748000395350},{"_id":"themes/fluid/layout/_partials/header.ejs","hash":"3668304d08c48b68d532532921a12069a2736150","modified":1748000395352},{"_id":"themes/fluid/layout/_partials/css.ejs","hash":"901280e6fb3194c30542751d04f27e78b42d3c6f","modified":1748000395350},{"_id":"themes/fluid/layout/_partials/head.ejs","hash":"a0bcbbfc34efaef3b23c6b531e7f3201f2eab2dd","modified":1748000395351},{"_id":"themes/fluid/scripts/events/index.js","hash":"6c3b24207e4ea3ae4edeb715af40ef23711b92b9","modified":1748000395363},{"_id":"themes/fluid/scripts/filters/default-injects.js","hash":"3d30c722b9e24c33577d6fab822628841fadf992","modified":1748000395366},{"_id":"themes/fluid/layout/_partials/paginator.ejs","hash":"0d443f23c459787338917900f50fec1c8b3b3bdd","modified":1748000395353},{"_id":"themes/fluid/scripts/generators/index-generator.js","hash":"3550976efc94500284795f13485f5a1765fc120b","modified":1748000395367},{"_id":"themes/fluid/scripts/filters/locals.js","hash":"2340a576635b16fd2456b3494f5afe89cd7764db","modified":1748000395366},{"_id":"themes/fluid/layout/_partials/markdown-plugins.ejs","hash":"b5cd435b27f090939b6051bef41a38a3376044ac","modified":1748000395353},{"_id":"themes/fluid/scripts/filters/post-filter.js","hash":"67637461e3f94f9e9675369eb7ff015355d9ec54","modified":1748000395367},{"_id":"themes/fluid/scripts/generators/local-search.js","hash":"33427308ca29f1d76336c83e704571c9de75df02","modified":1748000395367},{"_id":"themes/fluid/scripts/generators/pages.js","hash":"3fb72d3c2224c32d861a6e8a85e78a8b67e6a244","modified":1748000395368},{"_id":"themes/fluid/scripts/tags/button.js","hash":"e1d0caed12e7cd9a35cf64272c41854b2901a58f","modified":1748000395371},{"_id":"themes/fluid/source/css/highlight-dark.styl","hash":"c74d7aed425d20f2fa096f386a9521b67b9ab269","modified":1748000395389},{"_id":"themes/fluid/layout/_partials/scripts.ejs","hash":"89fc9f663a1091911b79ab9697c09446d16184f9","modified":1748000395358},{"_id":"themes/fluid/layout/_partials/search.ejs","hash":"57a0f61242d9ce2bd2c51b2f84193f6dc1377ef9","modified":1748000395359},{"_id":"themes/fluid/scripts/tags/checkbox.js","hash":"1ff4ea054f2c735dfaccb0be90f1708a2a750bc8","modified":1748000395372},{"_id":"themes/fluid/source/css/highlight.styl","hash":"57ce8b8f95ab1f40612a9dce1793de5ab9b4bbfc","modified":1748000395390},{"_id":"themes/fluid/scripts/tags/fold.js","hash":"a93e2603021ad38714e870399767bea24e7cbe3e","modified":1748000395372},{"_id":"themes/fluid/scripts/tags/label.js","hash":"6c5916d86c63795c7e910bf614b0e7ece5073702","modified":1748000395373},{"_id":"themes/fluid/source/css/main.styl","hash":"9e9171325bb7148c11ceee283d00c137c8a1c5c5","modified":1748000395390},{"_id":"themes/fluid/scripts/tags/group-image.js","hash":"cc176cc1d7e7cc28cedf8397ae748c691d140be2","modified":1748000395372},{"_id":"themes/fluid/scripts/tags/note.js","hash":"e300ec4ee6c63464859ab000e987bf8dd7db4025","modified":1748000395373},{"_id":"themes/fluid/source/css/gitalk.css","hash":"1fe60b2ab1d704f5a4f55e700dca5b8785fb390e","modified":1748000395389},{"_id":"themes/fluid/scripts/tags/mermaid.js","hash":"dbfe59fde77d87b1d7d0c46480a2a729010988eb","modified":1748000395373},{"_id":"themes/fluid/scripts/helpers/date.js","hash":"9bc9ba08d1d871394ee1c3a1cc2f21dc343f515a","modified":1748000395368},{"_id":"themes/fluid/scripts/helpers/import.js","hash":"f9821f7789ea6f069977a8c642aa5ccb6d19077c","modified":1748000395369},{"_id":"themes/fluid/scripts/helpers/engine.js","hash":"96af7e55fdbe0819bacc554ecbfe42375a088df6","modified":1748000395368},{"_id":"themes/fluid/scripts/helpers/export-config.js","hash":"14a207a7d4e329382ab5d4e1da1ef85ff043daba","modified":1748000395368},{"_id":"themes/fluid/scripts/helpers/injects.js","hash":"9219d59c51930c7a82fcde918d6efbc5aa572ea2","modified":1748000395369},{"_id":"themes/fluid/scripts/helpers/page.js","hash":"49b2c6449d7be35739c6cfea3cab4e790580983a","modified":1748000395369},{"_id":"themes/fluid/scripts/helpers/scope.js","hash":"3b67d50050158423c8fa47f1de6aedcfe916637b","modified":1748000395370},{"_id":"themes/fluid/scripts/helpers/url.js","hash":"f713ddb6c8018ec7b96d3567057f1f932609beea","modified":1748000395370},{"_id":"themes/fluid/scripts/helpers/utils.js","hash":"f57be245e6e7228673e1dec3a3477e731492c5c1","modified":1748000395370},{"_id":"themes/fluid/scripts/helpers/wordcount.js","hash":"0bb33314aa5cfe326ab9bb14b545e343e4db4193","modified":1748000395371},{"_id":"themes/fluid/scripts/utils/compare-versions.js","hash":"37f90bd4e35ce49457dc2a348b9f66e0b242c014","modified":1748000395374},{"_id":"themes/fluid/scripts/utils/crypto.js","hash":"474b00a57f43dbe7bc2876d637ece4214d016c06","modified":1748000395374},{"_id":"themes/fluid/scripts/utils/object.js","hash":"3e03b534e2e92a6e17567b006d7e3eaad4b37598","modified":1748000395374},{"_id":"themes/fluid/scripts/utils/resolve.js","hash":"a5d70005913ab03cea0a0dc601097628b4dbd5a8","modified":1748000395375},{"_id":"themes/fluid/scripts/utils/url-join.js","hash":"dbdb10b23fcd3928e86a4cb46fa3455e060b4aa0","modified":1748000395375},{"_id":"themes/fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1747229156000},{"_id":"themes/fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1747229156000},{"_id":"themes/fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1747229156000},{"_id":"themes/fluid/source/js/boot.js","hash":"33bb7c8255d2e3c93a1bea8c9221399b3a868a63","modified":1748000395393},{"_id":"themes/fluid/source/js/img-lazyload.js","hash":"67f6250f98b36a6599ea982d11cbb060c5ffb92a","modified":1748000395394},{"_id":"themes/fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1747229156000},{"_id":"themes/fluid/source/js/color-schema.js","hash":"e7addcc88eb73dec4a9a8641a4bb68966a38a65d","modified":1748000395393},{"_id":"themes/fluid/source/js/events.js","hash":"3efd602cdb694902d6e74c4eb1e5bd70120ac5b1","modified":1748000395394},{"_id":"themes/fluid/source/js/leancloud.js","hash":"e9ad1b5659f0af867174687daa0ecf4375e40b75","modified":1748000395394},{"_id":"themes/fluid/source/js/local-search.js","hash":"491021125d2579e841c83f36d3ab790d1eab9d1e","modified":1748000395395},{"_id":"themes/fluid/source/js/plugins.js","hash":"753c2cf95f2659fef80277b895f4da10c8888c72","modified":1748000395395},{"_id":"themes/fluid/source/js/umami-view.js","hash":"370ab30ab88c596d85327dbd7db3bafd49489fdd","modified":1748000395395},{"_id":"themes/fluid/layout/_partials/comments/changyan.ejs","hash":"0c410ef79785897c8de3da333b057a2936fd569b","modified":1748000395346},{"_id":"themes/fluid/source/xml/local-search.xml","hash":"85fcc23b4db654a7f91fc55b6fb0442bb3ed3a9a","modified":1748000395396},{"_id":"themes/fluid/source/js/utils.js","hash":"9d0423db40a787f3b19968205b9ed92a848c9153","modified":1748000395396},{"_id":"themes/fluid/layout/_partials/comments/discuss.ejs","hash":"d400e5721af28cefecaf50b46c82dcdde4cda4a8","modified":1748000395347},{"_id":"themes/fluid/layout/_partials/comments/cusdis.ejs","hash":"1e93ca89777e4beb0f0e5cb70e03aab48e958542","modified":1748000395346},{"_id":"themes/fluid/layout/_partials/comments/gitalk.ejs","hash":"7f04e5c22821bb94da791973d9c6692b03bac81d","modified":1748000395347},{"_id":"themes/fluid/layout/_partials/comments/livere.ejs","hash":"bcceafab01fe695c59951d939f7cef502f3d7b48","modified":1748000395348},{"_id":"themes/fluid/layout/_partials/comments/giscus.ejs","hash":"66995ec9dab10ed35c2a775010c447113c6848d4","modified":1748000395347},{"_id":"themes/fluid/layout/_partials/comments/disqus.ejs","hash":"79ec17eec6e15076c685688e740230e92c66efa9","modified":1748000395347},{"_id":"themes/fluid/layout/_partials/header/banner.ejs","hash":"a84d8dcb44f5f6289ef09db4d02ab14de72c2c87","modified":1748000395352},{"_id":"themes/fluid/layout/_partials/comments/remark42.ejs","hash":"45c879768b40ba56af62e18ad54bffbf73a6f3a1","modified":1748000395348},{"_id":"themes/fluid/layout/_partials/comments/twikoo.ejs","hash":"938eb60413ae8af83ffeaba4d85df88387cdd5be","modified":1748000395349},{"_id":"themes/fluid/layout/_partials/comments/utterances.ejs","hash":"d7bcc183fc31af643e7835b13da10fe2ab8614ce","modified":1748000395349},{"_id":"themes/fluid/layout/_partials/comments/valine.ejs","hash":"ef04d4fc3f26588ae9d8712938d648304fc05455","modified":1748000395349},{"_id":"themes/fluid/layout/_partials/comments/waline.ejs","hash":"df6bae1a93827991049f7a33f6a69681c60eab0e","modified":1748000395349},{"_id":"themes/fluid/layout/_partials/header/navigation.ejs","hash":"e5219b14410066bf8ab491379aca797304b4a914","modified":1748000395352},{"_id":"themes/fluid/layout/_partials/footer/statistics.ejs","hash":"047bece1db5cdf96cb78a44c6420ce3e92e6a9ca","modified":1748000395351},{"_id":"themes/fluid/layout/_partials/footer/beian.ejs","hash":"77d0c9df31a22ed8a3e341637bde4165a11a7ce9","modified":1748000395351},{"_id":"themes/fluid/layout/_partials/plugins/code-widget.ejs","hash":"03c7c69fbb1754fdccfa18671aac23b8637b869e","modified":1748000395354},{"_id":"themes/fluid/layout/_partials/plugins/analytics.ejs","hash":"f8fe8e58b83f627db82c0dbeb663389efc33c1c6","modified":1748000395353},{"_id":"themes/fluid/layout/_partials/plugins/encrypt.ejs","hash":"018cab52ff696a6c78ebc01e10237a90a0c33603","modified":1748000395354},{"_id":"themes/fluid/layout/_partials/plugins/fancybox.ejs","hash":"3900e54ade140e0e49c571a1955f0b1f3a59b281","modified":1748000395354},{"_id":"themes/fluid/layout/_partials/plugins/anchorjs.ejs","hash":"8a4ea62c46f9a75c94096a27b2d3f5c10a2f82e5","modified":1748000395354},{"_id":"themes/fluid/layout/_partials/plugins/highlight.ejs","hash":"502b99e19e496825df7032ca2b0b1a95ebb2b357","modified":1748000395355},{"_id":"themes/fluid/layout/_partials/plugins/mermaid.ejs","hash":"110e45e2d3433178f00f482adc863110f90c46d6","modified":1748000395355},{"_id":"themes/fluid/layout/_partials/plugins/nprogress.ejs","hash":"47c1df255aa552ad71ef3e57deca46530a8f2802","modified":1748000395356},{"_id":"themes/fluid/layout/_partials/post/category-bar.ejs","hash":"551ffae43844925beb099c85a9e6d8d9fcbf8086","modified":1748000395356},{"_id":"themes/fluid/layout/_partials/post/meta-bottom.ejs","hash":"f0cb813cd03642c9b68cff8b6669f73a61dd10f8","modified":1748000395357},{"_id":"themes/fluid/layout/_partials/plugins/math.ejs","hash":"d0f06fb482e3a8f9a53dfd94c4e4a65a43f1ff34","modified":1748000395355},{"_id":"themes/fluid/layout/_partials/plugins/moment.ejs","hash":"acc72c3284fe906a4505132c3d9a4720d80e6fcb","modified":1748000395355},{"_id":"themes/fluid/layout/_partials/plugins/typed.ejs","hash":"42850952e8f5858497fe774c2aff87b6563ab01e","modified":1748000395356},{"_id":"themes/fluid/layout/_partials/post/sidebar-left.ejs","hash":"db4ecdcc762bb1b1bae5060f0baa6115174779ff","modified":1748000395357},{"_id":"themes/fluid/scripts/events/lib/compatible-configs.js","hash":"31208a0db986ba864f756a8ec806b7d254440f9b","modified":1748000395363},{"_id":"themes/fluid/layout/_partials/post/copyright.ejs","hash":"26905d5862b1531ebcc175af15178dabeecc81c8","modified":1748000395357},{"_id":"themes/fluid/layout/_partials/post/sidebar-right.ejs","hash":"2507cdad08f61cf8c1d9b0ca7f4f1dc8c4e5841b","modified":1748000395358},{"_id":"themes/fluid/layout/_partials/post/meta-top.ejs","hash":"73827074db4e0fc3d52c51a76285df87aa5e5a7f","modified":1748000395357},{"_id":"themes/fluid/scripts/events/lib/footnote.js","hash":"9b1934c61dc78622a07da554413f6ad31854576d","modified":1748000395364},{"_id":"themes/fluid/scripts/events/lib/hello.js","hash":"da987411ae4a4e6896a9b8af1fce6209192af28e","modified":1748000395364},{"_id":"themes/fluid/layout/_partials/post/toc.ejs","hash":"1b1eb4c8e163a5d909e86da76ef778948e0e0b77","modified":1748000395358},{"_id":"themes/fluid/scripts/events/lib/highlight.js","hash":"d103e4bf612b2445bb136712d57b81e784a313e2","modified":1748000395364},{"_id":"themes/fluid/scripts/events/lib/injects.js","hash":"92123b7280695b4ac6650f5e1d7fa0d772c71f5b","modified":1748000395365},{"_id":"themes/fluid/scripts/events/lib/lazyload.js","hash":"c9696633f77dd8055e900497469f9e64eca4d97f","modified":1748000395365},{"_id":"themes/fluid/source/css/_functions/base.styl","hash":"171697018fd384fce0834875ca94b91f16564cac","modified":1748000395376},{"_id":"themes/fluid/scripts/events/lib/merge-configs.js","hash":"ec6bf395ccad3dd41f29dc0080aeabf413e30fd9","modified":1748000395366},{"_id":"themes/fluid/source/css/_mixins/base.styl","hash":"046979dbd8cdabd21d89f9c1d8f1bb3f2fd06d6f","modified":1748000395376},{"_id":"themes/fluid/source/css/_pages/pages.styl","hash":"92c062cf55457b6549497244d09ec34e9c0c95c2","modified":1748000395388},{"_id":"themes/fluid/source/css/_pages/_about/about.styl","hash":"8ba5fb6a8ced1de6f7893184bf12f4021fe22595","modified":1748000395377},{"_id":"themes/fluid/source/css/_pages/_archive/archive.styl","hash":"e3846fb429f6732bd15fde40f7c28b3492d786c8","modified":1748000395377},{"_id":"themes/fluid/source/css/_variables/base.styl","hash":"9ea66cf79f1e4356b6b402bc3dc5fb55c9862f1f","modified":1748000395389},{"_id":"themes/fluid/source/css/_pages/_category/category-bar.styl","hash":"f35415bd86b5c26fbc71728048d9e1481263554f","modified":1748000395384},{"_id":"themes/fluid/source/css/_pages/_base/base.styl","hash":"cd255079553985722ee80fb1833f6507dde52194","modified":1748000395383},{"_id":"themes/fluid/source/css/_pages/_base/color-schema.styl","hash":"66d5b045c0e54001d3c98c5901d72590fe08acc4","modified":1748000395383},{"_id":"themes/fluid/source/css/_pages/_base/inline.styl","hash":"96c3bb95dea4b3d3ecd20b810a674bfcef04870c","modified":1748000395383},{"_id":"themes/fluid/source/css/_pages/_base/print.styl","hash":"571bd018e914bd0f7c5f89df874b5937937e5fa6","modified":1748000395384},{"_id":"themes/fluid/source/css/_pages/_base/keyframes.styl","hash":"58a7f8f2baea2d58cf5f7edfc91314ee5d7156ca","modified":1748000395383},{"_id":"themes/fluid/source/css/_pages/_index/index.styl","hash":"bac20c8fb20276b08972df5ecc7a5850a72393f4","modified":1748000395385},{"_id":"themes/fluid/source/css/_pages/_category/category-chain.styl","hash":"4263f7b930e6b57e13295d17fd3745a9e5c52494","modified":1748000395384},{"_id":"themes/fluid/source/css/_pages/_category/category-list.styl","hash":"d3aeb7bf22d52d7dde59b292090ef8b46943718a","modified":1748000395385},{"_id":"themes/fluid/source/css/_pages/_links/links.styl","hash":"d3ef491fd449d89a1b95801dee788a5d9bec4320","modified":1748000395385},{"_id":"themes/fluid/source/css/_pages/_post/highlight.styl","hash":"d73cccb65eaa804910884df17442e34736b3f4fb","modified":1748000395386},{"_id":"themes/fluid/source/css/_pages/_post/comment.styl","hash":"1fc96d09d52d9502e84e4e2a8d482ea45e8b81ea","modified":1748000395386},{"_id":"themes/fluid/source/css/_pages/_tag/tags.styl","hash":"29e9b72cfda2f2baf9cf2597fcd7f9e66303a9bd","modified":1748000395388},{"_id":"themes/fluid/source/css/_pages/_post/markdown.styl","hash":"2d12f23b46d0ce07ae810bc4f5635c490a098fa4","modified":1748000395387},{"_id":"themes/fluid/source/css/_pages/_post/post-page.styl","hash":"6a35a450bd0a12f68fd92aac3f88b23475a98d46","modified":1748000395387},{"_id":"themes/fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"26d65475b1c52a61115044db8883df6739c3a473","modified":1748000395378},{"_id":"themes/fluid/source/css/_pages/_post/post-tag.styl","hash":"31c64c3fae4a0fc4747d8afeb72f7a9667c5326c","modified":1748000395387},{"_id":"themes/fluid/source/css/_pages/_base/_widget/board.styl","hash":"1068d71721baeed76bf0176f9b964d36b5764c9f","modified":1748000395378},{"_id":"themes/fluid/source/css/_pages/_base/_widget/banner.styl","hash":"80301db38e448e40e88bb34d0128628b0809b243","modified":1748000395378},{"_id":"themes/fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"417a7388b39c0203178b0032e151febd66a0e9f3","modified":1748000395379},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"41935973a66c14ab2bea0539d4b1f15c62534fa4","modified":1748000395380},{"_id":"themes/fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"3ac1eb36e124adef607775aa505386d5680960e2","modified":1748000395379},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footer.styl","hash":"e6f5921ff9009c1853e7db30c482bc1682433ed9","modified":1748000395379},{"_id":"themes/fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"48799d3148ef6493be0e05897c635124e9b05d03","modified":1748000395381},{"_id":"themes/fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"8fad325e411bc83c8ebdc4115015477eed5f60da","modified":1748000395381},{"_id":"themes/fluid/source/css/_pages/_base/_widget/header.styl","hash":"88c3c2d99a097142a87eeec0c7c65a3789f25117","modified":1748000395380},{"_id":"themes/fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"f4ae7cbf2f10f459de7864f8e642553b587df889","modified":1748000395381},{"_id":"themes/fluid/source/css/_pages/_base/_widget/modal.styl","hash":"0ca6171ce262339e0e36cfea0978b554d87ae7fc","modified":1748000395380},{"_id":"themes/fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"04447d3b673be84a1af1dc57933a3c41dd7c0cfe","modified":1748000395381},{"_id":"themes/fluid/source/css/_pages/_base/_widget/search.styl","hash":"1f4e678d7219815ab62de1b92ec75e021247f90b","modified":1748000395382},{"_id":"themes/fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"e4dbbbb1a2508a72bc04680552d7ebbea0eed0fe","modified":1748000395382},{"_id":"themes/fluid/source/css/_pages/_base/_widget/toc.styl","hash":"5defef321e3e933fe84f3f2ca481c88f55381fb0","modified":1748000395382},{"_id":"themes/fluid/source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1747229156000},{"_id":"source/_posts/Array-set-map summary.md","hash":"36e53f01c4d0cd6b6f8100879302ebfe2f5f4ab4","modified":1748339859500},{"_id":"source/_posts/Dependencies-collecting of vue3.md","hash":"3cd52b2c0a9f4d73a52e0a6c277dd0097b73af59","modified":1748341041034},{"_id":"source/_posts/Differences-between-two-kinds-inherit-approches.md","hash":"ac525492c30241456bdf98946b0da402d8962c4d","modified":1750515374913},{"_id":"source/_posts/Vite-server-error.md","hash":"c07a5fa240f0986d682e67da5e09ff77c8ee50e8","modified":1750515416740},{"_id":"source/_posts/Manage-wx-could-service.md","hash":"2d53f528712b111a646a8f086e2d277023b925af","modified":1750515404677},{"_id":"public/local-search.xml","hash":"947b9f39ccdca841cb12dab02b2201e12a45134a","modified":1749475390375},{"_id":"public/about/index.html","hash":"a60cbf77a80e2519d2ca1da35b18d1229f15c113","modified":1749810743260},{"_id":"public/archives/index.html","hash":"6289737198577aba4144ad61fea5b78ea961be0d","modified":1749810743260},{"_id":"public/archives/2025/index.html","hash":"8b7350d817ba07193ee3d6a1446a60ccce146f97","modified":1749810743260},{"_id":"public/archives/2025/05/index.html","hash":"298a5f3d70097cacae6eb79555de0b1211d490c0","modified":1749810743260},{"_id":"public/404.html","hash":"6cb75f8d6165349e79d0c7318db154dd3294377c","modified":1749810743260},{"_id":"public/tags/index.html","hash":"46e78f961e252e68dcb2d4bda28d9e315d598575","modified":1749810743260},{"_id":"public/categories/index.html","hash":"b482e9495303a051eab82a210c774de2ab99f412","modified":1749810743260},{"_id":"public/links/index.html","hash":"8195d3ce63c82fbe0b188f3e42c7de151beb2b04","modified":1749810743260},{"_id":"public/2025/05/23/Vite-server-error/index.html","hash":"309bbba15bc120ee37ef672b31243fb7fd474c47","modified":1748071533101},{"_id":"public/2025/05/23/Dependencies-collecting of vue3/index.html","hash":"5725e4d0e48383682516d632deeba5180d76c7d0","modified":1748071533101},{"_id":"public/2025/05/23/Differences-between-two-kinds-inherit-approches/index.html","hash":"c54ad69352b37b3086d1a6f5a2d7f2c54a82a319","modified":1748071533101},{"_id":"public/2025/05/23/Manage-wx-could-service/index.html","hash":"41393f6be44e648e529f056f75ede8793ddc3ba6","modified":1748071533101},{"_id":"public/2025/05/23/Array-set-map summary/index.html","hash":"786108c45cedfb827bc7bc43814969e754cd7090","modified":1748071533101},{"_id":"public/index.html","hash":"12afc221f68e82ce035bf16a740210d9ae2b8d1c","modified":1749810743260},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1749475390375},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1749475390375},{"_id":"public/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1749475390375},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1749475390375},{"_id":"public/xml/local-search.xml","hash":"85fcc23b4db654a7f91fc55b6fb0442bb3ed3a9a","modified":1749475390375},{"_id":"public/css/highlight-dark.css","hash":"902294bada4323c0f51502d67cba8c3a0298952f","modified":1749475390375},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1749475390375},{"_id":"public/css/highlight.css","hash":"04d4ddbb5e1d1007447c2fe293ee05aae9b9563e","modified":1749475390375},{"_id":"public/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1749475390375},{"_id":"public/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1749475390375},{"_id":"public/js/color-schema.js","hash":"1ef88c881b9f942deadde3d890387b94c617342a","modified":1749475390375},{"_id":"public/js/events.js","hash":"6869811f67e4c3de3edfa4b08464bb242b97a402","modified":1749475390375},{"_id":"public/js/local-search.js","hash":"b9945f76f8682f3ec32edfb285b26eb559f7b7e8","modified":1749475390375},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1749475390375},{"_id":"public/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1749475390375},{"_id":"public/js/utils.js","hash":"b82e7c289a66dfd36064470fd41c0e96fc598b43","modified":1749475390375},{"_id":"public/js/umami-view.js","hash":"33c4b3883fa747604074ad3921606eeeaeb50716","modified":1749475390375},{"_id":"public/css/main.css","hash":"14ebd9b515085666cee29bbcbe362ad3604ab62a","modified":1749475390375},{"_id":"public/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1749475390375},{"_id":"themes/fluid/source/img/drawn.jpg","hash":"a8afab014b63afa5e2c043eb7b50ecba6b03edfb","modified":1748007916979},{"_id":"themes/fluid/source/img/wild-fire.jpg","hash":"a032903bb422e1d524a190a19b02b0031dc87b91","modified":1749654949932},{"_id":"source/CNAME","hash":"d675053c77f7d0d901b00e800fba6471d1083778","modified":1749478124195},{"_id":"source/baidu_verify_codeva-fVR3SShMVh.html","hash":"09e554351f969b229ae91d76101bae10651bb03e","modified":1748071350688},{"_id":"public/CNAME","hash":"d675053c77f7d0d901b00e800fba6471d1083778","modified":1749566624299},{"_id":"public/baidu_verify_codeva-fVR3SShMVh.html","hash":"09e554351f969b229ae91d76101bae10651bb03e","modified":1749475390375},{"_id":"public/img/drawn.jpg","hash":"a8afab014b63afa5e2c043eb7b50ecba6b03edfb","modified":1749475390375},{"_id":"public/img/wild-fire.jpg","hash":"82061013d2890c5b73b0b5eee565836c13e5223a","modified":1749475390375},{"_id":"public/sitemap.xml","hash":"bcab51d74c4616eaa7ad5bd1e916741fa52c2abd","modified":1749810743260},{"_id":"themes/fluid/source/img/favicon.jpg","hash":"4d9939b7432e3123a74eb5ed0826decfa218654e","modified":1742396857314},{"_id":"source/imgs/微信云对象存储..png","hash":"7b056d08b21247c00d5cbd834717fb39d98cb9ec","modified":1742395108314},{"_id":"source/_imgs/微信云对象存储..png","hash":"7b056d08b21247c00d5cbd834717fb39d98cb9ec","modified":1742395108314},{"_id":"source/_posts/build-personal-blog-1.md","hash":"d2fa1b8efcf83882ad0c24f9653f3ef6e2fe89d1","modified":1750515123314},{"_id":"source/imgs/build-blog1/blog1.jpg","hash":"cd119385d9f85524aeb92a1c3cdac16ca712118f","modified":1748271496822},{"_id":"source/imgs/build-blog1/blog2.jpg","hash":"088f470ce2f0c902c5115d1e4891f473a6445d55","modified":1748272050586},{"_id":"source/imgs/build-blog1/blog4.jpg","hash":"bc8543254d3656f309148392d9145f26ba13d79c","modified":1748272272567},{"_id":"source/imgs/build-blog1/blog5.jpg","hash":"9bee4e5c47c165fe9d6398bc7c1da75a9d94b730","modified":1748272314963},{"_id":"source/imgs/build-blog1/blog6.jpg","hash":"077be667affcb34f66cba6385aa759c0e37b3a2d","modified":1748272596664},{"_id":"source/imgs/build-blog1/blog3.jpg","hash":"20f8f6d4a7e06e9f33cbd43d5a45e09a4b477081","modified":1748272066872},{"_id":"source/_posts/build-personal-blog2.md","hash":"2b90c2c3e16c676739f136d87b2ddbd1466dc70c","modified":1750515246636},{"_id":"source/imgs/build-blogs2/step6.png","hash":"86d9ba02ef7752faa3e24aaef96077948158029e","modified":1748793429848},{"_id":"source/imgs/build-blogs2/step3.png","hash":"2b02a0b60c175b40b26bcab15a4ced3b98cf3e0b","modified":1748792345120},{"_id":"source/imgs/build-blogs2/step2.png","hash":"d3986fd605c513604b613b33fffe08558b533cc2","modified":1748791166898},{"_id":"source/imgs/build-blogs2/step4.png","hash":"29c14be4e9e80b8635d499750f5194cfa6b5acd2","modified":1748792483283},{"_id":"source/imgs/build-blogs2/step5.png","hash":"a5c84254c295a7d601e0018ac4b3037099f606d3","modified":1748792530326},{"_id":"source/imgs/build-blogs2/step1.png","hash":"db8d892d97fbc6980c201f5ec38a3f7a24bd85c3","modified":1748791038005},{"_id":"source/imgs/build-blog1/step1.png","hash":"711d482f34bc57def949dca2218da0a1e3f6bc9a","modified":1748789955181},{"_id":"source/imgs/build-blogs2/my-sit.png","hash":"cf76b3e7a36c6cf1d27efa4d40f63439f561f3ea","modified":1748794050495},{"_id":"source/_posts/Array-set-map-summary.md","hash":"36e53f01c4d0cd6b6f8100879302ebfe2f5f4ab4","modified":1748341041034},{"_id":"source/_posts/Dependencies-collecting-of-vue3.md","hash":"23b30f23d8950924b3dfa2568d14c149070e6c19","modified":1750515344943},{"_id":"source/_posts/build-personal-blog3.md","hash":"21018a3e6f20794e928d0100952343ae5531e854","modified":1750515252585},{"_id":"source/_posts/install-node.md","hash":"9611ae98b8f09c571436a9dc4a7f27aa267dc2c3","modified":1750515390563},{"_id":"source/imgs/build-blog3/Node3.png","hash":"97193904adddd2b64a742b36d4ac28052fc68117","modified":1749376123921},{"_id":"source/imgs/build-blog3/Node1.png","hash":"591ef5e5fdb097108293f893a631501931e67b38","modified":1749376075356},{"_id":"source/imgs/build-blog3/Node4.png","hash":"f5c3cfad516dd22e56ed076181feb8fc1366e8b8","modified":1749376186987},{"_id":"source/imgs/build-blog3/Node5.png","hash":"3fd0511638d580b100a713ea6113195f798fb71e","modified":1749376235077},{"_id":"source/imgs/build-blog3/Node2.png","hash":"614523f08d105749081b439f647461a137fcbc6c","modified":1749376096117},{"_id":"source/imgs/build-blog3/Node-folder.png","hash":"ffde5efeff9f43940e304e0ddb41359d9ca5a669","modified":1749377154488},{"_id":"source/imgs/build-blog3/step2.png","hash":"f5f6e40335355783484b68f65af0084e8e24673d","modified":1749378859093},{"_id":"source/imgs/build-blog3/NodeSite.png","hash":"f329461b13550c1d5250051abb17f8f86dbb525d","modified":1749376642259},{"_id":"source/imgs/build-blog3/site-generator.png","hash":"ac0ac0acf6baf61cd8f4f1e7224a9a073b7487cc","modified":1749373197931},{"_id":"source/imgs/build-blog3/site-generator2.png","hash":"fd7f96858fa44b04a3889a70128f060f51a8f5d7","modified":1749373231119},{"_id":"source/imgs/build-blog3/landscape.png","hash":"004c644178862bb6b1a88f2aec28c2c798a5f297","modified":1749381480640},{"_id":"source/imgs/build-blog3/hexo.png","hash":"24ab106e07dc9e398585bb6cc8a97e0bf835524c","modified":1749474595463},{"_id":"source/imgs/build-blog3/success.png","hash":"bf98fd9d229170cf98f0bc36a997df939a60c894","modified":1749474595487},{"_id":"source/imgs/build-blog3/environment3.png","hash":"b781ebc267a5f2356718ed7cc4d69bf0ddf50a95","modified":1749474595459},{"_id":"source/imgs/build-blog3/environment2.png","hash":"6742c24212564b134aa4450dab74360bdd581832","modified":1749474595455},{"_id":"source/imgs/build-blog3/environment5.png","hash":"00b40562694443e0b0be7303a9c8bac4e92ef0d0","modified":1749474595463},{"_id":"source/imgs/build-blog3/environment4.png","hash":"dba3ff701e1101b3176a524b82561ab581c391d5","modified":1749474595459},{"_id":"source/imgs/build-blog3/md2html.png","hash":"7c7eae0c82cb87699e3540c85d07454ff1a1668f","modified":1749474595475},{"_id":"source/imgs/build-blog3/environment1.png","hash":"dabc596a066194027aec024f042d060ea00e2fed","modified":1749474595451},{"_id":"source/robot.txt","hash":"85504474b6ea499f464150f39b13dd09c09353ae","modified":1749478196270},{"_id":"public/baidu_urls.txt","hash":"6f807e83ebc10ef39022f28374fcb452e15d0d15","modified":1749810743260},{"_id":"public/archives/2025/06/index.html","hash":"c9b297c61720314ce7cdd7c98f94dfbfd5e06c69","modified":1749810743260},{"_id":"public/tags/Javascript/index.html","hash":"7b773c8bf5b1b2b05092a08d3cfc62cb9252e47f","modified":1749810743260},{"_id":"public/tags/Array/index.html","hash":"01cfb57b481e136e1a64c0374688138c5f3156e0","modified":1749810743260},{"_id":"public/tags/Set/index.html","hash":"b36ebc92ac131008561c17aefa433c4b0a8c1eec","modified":1749810743260},{"_id":"public/tags/Map/index.html","hash":"8b9772c03d0e82c518c7be1d1971f1e72c881474","modified":1749810743260},{"_id":"public/tags/博客搭建/index.html","hash":"9ddd17d6816737b8823afa13e74163f3455c0af1","modified":1749810743260},{"_id":"public/tags/个人IP/index.html","hash":"8e8fb8bc52f44d6e4afb9352945dd4d63b7a681e","modified":1749810743260},{"_id":"public/tags/Vue/index.html","hash":"81da78d2265f361999afb2dab5bf1b0ae6cf61cf","modified":1749810743260},{"_id":"public/tags/源码阅读/index.html","hash":"4874c5c6341ead53b520bd629eaa00954927d59d","modified":1749810743260},{"_id":"public/tags/依赖收集/index.html","hash":"31b8df578129bd05668346cff0ece1bc1d897566","modified":1749810743260},{"_id":"public/tags/小程序/index.html","hash":"43f1d7649e351e512400297333d2bcdaa7e1ef9f","modified":1749810743260},{"_id":"public/tags/微信云/index.html","hash":"04929fcb2ecc00563bb1b675900d7322bdfe506a","modified":1749810743260},{"_id":"public/tags/对象存储/index.html","hash":"381f34c38e7b8df1870a3e314ac079bb8518d056","modified":1749810743260},{"_id":"public/tags/Vite/index.html","hash":"ac963974f495cf2547aaef6aba0af7118dd58712","modified":1749810743260},{"_id":"public/tags/Proxy/index.html","hash":"361493da5dbbcab59289647b7b7ed6dab558b2fb","modified":1749810743260},{"_id":"public/tags/error/index.html","hash":"0781a7be95480ef3b36ecdd18da69feb0dce3737","modified":1749810743260},{"_id":"public/posts/install-node.html","hash":"3ceeab4203cfffde9d4143b7d5e3a1181817b746","modified":1749810743260},{"_id":"public/posts/build-personal-blog3.html","hash":"d3fc42356a24af241d69e7b5d26e04080e9bf826","modified":1749810743260},{"_id":"public/posts/build-personal-blog2.html","hash":"f6b869e429d29162f52e8bfa81e054a3a427ae13","modified":1749810743260},{"_id":"public/posts/build-personal-blog-1.html","hash":"b092603f7a8b34c28bfade591abca7b5f9a1e6e7","modified":1749810743260},{"_id":"public/posts/Differences-between-two-kinds-inherit-approches.html","hash":"4784e937ae208a27de85b6eefa1d0c75c52e42a6","modified":1749810743260},{"_id":"public/posts/Manage-wx-could-service.html","hash":"8f53960ba2465339ba296489dcb975329af55ad7","modified":1749810743260},{"_id":"public/posts/Vite-server-error.html","hash":"3aeb337dfa6107a2692b39154ab08d6ed8d6b113","modified":1749810743260},{"_id":"public/posts/Array-set-map-summary.html","hash":"58fbacfb3cdce037635b189ea033462261b0382c","modified":1749810743260},{"_id":"public/posts/Dependencies-collecting-of-vue3.html","hash":"174de09d990e327fe28b1f45df06ad75dd758cd9","modified":1749810743260},{"_id":"public/tags/Node安装/index.html","hash":"bc9e120a1ec84657397fd62ad97a29faed8e516e","modified":1749810743260},{"_id":"public/tags/npm/index.html","hash":"60bc7838da9cfa4c640b72964ce1db5bb4e5aebb","modified":1749810743260},{"_id":"public/imgs/微信云对象存储..png","hash":"7b056d08b21247c00d5cbd834717fb39d98cb9ec","modified":1749475390375},{"_id":"public/img/favicon.jpg","hash":"4d9939b7432e3123a74eb5ed0826decfa218654e","modified":1749475390375},{"_id":"public/imgs/build-blogs2/step6.png","hash":"86d9ba02ef7752faa3e24aaef96077948158029e","modified":1749475390375},{"_id":"public/imgs/build-blog3/Node1.png","hash":"591ef5e5fdb097108293f893a631501931e67b38","modified":1749475390375},{"_id":"public/imgs/build-blog3/Node2.png","hash":"614523f08d105749081b439f647461a137fcbc6c","modified":1749475390375},{"_id":"public/imgs/build-blog3/Node3.png","hash":"97193904adddd2b64a742b36d4ac28052fc68117","modified":1749475390375},{"_id":"public/imgs/build-blog3/Node4.png","hash":"f5c3cfad516dd22e56ed076181feb8fc1366e8b8","modified":1749475390375},{"_id":"public/imgs/build-blog3/Node5.png","hash":"3fd0511638d580b100a713ea6113195f798fb71e","modified":1749475390375},{"_id":"public/imgs/build-blog3/step2.png","hash":"f5f6e40335355783484b68f65af0084e8e24673d","modified":1749475390375},{"_id":"public/robot.txt","hash":"85504474b6ea499f464150f39b13dd09c09353ae","modified":1749566624299},{"_id":"public/imgs/build-blog3/success.png","hash":"bf98fd9d229170cf98f0bc36a997df939a60c894","modified":1749475390375},{"_id":"public/imgs/build-blog3/hexo.png","hash":"24ab106e07dc9e398585bb6cc8a97e0bf835524c","modified":1749475390375},{"_id":"public/imgs/build-blogs2/step3.png","hash":"2b02a0b60c175b40b26bcab15a4ced3b98cf3e0b","modified":1749475390375},{"_id":"public/imgs/build-blog3/environment2.png","hash":"6742c24212564b134aa4450dab74360bdd581832","modified":1749475390375},{"_id":"public/imgs/build-blog3/environment4.png","hash":"dba3ff701e1101b3176a524b82561ab581c391d5","modified":1749475390375},{"_id":"public/imgs/build-blog3/environment3.png","hash":"b781ebc267a5f2356718ed7cc4d69bf0ddf50a95","modified":1749475390375},{"_id":"public/imgs/build-blog3/md2html.png","hash":"7c7eae0c82cb87699e3540c85d07454ff1a1668f","modified":1749475390375},{"_id":"public/imgs/build-blog3/environment5.png","hash":"00b40562694443e0b0be7303a9c8bac4e92ef0d0","modified":1749475390375},{"_id":"public/imgs/build-blogs2/step4.png","hash":"29c14be4e9e80b8635d499750f5194cfa6b5acd2","modified":1749475390375},{"_id":"public/imgs/build-blogs2/step5.png","hash":"a5c84254c295a7d601e0018ac4b3037099f606d3","modified":1749475390375},{"_id":"public/imgs/build-blogs2/step2.png","hash":"d3986fd605c513604b613b33fffe08558b533cc2","modified":1749475390375},{"_id":"public/imgs/build-blog3/site-generator.png","hash":"ac0ac0acf6baf61cd8f4f1e7224a9a073b7487cc","modified":1749475390375},{"_id":"public/imgs/build-blog3/Node-folder.png","hash":"ffde5efeff9f43940e304e0ddb41359d9ca5a669","modified":1749475390375},{"_id":"public/imgs/build-blogs2/step1.png","hash":"db8d892d97fbc6980c201f5ec38a3f7a24bd85c3","modified":1749475390375},{"_id":"public/imgs/build-blog3/site-generator2.png","hash":"fd7f96858fa44b04a3889a70128f060f51a8f5d7","modified":1749475390375},{"_id":"public/imgs/build-blog3/NodeSite.png","hash":"f329461b13550c1d5250051abb17f8f86dbb525d","modified":1749475390375},{"_id":"public/imgs/build-blog1/blog5.jpg","hash":"9bee4e5c47c165fe9d6398bc7c1da75a9d94b730","modified":1749475390375},{"_id":"public/imgs/build-blog1/blog1.jpg","hash":"cd119385d9f85524aeb92a1c3cdac16ca712118f","modified":1749475390375},{"_id":"public/imgs/build-blog1/step1.png","hash":"711d482f34bc57def949dca2218da0a1e3f6bc9a","modified":1749475390375},{"_id":"public/imgs/build-blog1/blog2.jpg","hash":"088f470ce2f0c902c5115d1e4891f473a6445d55","modified":1749475390375},{"_id":"public/imgs/build-blog3/environment1.png","hash":"dabc596a066194027aec024f042d060ea00e2fed","modified":1749475390375},{"_id":"public/imgs/build-blog1/blog4.jpg","hash":"bc8543254d3656f309148392d9145f26ba13d79c","modified":1749475390375},{"_id":"public/imgs/build-blog3/landscape.png","hash":"004c644178862bb6b1a88f2aec28c2c798a5f297","modified":1749475390375},{"_id":"public/imgs/build-blog1/blog6.jpg","hash":"077be667affcb34f66cba6385aa759c0e37b3a2d","modified":1749475390375},{"_id":"public/imgs/build-blog1/blog3.jpg","hash":"20f8f6d4a7e06e9f33cbd43d5a45e09a4b477081","modified":1749475390375},{"_id":"public/imgs/build-blogs2/my-sit.png","hash":"cf76b3e7a36c6cf1d27efa4d40f63439f561f3ea","modified":1749475390375},{"_id":"source/robots.txt","hash":"6b7a2f0efb2c683cc187a15d7116e0512abb49db","modified":1750166927517},{"_id":"source/b9845fe647a6579b4eb9925de54a5832.txt","hash":"0c0d17b5ae2a2d38d7f2816c34c3fcfa428905cd","modified":1749811078175},{"_id":"public/b9845fe647a6579b4eb9925de54a5832.txt","hash":"0c0d17b5ae2a2d38d7f2816c34c3fcfa428905cd","modified":1749811080846},{"_id":"source/BingSiteAuth.xml","hash":"f2d151fb6d0d33ba6f3085c226173a069f7a44b3","modified":1749822925946},{"_id":"source/_posts/build-personal-blog4.md","hash":"94bd5ccfe5b3d95ee7ca383942811f9f7b41801f","modified":1750515256816},{"_id":"source/imgs/build-blog4/actions.png","hash":"1b70af9d8e9d18633673ce52232de076a1183c5c","modified":1749998280512},{"_id":"source/_posts/component-versatility.md","hash":"3b2034452e5ece732dd74ba84035f6fbad00f28f","modified":1750862604225},{"_id":"source/_posts/node-numpy.md","hash":"567b4af664f626960e7374886737e67322a1e4e3","modified":1751035958779},{"_id":"source/imgs/bad-code/en.jfif","hash":"188a8854a6bc25f91bd11fdafc4c0e1677facce3","modified":1750860915463},{"_id":"source/_posts/cookie-session-token.md","hash":"80fa07580d1d19a38a2c4c231f8e558936b017b5","modified":1751375954805}],"Category":[{"name":"搭建博客","_id":"cmc6bkbeh00009wup9dwxcteb"},{"name":"Vue源码阅读","_id":"cmcbtzcup00002gup8w90c81j"},{"name":"Web开发","_id":"cmcbtzcuv00012gup1hcads2f"},{"name":"小程序开发","_id":"cmcbtzcux00032gup1x8e8jv9"},{"name":"网络安全","parent":"cmcbtzcuv00012gup1hcads2f","_id":"cmckk1h8s0002ioup5v5243m1"}],"Data":[],"Page":[{"title":"about","date":"2025-05-23T04:55:03.000Z","_content":"## Hi there 👋 ![](https://komarev.com/ghpvc/?username=jvxiao&color=blue&style=plastic)\n\n<!--\n**jvxiao/jvxiao** is a ✨ _special_ ✨ repository because its `README.md` (this file) appears on your GitHub profile.\n\nHere are some ideas to get you started:\n\n- 🔭 I’m currently working on ...\n- 🌱 I’m currently learning ...\n- 👯 I’m looking to collaborate on ...\n- 🤔 I’m looking for help with ...\n- 💬 Ask me about ...\n- 📫 How to reach me: ... \n- 😄 Pronouns: ...\n- ⚡ Fun fact: ...\n-->\n\nHi, I am Jovin Xiao, as known as jvxiao, a full-time front-end developer. In the past few years, I have mainly used Vue and Node to complete my development work. \n\nIn my spare time, I enjoy learning new things and creating some very interesting projects. If you like my projects, please don't hesitate to give me a star or kindly consider [sponsoring me by afdian](https://afdian.com/a/jvxiao).\n\nFeel free to contact me.\n\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2025-05-23 12:55:03\n---\n## Hi there 👋 ![](https://komarev.com/ghpvc/?username=jvxiao&color=blue&style=plastic)\n\n<!--\n**jvxiao/jvxiao** is a ✨ _special_ ✨ repository because its `README.md` (this file) appears on your GitHub profile.\n\nHere are some ideas to get you started:\n\n- 🔭 I’m currently working on ...\n- 🌱 I’m currently learning ...\n- 👯 I’m looking to collaborate on ...\n- 🤔 I’m looking for help with ...\n- 💬 Ask me about ...\n- 📫 How to reach me: ... \n- 😄 Pronouns: ...\n- ⚡ Fun fact: ...\n-->\n\nHi, I am Jovin Xiao, as known as jvxiao, a full-time front-end developer. In the past few years, I have mainly used Vue and Node to complete my development work. \n\nIn my spare time, I enjoy learning new things and creating some very interesting projects. If you like my projects, please don't hesitate to give me a star or kindly consider [sponsoring me by afdian](https://afdian.com/a/jvxiao).\n\nFeel free to contact me.\n\n","updated":"2025-06-17T13:54:22.433Z","path":"about/index.html","_id":"cmb0bvn9s0001hwupchmoepb5","comments":1,"layout":"page","content":"<h2 id=\"Hi-there-👋\"><a href=\"#Hi-there-👋\" class=\"headerlink\" title=\"Hi there 👋 \"></a>Hi there 👋 <img src=\"https://komarev.com/ghpvc/?username=jvxiao&color=blue&style=plastic\"></h2><!--\n**jvxiao/jvxiao** is a ✨ _special_ ✨ repository because its `README.md` (this file) appears on your GitHub profile.\n\nHere are some ideas to get you started:\n\n- 🔭 I’m currently working on ...\n- 🌱 I’m currently learning ...\n- 👯 I’m looking to collaborate on ...\n- 🤔 I’m looking for help with ...\n- 💬 Ask me about ...\n- 📫 How to reach me: ... \n- 😄 Pronouns: ...\n- ⚡ Fun fact: ...\n-->\n\n<p>Hi, I am Jovin Xiao, as known as jvxiao, a full-time front-end developer. In the past few years, I have mainly used Vue and Node to complete my development work. </p>\n<p>In my spare time, I enjoy learning new things and creating some very interesting projects. If you like my projects, please don’t hesitate to give me a star or kindly consider <a href=\"https://afdian.com/a/jvxiao\">sponsoring me by afdian</a>.</p>\n<p>Feel free to contact me.</p>\n","excerpt":"","more":"<h2 id=\"Hi-there-👋\"><a href=\"#Hi-there-👋\" class=\"headerlink\" title=\"Hi there 👋 \"></a>Hi there 👋 <img src=\"https://komarev.com/ghpvc/?username=jvxiao&color=blue&style=plastic\"></h2><!--\n**jvxiao/jvxiao** is a ✨ _special_ ✨ repository because its `README.md` (this file) appears on your GitHub profile.\n\nHere are some ideas to get you started:\n\n- 🔭 I’m currently working on ...\n- 🌱 I’m currently learning ...\n- 👯 I’m looking to collaborate on ...\n- 🤔 I’m looking for help with ...\n- 💬 Ask me about ...\n- 📫 How to reach me: ... \n- 😄 Pronouns: ...\n- ⚡ Fun fact: ...\n-->\n\n<p>Hi, I am Jovin Xiao, as known as jvxiao, a full-time front-end developer. In the past few years, I have mainly used Vue and Node to complete my development work. </p>\n<p>In my spare time, I enjoy learning new things and creating some very interesting projects. If you like my projects, please don’t hesitate to give me a star or kindly consider <a href=\"https://afdian.com/a/jvxiao\">sponsoring me by afdian</a>.</p>\n<p>Feel free to contact me.</p>\n"}],"Post":[{"title":"Javascript中两种不同的继承方式对比","date":"2025-05-23T04:40:00.000Z","targs":["Javascript","继承"],"_content":"\n# Dog.prototype = new Animal() 和 Dog.prototype.proto = Animal.prototype的两种继承方式的区别\n\n\n## 1. Dog.prototype = new Animal()\n\n### 语法和机制\n- **​目的**：通过创建 Animal 的实例来继承其原型链。\n- ​**底层逻辑**：将 Dog.prototype 替换为一个新的 Animal 实例。\n- **​原型链结构**：\n\n```javascript\nDog.prototype → Animal 实例 → Animal.prototype → Object.prototype → null\n```\n\n因此，Dog 的实例通过原型链可以访问 Animal 实例的属性和 Animal.prototype 的方法。\n\n### ​特点\n\n- **​调用父类构造函数**： 会执行 Animal() 构造函数，初始化父类属性（如 this.name)\n- **继承实例属性**：Dog.prototype 会包含 Animal 实例的属性（如 name），即使这些属性是实例级别的。\n\n- **覆盖原有原型**：替换 Dog.prototype 后，原先定义在 Dog.prototype 上的方法会被丢失，需重新添加。\n​- **constructor 问题**：Dog.prototype.constructor 会指向 Animal，需手动修正：\n``` javascript\n  Dog.prototype.constructor = Dog;\n```\n​示例\n``` javascript\n  function Animal() { this.name = \"Animal\"; }\n  Animal.prototype.eat = function() { console.log(\"Eat\"); };\n\n  function Dog() {}\n  Dog.prototype = new Animal(); // 继承\n  Dog.prototype.constructor = Dog; // 修复 constructor\n\n  const dog = new Dog();\n  console.log(dog.name); // \"Animal\"（继承自 Animal 实例）\n  dog.eat();           // \"Eat\"（继承自 Animal.prototype）\n```\n\n## ​2. Dog.prototype.proto = Animal.prototype\n\n### ​语法和机制\n\n- ​目的：直接让 Dog.prototype 的 proto 属性（即 __proto__）指向 Animal.prototype。\n\n- ​底层逻辑：修改 Dog.prototype 的原型链。\n\n​-  原型链结构：\n```javascript\n  Dog.prototype → Animal.prototype → Object.prototype → null\n```\n\n因此，Dog 的实例直接通过原型链访问 Animal.prototype 的方法，但不会继承 Animal 实例的属性。\n### ​特点\n\n- **​不调用父类构造函数**：不会执行 Animal()，避免副作用（如初始化逻辑）。\n\n​- **仅继承原型方法**：Dog 的实例只能访问 Animal.prototype 的方法，无法获取 Animal 实例的属性（如 name）。\n\n- **​保留原有原型**：不会覆盖 Dog.prototype 上已定义的方法。\n\n- **​非标准操作**：直接修改 proto（或 __proto__）是非标准的，可能影响性能，推荐用 Object.setPrototypeOf()：\n```javascript\nObject.setPrototypeOf(Dog.prototype, Animal.prototype);\n```\n​示例\n```javascript\nfunction Animal() { this.name = \"Animal\"; }\nAnimal.prototype.eat = function() { console.log(\"Eat\"); };\n\nfunction Dog() {}\nDog.prototype.proto = Animal.prototype; // 直接修改 proto\n\nconst dog = new Dog();\nconsole.log(dog.name); // undefined（未继承 Animal 实例属性）\ndog.eat();           // \"Eat\"（继承自 Animal.prototype）\n\n```\n\n### ​关键区别总结\n\n### ​**关键区别总结**\n\n| ​**特性**                | `Dog.prototype = new Animal()`                          | `Dog.prototype.__proto__ = Animal.prototype`         |\n|-------------------------|--------------------------------------------------------|-----------------------------------------------------|\n| ​**调用父类构造函数**     | ✅ 是（执行 `Animal()`，初始化父类实例属性）            | ❌ 否（直接链接原型，不调用构造函数）                 |\n| ​**继承实例属性**         | ✅ 是（继承 `Animal` 实例的属性，如 `this.name`）       | ❌ 否（仅继承原型方法，不包含实例属性）               |\n| ​**覆盖原型对象**         | ✅ 是（完全替换 `Dog.prototype` 为新实例）             | ❌ 否（仅修改原型的 `__proto__`，保留原有属性和方法） |\n| ​**constructor修正**    | ✅ 需手动修复（`Dog.prototype.constructor = Dog`）     | ✅ 通常无需修复（原型链未改变构造函数引用）           |\n| ​**兼容性**               | ⚠️ 传统写法，但可能引发副作用（如多余属性继承）       | ⚠️ 非标准操作（直接修改 `__proto__` 可能影响性能）   |\n| ​**推荐程度**             | ❌ 不推荐（问题多，已过时）                             | ⚠️ 慎用（可用 `Object.setPrototypeOf()` 替代）         |\n| ​**原型链结构**           | `Dog.prototype → Animal 实例 → Animal.prototype`         | `Dog.prototype → Animal.prototype → Object.prototype`   |\n| ​**是否继承父类方法**     | ✅ 是（通过 `Animal.prototype`）                       | ✅ 是（直接链接到 `Animal.prototype`）                |\n| ​**是否继承父类实例方法** | ❌ 否（仅继承原型方法，实例属性不会被继承）             | ❌ 否（同上）                                        |\n| ​**典型用途**             | 早期原型链继承（已不推荐）                            | 理论原型链扩展（极少使用，多用 `Object.create()`）   |\n| ​**替代方案**             | `Object.create(Animal.prototype)` + 手动初始化属性     | `Object.setPrototypeOf(Dog.prototype, Animal.prototype)` |\n| ​**ES6 推荐写法**         | `class Dog extends Animal {}`                           | `class Dog extends Animal {}`                         |\n\n### 补充说明\n- ​**Dog.prototype = new Animal() 的问题**：\n\n  - 强制调用父类构造函数，可能导致不必要的初始化逻辑（如 Animal 的 this.name）。\n  - 会将父类实例的属性（如 name）提升为 Dog.prototype 的属性，导致所有子类实例共享这些属性（可能引发意外行为）。\n\n- ​**Dog.prototype.__proto__ = Animal.prototype 的问题**：\n\n  - ​非标准操作：虽然浏览器支持，但 __proto__ 是内部属性，直接修改可能导致性能下降或兼容性问题。\n  - ​无法继承父类构造函数：子类实例仍需通过 new Dog() 创建，不会自动调用父类构造函数。\n\n\n### ​现代替代方案：\n\n​**Object.create()**：\n```javascript\nDog.prototype = Object.create(Animal.prototype);\nDog.prototype.constructor = Dog;\n```\n直接继承 Animal.prototype，不调用父类构造函数，更安全高效。\n\n​ES6 class 语法：\n```javascript\nclass Dog extends Animal {}\n```\n自动处理原型链和构造函数继承，代码更简洁清晰。","source":"_posts/Differences-between-two-kinds-inherit-approches.md","raw":"\n---\ntitle: Javascript中两种不同的继承方式对比\ndate: 2025-05-23 12:40:00\ncategory: Web开发\ntargs:\n  - Javascript\n  - 继承\n---\n\n# Dog.prototype = new Animal() 和 Dog.prototype.proto = Animal.prototype的两种继承方式的区别\n\n\n## 1. Dog.prototype = new Animal()\n\n### 语法和机制\n- **​目的**：通过创建 Animal 的实例来继承其原型链。\n- ​**底层逻辑**：将 Dog.prototype 替换为一个新的 Animal 实例。\n- **​原型链结构**：\n\n```javascript\nDog.prototype → Animal 实例 → Animal.prototype → Object.prototype → null\n```\n\n因此，Dog 的实例通过原型链可以访问 Animal 实例的属性和 Animal.prototype 的方法。\n\n### ​特点\n\n- **​调用父类构造函数**： 会执行 Animal() 构造函数，初始化父类属性（如 this.name)\n- **继承实例属性**：Dog.prototype 会包含 Animal 实例的属性（如 name），即使这些属性是实例级别的。\n\n- **覆盖原有原型**：替换 Dog.prototype 后，原先定义在 Dog.prototype 上的方法会被丢失，需重新添加。\n​- **constructor 问题**：Dog.prototype.constructor 会指向 Animal，需手动修正：\n``` javascript\n  Dog.prototype.constructor = Dog;\n```\n​示例\n``` javascript\n  function Animal() { this.name = \"Animal\"; }\n  Animal.prototype.eat = function() { console.log(\"Eat\"); };\n\n  function Dog() {}\n  Dog.prototype = new Animal(); // 继承\n  Dog.prototype.constructor = Dog; // 修复 constructor\n\n  const dog = new Dog();\n  console.log(dog.name); // \"Animal\"（继承自 Animal 实例）\n  dog.eat();           // \"Eat\"（继承自 Animal.prototype）\n```\n\n## ​2. Dog.prototype.proto = Animal.prototype\n\n### ​语法和机制\n\n- ​目的：直接让 Dog.prototype 的 proto 属性（即 __proto__）指向 Animal.prototype。\n\n- ​底层逻辑：修改 Dog.prototype 的原型链。\n\n​-  原型链结构：\n```javascript\n  Dog.prototype → Animal.prototype → Object.prototype → null\n```\n\n因此，Dog 的实例直接通过原型链访问 Animal.prototype 的方法，但不会继承 Animal 实例的属性。\n### ​特点\n\n- **​不调用父类构造函数**：不会执行 Animal()，避免副作用（如初始化逻辑）。\n\n​- **仅继承原型方法**：Dog 的实例只能访问 Animal.prototype 的方法，无法获取 Animal 实例的属性（如 name）。\n\n- **​保留原有原型**：不会覆盖 Dog.prototype 上已定义的方法。\n\n- **​非标准操作**：直接修改 proto（或 __proto__）是非标准的，可能影响性能，推荐用 Object.setPrototypeOf()：\n```javascript\nObject.setPrototypeOf(Dog.prototype, Animal.prototype);\n```\n​示例\n```javascript\nfunction Animal() { this.name = \"Animal\"; }\nAnimal.prototype.eat = function() { console.log(\"Eat\"); };\n\nfunction Dog() {}\nDog.prototype.proto = Animal.prototype; // 直接修改 proto\n\nconst dog = new Dog();\nconsole.log(dog.name); // undefined（未继承 Animal 实例属性）\ndog.eat();           // \"Eat\"（继承自 Animal.prototype）\n\n```\n\n### ​关键区别总结\n\n### ​**关键区别总结**\n\n| ​**特性**                | `Dog.prototype = new Animal()`                          | `Dog.prototype.__proto__ = Animal.prototype`         |\n|-------------------------|--------------------------------------------------------|-----------------------------------------------------|\n| ​**调用父类构造函数**     | ✅ 是（执行 `Animal()`，初始化父类实例属性）            | ❌ 否（直接链接原型，不调用构造函数）                 |\n| ​**继承实例属性**         | ✅ 是（继承 `Animal` 实例的属性，如 `this.name`）       | ❌ 否（仅继承原型方法，不包含实例属性）               |\n| ​**覆盖原型对象**         | ✅ 是（完全替换 `Dog.prototype` 为新实例）             | ❌ 否（仅修改原型的 `__proto__`，保留原有属性和方法） |\n| ​**constructor修正**    | ✅ 需手动修复（`Dog.prototype.constructor = Dog`）     | ✅ 通常无需修复（原型链未改变构造函数引用）           |\n| ​**兼容性**               | ⚠️ 传统写法，但可能引发副作用（如多余属性继承）       | ⚠️ 非标准操作（直接修改 `__proto__` 可能影响性能）   |\n| ​**推荐程度**             | ❌ 不推荐（问题多，已过时）                             | ⚠️ 慎用（可用 `Object.setPrototypeOf()` 替代）         |\n| ​**原型链结构**           | `Dog.prototype → Animal 实例 → Animal.prototype`         | `Dog.prototype → Animal.prototype → Object.prototype`   |\n| ​**是否继承父类方法**     | ✅ 是（通过 `Animal.prototype`）                       | ✅ 是（直接链接到 `Animal.prototype`）                |\n| ​**是否继承父类实例方法** | ❌ 否（仅继承原型方法，实例属性不会被继承）             | ❌ 否（同上）                                        |\n| ​**典型用途**             | 早期原型链继承（已不推荐）                            | 理论原型链扩展（极少使用，多用 `Object.create()`）   |\n| ​**替代方案**             | `Object.create(Animal.prototype)` + 手动初始化属性     | `Object.setPrototypeOf(Dog.prototype, Animal.prototype)` |\n| ​**ES6 推荐写法**         | `class Dog extends Animal {}`                           | `class Dog extends Animal {}`                         |\n\n### 补充说明\n- ​**Dog.prototype = new Animal() 的问题**：\n\n  - 强制调用父类构造函数，可能导致不必要的初始化逻辑（如 Animal 的 this.name）。\n  - 会将父类实例的属性（如 name）提升为 Dog.prototype 的属性，导致所有子类实例共享这些属性（可能引发意外行为）。\n\n- ​**Dog.prototype.__proto__ = Animal.prototype 的问题**：\n\n  - ​非标准操作：虽然浏览器支持，但 __proto__ 是内部属性，直接修改可能导致性能下降或兼容性问题。\n  - ​无法继承父类构造函数：子类实例仍需通过 new Dog() 创建，不会自动调用父类构造函数。\n\n\n### ​现代替代方案：\n\n​**Object.create()**：\n```javascript\nDog.prototype = Object.create(Animal.prototype);\nDog.prototype.constructor = Dog;\n```\n直接继承 Animal.prototype，不调用父类构造函数，更安全高效。\n\n​ES6 class 语法：\n```javascript\nclass Dog extends Animal {}\n```\n自动处理原型链和构造函数继承，代码更简洁清晰。","slug":"Differences-between-two-kinds-inherit-approches","published":1,"updated":"2025-06-21T14:16:14.913Z","_id":"cmb0qjkpr000250up21mk5ky1","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"Dog-prototype-new-Animal-和-Dog-prototype-proto-Animal-prototype的两种继承方式的区别\"><a href=\"#Dog-prototype-new-Animal-和-Dog-prototype-proto-Animal-prototype的两种继承方式的区别\" class=\"headerlink\" title=\"Dog.prototype &#x3D; new Animal() 和 Dog.prototype.proto &#x3D; Animal.prototype的两种继承方式的区别\"></a>Dog.prototype &#x3D; new Animal() 和 Dog.prototype.proto &#x3D; Animal.prototype的两种继承方式的区别</h1><h2 id=\"1-Dog-prototype-new-Animal\"><a href=\"#1-Dog-prototype-new-Animal\" class=\"headerlink\" title=\"1. Dog.prototype &#x3D; new Animal()\"></a>1. Dog.prototype &#x3D; new Animal()</h2><h3 id=\"语法和机制\"><a href=\"#语法和机制\" class=\"headerlink\" title=\"语法和机制\"></a>语法和机制</h3><ul>\n<li><strong>​目的</strong>：通过创建 Animal 的实例来继承其原型链。</li>\n<li>​<strong>底层逻辑</strong>：将 Dog.prototype 替换为一个新的 Animal 实例。</li>\n<li><strong>​原型链结构</strong>：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> → <span class=\"hljs-title class_\">Animal</span> 实例 → <span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> → <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> → <span class=\"hljs-literal\">null</span><br></code></pre></td></tr></table></figure>\n\n<p>因此，Dog 的实例通过原型链可以访问 Animal 实例的属性和 Animal.prototype 的方法。</p>\n<h3 id=\"​特点\"><a href=\"#​特点\" class=\"headerlink\" title=\"​特点\"></a>​特点</h3><ul>\n<li><p><strong>​调用父类构造函数</strong>： 会执行 Animal() 构造函数，初始化父类属性（如 this.name)</p>\n</li>\n<li><p><strong>继承实例属性</strong>：Dog.prototype 会包含 Animal 实例的属性（如 name），即使这些属性是实例级别的。</p>\n</li>\n<li><p><strong>覆盖原有原型</strong>：替换 Dog.prototype 后，原先定义在 Dog.prototype 上的方法会被丢失，需重新添加。<br>​- <strong>constructor 问题</strong>：Dog.prototype.constructor 会指向 Animal，需手动修正：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">constructor</span> = <span class=\"hljs-title class_\">Dog</span>;<br></code></pre></td></tr></table></figure>\n<p>​示例</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Animal</span>(<span class=\"hljs-params\"></span>) &#123; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = <span class=\"hljs-string\">&quot;Animal&quot;</span>; &#125;<br><span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">eat</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;Eat&quot;</span>); &#125;;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Dog</span>(<span class=\"hljs-params\"></span>) &#123;&#125;<br><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Animal</span>(); <span class=\"hljs-comment\">// 继承</span><br><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">constructor</span> = <span class=\"hljs-title class_\">Dog</span>; <span class=\"hljs-comment\">// 修复 constructor</span><br><br><span class=\"hljs-keyword\">const</span> dog = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Dog</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(dog.<span class=\"hljs-property\">name</span>); <span class=\"hljs-comment\">// &quot;Animal&quot;（继承自 Animal 实例）</span><br>dog.<span class=\"hljs-title function_\">eat</span>();           <span class=\"hljs-comment\">// &quot;Eat&quot;（继承自 Animal.prototype）</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"​2-Dog-prototype-proto-Animal-prototype\"><a href=\"#​2-Dog-prototype-proto-Animal-prototype\" class=\"headerlink\" title=\"​2. Dog.prototype.proto &#x3D; Animal.prototype\"></a>​2. Dog.prototype.proto &#x3D; Animal.prototype</h2><h3 id=\"​语法和机制\"><a href=\"#​语法和机制\" class=\"headerlink\" title=\"​语法和机制\"></a>​语法和机制</h3><ul>\n<li><p>​目的：直接让 Dog.prototype 的 proto 属性（即 __proto__）指向 Animal.prototype。</p>\n</li>\n<li><p>​底层逻辑：修改 Dog.prototype 的原型链。</p>\n</li>\n</ul>\n<p>​-  原型链结构：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> → <span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> → <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> → <span class=\"hljs-literal\">null</span><br></code></pre></td></tr></table></figure>\n\n<p>因此，Dog 的实例直接通过原型链访问 Animal.prototype 的方法，但不会继承 Animal 实例的属性。</p>\n<h3 id=\"​特点-1\"><a href=\"#​特点-1\" class=\"headerlink\" title=\"​特点\"></a>​特点</h3><ul>\n<li><strong>​不调用父类构造函数</strong>：不会执行 Animal()，避免副作用（如初始化逻辑）。</li>\n</ul>\n<p>​- <strong>仅继承原型方法</strong>：Dog 的实例只能访问 Animal.prototype 的方法，无法获取 Animal 实例的属性（如 name）。</p>\n<ul>\n<li><p><strong>​保留原有原型</strong>：不会覆盖 Dog.prototype 上已定义的方法。</p>\n</li>\n<li><p><strong>​非标准操作</strong>：直接修改 proto（或 __proto__）是非标准的，可能影响性能，推荐用 Object.setPrototypeOf()：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">setPrototypeOf</span>(<span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>, <span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);<br></code></pre></td></tr></table></figure>\n<p>​示例</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Animal</span>(<span class=\"hljs-params\"></span>) &#123; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = <span class=\"hljs-string\">&quot;Animal&quot;</span>; &#125;<br><span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">eat</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;Eat&quot;</span>); &#125;;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Dog</span>(<span class=\"hljs-params\"></span>) &#123;&#125;<br><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">proto</span> = <span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>; <span class=\"hljs-comment\">// 直接修改 proto</span><br><br><span class=\"hljs-keyword\">const</span> dog = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Dog</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(dog.<span class=\"hljs-property\">name</span>); <span class=\"hljs-comment\">// undefined（未继承 Animal 实例属性）</span><br>dog.<span class=\"hljs-title function_\">eat</span>();           <span class=\"hljs-comment\">// &quot;Eat&quot;（继承自 Animal.prototype）</span><br><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"​关键区别总结\"><a href=\"#​关键区别总结\" class=\"headerlink\" title=\"​关键区别总结\"></a>​关键区别总结</h3><h3 id=\"​关键区别总结-1\"><a href=\"#​关键区别总结-1\" class=\"headerlink\" title=\"​关键区别总结\"></a>​<strong>关键区别总结</strong></h3><table>\n<thead>\n<tr>\n<th>​<strong>特性</strong></th>\n<th><code>Dog.prototype = new Animal()</code></th>\n<th><code>Dog.prototype.__proto__ = Animal.prototype</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>​<strong>调用父类构造函数</strong></td>\n<td>✅ 是（执行 <code>Animal()</code>，初始化父类实例属性）</td>\n<td>❌ 否（直接链接原型，不调用构造函数）</td>\n</tr>\n<tr>\n<td>​<strong>继承实例属性</strong></td>\n<td>✅ 是（继承 <code>Animal</code> 实例的属性，如 <code>this.name</code>）</td>\n<td>❌ 否（仅继承原型方法，不包含实例属性）</td>\n</tr>\n<tr>\n<td>​<strong>覆盖原型对象</strong></td>\n<td>✅ 是（完全替换 <code>Dog.prototype</code> 为新实例）</td>\n<td>❌ 否（仅修改原型的 <code>__proto__</code>，保留原有属性和方法）</td>\n</tr>\n<tr>\n<td>​<strong>constructor修正</strong></td>\n<td>✅ 需手动修复（<code>Dog.prototype.constructor = Dog</code>）</td>\n<td>✅ 通常无需修复（原型链未改变构造函数引用）</td>\n</tr>\n<tr>\n<td>​<strong>兼容性</strong></td>\n<td>⚠️ 传统写法，但可能引发副作用（如多余属性继承）</td>\n<td>⚠️ 非标准操作（直接修改 <code>__proto__</code> 可能影响性能）</td>\n</tr>\n<tr>\n<td>​<strong>推荐程度</strong></td>\n<td>❌ 不推荐（问题多，已过时）</td>\n<td>⚠️ 慎用（可用 <code>Object.setPrototypeOf()</code> 替代）</td>\n</tr>\n<tr>\n<td>​<strong>原型链结构</strong></td>\n<td><code>Dog.prototype → Animal 实例 → Animal.prototype</code></td>\n<td><code>Dog.prototype → Animal.prototype → Object.prototype</code></td>\n</tr>\n<tr>\n<td>​<strong>是否继承父类方法</strong></td>\n<td>✅ 是（通过 <code>Animal.prototype</code>）</td>\n<td>✅ 是（直接链接到 <code>Animal.prototype</code>）</td>\n</tr>\n<tr>\n<td>​<strong>是否继承父类实例方法</strong></td>\n<td>❌ 否（仅继承原型方法，实例属性不会被继承）</td>\n<td>❌ 否（同上）</td>\n</tr>\n<tr>\n<td>​<strong>典型用途</strong></td>\n<td>早期原型链继承（已不推荐）</td>\n<td>理论原型链扩展（极少使用，多用 <code>Object.create()</code>）</td>\n</tr>\n<tr>\n<td>​<strong>替代方案</strong></td>\n<td><code>Object.create(Animal.prototype)</code> + 手动初始化属性</td>\n<td><code>Object.setPrototypeOf(Dog.prototype, Animal.prototype)</code></td>\n</tr>\n<tr>\n<td>​<strong>ES6 推荐写法</strong></td>\n<td><code>class Dog extends Animal &#123;&#125;</code></td>\n<td><code>class Dog extends Animal &#123;&#125;</code></td>\n</tr>\n</tbody></table>\n<h3 id=\"补充说明\"><a href=\"#补充说明\" class=\"headerlink\" title=\"补充说明\"></a>补充说明</h3><ul>\n<li><p>​<strong>Dog.prototype &#x3D; new Animal() 的问题</strong>：</p>\n<ul>\n<li>强制调用父类构造函数，可能导致不必要的初始化逻辑（如 Animal 的 this.name）。</li>\n<li>会将父类实例的属性（如 name）提升为 Dog.prototype 的属性，导致所有子类实例共享这些属性（可能引发意外行为）。</li>\n</ul>\n</li>\n<li><p>​<strong>Dog.prototype.<strong>proto</strong> &#x3D; Animal.prototype 的问题</strong>：</p>\n<ul>\n<li>​非标准操作：虽然浏览器支持，但 <strong>proto</strong> 是内部属性，直接修改可能导致性能下降或兼容性问题。</li>\n<li>​无法继承父类构造函数：子类实例仍需通过 new Dog() 创建，不会自动调用父类构造函数。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"​现代替代方案：\"><a href=\"#​现代替代方案：\" class=\"headerlink\" title=\"​现代替代方案：\"></a>​现代替代方案：</h3><p>​**Object.create()**：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(<span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);<br><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">constructor</span> = <span class=\"hljs-title class_\">Dog</span>;<br></code></pre></td></tr></table></figure>\n<p>直接继承 Animal.prototype，不调用父类构造函数，更安全高效。</p>\n<p>​ES6 class 语法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Dog</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Animal</span> &#123;&#125;<br></code></pre></td></tr></table></figure>\n<p>自动处理原型链和构造函数继承，代码更简洁清晰。</p>\n","excerpt":"","more":"<h1 id=\"Dog-prototype-new-Animal-和-Dog-prototype-proto-Animal-prototype的两种继承方式的区别\"><a href=\"#Dog-prototype-new-Animal-和-Dog-prototype-proto-Animal-prototype的两种继承方式的区别\" class=\"headerlink\" title=\"Dog.prototype &#x3D; new Animal() 和 Dog.prototype.proto &#x3D; Animal.prototype的两种继承方式的区别\"></a>Dog.prototype &#x3D; new Animal() 和 Dog.prototype.proto &#x3D; Animal.prototype的两种继承方式的区别</h1><h2 id=\"1-Dog-prototype-new-Animal\"><a href=\"#1-Dog-prototype-new-Animal\" class=\"headerlink\" title=\"1. Dog.prototype &#x3D; new Animal()\"></a>1. Dog.prototype &#x3D; new Animal()</h2><h3 id=\"语法和机制\"><a href=\"#语法和机制\" class=\"headerlink\" title=\"语法和机制\"></a>语法和机制</h3><ul>\n<li><strong>​目的</strong>：通过创建 Animal 的实例来继承其原型链。</li>\n<li>​<strong>底层逻辑</strong>：将 Dog.prototype 替换为一个新的 Animal 实例。</li>\n<li><strong>​原型链结构</strong>：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> → <span class=\"hljs-title class_\">Animal</span> 实例 → <span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> → <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> → <span class=\"hljs-literal\">null</span><br></code></pre></td></tr></table></figure>\n\n<p>因此，Dog 的实例通过原型链可以访问 Animal 实例的属性和 Animal.prototype 的方法。</p>\n<h3 id=\"​特点\"><a href=\"#​特点\" class=\"headerlink\" title=\"​特点\"></a>​特点</h3><ul>\n<li><p><strong>​调用父类构造函数</strong>： 会执行 Animal() 构造函数，初始化父类属性（如 this.name)</p>\n</li>\n<li><p><strong>继承实例属性</strong>：Dog.prototype 会包含 Animal 实例的属性（如 name），即使这些属性是实例级别的。</p>\n</li>\n<li><p><strong>覆盖原有原型</strong>：替换 Dog.prototype 后，原先定义在 Dog.prototype 上的方法会被丢失，需重新添加。<br>​- <strong>constructor 问题</strong>：Dog.prototype.constructor 会指向 Animal，需手动修正：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">constructor</span> = <span class=\"hljs-title class_\">Dog</span>;<br></code></pre></td></tr></table></figure>\n<p>​示例</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Animal</span>(<span class=\"hljs-params\"></span>) &#123; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = <span class=\"hljs-string\">&quot;Animal&quot;</span>; &#125;<br><span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">eat</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;Eat&quot;</span>); &#125;;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Dog</span>(<span class=\"hljs-params\"></span>) &#123;&#125;<br><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Animal</span>(); <span class=\"hljs-comment\">// 继承</span><br><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">constructor</span> = <span class=\"hljs-title class_\">Dog</span>; <span class=\"hljs-comment\">// 修复 constructor</span><br><br><span class=\"hljs-keyword\">const</span> dog = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Dog</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(dog.<span class=\"hljs-property\">name</span>); <span class=\"hljs-comment\">// &quot;Animal&quot;（继承自 Animal 实例）</span><br>dog.<span class=\"hljs-title function_\">eat</span>();           <span class=\"hljs-comment\">// &quot;Eat&quot;（继承自 Animal.prototype）</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"​2-Dog-prototype-proto-Animal-prototype\"><a href=\"#​2-Dog-prototype-proto-Animal-prototype\" class=\"headerlink\" title=\"​2. Dog.prototype.proto &#x3D; Animal.prototype\"></a>​2. Dog.prototype.proto &#x3D; Animal.prototype</h2><h3 id=\"​语法和机制\"><a href=\"#​语法和机制\" class=\"headerlink\" title=\"​语法和机制\"></a>​语法和机制</h3><ul>\n<li><p>​目的：直接让 Dog.prototype 的 proto 属性（即 __proto__）指向 Animal.prototype。</p>\n</li>\n<li><p>​底层逻辑：修改 Dog.prototype 的原型链。</p>\n</li>\n</ul>\n<p>​-  原型链结构：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> → <span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> → <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> → <span class=\"hljs-literal\">null</span><br></code></pre></td></tr></table></figure>\n\n<p>因此，Dog 的实例直接通过原型链访问 Animal.prototype 的方法，但不会继承 Animal 实例的属性。</p>\n<h3 id=\"​特点-1\"><a href=\"#​特点-1\" class=\"headerlink\" title=\"​特点\"></a>​特点</h3><ul>\n<li><strong>​不调用父类构造函数</strong>：不会执行 Animal()，避免副作用（如初始化逻辑）。</li>\n</ul>\n<p>​- <strong>仅继承原型方法</strong>：Dog 的实例只能访问 Animal.prototype 的方法，无法获取 Animal 实例的属性（如 name）。</p>\n<ul>\n<li><p><strong>​保留原有原型</strong>：不会覆盖 Dog.prototype 上已定义的方法。</p>\n</li>\n<li><p><strong>​非标准操作</strong>：直接修改 proto（或 __proto__）是非标准的，可能影响性能，推荐用 Object.setPrototypeOf()：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">setPrototypeOf</span>(<span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>, <span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);<br></code></pre></td></tr></table></figure>\n<p>​示例</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Animal</span>(<span class=\"hljs-params\"></span>) &#123; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = <span class=\"hljs-string\">&quot;Animal&quot;</span>; &#125;<br><span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">eat</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;Eat&quot;</span>); &#125;;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Dog</span>(<span class=\"hljs-params\"></span>) &#123;&#125;<br><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">proto</span> = <span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>; <span class=\"hljs-comment\">// 直接修改 proto</span><br><br><span class=\"hljs-keyword\">const</span> dog = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Dog</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(dog.<span class=\"hljs-property\">name</span>); <span class=\"hljs-comment\">// undefined（未继承 Animal 实例属性）</span><br>dog.<span class=\"hljs-title function_\">eat</span>();           <span class=\"hljs-comment\">// &quot;Eat&quot;（继承自 Animal.prototype）</span><br><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"​关键区别总结\"><a href=\"#​关键区别总结\" class=\"headerlink\" title=\"​关键区别总结\"></a>​关键区别总结</h3><h3 id=\"​关键区别总结-1\"><a href=\"#​关键区别总结-1\" class=\"headerlink\" title=\"​关键区别总结\"></a>​<strong>关键区别总结</strong></h3><table>\n<thead>\n<tr>\n<th>​<strong>特性</strong></th>\n<th><code>Dog.prototype = new Animal()</code></th>\n<th><code>Dog.prototype.__proto__ = Animal.prototype</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>​<strong>调用父类构造函数</strong></td>\n<td>✅ 是（执行 <code>Animal()</code>，初始化父类实例属性）</td>\n<td>❌ 否（直接链接原型，不调用构造函数）</td>\n</tr>\n<tr>\n<td>​<strong>继承实例属性</strong></td>\n<td>✅ 是（继承 <code>Animal</code> 实例的属性，如 <code>this.name</code>）</td>\n<td>❌ 否（仅继承原型方法，不包含实例属性）</td>\n</tr>\n<tr>\n<td>​<strong>覆盖原型对象</strong></td>\n<td>✅ 是（完全替换 <code>Dog.prototype</code> 为新实例）</td>\n<td>❌ 否（仅修改原型的 <code>__proto__</code>，保留原有属性和方法）</td>\n</tr>\n<tr>\n<td>​<strong>constructor修正</strong></td>\n<td>✅ 需手动修复（<code>Dog.prototype.constructor = Dog</code>）</td>\n<td>✅ 通常无需修复（原型链未改变构造函数引用）</td>\n</tr>\n<tr>\n<td>​<strong>兼容性</strong></td>\n<td>⚠️ 传统写法，但可能引发副作用（如多余属性继承）</td>\n<td>⚠️ 非标准操作（直接修改 <code>__proto__</code> 可能影响性能）</td>\n</tr>\n<tr>\n<td>​<strong>推荐程度</strong></td>\n<td>❌ 不推荐（问题多，已过时）</td>\n<td>⚠️ 慎用（可用 <code>Object.setPrototypeOf()</code> 替代）</td>\n</tr>\n<tr>\n<td>​<strong>原型链结构</strong></td>\n<td><code>Dog.prototype → Animal 实例 → Animal.prototype</code></td>\n<td><code>Dog.prototype → Animal.prototype → Object.prototype</code></td>\n</tr>\n<tr>\n<td>​<strong>是否继承父类方法</strong></td>\n<td>✅ 是（通过 <code>Animal.prototype</code>）</td>\n<td>✅ 是（直接链接到 <code>Animal.prototype</code>）</td>\n</tr>\n<tr>\n<td>​<strong>是否继承父类实例方法</strong></td>\n<td>❌ 否（仅继承原型方法，实例属性不会被继承）</td>\n<td>❌ 否（同上）</td>\n</tr>\n<tr>\n<td>​<strong>典型用途</strong></td>\n<td>早期原型链继承（已不推荐）</td>\n<td>理论原型链扩展（极少使用，多用 <code>Object.create()</code>）</td>\n</tr>\n<tr>\n<td>​<strong>替代方案</strong></td>\n<td><code>Object.create(Animal.prototype)</code> + 手动初始化属性</td>\n<td><code>Object.setPrototypeOf(Dog.prototype, Animal.prototype)</code></td>\n</tr>\n<tr>\n<td>​<strong>ES6 推荐写法</strong></td>\n<td><code>class Dog extends Animal &#123;&#125;</code></td>\n<td><code>class Dog extends Animal &#123;&#125;</code></td>\n</tr>\n</tbody></table>\n<h3 id=\"补充说明\"><a href=\"#补充说明\" class=\"headerlink\" title=\"补充说明\"></a>补充说明</h3><ul>\n<li><p>​<strong>Dog.prototype &#x3D; new Animal() 的问题</strong>：</p>\n<ul>\n<li>强制调用父类构造函数，可能导致不必要的初始化逻辑（如 Animal 的 this.name）。</li>\n<li>会将父类实例的属性（如 name）提升为 Dog.prototype 的属性，导致所有子类实例共享这些属性（可能引发意外行为）。</li>\n</ul>\n</li>\n<li><p>​<strong>Dog.prototype.<strong>proto</strong> &#x3D; Animal.prototype 的问题</strong>：</p>\n<ul>\n<li>​非标准操作：虽然浏览器支持，但 <strong>proto</strong> 是内部属性，直接修改可能导致性能下降或兼容性问题。</li>\n<li>​无法继承父类构造函数：子类实例仍需通过 new Dog() 创建，不会自动调用父类构造函数。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"​现代替代方案：\"><a href=\"#​现代替代方案：\" class=\"headerlink\" title=\"​现代替代方案：\"></a>​现代替代方案：</h3><p>​**Object.create()**：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(<span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);<br><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">constructor</span> = <span class=\"hljs-title class_\">Dog</span>;<br></code></pre></td></tr></table></figure>\n<p>直接继承 Animal.prototype，不调用父类构造函数，更安全高效。</p>\n<p>​ES6 class 语法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Dog</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Animal</span> &#123;&#125;<br></code></pre></td></tr></table></figure>\n<p>自动处理原型链和构造函数继承，代码更简洁清晰。</p>\n"},{"title":"关于微信云托管对象存储那点事","date":"2025-05-23T04:40:00.000Z","_content":"最近在鼓捣一个关于图像处理相关的小程序，出于快速开发考虑，在后台开发这块，没有选择走传统的后台部署服务。毕竟，购买云服务器，注册购买域名以及备案等一系列操作下来，也够让人心累。\n\n这次选择的是微信开发的平台的云托管，至于为什么走的不是云函数开发，其中就涉及到了开发语言的选择--python, 如果改用javascript重写一下，成本有点高，所以最终方案选择云托管。\n\n在按照云托管的部署流程一通走下来后，everything is fine. But...\n\n离大谱的，接口请求和响应，居然不能超过1M, 而我这程序就是关于图像处理的，动不动图片大小就会超过1M。如果非要限制用户图片大小限制在1M以下，太过影响用户体验。\n\n此外我还想过，在用户端使用图像压缩，但图像太大压缩也会存在超过1M的情况，另外清晰度也会受到影响。\n\n在微信开发社区和各个IT论坛找了一圈下来，其实没有比较好的解决方案，最终都需要经过一个中间对象存储的过程。\n\n也就是先将图片上传到云上，让后将图片对象的id作为接口入参传入，后台需要使用到图片的时候根据图片id下载即可，然后将处理后的图片，又要上传回云上，返回给客户端新的图片的id，客户端可以根据图片id来获取资源。如下图\n\n<!-- ![处理流程](./imgs/微信云对象存储..png) -->\n<div align=\"center\">\n    <img src=\"/imgs/微信云对象存储..png\" width=\"80%\" height=\"20%\" alt=\"处理流程\"/>\n</div>\n\n\n\n对象存储云平台其实很多，例如比较有名的比如七牛，阿里，还有腾讯云自己的。我这里采用了微信云对象存储，具体的使用呢可以参考 [微信云托管对象存储](https://developers.weixin.qq.com/minigame/dev/wxcloudrun/src/guide/storage/manage.html)，相应的开发手册可以参考[对象存储-服务端和其他客户端](https://developers.weixin.qq.com/minigame/dev/wxcloudrun/src/development/storage/service/)\n\n\n为了在后续的开发中更好处理类似的情况，我将微信云托管对象存储做成了一个模块，具体实现情况如下。\n\n首先，需要从自己的小程序或者和云托管平台获取到以下三个重要参数：\n\n- **APPID** ： \"your-wechat-appid\"\n- **SECRET**： \"your-wechat-secret\"\n- **ENV_ID**： \"your-cloud-env-id\"\n\n- ### 文件上传 (获取token-获取元数据-上传COS)\n\n微信开放平台如果第三方调用对应接口的话，都是需要鉴权了，所以首先我们需要获取到token值。\n\n``` Python\ndef _refresh_access_token(self):\n        \"\"\"获取或刷新access_token\"\"\"\n        url = \"https://api.weixin.qq.com/cgi-bin/token\"\n        params = {\n            \"grant_type\": \"client_credential\",\n            \"appid\": self.appid,\n            \"secret\": self.secret\n        }\n        response = requests.get(url, params=params, verify=False).json()\n        if 'access_token' in response:\n            self.access_token = response['access_token']\n            self.token_expires = time.time() + response['expires_in'] - 300  # 提前5分钟刷新\n        else:\n            raise Exception(f\"获取access_token失败: {response}\")\n```\n\n\n文件上传可以分成2步：**1获取上传元数据，2上传文件到COS**。\n\n获取元数据可以理解为向平台发送请求，获取一个用来存放一个文件（存储对象）的一个URL地址, 上传文件到COS可以则可以理解成将资源放到上一步生成的URL地址上，经此，文件才算真正的上传成功了。\n\n``` Python\n    def upload_file(self, local_path, cloud_path):\n        \"\"\"\n        上传本地文件到微信云存储\n        :param local_path: 本地文件路径\n        :param cloud_path: 云端存储路径（如：'images/example.jpg'）\n        :return: 文件ID（用于后续下载）\n        \"\"\"\n        self._ensure_access_token()\n        \n        # 1. 获取上传元数据\n        upload_meta_url = \"https://api.weixin.qq.com/tcb/uploadfile\"\n        params = {\"access_token\": self.access_token}\n        payload = {\"env\": self.env, \"path\": cloud_path}\n        response = requests.post(upload_meta_url, params=params, json=payload,verify=False).json()\n        print(payload, params)\n        if response.get('errcode', 0) != 0:\n            raise Exception(f\"上传元数据获取失败: {response}\")\n        \n        # 2. 上传文件到COS\n        cos_url = response['url']\n       \n        key = cloud_path.split('/')[-1]\n        print(key)\n        files = {\n            \"Signature\":(None,response['authorization']),\n            \"x-cos-meta-fileid\": (None, response['cos_file_id']),\n            \"x-cos-security-token\": (None,response['token']),\n            \"key\": (None, cloud_path),\n            'file':(key, open(local_path, 'rb')),\n        }\n\n        upload_resp = requests.post(cos_url, files=files, verify=False)\n        if upload_resp.status_code != 204:\n            raise Exception(f\"COS上传失败: {upload_resp.text}\", upload_resp)\n       \n        return response['file_id']\n```\n\n\n- ### 文件下载\n\n下载文件相对简单一些，直接调用微信开放平台对外提供的批量下载接口，当然对应的token也是需要的，这部分就不做赘述，代码实现可以参考下方。\n\n``` Python \n\ndef download_file(self, file_id, local_path):\n        \"\"\"\n        从微信云存储下载文件\n        :param file_id: 文件ID（上传时返回的file_id）\n        :param local_path: 本地存储路径\n        \"\"\"\n        self._ensure_access_token()\n        \n        # 1. 获取下载链接\n        download_meta_url = \"https://api.weixin.qq.com/tcb/batchdownloadfile\"\n        params = {\"access_token\": self.access_token}\n        payload = {\n            \"env\": self.env,\n            \"file_list\": [{\"fileid\": file_id, \"max_age\": 7200}]\n        }\n        response = requests.post(download_meta_url, params=params, json=payload, verify=False).json()\n        \n        if response.get('errcode', 0) != 0:\n            raise Exception(f\"下载元数据获取失败: {response}\")\n        \n        file_info = response['file_list'][0]\n        if file_info['status'] != 0:\n            raise Exception(f\"下载错误: {file_info['errmsg']}\")\n        \n        # 2. 下载文件\n        download_resp = requests.get(file_info['download_url'], verify=False)\n        if download_resp.status_code != 200:\n            raise Exception(\"文件下载失败\")\n        \n        with open(local_path, 'wb') as f:\n            f.write(download_resp.content)\n            \n        return True\n```\n\n以上就是微信云托管上对象存储的上传和下载的实现了。为了方便，我们可以将功能在一个类中实现。此外，考虑到token获取接口是有限制的，每天的调用次数是2000次，而每个token的有效时间是2小时，因此可以重复利用已有token。\n\n最终，完整的代码实现如下：\n\n``` Python\n# wx-cloud-storage.py\n# description: 微信云托管对象存储管理模块\nimport requests\nimport time\n\nclass WeChatCloudStorage:\n    def __init__(self, appid, secret, env):\n        self.appid = appid\n        self.secret = secret\n        self.env = env\n        self.access_token = None\n        self.token_expires = 0  # Token过期时间戳\n\n    def _refresh_access_token(self):\n        \"\"\"获取或刷新access_token\"\"\"\n        url = \"https://api.weixin.qq.com/cgi-bin/token\"\n        params = {\n            \"grant_type\": \"client_credential\",\n            \"appid\": self.appid,\n            \"secret\": self.secret\n        }\n        response = requests.get(url, params=params, verify=False).json()\n        if 'access_token' in response:\n            self.access_token = response['access_token']\n            self.token_expires = time.time() + response['expires_in'] - 300  # 提前5分钟刷新\n        else:\n            raise Exception(f\"获取access_token失败: {response}\")\n\n    def _ensure_access_token(self):\n        \"\"\"确保access_token有效\"\"\"\n        if time.time() >= self.token_expires or not self.access_token:\n            self._refresh_access_token()\n\n    def upload_file(self, local_path, cloud_path):\n        \"\"\"\n        上传本地文件到微信云存储\n        :param local_path: 本地文件路径\n        :param cloud_path: 云端存储路径（如：'images/example.jpg'）\n        :return: 文件ID（用于后续下载）\n        \"\"\"\n        self._ensure_access_token()\n        \n        # 1. 获取上传元数据\n        upload_meta_url = \"https://api.weixin.qq.com/tcb/uploadfile\"\n        params = {\"access_token\": self.access_token}\n        payload = {\"env\": self.env, \"path\": cloud_path}\n        response = requests.post(upload_meta_url, params=params, json=payload,verify=False).json()\n        print(payload, params)\n        if response.get('errcode', 0) != 0:\n            raise Exception(f\"上传元数据获取失败: {response}\")\n        \n        # 2. 上传文件到COS\n        cos_url = response['url']\n       \n        key = cloud_path.split('/')[-1]\n        print(key)\n        files = {\n            \"Signature\":(None,response['authorization']),\n            \"x-cos-meta-fileid\": (None, response['cos_file_id']),\n            \"x-cos-security-token\": (None,response['token']),\n            \"key\": (None, cloud_path),\n            'file':(key, open(local_path, 'rb')),\n        }\n\n        upload_resp = requests.post(cos_url, files=files, verify=False)\n        if upload_resp.status_code != 204:\n            raise Exception(f\"COS上传失败: {upload_resp.text}\", upload_resp)\n       \n        return response['file_id']\n\n    def download_file(self, file_id, local_path):\n        \"\"\"\n        从微信云存储下载文件\n        :param file_id: 文件ID（上传时返回的file_id）\n        :param local_path: 本地存储路径\n        \"\"\"\n        self._ensure_access_token()\n        \n        # 1. 获取下载链接\n        download_meta_url = \"https://api.weixin.qq.com/tcb/batchdownloadfile\"\n        params = {\"access_token\": self.access_token}\n        payload = {\n            \"env\": self.env,\n            \"file_list\": [{\"fileid\": file_id, \"max_age\": 7200}]\n        }\n        response = requests.post(download_meta_url, params=params, json=payload, verify=False).json()\n        \n        if response.get('errcode', 0) != 0:\n            raise Exception(f\"下载元数据获取失败: {response}\")\n        \n        file_info = response['file_list'][0]\n        if file_info['status'] != 0:\n            raise Exception(f\"下载错误: {file_info['errmsg']}\")\n        \n        # 2. 下载文件\n        download_resp = requests.get(file_info['download_url'], verify=False)\n        if download_resp.status_code != 200:\n            raise Exception(\"文件下载失败\")\n        \n        with open(local_path, 'wb') as f:\n            f.write(download_resp.content)\n            \n        return True\n\n# 使用示例\nif __name__ == \"__main__\":\n    # 配置信息（需要替换为实际值）\n    APPID = \"your-wechat-appid\"\n    SECRET = \"your-wechat-secret\"\n    ENV_ID = \"your-cloud-env-id\"\n   \n    # 上传示例\n    storage = WeChatCloudStorage(APPID, SECRET, ENV_ID)\n    try:\n        file_id = storage.upload_file(\"../test.png\", \"image/test2.png\")\n        print(f\"文件上传成功，File ID: {file_id}\")\n    except Exception as e:\n        print(f\"上传失败: {e}\")\n    # 下载示例\n    try:\n        storage.download_file(file_id, \"downloaded_image.jpg\")\n        print(\"文件下载成功\")\n    except Exception as e:\n        print(f\"下载失败: {e}\")\n\n\n```\n\n以上就是关于对象存储管理相关的内容了，如果你在开发类似的功能过程中有类似的idea或者遇到一些难搞的坑，欢迎一起讨论。","source":"_posts/Manage-wx-could-service.md","raw":"---\ntitle: 关于微信云托管对象存储那点事\ndate: 2025-05-23 12:40:00\ncategory: 小程序开发\ntags:\n    - 小程序\n    - 微信云\n    - 对象存储\n---\n最近在鼓捣一个关于图像处理相关的小程序，出于快速开发考虑，在后台开发这块，没有选择走传统的后台部署服务。毕竟，购买云服务器，注册购买域名以及备案等一系列操作下来，也够让人心累。\n\n这次选择的是微信开发的平台的云托管，至于为什么走的不是云函数开发，其中就涉及到了开发语言的选择--python, 如果改用javascript重写一下，成本有点高，所以最终方案选择云托管。\n\n在按照云托管的部署流程一通走下来后，everything is fine. But...\n\n离大谱的，接口请求和响应，居然不能超过1M, 而我这程序就是关于图像处理的，动不动图片大小就会超过1M。如果非要限制用户图片大小限制在1M以下，太过影响用户体验。\n\n此外我还想过，在用户端使用图像压缩，但图像太大压缩也会存在超过1M的情况，另外清晰度也会受到影响。\n\n在微信开发社区和各个IT论坛找了一圈下来，其实没有比较好的解决方案，最终都需要经过一个中间对象存储的过程。\n\n也就是先将图片上传到云上，让后将图片对象的id作为接口入参传入，后台需要使用到图片的时候根据图片id下载即可，然后将处理后的图片，又要上传回云上，返回给客户端新的图片的id，客户端可以根据图片id来获取资源。如下图\n\n<!-- ![处理流程](./imgs/微信云对象存储..png) -->\n<div align=\"center\">\n    <img src=\"/imgs/微信云对象存储..png\" width=\"80%\" height=\"20%\" alt=\"处理流程\"/>\n</div>\n\n\n\n对象存储云平台其实很多，例如比较有名的比如七牛，阿里，还有腾讯云自己的。我这里采用了微信云对象存储，具体的使用呢可以参考 [微信云托管对象存储](https://developers.weixin.qq.com/minigame/dev/wxcloudrun/src/guide/storage/manage.html)，相应的开发手册可以参考[对象存储-服务端和其他客户端](https://developers.weixin.qq.com/minigame/dev/wxcloudrun/src/development/storage/service/)\n\n\n为了在后续的开发中更好处理类似的情况，我将微信云托管对象存储做成了一个模块，具体实现情况如下。\n\n首先，需要从自己的小程序或者和云托管平台获取到以下三个重要参数：\n\n- **APPID** ： \"your-wechat-appid\"\n- **SECRET**： \"your-wechat-secret\"\n- **ENV_ID**： \"your-cloud-env-id\"\n\n- ### 文件上传 (获取token-获取元数据-上传COS)\n\n微信开放平台如果第三方调用对应接口的话，都是需要鉴权了，所以首先我们需要获取到token值。\n\n``` Python\ndef _refresh_access_token(self):\n        \"\"\"获取或刷新access_token\"\"\"\n        url = \"https://api.weixin.qq.com/cgi-bin/token\"\n        params = {\n            \"grant_type\": \"client_credential\",\n            \"appid\": self.appid,\n            \"secret\": self.secret\n        }\n        response = requests.get(url, params=params, verify=False).json()\n        if 'access_token' in response:\n            self.access_token = response['access_token']\n            self.token_expires = time.time() + response['expires_in'] - 300  # 提前5分钟刷新\n        else:\n            raise Exception(f\"获取access_token失败: {response}\")\n```\n\n\n文件上传可以分成2步：**1获取上传元数据，2上传文件到COS**。\n\n获取元数据可以理解为向平台发送请求，获取一个用来存放一个文件（存储对象）的一个URL地址, 上传文件到COS可以则可以理解成将资源放到上一步生成的URL地址上，经此，文件才算真正的上传成功了。\n\n``` Python\n    def upload_file(self, local_path, cloud_path):\n        \"\"\"\n        上传本地文件到微信云存储\n        :param local_path: 本地文件路径\n        :param cloud_path: 云端存储路径（如：'images/example.jpg'）\n        :return: 文件ID（用于后续下载）\n        \"\"\"\n        self._ensure_access_token()\n        \n        # 1. 获取上传元数据\n        upload_meta_url = \"https://api.weixin.qq.com/tcb/uploadfile\"\n        params = {\"access_token\": self.access_token}\n        payload = {\"env\": self.env, \"path\": cloud_path}\n        response = requests.post(upload_meta_url, params=params, json=payload,verify=False).json()\n        print(payload, params)\n        if response.get('errcode', 0) != 0:\n            raise Exception(f\"上传元数据获取失败: {response}\")\n        \n        # 2. 上传文件到COS\n        cos_url = response['url']\n       \n        key = cloud_path.split('/')[-1]\n        print(key)\n        files = {\n            \"Signature\":(None,response['authorization']),\n            \"x-cos-meta-fileid\": (None, response['cos_file_id']),\n            \"x-cos-security-token\": (None,response['token']),\n            \"key\": (None, cloud_path),\n            'file':(key, open(local_path, 'rb')),\n        }\n\n        upload_resp = requests.post(cos_url, files=files, verify=False)\n        if upload_resp.status_code != 204:\n            raise Exception(f\"COS上传失败: {upload_resp.text}\", upload_resp)\n       \n        return response['file_id']\n```\n\n\n- ### 文件下载\n\n下载文件相对简单一些，直接调用微信开放平台对外提供的批量下载接口，当然对应的token也是需要的，这部分就不做赘述，代码实现可以参考下方。\n\n``` Python \n\ndef download_file(self, file_id, local_path):\n        \"\"\"\n        从微信云存储下载文件\n        :param file_id: 文件ID（上传时返回的file_id）\n        :param local_path: 本地存储路径\n        \"\"\"\n        self._ensure_access_token()\n        \n        # 1. 获取下载链接\n        download_meta_url = \"https://api.weixin.qq.com/tcb/batchdownloadfile\"\n        params = {\"access_token\": self.access_token}\n        payload = {\n            \"env\": self.env,\n            \"file_list\": [{\"fileid\": file_id, \"max_age\": 7200}]\n        }\n        response = requests.post(download_meta_url, params=params, json=payload, verify=False).json()\n        \n        if response.get('errcode', 0) != 0:\n            raise Exception(f\"下载元数据获取失败: {response}\")\n        \n        file_info = response['file_list'][0]\n        if file_info['status'] != 0:\n            raise Exception(f\"下载错误: {file_info['errmsg']}\")\n        \n        # 2. 下载文件\n        download_resp = requests.get(file_info['download_url'], verify=False)\n        if download_resp.status_code != 200:\n            raise Exception(\"文件下载失败\")\n        \n        with open(local_path, 'wb') as f:\n            f.write(download_resp.content)\n            \n        return True\n```\n\n以上就是微信云托管上对象存储的上传和下载的实现了。为了方便，我们可以将功能在一个类中实现。此外，考虑到token获取接口是有限制的，每天的调用次数是2000次，而每个token的有效时间是2小时，因此可以重复利用已有token。\n\n最终，完整的代码实现如下：\n\n``` Python\n# wx-cloud-storage.py\n# description: 微信云托管对象存储管理模块\nimport requests\nimport time\n\nclass WeChatCloudStorage:\n    def __init__(self, appid, secret, env):\n        self.appid = appid\n        self.secret = secret\n        self.env = env\n        self.access_token = None\n        self.token_expires = 0  # Token过期时间戳\n\n    def _refresh_access_token(self):\n        \"\"\"获取或刷新access_token\"\"\"\n        url = \"https://api.weixin.qq.com/cgi-bin/token\"\n        params = {\n            \"grant_type\": \"client_credential\",\n            \"appid\": self.appid,\n            \"secret\": self.secret\n        }\n        response = requests.get(url, params=params, verify=False).json()\n        if 'access_token' in response:\n            self.access_token = response['access_token']\n            self.token_expires = time.time() + response['expires_in'] - 300  # 提前5分钟刷新\n        else:\n            raise Exception(f\"获取access_token失败: {response}\")\n\n    def _ensure_access_token(self):\n        \"\"\"确保access_token有效\"\"\"\n        if time.time() >= self.token_expires or not self.access_token:\n            self._refresh_access_token()\n\n    def upload_file(self, local_path, cloud_path):\n        \"\"\"\n        上传本地文件到微信云存储\n        :param local_path: 本地文件路径\n        :param cloud_path: 云端存储路径（如：'images/example.jpg'）\n        :return: 文件ID（用于后续下载）\n        \"\"\"\n        self._ensure_access_token()\n        \n        # 1. 获取上传元数据\n        upload_meta_url = \"https://api.weixin.qq.com/tcb/uploadfile\"\n        params = {\"access_token\": self.access_token}\n        payload = {\"env\": self.env, \"path\": cloud_path}\n        response = requests.post(upload_meta_url, params=params, json=payload,verify=False).json()\n        print(payload, params)\n        if response.get('errcode', 0) != 0:\n            raise Exception(f\"上传元数据获取失败: {response}\")\n        \n        # 2. 上传文件到COS\n        cos_url = response['url']\n       \n        key = cloud_path.split('/')[-1]\n        print(key)\n        files = {\n            \"Signature\":(None,response['authorization']),\n            \"x-cos-meta-fileid\": (None, response['cos_file_id']),\n            \"x-cos-security-token\": (None,response['token']),\n            \"key\": (None, cloud_path),\n            'file':(key, open(local_path, 'rb')),\n        }\n\n        upload_resp = requests.post(cos_url, files=files, verify=False)\n        if upload_resp.status_code != 204:\n            raise Exception(f\"COS上传失败: {upload_resp.text}\", upload_resp)\n       \n        return response['file_id']\n\n    def download_file(self, file_id, local_path):\n        \"\"\"\n        从微信云存储下载文件\n        :param file_id: 文件ID（上传时返回的file_id）\n        :param local_path: 本地存储路径\n        \"\"\"\n        self._ensure_access_token()\n        \n        # 1. 获取下载链接\n        download_meta_url = \"https://api.weixin.qq.com/tcb/batchdownloadfile\"\n        params = {\"access_token\": self.access_token}\n        payload = {\n            \"env\": self.env,\n            \"file_list\": [{\"fileid\": file_id, \"max_age\": 7200}]\n        }\n        response = requests.post(download_meta_url, params=params, json=payload, verify=False).json()\n        \n        if response.get('errcode', 0) != 0:\n            raise Exception(f\"下载元数据获取失败: {response}\")\n        \n        file_info = response['file_list'][0]\n        if file_info['status'] != 0:\n            raise Exception(f\"下载错误: {file_info['errmsg']}\")\n        \n        # 2. 下载文件\n        download_resp = requests.get(file_info['download_url'], verify=False)\n        if download_resp.status_code != 200:\n            raise Exception(\"文件下载失败\")\n        \n        with open(local_path, 'wb') as f:\n            f.write(download_resp.content)\n            \n        return True\n\n# 使用示例\nif __name__ == \"__main__\":\n    # 配置信息（需要替换为实际值）\n    APPID = \"your-wechat-appid\"\n    SECRET = \"your-wechat-secret\"\n    ENV_ID = \"your-cloud-env-id\"\n   \n    # 上传示例\n    storage = WeChatCloudStorage(APPID, SECRET, ENV_ID)\n    try:\n        file_id = storage.upload_file(\"../test.png\", \"image/test2.png\")\n        print(f\"文件上传成功，File ID: {file_id}\")\n    except Exception as e:\n        print(f\"上传失败: {e}\")\n    # 下载示例\n    try:\n        storage.download_file(file_id, \"downloaded_image.jpg\")\n        print(\"文件下载成功\")\n    except Exception as e:\n        print(f\"下载失败: {e}\")\n\n\n```\n\n以上就是关于对象存储管理相关的内容了，如果你在开发类似的功能过程中有类似的idea或者遇到一些难搞的坑，欢迎一起讨论。","slug":"Manage-wx-could-service","published":1,"updated":"2025-06-21T14:16:44.677Z","_id":"cmb0qjkps000350up5hzhbjyl","comments":1,"layout":"post","photos":[],"content":"<p>最近在鼓捣一个关于图像处理相关的小程序，出于快速开发考虑，在后台开发这块，没有选择走传统的后台部署服务。毕竟，购买云服务器，注册购买域名以及备案等一系列操作下来，也够让人心累。</p>\n<p>这次选择的是微信开发的平台的云托管，至于为什么走的不是云函数开发，其中就涉及到了开发语言的选择–python, 如果改用javascript重写一下，成本有点高，所以最终方案选择云托管。</p>\n<p>在按照云托管的部署流程一通走下来后，everything is fine. But…</p>\n<p>离大谱的，接口请求和响应，居然不能超过1M, 而我这程序就是关于图像处理的，动不动图片大小就会超过1M。如果非要限制用户图片大小限制在1M以下，太过影响用户体验。</p>\n<p>此外我还想过，在用户端使用图像压缩，但图像太大压缩也会存在超过1M的情况，另外清晰度也会受到影响。</p>\n<p>在微信开发社区和各个IT论坛找了一圈下来，其实没有比较好的解决方案，最终都需要经过一个中间对象存储的过程。</p>\n<p>也就是先将图片上传到云上，让后将图片对象的id作为接口入参传入，后台需要使用到图片的时候根据图片id下载即可，然后将处理后的图片，又要上传回云上，返回给客户端新的图片的id，客户端可以根据图片id来获取资源。如下图</p>\n<!-- ![处理流程](./imgs/微信云对象存储..png) -->\n<div align=\"center\">\n    <img src=\"/imgs/微信云对象存储..png\" width=\"80%\" height=\"20%\" alt=\"处理流程\"/>\n</div>\n\n\n\n<p>对象存储云平台其实很多，例如比较有名的比如七牛，阿里，还有腾讯云自己的。我这里采用了微信云对象存储，具体的使用呢可以参考 <a href=\"https://developers.weixin.qq.com/minigame/dev/wxcloudrun/src/guide/storage/manage.html\">微信云托管对象存储</a>，相应的开发手册可以参考<a href=\"https://developers.weixin.qq.com/minigame/dev/wxcloudrun/src/development/storage/service/\">对象存储-服务端和其他客户端</a></p>\n<p>为了在后续的开发中更好处理类似的情况，我将微信云托管对象存储做成了一个模块，具体实现情况如下。</p>\n<p>首先，需要从自己的小程序或者和云托管平台获取到以下三个重要参数：</p>\n<ul>\n<li><p><strong>APPID</strong> ： “your-wechat-appid”</p>\n</li>\n<li><p><strong>SECRET</strong>： “your-wechat-secret”</p>\n</li>\n<li><p><strong>ENV_ID</strong>： “your-cloud-env-id”</p>\n</li>\n<li><h3 id=\"文件上传-获取token-获取元数据-上传COS\"><a href=\"#文件上传-获取token-获取元数据-上传COS\" class=\"headerlink\" title=\"文件上传 (获取token-获取元数据-上传COS)\"></a>文件上传 (获取token-获取元数据-上传COS)</h3></li>\n</ul>\n<p>微信开放平台如果第三方调用对应接口的话，都是需要鉴权了，所以首先我们需要获取到token值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_refresh_access_token</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;获取或刷新access_token&quot;&quot;&quot;</span><br>        url = <span class=\"hljs-string\">&quot;https://api.weixin.qq.com/cgi-bin/token&quot;</span><br>        params = &#123;<br>            <span class=\"hljs-string\">&quot;grant_type&quot;</span>: <span class=\"hljs-string\">&quot;client_credential&quot;</span>,<br>            <span class=\"hljs-string\">&quot;appid&quot;</span>: <span class=\"hljs-variable language_\">self</span>.appid,<br>            <span class=\"hljs-string\">&quot;secret&quot;</span>: <span class=\"hljs-variable language_\">self</span>.secret<br>        &#125;<br>        response = requests.get(url, params=params, verify=<span class=\"hljs-literal\">False</span>).json()<br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-string\">&#x27;access_token&#x27;</span> <span class=\"hljs-keyword\">in</span> response:<br>            <span class=\"hljs-variable language_\">self</span>.access_token = response[<span class=\"hljs-string\">&#x27;access_token&#x27;</span>]<br>            <span class=\"hljs-variable language_\">self</span>.token_expires = time.time() + response[<span class=\"hljs-string\">&#x27;expires_in&#x27;</span>] - <span class=\"hljs-number\">300</span>  <span class=\"hljs-comment\"># 提前5分钟刷新</span><br>        <span class=\"hljs-keyword\">else</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;获取access_token失败: <span class=\"hljs-subst\">&#123;response&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n\n<p>文件上传可以分成2步：<strong>1获取上传元数据，2上传文件到COS</strong>。</p>\n<p>获取元数据可以理解为向平台发送请求，获取一个用来存放一个文件（存储对象）的一个URL地址, 上传文件到COS可以则可以理解成将资源放到上一步生成的URL地址上，经此，文件才算真正的上传成功了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">upload_file</span>(<span class=\"hljs-params\">self, local_path, cloud_path</span>):<br>    <span class=\"hljs-string\">&quot;&quot;&quot;</span><br><span class=\"hljs-string\">    上传本地文件到微信云存储</span><br><span class=\"hljs-string\">    :param local_path: 本地文件路径</span><br><span class=\"hljs-string\">    :param cloud_path: 云端存储路径（如：&#x27;images/example.jpg&#x27;）</span><br><span class=\"hljs-string\">    :return: 文件ID（用于后续下载）</span><br><span class=\"hljs-string\">    &quot;&quot;&quot;</span><br>    <span class=\"hljs-variable language_\">self</span>._ensure_access_token()<br>    <br>    <span class=\"hljs-comment\"># 1. 获取上传元数据</span><br>    upload_meta_url = <span class=\"hljs-string\">&quot;https://api.weixin.qq.com/tcb/uploadfile&quot;</span><br>    params = &#123;<span class=\"hljs-string\">&quot;access_token&quot;</span>: <span class=\"hljs-variable language_\">self</span>.access_token&#125;<br>    payload = &#123;<span class=\"hljs-string\">&quot;env&quot;</span>: <span class=\"hljs-variable language_\">self</span>.env, <span class=\"hljs-string\">&quot;path&quot;</span>: cloud_path&#125;<br>    response = requests.post(upload_meta_url, params=params, json=payload,verify=<span class=\"hljs-literal\">False</span>).json()<br>    <span class=\"hljs-built_in\">print</span>(payload, params)<br>    <span class=\"hljs-keyword\">if</span> response.get(<span class=\"hljs-string\">&#x27;errcode&#x27;</span>, <span class=\"hljs-number\">0</span>) != <span class=\"hljs-number\">0</span>:<br>        <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;上传元数据获取失败: <span class=\"hljs-subst\">&#123;response&#125;</span>&quot;</span>)<br>    <br>    <span class=\"hljs-comment\"># 2. 上传文件到COS</span><br>    cos_url = response[<span class=\"hljs-string\">&#x27;url&#x27;</span>]<br>   <br>    key = cloud_path.split(<span class=\"hljs-string\">&#x27;/&#x27;</span>)[-<span class=\"hljs-number\">1</span>]<br>    <span class=\"hljs-built_in\">print</span>(key)<br>    files = &#123;<br>        <span class=\"hljs-string\">&quot;Signature&quot;</span>:(<span class=\"hljs-literal\">None</span>,response[<span class=\"hljs-string\">&#x27;authorization&#x27;</span>]),<br>        <span class=\"hljs-string\">&quot;x-cos-meta-fileid&quot;</span>: (<span class=\"hljs-literal\">None</span>, response[<span class=\"hljs-string\">&#x27;cos_file_id&#x27;</span>]),<br>        <span class=\"hljs-string\">&quot;x-cos-security-token&quot;</span>: (<span class=\"hljs-literal\">None</span>,response[<span class=\"hljs-string\">&#x27;token&#x27;</span>]),<br>        <span class=\"hljs-string\">&quot;key&quot;</span>: (<span class=\"hljs-literal\">None</span>, cloud_path),<br>        <span class=\"hljs-string\">&#x27;file&#x27;</span>:(key, <span class=\"hljs-built_in\">open</span>(local_path, <span class=\"hljs-string\">&#x27;rb&#x27;</span>)),<br>    &#125;<br><br>    upload_resp = requests.post(cos_url, files=files, verify=<span class=\"hljs-literal\">False</span>)<br>    <span class=\"hljs-keyword\">if</span> upload_resp.status_code != <span class=\"hljs-number\">204</span>:<br>        <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;COS上传失败: <span class=\"hljs-subst\">&#123;upload_resp.text&#125;</span>&quot;</span>, upload_resp)<br>   <br>    <span class=\"hljs-keyword\">return</span> response[<span class=\"hljs-string\">&#x27;file_id&#x27;</span>]<br></code></pre></td></tr></table></figure>\n\n\n<ul>\n<li><h3 id=\"文件下载\"><a href=\"#文件下载\" class=\"headerlink\" title=\"文件下载\"></a>文件下载</h3></li>\n</ul>\n<p>下载文件相对简单一些，直接调用微信开放平台对外提供的批量下载接口，当然对应的token也是需要的，这部分就不做赘述，代码实现可以参考下方。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Python\"><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">download_file</span>(<span class=\"hljs-params\">self, file_id, local_path</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;</span><br><span class=\"hljs-string\">        从微信云存储下载文件</span><br><span class=\"hljs-string\">        :param file_id: 文件ID（上传时返回的file_id）</span><br><span class=\"hljs-string\">        :param local_path: 本地存储路径</span><br><span class=\"hljs-string\">        &quot;&quot;&quot;</span><br>        <span class=\"hljs-variable language_\">self</span>._ensure_access_token()<br>        <br>        <span class=\"hljs-comment\"># 1. 获取下载链接</span><br>        download_meta_url = <span class=\"hljs-string\">&quot;https://api.weixin.qq.com/tcb/batchdownloadfile&quot;</span><br>        params = &#123;<span class=\"hljs-string\">&quot;access_token&quot;</span>: <span class=\"hljs-variable language_\">self</span>.access_token&#125;<br>        payload = &#123;<br>            <span class=\"hljs-string\">&quot;env&quot;</span>: <span class=\"hljs-variable language_\">self</span>.env,<br>            <span class=\"hljs-string\">&quot;file_list&quot;</span>: [&#123;<span class=\"hljs-string\">&quot;fileid&quot;</span>: file_id, <span class=\"hljs-string\">&quot;max_age&quot;</span>: <span class=\"hljs-number\">7200</span>&#125;]<br>        &#125;<br>        response = requests.post(download_meta_url, params=params, json=payload, verify=<span class=\"hljs-literal\">False</span>).json()<br>        <br>        <span class=\"hljs-keyword\">if</span> response.get(<span class=\"hljs-string\">&#x27;errcode&#x27;</span>, <span class=\"hljs-number\">0</span>) != <span class=\"hljs-number\">0</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;下载元数据获取失败: <span class=\"hljs-subst\">&#123;response&#125;</span>&quot;</span>)<br>        <br>        file_info = response[<span class=\"hljs-string\">&#x27;file_list&#x27;</span>][<span class=\"hljs-number\">0</span>]<br>        <span class=\"hljs-keyword\">if</span> file_info[<span class=\"hljs-string\">&#x27;status&#x27;</span>] != <span class=\"hljs-number\">0</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;下载错误: <span class=\"hljs-subst\">&#123;file_info[<span class=\"hljs-string\">&#x27;errmsg&#x27;</span>]&#125;</span>&quot;</span>)<br>        <br>        <span class=\"hljs-comment\"># 2. 下载文件</span><br>        download_resp = requests.get(file_info[<span class=\"hljs-string\">&#x27;download_url&#x27;</span>], verify=<span class=\"hljs-literal\">False</span>)<br>        <span class=\"hljs-keyword\">if</span> download_resp.status_code != <span class=\"hljs-number\">200</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">&quot;文件下载失败&quot;</span>)<br>        <br>        <span class=\"hljs-keyword\">with</span> <span class=\"hljs-built_in\">open</span>(local_path, <span class=\"hljs-string\">&#x27;wb&#x27;</span>) <span class=\"hljs-keyword\">as</span> f:<br>            f.write(download_resp.content)<br>            <br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span><br></code></pre></td></tr></table></figure>\n\n<p>以上就是微信云托管上对象存储的上传和下载的实现了。为了方便，我们可以将功能在一个类中实现。此外，考虑到token获取接口是有限制的，每天的调用次数是2000次，而每个token的有效时间是2小时，因此可以重复利用已有token。</p>\n<p>最终，完整的代码实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Python\"><span class=\"hljs-comment\"># wx-cloud-storage.py</span><br><span class=\"hljs-comment\"># description: 微信云托管对象存储管理模块</span><br><span class=\"hljs-keyword\">import</span> requests<br><span class=\"hljs-keyword\">import</span> time<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">WeChatCloudStorage</span>:<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, appid, secret, env</span>):<br>        <span class=\"hljs-variable language_\">self</span>.appid = appid<br>        <span class=\"hljs-variable language_\">self</span>.secret = secret<br>        <span class=\"hljs-variable language_\">self</span>.env = env<br>        <span class=\"hljs-variable language_\">self</span>.access_token = <span class=\"hljs-literal\">None</span><br>        <span class=\"hljs-variable language_\">self</span>.token_expires = <span class=\"hljs-number\">0</span>  <span class=\"hljs-comment\"># Token过期时间戳</span><br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_refresh_access_token</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;获取或刷新access_token&quot;&quot;&quot;</span><br>        url = <span class=\"hljs-string\">&quot;https://api.weixin.qq.com/cgi-bin/token&quot;</span><br>        params = &#123;<br>            <span class=\"hljs-string\">&quot;grant_type&quot;</span>: <span class=\"hljs-string\">&quot;client_credential&quot;</span>,<br>            <span class=\"hljs-string\">&quot;appid&quot;</span>: <span class=\"hljs-variable language_\">self</span>.appid,<br>            <span class=\"hljs-string\">&quot;secret&quot;</span>: <span class=\"hljs-variable language_\">self</span>.secret<br>        &#125;<br>        response = requests.get(url, params=params, verify=<span class=\"hljs-literal\">False</span>).json()<br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-string\">&#x27;access_token&#x27;</span> <span class=\"hljs-keyword\">in</span> response:<br>            <span class=\"hljs-variable language_\">self</span>.access_token = response[<span class=\"hljs-string\">&#x27;access_token&#x27;</span>]<br>            <span class=\"hljs-variable language_\">self</span>.token_expires = time.time() + response[<span class=\"hljs-string\">&#x27;expires_in&#x27;</span>] - <span class=\"hljs-number\">300</span>  <span class=\"hljs-comment\"># 提前5分钟刷新</span><br>        <span class=\"hljs-keyword\">else</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;获取access_token失败: <span class=\"hljs-subst\">&#123;response&#125;</span>&quot;</span>)<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_ensure_access_token</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;确保access_token有效&quot;&quot;&quot;</span><br>        <span class=\"hljs-keyword\">if</span> time.time() &gt;= <span class=\"hljs-variable language_\">self</span>.token_expires <span class=\"hljs-keyword\">or</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-variable language_\">self</span>.access_token:<br>            <span class=\"hljs-variable language_\">self</span>._refresh_access_token()<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">upload_file</span>(<span class=\"hljs-params\">self, local_path, cloud_path</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;</span><br><span class=\"hljs-string\">        上传本地文件到微信云存储</span><br><span class=\"hljs-string\">        :param local_path: 本地文件路径</span><br><span class=\"hljs-string\">        :param cloud_path: 云端存储路径（如：&#x27;images/example.jpg&#x27;）</span><br><span class=\"hljs-string\">        :return: 文件ID（用于后续下载）</span><br><span class=\"hljs-string\">        &quot;&quot;&quot;</span><br>        <span class=\"hljs-variable language_\">self</span>._ensure_access_token()<br>        <br>        <span class=\"hljs-comment\"># 1. 获取上传元数据</span><br>        upload_meta_url = <span class=\"hljs-string\">&quot;https://api.weixin.qq.com/tcb/uploadfile&quot;</span><br>        params = &#123;<span class=\"hljs-string\">&quot;access_token&quot;</span>: <span class=\"hljs-variable language_\">self</span>.access_token&#125;<br>        payload = &#123;<span class=\"hljs-string\">&quot;env&quot;</span>: <span class=\"hljs-variable language_\">self</span>.env, <span class=\"hljs-string\">&quot;path&quot;</span>: cloud_path&#125;<br>        response = requests.post(upload_meta_url, params=params, json=payload,verify=<span class=\"hljs-literal\">False</span>).json()<br>        <span class=\"hljs-built_in\">print</span>(payload, params)<br>        <span class=\"hljs-keyword\">if</span> response.get(<span class=\"hljs-string\">&#x27;errcode&#x27;</span>, <span class=\"hljs-number\">0</span>) != <span class=\"hljs-number\">0</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;上传元数据获取失败: <span class=\"hljs-subst\">&#123;response&#125;</span>&quot;</span>)<br>        <br>        <span class=\"hljs-comment\"># 2. 上传文件到COS</span><br>        cos_url = response[<span class=\"hljs-string\">&#x27;url&#x27;</span>]<br>       <br>        key = cloud_path.split(<span class=\"hljs-string\">&#x27;/&#x27;</span>)[-<span class=\"hljs-number\">1</span>]<br>        <span class=\"hljs-built_in\">print</span>(key)<br>        files = &#123;<br>            <span class=\"hljs-string\">&quot;Signature&quot;</span>:(<span class=\"hljs-literal\">None</span>,response[<span class=\"hljs-string\">&#x27;authorization&#x27;</span>]),<br>            <span class=\"hljs-string\">&quot;x-cos-meta-fileid&quot;</span>: (<span class=\"hljs-literal\">None</span>, response[<span class=\"hljs-string\">&#x27;cos_file_id&#x27;</span>]),<br>            <span class=\"hljs-string\">&quot;x-cos-security-token&quot;</span>: (<span class=\"hljs-literal\">None</span>,response[<span class=\"hljs-string\">&#x27;token&#x27;</span>]),<br>            <span class=\"hljs-string\">&quot;key&quot;</span>: (<span class=\"hljs-literal\">None</span>, cloud_path),<br>            <span class=\"hljs-string\">&#x27;file&#x27;</span>:(key, <span class=\"hljs-built_in\">open</span>(local_path, <span class=\"hljs-string\">&#x27;rb&#x27;</span>)),<br>        &#125;<br><br>        upload_resp = requests.post(cos_url, files=files, verify=<span class=\"hljs-literal\">False</span>)<br>        <span class=\"hljs-keyword\">if</span> upload_resp.status_code != <span class=\"hljs-number\">204</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;COS上传失败: <span class=\"hljs-subst\">&#123;upload_resp.text&#125;</span>&quot;</span>, upload_resp)<br>       <br>        <span class=\"hljs-keyword\">return</span> response[<span class=\"hljs-string\">&#x27;file_id&#x27;</span>]<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">download_file</span>(<span class=\"hljs-params\">self, file_id, local_path</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;</span><br><span class=\"hljs-string\">        从微信云存储下载文件</span><br><span class=\"hljs-string\">        :param file_id: 文件ID（上传时返回的file_id）</span><br><span class=\"hljs-string\">        :param local_path: 本地存储路径</span><br><span class=\"hljs-string\">        &quot;&quot;&quot;</span><br>        <span class=\"hljs-variable language_\">self</span>._ensure_access_token()<br>        <br>        <span class=\"hljs-comment\"># 1. 获取下载链接</span><br>        download_meta_url = <span class=\"hljs-string\">&quot;https://api.weixin.qq.com/tcb/batchdownloadfile&quot;</span><br>        params = &#123;<span class=\"hljs-string\">&quot;access_token&quot;</span>: <span class=\"hljs-variable language_\">self</span>.access_token&#125;<br>        payload = &#123;<br>            <span class=\"hljs-string\">&quot;env&quot;</span>: <span class=\"hljs-variable language_\">self</span>.env,<br>            <span class=\"hljs-string\">&quot;file_list&quot;</span>: [&#123;<span class=\"hljs-string\">&quot;fileid&quot;</span>: file_id, <span class=\"hljs-string\">&quot;max_age&quot;</span>: <span class=\"hljs-number\">7200</span>&#125;]<br>        &#125;<br>        response = requests.post(download_meta_url, params=params, json=payload, verify=<span class=\"hljs-literal\">False</span>).json()<br>        <br>        <span class=\"hljs-keyword\">if</span> response.get(<span class=\"hljs-string\">&#x27;errcode&#x27;</span>, <span class=\"hljs-number\">0</span>) != <span class=\"hljs-number\">0</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;下载元数据获取失败: <span class=\"hljs-subst\">&#123;response&#125;</span>&quot;</span>)<br>        <br>        file_info = response[<span class=\"hljs-string\">&#x27;file_list&#x27;</span>][<span class=\"hljs-number\">0</span>]<br>        <span class=\"hljs-keyword\">if</span> file_info[<span class=\"hljs-string\">&#x27;status&#x27;</span>] != <span class=\"hljs-number\">0</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;下载错误: <span class=\"hljs-subst\">&#123;file_info[<span class=\"hljs-string\">&#x27;errmsg&#x27;</span>]&#125;</span>&quot;</span>)<br>        <br>        <span class=\"hljs-comment\"># 2. 下载文件</span><br>        download_resp = requests.get(file_info[<span class=\"hljs-string\">&#x27;download_url&#x27;</span>], verify=<span class=\"hljs-literal\">False</span>)<br>        <span class=\"hljs-keyword\">if</span> download_resp.status_code != <span class=\"hljs-number\">200</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">&quot;文件下载失败&quot;</span>)<br>        <br>        <span class=\"hljs-keyword\">with</span> <span class=\"hljs-built_in\">open</span>(local_path, <span class=\"hljs-string\">&#x27;wb&#x27;</span>) <span class=\"hljs-keyword\">as</span> f:<br>            f.write(download_resp.content)<br>            <br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span><br><br><span class=\"hljs-comment\"># 使用示例</span><br><span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:<br>    <span class=\"hljs-comment\"># 配置信息（需要替换为实际值）</span><br>    APPID = <span class=\"hljs-string\">&quot;your-wechat-appid&quot;</span><br>    SECRET = <span class=\"hljs-string\">&quot;your-wechat-secret&quot;</span><br>    ENV_ID = <span class=\"hljs-string\">&quot;your-cloud-env-id&quot;</span><br>   <br>    <span class=\"hljs-comment\"># 上传示例</span><br>    storage = WeChatCloudStorage(APPID, SECRET, ENV_ID)<br>    <span class=\"hljs-keyword\">try</span>:<br>        file_id = storage.upload_file(<span class=\"hljs-string\">&quot;../test.png&quot;</span>, <span class=\"hljs-string\">&quot;image/test2.png&quot;</span>)<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;文件上传成功，File ID: <span class=\"hljs-subst\">&#123;file_id&#125;</span>&quot;</span>)<br>    <span class=\"hljs-keyword\">except</span> Exception <span class=\"hljs-keyword\">as</span> e:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;上传失败: <span class=\"hljs-subst\">&#123;e&#125;</span>&quot;</span>)<br>    <span class=\"hljs-comment\"># 下载示例</span><br>    <span class=\"hljs-keyword\">try</span>:<br>        storage.download_file(file_id, <span class=\"hljs-string\">&quot;downloaded_image.jpg&quot;</span>)<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;文件下载成功&quot;</span>)<br>    <span class=\"hljs-keyword\">except</span> Exception <span class=\"hljs-keyword\">as</span> e:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;下载失败: <span class=\"hljs-subst\">&#123;e&#125;</span>&quot;</span>)<br><br><br></code></pre></td></tr></table></figure>\n\n<p>以上就是关于对象存储管理相关的内容了，如果你在开发类似的功能过程中有类似的idea或者遇到一些难搞的坑，欢迎一起讨论。</p>\n","excerpt":"","more":"<p>最近在鼓捣一个关于图像处理相关的小程序，出于快速开发考虑，在后台开发这块，没有选择走传统的后台部署服务。毕竟，购买云服务器，注册购买域名以及备案等一系列操作下来，也够让人心累。</p>\n<p>这次选择的是微信开发的平台的云托管，至于为什么走的不是云函数开发，其中就涉及到了开发语言的选择–python, 如果改用javascript重写一下，成本有点高，所以最终方案选择云托管。</p>\n<p>在按照云托管的部署流程一通走下来后，everything is fine. But…</p>\n<p>离大谱的，接口请求和响应，居然不能超过1M, 而我这程序就是关于图像处理的，动不动图片大小就会超过1M。如果非要限制用户图片大小限制在1M以下，太过影响用户体验。</p>\n<p>此外我还想过，在用户端使用图像压缩，但图像太大压缩也会存在超过1M的情况，另外清晰度也会受到影响。</p>\n<p>在微信开发社区和各个IT论坛找了一圈下来，其实没有比较好的解决方案，最终都需要经过一个中间对象存储的过程。</p>\n<p>也就是先将图片上传到云上，让后将图片对象的id作为接口入参传入，后台需要使用到图片的时候根据图片id下载即可，然后将处理后的图片，又要上传回云上，返回给客户端新的图片的id，客户端可以根据图片id来获取资源。如下图</p>\n<!-- ![处理流程](./imgs/微信云对象存储..png) -->\n<div align=\"center\">\n    <img src=\"/imgs/微信云对象存储..png\" width=\"80%\" height=\"20%\" alt=\"处理流程\"/>\n</div>\n\n\n\n<p>对象存储云平台其实很多，例如比较有名的比如七牛，阿里，还有腾讯云自己的。我这里采用了微信云对象存储，具体的使用呢可以参考 <a href=\"https://developers.weixin.qq.com/minigame/dev/wxcloudrun/src/guide/storage/manage.html\">微信云托管对象存储</a>，相应的开发手册可以参考<a href=\"https://developers.weixin.qq.com/minigame/dev/wxcloudrun/src/development/storage/service/\">对象存储-服务端和其他客户端</a></p>\n<p>为了在后续的开发中更好处理类似的情况，我将微信云托管对象存储做成了一个模块，具体实现情况如下。</p>\n<p>首先，需要从自己的小程序或者和云托管平台获取到以下三个重要参数：</p>\n<ul>\n<li><p><strong>APPID</strong> ： “your-wechat-appid”</p>\n</li>\n<li><p><strong>SECRET</strong>： “your-wechat-secret”</p>\n</li>\n<li><p><strong>ENV_ID</strong>： “your-cloud-env-id”</p>\n</li>\n<li><h3 id=\"文件上传-获取token-获取元数据-上传COS\"><a href=\"#文件上传-获取token-获取元数据-上传COS\" class=\"headerlink\" title=\"文件上传 (获取token-获取元数据-上传COS)\"></a>文件上传 (获取token-获取元数据-上传COS)</h3></li>\n</ul>\n<p>微信开放平台如果第三方调用对应接口的话，都是需要鉴权了，所以首先我们需要获取到token值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_refresh_access_token</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;获取或刷新access_token&quot;&quot;&quot;</span><br>        url = <span class=\"hljs-string\">&quot;https://api.weixin.qq.com/cgi-bin/token&quot;</span><br>        params = &#123;<br>            <span class=\"hljs-string\">&quot;grant_type&quot;</span>: <span class=\"hljs-string\">&quot;client_credential&quot;</span>,<br>            <span class=\"hljs-string\">&quot;appid&quot;</span>: <span class=\"hljs-variable language_\">self</span>.appid,<br>            <span class=\"hljs-string\">&quot;secret&quot;</span>: <span class=\"hljs-variable language_\">self</span>.secret<br>        &#125;<br>        response = requests.get(url, params=params, verify=<span class=\"hljs-literal\">False</span>).json()<br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-string\">&#x27;access_token&#x27;</span> <span class=\"hljs-keyword\">in</span> response:<br>            <span class=\"hljs-variable language_\">self</span>.access_token = response[<span class=\"hljs-string\">&#x27;access_token&#x27;</span>]<br>            <span class=\"hljs-variable language_\">self</span>.token_expires = time.time() + response[<span class=\"hljs-string\">&#x27;expires_in&#x27;</span>] - <span class=\"hljs-number\">300</span>  <span class=\"hljs-comment\"># 提前5分钟刷新</span><br>        <span class=\"hljs-keyword\">else</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;获取access_token失败: <span class=\"hljs-subst\">&#123;response&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n\n<p>文件上传可以分成2步：<strong>1获取上传元数据，2上传文件到COS</strong>。</p>\n<p>获取元数据可以理解为向平台发送请求，获取一个用来存放一个文件（存储对象）的一个URL地址, 上传文件到COS可以则可以理解成将资源放到上一步生成的URL地址上，经此，文件才算真正的上传成功了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">upload_file</span>(<span class=\"hljs-params\">self, local_path, cloud_path</span>):<br>    <span class=\"hljs-string\">&quot;&quot;&quot;</span><br><span class=\"hljs-string\">    上传本地文件到微信云存储</span><br><span class=\"hljs-string\">    :param local_path: 本地文件路径</span><br><span class=\"hljs-string\">    :param cloud_path: 云端存储路径（如：&#x27;images/example.jpg&#x27;）</span><br><span class=\"hljs-string\">    :return: 文件ID（用于后续下载）</span><br><span class=\"hljs-string\">    &quot;&quot;&quot;</span><br>    <span class=\"hljs-variable language_\">self</span>._ensure_access_token()<br>    <br>    <span class=\"hljs-comment\"># 1. 获取上传元数据</span><br>    upload_meta_url = <span class=\"hljs-string\">&quot;https://api.weixin.qq.com/tcb/uploadfile&quot;</span><br>    params = &#123;<span class=\"hljs-string\">&quot;access_token&quot;</span>: <span class=\"hljs-variable language_\">self</span>.access_token&#125;<br>    payload = &#123;<span class=\"hljs-string\">&quot;env&quot;</span>: <span class=\"hljs-variable language_\">self</span>.env, <span class=\"hljs-string\">&quot;path&quot;</span>: cloud_path&#125;<br>    response = requests.post(upload_meta_url, params=params, json=payload,verify=<span class=\"hljs-literal\">False</span>).json()<br>    <span class=\"hljs-built_in\">print</span>(payload, params)<br>    <span class=\"hljs-keyword\">if</span> response.get(<span class=\"hljs-string\">&#x27;errcode&#x27;</span>, <span class=\"hljs-number\">0</span>) != <span class=\"hljs-number\">0</span>:<br>        <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;上传元数据获取失败: <span class=\"hljs-subst\">&#123;response&#125;</span>&quot;</span>)<br>    <br>    <span class=\"hljs-comment\"># 2. 上传文件到COS</span><br>    cos_url = response[<span class=\"hljs-string\">&#x27;url&#x27;</span>]<br>   <br>    key = cloud_path.split(<span class=\"hljs-string\">&#x27;/&#x27;</span>)[-<span class=\"hljs-number\">1</span>]<br>    <span class=\"hljs-built_in\">print</span>(key)<br>    files = &#123;<br>        <span class=\"hljs-string\">&quot;Signature&quot;</span>:(<span class=\"hljs-literal\">None</span>,response[<span class=\"hljs-string\">&#x27;authorization&#x27;</span>]),<br>        <span class=\"hljs-string\">&quot;x-cos-meta-fileid&quot;</span>: (<span class=\"hljs-literal\">None</span>, response[<span class=\"hljs-string\">&#x27;cos_file_id&#x27;</span>]),<br>        <span class=\"hljs-string\">&quot;x-cos-security-token&quot;</span>: (<span class=\"hljs-literal\">None</span>,response[<span class=\"hljs-string\">&#x27;token&#x27;</span>]),<br>        <span class=\"hljs-string\">&quot;key&quot;</span>: (<span class=\"hljs-literal\">None</span>, cloud_path),<br>        <span class=\"hljs-string\">&#x27;file&#x27;</span>:(key, <span class=\"hljs-built_in\">open</span>(local_path, <span class=\"hljs-string\">&#x27;rb&#x27;</span>)),<br>    &#125;<br><br>    upload_resp = requests.post(cos_url, files=files, verify=<span class=\"hljs-literal\">False</span>)<br>    <span class=\"hljs-keyword\">if</span> upload_resp.status_code != <span class=\"hljs-number\">204</span>:<br>        <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;COS上传失败: <span class=\"hljs-subst\">&#123;upload_resp.text&#125;</span>&quot;</span>, upload_resp)<br>   <br>    <span class=\"hljs-keyword\">return</span> response[<span class=\"hljs-string\">&#x27;file_id&#x27;</span>]<br></code></pre></td></tr></table></figure>\n\n\n<ul>\n<li><h3 id=\"文件下载\"><a href=\"#文件下载\" class=\"headerlink\" title=\"文件下载\"></a>文件下载</h3></li>\n</ul>\n<p>下载文件相对简单一些，直接调用微信开放平台对外提供的批量下载接口，当然对应的token也是需要的，这部分就不做赘述，代码实现可以参考下方。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Python\"><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">download_file</span>(<span class=\"hljs-params\">self, file_id, local_path</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;</span><br><span class=\"hljs-string\">        从微信云存储下载文件</span><br><span class=\"hljs-string\">        :param file_id: 文件ID（上传时返回的file_id）</span><br><span class=\"hljs-string\">        :param local_path: 本地存储路径</span><br><span class=\"hljs-string\">        &quot;&quot;&quot;</span><br>        <span class=\"hljs-variable language_\">self</span>._ensure_access_token()<br>        <br>        <span class=\"hljs-comment\"># 1. 获取下载链接</span><br>        download_meta_url = <span class=\"hljs-string\">&quot;https://api.weixin.qq.com/tcb/batchdownloadfile&quot;</span><br>        params = &#123;<span class=\"hljs-string\">&quot;access_token&quot;</span>: <span class=\"hljs-variable language_\">self</span>.access_token&#125;<br>        payload = &#123;<br>            <span class=\"hljs-string\">&quot;env&quot;</span>: <span class=\"hljs-variable language_\">self</span>.env,<br>            <span class=\"hljs-string\">&quot;file_list&quot;</span>: [&#123;<span class=\"hljs-string\">&quot;fileid&quot;</span>: file_id, <span class=\"hljs-string\">&quot;max_age&quot;</span>: <span class=\"hljs-number\">7200</span>&#125;]<br>        &#125;<br>        response = requests.post(download_meta_url, params=params, json=payload, verify=<span class=\"hljs-literal\">False</span>).json()<br>        <br>        <span class=\"hljs-keyword\">if</span> response.get(<span class=\"hljs-string\">&#x27;errcode&#x27;</span>, <span class=\"hljs-number\">0</span>) != <span class=\"hljs-number\">0</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;下载元数据获取失败: <span class=\"hljs-subst\">&#123;response&#125;</span>&quot;</span>)<br>        <br>        file_info = response[<span class=\"hljs-string\">&#x27;file_list&#x27;</span>][<span class=\"hljs-number\">0</span>]<br>        <span class=\"hljs-keyword\">if</span> file_info[<span class=\"hljs-string\">&#x27;status&#x27;</span>] != <span class=\"hljs-number\">0</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;下载错误: <span class=\"hljs-subst\">&#123;file_info[<span class=\"hljs-string\">&#x27;errmsg&#x27;</span>]&#125;</span>&quot;</span>)<br>        <br>        <span class=\"hljs-comment\"># 2. 下载文件</span><br>        download_resp = requests.get(file_info[<span class=\"hljs-string\">&#x27;download_url&#x27;</span>], verify=<span class=\"hljs-literal\">False</span>)<br>        <span class=\"hljs-keyword\">if</span> download_resp.status_code != <span class=\"hljs-number\">200</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">&quot;文件下载失败&quot;</span>)<br>        <br>        <span class=\"hljs-keyword\">with</span> <span class=\"hljs-built_in\">open</span>(local_path, <span class=\"hljs-string\">&#x27;wb&#x27;</span>) <span class=\"hljs-keyword\">as</span> f:<br>            f.write(download_resp.content)<br>            <br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span><br></code></pre></td></tr></table></figure>\n\n<p>以上就是微信云托管上对象存储的上传和下载的实现了。为了方便，我们可以将功能在一个类中实现。此外，考虑到token获取接口是有限制的，每天的调用次数是2000次，而每个token的有效时间是2小时，因此可以重复利用已有token。</p>\n<p>最终，完整的代码实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Python\"><span class=\"hljs-comment\"># wx-cloud-storage.py</span><br><span class=\"hljs-comment\"># description: 微信云托管对象存储管理模块</span><br><span class=\"hljs-keyword\">import</span> requests<br><span class=\"hljs-keyword\">import</span> time<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">WeChatCloudStorage</span>:<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, appid, secret, env</span>):<br>        <span class=\"hljs-variable language_\">self</span>.appid = appid<br>        <span class=\"hljs-variable language_\">self</span>.secret = secret<br>        <span class=\"hljs-variable language_\">self</span>.env = env<br>        <span class=\"hljs-variable language_\">self</span>.access_token = <span class=\"hljs-literal\">None</span><br>        <span class=\"hljs-variable language_\">self</span>.token_expires = <span class=\"hljs-number\">0</span>  <span class=\"hljs-comment\"># Token过期时间戳</span><br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_refresh_access_token</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;获取或刷新access_token&quot;&quot;&quot;</span><br>        url = <span class=\"hljs-string\">&quot;https://api.weixin.qq.com/cgi-bin/token&quot;</span><br>        params = &#123;<br>            <span class=\"hljs-string\">&quot;grant_type&quot;</span>: <span class=\"hljs-string\">&quot;client_credential&quot;</span>,<br>            <span class=\"hljs-string\">&quot;appid&quot;</span>: <span class=\"hljs-variable language_\">self</span>.appid,<br>            <span class=\"hljs-string\">&quot;secret&quot;</span>: <span class=\"hljs-variable language_\">self</span>.secret<br>        &#125;<br>        response = requests.get(url, params=params, verify=<span class=\"hljs-literal\">False</span>).json()<br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-string\">&#x27;access_token&#x27;</span> <span class=\"hljs-keyword\">in</span> response:<br>            <span class=\"hljs-variable language_\">self</span>.access_token = response[<span class=\"hljs-string\">&#x27;access_token&#x27;</span>]<br>            <span class=\"hljs-variable language_\">self</span>.token_expires = time.time() + response[<span class=\"hljs-string\">&#x27;expires_in&#x27;</span>] - <span class=\"hljs-number\">300</span>  <span class=\"hljs-comment\"># 提前5分钟刷新</span><br>        <span class=\"hljs-keyword\">else</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;获取access_token失败: <span class=\"hljs-subst\">&#123;response&#125;</span>&quot;</span>)<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_ensure_access_token</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;确保access_token有效&quot;&quot;&quot;</span><br>        <span class=\"hljs-keyword\">if</span> time.time() &gt;= <span class=\"hljs-variable language_\">self</span>.token_expires <span class=\"hljs-keyword\">or</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-variable language_\">self</span>.access_token:<br>            <span class=\"hljs-variable language_\">self</span>._refresh_access_token()<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">upload_file</span>(<span class=\"hljs-params\">self, local_path, cloud_path</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;</span><br><span class=\"hljs-string\">        上传本地文件到微信云存储</span><br><span class=\"hljs-string\">        :param local_path: 本地文件路径</span><br><span class=\"hljs-string\">        :param cloud_path: 云端存储路径（如：&#x27;images/example.jpg&#x27;）</span><br><span class=\"hljs-string\">        :return: 文件ID（用于后续下载）</span><br><span class=\"hljs-string\">        &quot;&quot;&quot;</span><br>        <span class=\"hljs-variable language_\">self</span>._ensure_access_token()<br>        <br>        <span class=\"hljs-comment\"># 1. 获取上传元数据</span><br>        upload_meta_url = <span class=\"hljs-string\">&quot;https://api.weixin.qq.com/tcb/uploadfile&quot;</span><br>        params = &#123;<span class=\"hljs-string\">&quot;access_token&quot;</span>: <span class=\"hljs-variable language_\">self</span>.access_token&#125;<br>        payload = &#123;<span class=\"hljs-string\">&quot;env&quot;</span>: <span class=\"hljs-variable language_\">self</span>.env, <span class=\"hljs-string\">&quot;path&quot;</span>: cloud_path&#125;<br>        response = requests.post(upload_meta_url, params=params, json=payload,verify=<span class=\"hljs-literal\">False</span>).json()<br>        <span class=\"hljs-built_in\">print</span>(payload, params)<br>        <span class=\"hljs-keyword\">if</span> response.get(<span class=\"hljs-string\">&#x27;errcode&#x27;</span>, <span class=\"hljs-number\">0</span>) != <span class=\"hljs-number\">0</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;上传元数据获取失败: <span class=\"hljs-subst\">&#123;response&#125;</span>&quot;</span>)<br>        <br>        <span class=\"hljs-comment\"># 2. 上传文件到COS</span><br>        cos_url = response[<span class=\"hljs-string\">&#x27;url&#x27;</span>]<br>       <br>        key = cloud_path.split(<span class=\"hljs-string\">&#x27;/&#x27;</span>)[-<span class=\"hljs-number\">1</span>]<br>        <span class=\"hljs-built_in\">print</span>(key)<br>        files = &#123;<br>            <span class=\"hljs-string\">&quot;Signature&quot;</span>:(<span class=\"hljs-literal\">None</span>,response[<span class=\"hljs-string\">&#x27;authorization&#x27;</span>]),<br>            <span class=\"hljs-string\">&quot;x-cos-meta-fileid&quot;</span>: (<span class=\"hljs-literal\">None</span>, response[<span class=\"hljs-string\">&#x27;cos_file_id&#x27;</span>]),<br>            <span class=\"hljs-string\">&quot;x-cos-security-token&quot;</span>: (<span class=\"hljs-literal\">None</span>,response[<span class=\"hljs-string\">&#x27;token&#x27;</span>]),<br>            <span class=\"hljs-string\">&quot;key&quot;</span>: (<span class=\"hljs-literal\">None</span>, cloud_path),<br>            <span class=\"hljs-string\">&#x27;file&#x27;</span>:(key, <span class=\"hljs-built_in\">open</span>(local_path, <span class=\"hljs-string\">&#x27;rb&#x27;</span>)),<br>        &#125;<br><br>        upload_resp = requests.post(cos_url, files=files, verify=<span class=\"hljs-literal\">False</span>)<br>        <span class=\"hljs-keyword\">if</span> upload_resp.status_code != <span class=\"hljs-number\">204</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;COS上传失败: <span class=\"hljs-subst\">&#123;upload_resp.text&#125;</span>&quot;</span>, upload_resp)<br>       <br>        <span class=\"hljs-keyword\">return</span> response[<span class=\"hljs-string\">&#x27;file_id&#x27;</span>]<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">download_file</span>(<span class=\"hljs-params\">self, file_id, local_path</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;</span><br><span class=\"hljs-string\">        从微信云存储下载文件</span><br><span class=\"hljs-string\">        :param file_id: 文件ID（上传时返回的file_id）</span><br><span class=\"hljs-string\">        :param local_path: 本地存储路径</span><br><span class=\"hljs-string\">        &quot;&quot;&quot;</span><br>        <span class=\"hljs-variable language_\">self</span>._ensure_access_token()<br>        <br>        <span class=\"hljs-comment\"># 1. 获取下载链接</span><br>        download_meta_url = <span class=\"hljs-string\">&quot;https://api.weixin.qq.com/tcb/batchdownloadfile&quot;</span><br>        params = &#123;<span class=\"hljs-string\">&quot;access_token&quot;</span>: <span class=\"hljs-variable language_\">self</span>.access_token&#125;<br>        payload = &#123;<br>            <span class=\"hljs-string\">&quot;env&quot;</span>: <span class=\"hljs-variable language_\">self</span>.env,<br>            <span class=\"hljs-string\">&quot;file_list&quot;</span>: [&#123;<span class=\"hljs-string\">&quot;fileid&quot;</span>: file_id, <span class=\"hljs-string\">&quot;max_age&quot;</span>: <span class=\"hljs-number\">7200</span>&#125;]<br>        &#125;<br>        response = requests.post(download_meta_url, params=params, json=payload, verify=<span class=\"hljs-literal\">False</span>).json()<br>        <br>        <span class=\"hljs-keyword\">if</span> response.get(<span class=\"hljs-string\">&#x27;errcode&#x27;</span>, <span class=\"hljs-number\">0</span>) != <span class=\"hljs-number\">0</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;下载元数据获取失败: <span class=\"hljs-subst\">&#123;response&#125;</span>&quot;</span>)<br>        <br>        file_info = response[<span class=\"hljs-string\">&#x27;file_list&#x27;</span>][<span class=\"hljs-number\">0</span>]<br>        <span class=\"hljs-keyword\">if</span> file_info[<span class=\"hljs-string\">&#x27;status&#x27;</span>] != <span class=\"hljs-number\">0</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;下载错误: <span class=\"hljs-subst\">&#123;file_info[<span class=\"hljs-string\">&#x27;errmsg&#x27;</span>]&#125;</span>&quot;</span>)<br>        <br>        <span class=\"hljs-comment\"># 2. 下载文件</span><br>        download_resp = requests.get(file_info[<span class=\"hljs-string\">&#x27;download_url&#x27;</span>], verify=<span class=\"hljs-literal\">False</span>)<br>        <span class=\"hljs-keyword\">if</span> download_resp.status_code != <span class=\"hljs-number\">200</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">&quot;文件下载失败&quot;</span>)<br>        <br>        <span class=\"hljs-keyword\">with</span> <span class=\"hljs-built_in\">open</span>(local_path, <span class=\"hljs-string\">&#x27;wb&#x27;</span>) <span class=\"hljs-keyword\">as</span> f:<br>            f.write(download_resp.content)<br>            <br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span><br><br><span class=\"hljs-comment\"># 使用示例</span><br><span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:<br>    <span class=\"hljs-comment\"># 配置信息（需要替换为实际值）</span><br>    APPID = <span class=\"hljs-string\">&quot;your-wechat-appid&quot;</span><br>    SECRET = <span class=\"hljs-string\">&quot;your-wechat-secret&quot;</span><br>    ENV_ID = <span class=\"hljs-string\">&quot;your-cloud-env-id&quot;</span><br>   <br>    <span class=\"hljs-comment\"># 上传示例</span><br>    storage = WeChatCloudStorage(APPID, SECRET, ENV_ID)<br>    <span class=\"hljs-keyword\">try</span>:<br>        file_id = storage.upload_file(<span class=\"hljs-string\">&quot;../test.png&quot;</span>, <span class=\"hljs-string\">&quot;image/test2.png&quot;</span>)<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;文件上传成功，File ID: <span class=\"hljs-subst\">&#123;file_id&#125;</span>&quot;</span>)<br>    <span class=\"hljs-keyword\">except</span> Exception <span class=\"hljs-keyword\">as</span> e:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;上传失败: <span class=\"hljs-subst\">&#123;e&#125;</span>&quot;</span>)<br>    <span class=\"hljs-comment\"># 下载示例</span><br>    <span class=\"hljs-keyword\">try</span>:<br>        storage.download_file(file_id, <span class=\"hljs-string\">&quot;downloaded_image.jpg&quot;</span>)<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;文件下载成功&quot;</span>)<br>    <span class=\"hljs-keyword\">except</span> Exception <span class=\"hljs-keyword\">as</span> e:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;下载失败: <span class=\"hljs-subst\">&#123;e&#125;</span>&quot;</span>)<br><br><br></code></pre></td></tr></table></figure>\n\n<p>以上就是关于对象存储管理相关的内容了，如果你在开发类似的功能过程中有类似的idea或者遇到一些难搞的坑，欢迎一起讨论。</p>\n"},{"title":"糟糕，Vite proxy error ECONNREFUSED","date":"2025-05-23T04:40:00.000Z","_content":" \n\n最近正在开发一款应用，前端框架是vite+vue, 后台服务也是使用的node+express组合，当一切工作都在顺利进行的时候，不出意外，意外出现了。\n\n当我尝试使用axios直连本地服务地址的时候，丝滑得如同德芙一样。然而每次请求地址都需要拼写全链接--即host+port+service-path，这是一件很愚蠢的事情。\n\n为了让事情变得简单一些，减少重复工作，我和聪明的各位一样决定使用vite的代理。\n\n因为web的地址9000，本地启动的后台服务地址是8080，所以我最初的配置如下：\n\n``` javascript\nexport default defineConfig({\n  # ...   其它配置\n  server: {\n    host: '0.0.0.0',\n    port: 9000,\n    proxy: {\n      '/api': {\n        target: 'http://localhost:8080/',\n        changeOrigin: true,\n      }\n    }\n  }\n})\n\n```\n\n然后它却对我说 `Vite proxy error ECONNREFUSED`\n\n那么多大风大浪都过去了，居然在这小阴沟里翻了船，忍不了！\n\n## 排查方向\n因为涉及到vite server配置，其本质就是http-server以及http-agent的问题,  于是从从下面几个方向做了一一排查\n\n- **Vite的服务器配置**\n\n- **端口占用或防火墙设置**\n\n- **浏览器或系统代理设置**\n\n- ​**Hosts文件配置问题或DNS解析问题**\n\n\n## 测试验证\n- 首先vite服务配置问题是最先被排除的，因为该项目配置已经经历了时间的考验，在很多项目中都有使用\n\n- 然后通过 `netstat -ano | find 9000` 检查并未发现端口被占用的情况\n\n- 至于代理，确实是开了--科学上网使用。然而在关闭之后，似乎没有起作用，所以问题不在这里。\n\n- 那么还剩最后一条，当我检查我本地的hosts文件时，纳尼，localhost没有配置指向本地的环回地址127.0.0.1，难道是这里出问题了吗。\n\n  为了验证这个想法，我将配置中的target做了以下修改:\n\n  ~~target: 'http://localhost:8080/'~~ </br>\n    target: 'http://127.0.0.1:8080/'\n\n  果然，生效了，看来之前的猜测是对的。\n\n</br>\n\n所以目前至少有两种方法可以解决该问题：\n\n  - **在vite配置中将localhost替换成127.0.0.1**\n  - **在hosts文件中添加localhost的地址**\n\n当然，第二种方式显然是更合理的，几乎是种一劳永逸的方法，在日后不同项目的开发中，总是难免还会存在使用localhost的情况。因此，建议在hosts文件中配置它。\n\n## 总结\n在这个问题中呢，其实也牵扯出更多的关于http server 和 http client相关的知识。不论是server的创建还是client的连接，正确的ip和端口是需要保证的。\n\n当遇到类似的情况时，不妨从底层思考在复杂的封装工具和配置的背后，它的本质是什么，以及正常使用时需要哪些因子的参与。","source":"_posts/Vite-server-error.md","raw":"---\ntitle: 糟糕，Vite proxy error ECONNREFUSED\ndate: 2025-05-23 12:40:00\ncategory: Web开发\ntags:\n  - Vite\n  - Proxy\n  - error\n--- \n\n最近正在开发一款应用，前端框架是vite+vue, 后台服务也是使用的node+express组合，当一切工作都在顺利进行的时候，不出意外，意外出现了。\n\n当我尝试使用axios直连本地服务地址的时候，丝滑得如同德芙一样。然而每次请求地址都需要拼写全链接--即host+port+service-path，这是一件很愚蠢的事情。\n\n为了让事情变得简单一些，减少重复工作，我和聪明的各位一样决定使用vite的代理。\n\n因为web的地址9000，本地启动的后台服务地址是8080，所以我最初的配置如下：\n\n``` javascript\nexport default defineConfig({\n  # ...   其它配置\n  server: {\n    host: '0.0.0.0',\n    port: 9000,\n    proxy: {\n      '/api': {\n        target: 'http://localhost:8080/',\n        changeOrigin: true,\n      }\n    }\n  }\n})\n\n```\n\n然后它却对我说 `Vite proxy error ECONNREFUSED`\n\n那么多大风大浪都过去了，居然在这小阴沟里翻了船，忍不了！\n\n## 排查方向\n因为涉及到vite server配置，其本质就是http-server以及http-agent的问题,  于是从从下面几个方向做了一一排查\n\n- **Vite的服务器配置**\n\n- **端口占用或防火墙设置**\n\n- **浏览器或系统代理设置**\n\n- ​**Hosts文件配置问题或DNS解析问题**\n\n\n## 测试验证\n- 首先vite服务配置问题是最先被排除的，因为该项目配置已经经历了时间的考验，在很多项目中都有使用\n\n- 然后通过 `netstat -ano | find 9000` 检查并未发现端口被占用的情况\n\n- 至于代理，确实是开了--科学上网使用。然而在关闭之后，似乎没有起作用，所以问题不在这里。\n\n- 那么还剩最后一条，当我检查我本地的hosts文件时，纳尼，localhost没有配置指向本地的环回地址127.0.0.1，难道是这里出问题了吗。\n\n  为了验证这个想法，我将配置中的target做了以下修改:\n\n  ~~target: 'http://localhost:8080/'~~ </br>\n    target: 'http://127.0.0.1:8080/'\n\n  果然，生效了，看来之前的猜测是对的。\n\n</br>\n\n所以目前至少有两种方法可以解决该问题：\n\n  - **在vite配置中将localhost替换成127.0.0.1**\n  - **在hosts文件中添加localhost的地址**\n\n当然，第二种方式显然是更合理的，几乎是种一劳永逸的方法，在日后不同项目的开发中，总是难免还会存在使用localhost的情况。因此，建议在hosts文件中配置它。\n\n## 总结\n在这个问题中呢，其实也牵扯出更多的关于http server 和 http client相关的知识。不论是server的创建还是client的连接，正确的ip和端口是需要保证的。\n\n当遇到类似的情况时，不妨从底层思考在复杂的封装工具和配置的背后，它的本质是什么，以及正常使用时需要哪些因子的参与。","slug":"Vite-server-error","published":1,"updated":"2025-06-21T14:16:56.740Z","_id":"cmb0qjkpt000450upatq31y8w","comments":1,"layout":"post","photos":[],"content":"<p>最近正在开发一款应用，前端框架是vite+vue, 后台服务也是使用的node+express组合，当一切工作都在顺利进行的时候，不出意外，意外出现了。</p>\n<p>当我尝试使用axios直连本地服务地址的时候，丝滑得如同德芙一样。然而每次请求地址都需要拼写全链接–即host+port+service-path，这是一件很愚蠢的事情。</p>\n<p>为了让事情变得简单一些，减少重复工作，我和聪明的各位一样决定使用vite的代理。</p>\n<p>因为web的地址9000，本地启动的后台服务地址是8080，所以我最初的配置如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title function_\">defineConfig</span>(&#123;<br>  # ...   其它配置<br>  <span class=\"hljs-attr\">server</span>: &#123;<br>    <span class=\"hljs-attr\">host</span>: <span class=\"hljs-string\">&#x27;0.0.0.0&#x27;</span>,<br>    <span class=\"hljs-attr\">port</span>: <span class=\"hljs-number\">9000</span>,<br>    <span class=\"hljs-attr\">proxy</span>: &#123;<br>      <span class=\"hljs-string\">&#x27;/api&#x27;</span>: &#123;<br>        <span class=\"hljs-attr\">target</span>: <span class=\"hljs-string\">&#x27;http://localhost:8080/&#x27;</span>,<br>        <span class=\"hljs-attr\">changeOrigin</span>: <span class=\"hljs-literal\">true</span>,<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;)<br><br></code></pre></td></tr></table></figure>\n\n<p>然后它却对我说 <code>Vite proxy error ECONNREFUSED</code></p>\n<p>那么多大风大浪都过去了，居然在这小阴沟里翻了船，忍不了！</p>\n<h2 id=\"排查方向\"><a href=\"#排查方向\" class=\"headerlink\" title=\"排查方向\"></a>排查方向</h2><p>因为涉及到vite server配置，其本质就是http-server以及http-agent的问题,  于是从从下面几个方向做了一一排查</p>\n<ul>\n<li><p><strong>Vite的服务器配置</strong></p>\n</li>\n<li><p><strong>端口占用或防火墙设置</strong></p>\n</li>\n<li><p><strong>浏览器或系统代理设置</strong></p>\n</li>\n<li><p>​<strong>Hosts文件配置问题或DNS解析问题</strong></p>\n</li>\n</ul>\n<h2 id=\"测试验证\"><a href=\"#测试验证\" class=\"headerlink\" title=\"测试验证\"></a>测试验证</h2><ul>\n<li><p>首先vite服务配置问题是最先被排除的，因为该项目配置已经经历了时间的考验，在很多项目中都有使用</p>\n</li>\n<li><p>然后通过 <code>netstat -ano | find 9000</code> 检查并未发现端口被占用的情况</p>\n</li>\n<li><p>至于代理，确实是开了–科学上网使用。然而在关闭之后，似乎没有起作用，所以问题不在这里。</p>\n</li>\n<li><p>那么还剩最后一条，当我检查我本地的hosts文件时，纳尼，localhost没有配置指向本地的环回地址127.0.0.1，难道是这里出问题了吗。</p>\n<p>为了验证这个想法，我将配置中的target做了以下修改:</p>\n<p><del>target: ‘<a href=\"http://localhost:8080/\">http://localhost:8080/</a>‘</del> </br><br>  target: ‘<a href=\"http://127.0.0.1:8080/\">http://127.0.0.1:8080/</a>‘</p>\n<p>果然，生效了，看来之前的猜测是对的。</p>\n</li>\n</ul>\n</br>\n\n<p>所以目前至少有两种方法可以解决该问题：</p>\n<ul>\n<li><strong>在vite配置中将localhost替换成127.0.0.1</strong></li>\n<li><strong>在hosts文件中添加localhost的地址</strong></li>\n</ul>\n<p>当然，第二种方式显然是更合理的，几乎是种一劳永逸的方法，在日后不同项目的开发中，总是难免还会存在使用localhost的情况。因此，建议在hosts文件中配置它。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>在这个问题中呢，其实也牵扯出更多的关于http server 和 http client相关的知识。不论是server的创建还是client的连接，正确的ip和端口是需要保证的。</p>\n<p>当遇到类似的情况时，不妨从底层思考在复杂的封装工具和配置的背后，它的本质是什么，以及正常使用时需要哪些因子的参与。</p>\n","excerpt":"","more":"<p>最近正在开发一款应用，前端框架是vite+vue, 后台服务也是使用的node+express组合，当一切工作都在顺利进行的时候，不出意外，意外出现了。</p>\n<p>当我尝试使用axios直连本地服务地址的时候，丝滑得如同德芙一样。然而每次请求地址都需要拼写全链接–即host+port+service-path，这是一件很愚蠢的事情。</p>\n<p>为了让事情变得简单一些，减少重复工作，我和聪明的各位一样决定使用vite的代理。</p>\n<p>因为web的地址9000，本地启动的后台服务地址是8080，所以我最初的配置如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title function_\">defineConfig</span>(&#123;<br>  # ...   其它配置<br>  <span class=\"hljs-attr\">server</span>: &#123;<br>    <span class=\"hljs-attr\">host</span>: <span class=\"hljs-string\">&#x27;0.0.0.0&#x27;</span>,<br>    <span class=\"hljs-attr\">port</span>: <span class=\"hljs-number\">9000</span>,<br>    <span class=\"hljs-attr\">proxy</span>: &#123;<br>      <span class=\"hljs-string\">&#x27;/api&#x27;</span>: &#123;<br>        <span class=\"hljs-attr\">target</span>: <span class=\"hljs-string\">&#x27;http://localhost:8080/&#x27;</span>,<br>        <span class=\"hljs-attr\">changeOrigin</span>: <span class=\"hljs-literal\">true</span>,<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;)<br><br></code></pre></td></tr></table></figure>\n\n<p>然后它却对我说 <code>Vite proxy error ECONNREFUSED</code></p>\n<p>那么多大风大浪都过去了，居然在这小阴沟里翻了船，忍不了！</p>\n<h2 id=\"排查方向\"><a href=\"#排查方向\" class=\"headerlink\" title=\"排查方向\"></a>排查方向</h2><p>因为涉及到vite server配置，其本质就是http-server以及http-agent的问题,  于是从从下面几个方向做了一一排查</p>\n<ul>\n<li><p><strong>Vite的服务器配置</strong></p>\n</li>\n<li><p><strong>端口占用或防火墙设置</strong></p>\n</li>\n<li><p><strong>浏览器或系统代理设置</strong></p>\n</li>\n<li><p>​<strong>Hosts文件配置问题或DNS解析问题</strong></p>\n</li>\n</ul>\n<h2 id=\"测试验证\"><a href=\"#测试验证\" class=\"headerlink\" title=\"测试验证\"></a>测试验证</h2><ul>\n<li><p>首先vite服务配置问题是最先被排除的，因为该项目配置已经经历了时间的考验，在很多项目中都有使用</p>\n</li>\n<li><p>然后通过 <code>netstat -ano | find 9000</code> 检查并未发现端口被占用的情况</p>\n</li>\n<li><p>至于代理，确实是开了–科学上网使用。然而在关闭之后，似乎没有起作用，所以问题不在这里。</p>\n</li>\n<li><p>那么还剩最后一条，当我检查我本地的hosts文件时，纳尼，localhost没有配置指向本地的环回地址127.0.0.1，难道是这里出问题了吗。</p>\n<p>为了验证这个想法，我将配置中的target做了以下修改:</p>\n<p><del>target: ‘<a href=\"http://localhost:8080/\">http://localhost:8080/</a>‘</del> </br><br>  target: ‘<a href=\"http://127.0.0.1:8080/\">http://127.0.0.1:8080/</a>‘</p>\n<p>果然，生效了，看来之前的猜测是对的。</p>\n</li>\n</ul>\n</br>\n\n<p>所以目前至少有两种方法可以解决该问题：</p>\n<ul>\n<li><strong>在vite配置中将localhost替换成127.0.0.1</strong></li>\n<li><strong>在hosts文件中添加localhost的地址</strong></li>\n</ul>\n<p>当然，第二种方式显然是更合理的，几乎是种一劳永逸的方法，在日后不同项目的开发中，总是难免还会存在使用localhost的情况。因此，建议在hosts文件中配置它。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>在这个问题中呢，其实也牵扯出更多的关于http server 和 http client相关的知识。不论是server的创建还是client的连接，正确的ip和端口是需要保证的。</p>\n<p>当遇到类似的情况时，不妨从底层思考在复杂的封装工具和配置的背后，它的本质是什么，以及正常使用时需要哪些因子的参与。</p>\n"},{"title":"搭建个人博客系列--(1) 为什么每个人都该有个数字自留地","date":"2025-05-25T05:40:00.000Z","keywords":["博客搭建","免费博客平台","托管博客","模板建站"],"_content":"\n![](../imgs/build-blog1/blog1.jpg)\n\n从2017年写第一篇博客，到现在已经过去8个年头了。\n\n期间在不同的平台也写过不少的博客，写了又删，删了有些，留下来的其实也没有多少。\n\n这么多年后，为什么我又和许多人一样，重新开辟自己已经荒芜的自留地？\n\n### 为什么写博客\n\n\n我清晰的记得，我写第一篇博客时的心情，以及那种纯粹的对知识的分享欲。那是一篇在我解决一个困扰我很久的问题之后写下关于[虚拟机安装](https://zhuanlan.zhihu.com/p/26994950)的博客，当时是在知乎上发的。只是让我没想到的是，它至今仍然是我博客中浏览量最高的一篇，有将近30w的浏览量。\n\n纯粹的知识的分享，以及那种来自他人对自己工作的认同感，以及由此产生的成就感，是一促使一个人坚持写博客的主要动力。\n\n![](../imgs/build-blog1/blog2.jpg)\n\n写博客锻炼一个人的表达。在写博客的过程中，尤其是刚开始时，刚经常容易提笔忘字，没有想好如何表达。写得久了，表达上也变得变得清晰，变得通畅。\n\n写博客让人思考，了解自我。写作其实是一件蛮费时间和精力的事情，尤其是当自己需要向别人阐述一件事情，让对方尽可能明白自己在说什么。但写着写着，似乎长时间来，这样的坚持也并没有最初那么难受了。并且，当他人没有理解到自己所表达的意思时，也没有想象中那么郁闷，能够接受自己偶尔不被理解的样。\n\n\n### 程序员写博客的必要性\n\n一个优秀的程序员往往也是一个好的博主。写博客并不需要多门高大上的内容，也不需要华丽的辞藻堆砌。用简洁易懂的语言，把一件事记录好，表达清楚，就OKay了，就像代码一样。\n\n开发过程遇见的问题，搭建环境中遇到的各种坑，都可以作为一篇博客或者系列博客的材料。\n\n![](../imgs/build-blog1/blog6.jpg)\n时间久了，所记录下的一篇篇博客，就不仅仅是简单的博客了，而是自己开发路上成长的最好的见证者。\n\n当你有时候翻看以前博客，嘴中呢喃‘以前怎么这么菜’，觉得眼前博客拿不出手时，那么就说明你真正进步了，也成长了。\n\n### 搭建自己的数字自留地\n\n如今写博客的平台很多，像大家熟知的博客园、CSND、掘金还有思否等。\n\n像博客园这种比较有怀旧情怀的，上面其实还是有蛮多干货的，我个人也特别中意里面的一些怀旧博客主题，不过这几年好像整体流量不及其它平台了。\n\nCSDN的话相对来说对刚刚开始创作博客的人来说比较友好，流量相对来说也大一些，不过毛病也很明显。广告多了些，再就是内容相互抄袭还是比较严重的\n\n至于像掘金和思否，接触相对较少，所以了解不是别多。不过掘金这几年弄得挺不错的，身边蛮多互联网大佬对这个平台评价都挺蛮好的。\n\n![](../imgs/build-blog1/blog4.jpg)\n\n虽然平台选择很多，但依然会有很多博主像作者一样，选择自己搭建自己的独立博客。\n\n不管你是把它打算经营成一个热门博客站点，还是做一个安静记录自己所思所想的树洞，都是你自己说了算。在自己的博客站里，自己就是这里的王。\n\n在搭建博客站点中，你会学习到许多的知识点，接触和使用到许多搭建站点的工具。在自己经过一番折腾，成功搭建起这块独属于自己的数字自留地的时候，心中也会颇有一番成就感。\n\n\n### 写在最后\n\n在这个系列后续的文章中，我将会详细的讲解搭建博客站点的每一个步骤。从技术选型，到本地博客，再到自动化部署，以及如何优雅的实现自己的博客域名，我尽可能的把每一个自己踩过的坑都讲清楚，让所有读者都少走一些弯路。\n\n如果你有什么好的想法或者问题，可以留言或者关注我的公众号“我做开发那些年”，我们一起交流。","source":"_posts/build-personal-blog-1.md","raw":"---\ntitle: 搭建个人博客系列--(1) 为什么每个人都该有个数字自留地\n\ndate: 2025-05-25 13:40:00\ncategory: 搭建博客\ntags: \n   - 博客搭建\n   - 个人IP\nkeywords: [博客搭建, 免费博客平台, 托管博客, 模板建站]\n---\n\n![](../imgs/build-blog1/blog1.jpg)\n\n从2017年写第一篇博客，到现在已经过去8个年头了。\n\n期间在不同的平台也写过不少的博客，写了又删，删了有些，留下来的其实也没有多少。\n\n这么多年后，为什么我又和许多人一样，重新开辟自己已经荒芜的自留地？\n\n### 为什么写博客\n\n\n我清晰的记得，我写第一篇博客时的心情，以及那种纯粹的对知识的分享欲。那是一篇在我解决一个困扰我很久的问题之后写下关于[虚拟机安装](https://zhuanlan.zhihu.com/p/26994950)的博客，当时是在知乎上发的。只是让我没想到的是，它至今仍然是我博客中浏览量最高的一篇，有将近30w的浏览量。\n\n纯粹的知识的分享，以及那种来自他人对自己工作的认同感，以及由此产生的成就感，是一促使一个人坚持写博客的主要动力。\n\n![](../imgs/build-blog1/blog2.jpg)\n\n写博客锻炼一个人的表达。在写博客的过程中，尤其是刚开始时，刚经常容易提笔忘字，没有想好如何表达。写得久了，表达上也变得变得清晰，变得通畅。\n\n写博客让人思考，了解自我。写作其实是一件蛮费时间和精力的事情，尤其是当自己需要向别人阐述一件事情，让对方尽可能明白自己在说什么。但写着写着，似乎长时间来，这样的坚持也并没有最初那么难受了。并且，当他人没有理解到自己所表达的意思时，也没有想象中那么郁闷，能够接受自己偶尔不被理解的样。\n\n\n### 程序员写博客的必要性\n\n一个优秀的程序员往往也是一个好的博主。写博客并不需要多门高大上的内容，也不需要华丽的辞藻堆砌。用简洁易懂的语言，把一件事记录好，表达清楚，就OKay了，就像代码一样。\n\n开发过程遇见的问题，搭建环境中遇到的各种坑，都可以作为一篇博客或者系列博客的材料。\n\n![](../imgs/build-blog1/blog6.jpg)\n时间久了，所记录下的一篇篇博客，就不仅仅是简单的博客了，而是自己开发路上成长的最好的见证者。\n\n当你有时候翻看以前博客，嘴中呢喃‘以前怎么这么菜’，觉得眼前博客拿不出手时，那么就说明你真正进步了，也成长了。\n\n### 搭建自己的数字自留地\n\n如今写博客的平台很多，像大家熟知的博客园、CSND、掘金还有思否等。\n\n像博客园这种比较有怀旧情怀的，上面其实还是有蛮多干货的，我个人也特别中意里面的一些怀旧博客主题，不过这几年好像整体流量不及其它平台了。\n\nCSDN的话相对来说对刚刚开始创作博客的人来说比较友好，流量相对来说也大一些，不过毛病也很明显。广告多了些，再就是内容相互抄袭还是比较严重的\n\n至于像掘金和思否，接触相对较少，所以了解不是别多。不过掘金这几年弄得挺不错的，身边蛮多互联网大佬对这个平台评价都挺蛮好的。\n\n![](../imgs/build-blog1/blog4.jpg)\n\n虽然平台选择很多，但依然会有很多博主像作者一样，选择自己搭建自己的独立博客。\n\n不管你是把它打算经营成一个热门博客站点，还是做一个安静记录自己所思所想的树洞，都是你自己说了算。在自己的博客站里，自己就是这里的王。\n\n在搭建博客站点中，你会学习到许多的知识点，接触和使用到许多搭建站点的工具。在自己经过一番折腾，成功搭建起这块独属于自己的数字自留地的时候，心中也会颇有一番成就感。\n\n\n### 写在最后\n\n在这个系列后续的文章中，我将会详细的讲解搭建博客站点的每一个步骤。从技术选型，到本地博客，再到自动化部署，以及如何优雅的实现自己的博客域名，我尽可能的把每一个自己踩过的坑都讲清楚，让所有读者都少走一些弯路。\n\n如果你有什么好的想法或者问题，可以留言或者关注我的公众号“我做开发那些年”，我们一起交流。","slug":"build-personal-blog-1","published":1,"updated":"2025-06-21T14:12:03.314Z","_id":"cmb6cfzp200082wup6kkdbh2b","comments":1,"layout":"post","photos":[],"content":"<p><img src=\"/../imgs/build-blog1/blog1.jpg\"></p>\n<p>从2017年写第一篇博客，到现在已经过去8个年头了。</p>\n<p>期间在不同的平台也写过不少的博客，写了又删，删了有些，留下来的其实也没有多少。</p>\n<p>这么多年后，为什么我又和许多人一样，重新开辟自己已经荒芜的自留地？</p>\n<h3 id=\"为什么写博客\"><a href=\"#为什么写博客\" class=\"headerlink\" title=\"为什么写博客\"></a>为什么写博客</h3><p>我清晰的记得，我写第一篇博客时的心情，以及那种纯粹的对知识的分享欲。那是一篇在我解决一个困扰我很久的问题之后写下关于<a href=\"https://zhuanlan.zhihu.com/p/26994950\">虚拟机安装</a>的博客，当时是在知乎上发的。只是让我没想到的是，它至今仍然是我博客中浏览量最高的一篇，有将近30w的浏览量。</p>\n<p>纯粹的知识的分享，以及那种来自他人对自己工作的认同感，以及由此产生的成就感，是一促使一个人坚持写博客的主要动力。</p>\n<p><img src=\"/../imgs/build-blog1/blog2.jpg\"></p>\n<p>写博客锻炼一个人的表达。在写博客的过程中，尤其是刚开始时，刚经常容易提笔忘字，没有想好如何表达。写得久了，表达上也变得变得清晰，变得通畅。</p>\n<p>写博客让人思考，了解自我。写作其实是一件蛮费时间和精力的事情，尤其是当自己需要向别人阐述一件事情，让对方尽可能明白自己在说什么。但写着写着，似乎长时间来，这样的坚持也并没有最初那么难受了。并且，当他人没有理解到自己所表达的意思时，也没有想象中那么郁闷，能够接受自己偶尔不被理解的样。</p>\n<h3 id=\"程序员写博客的必要性\"><a href=\"#程序员写博客的必要性\" class=\"headerlink\" title=\"程序员写博客的必要性\"></a>程序员写博客的必要性</h3><p>一个优秀的程序员往往也是一个好的博主。写博客并不需要多门高大上的内容，也不需要华丽的辞藻堆砌。用简洁易懂的语言，把一件事记录好，表达清楚，就OKay了，就像代码一样。</p>\n<p>开发过程遇见的问题，搭建环境中遇到的各种坑，都可以作为一篇博客或者系列博客的材料。</p>\n<p><img src=\"/../imgs/build-blog1/blog6.jpg\"><br>时间久了，所记录下的一篇篇博客，就不仅仅是简单的博客了，而是自己开发路上成长的最好的见证者。</p>\n<p>当你有时候翻看以前博客，嘴中呢喃‘以前怎么这么菜’，觉得眼前博客拿不出手时，那么就说明你真正进步了，也成长了。</p>\n<h3 id=\"搭建自己的数字自留地\"><a href=\"#搭建自己的数字自留地\" class=\"headerlink\" title=\"搭建自己的数字自留地\"></a>搭建自己的数字自留地</h3><p>如今写博客的平台很多，像大家熟知的博客园、CSND、掘金还有思否等。</p>\n<p>像博客园这种比较有怀旧情怀的，上面其实还是有蛮多干货的，我个人也特别中意里面的一些怀旧博客主题，不过这几年好像整体流量不及其它平台了。</p>\n<p>CSDN的话相对来说对刚刚开始创作博客的人来说比较友好，流量相对来说也大一些，不过毛病也很明显。广告多了些，再就是内容相互抄袭还是比较严重的</p>\n<p>至于像掘金和思否，接触相对较少，所以了解不是别多。不过掘金这几年弄得挺不错的，身边蛮多互联网大佬对这个平台评价都挺蛮好的。</p>\n<p><img src=\"/../imgs/build-blog1/blog4.jpg\"></p>\n<p>虽然平台选择很多，但依然会有很多博主像作者一样，选择自己搭建自己的独立博客。</p>\n<p>不管你是把它打算经营成一个热门博客站点，还是做一个安静记录自己所思所想的树洞，都是你自己说了算。在自己的博客站里，自己就是这里的王。</p>\n<p>在搭建博客站点中，你会学习到许多的知识点，接触和使用到许多搭建站点的工具。在自己经过一番折腾，成功搭建起这块独属于自己的数字自留地的时候，心中也会颇有一番成就感。</p>\n<h3 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h3><p>在这个系列后续的文章中，我将会详细的讲解搭建博客站点的每一个步骤。从技术选型，到本地博客，再到自动化部署，以及如何优雅的实现自己的博客域名，我尽可能的把每一个自己踩过的坑都讲清楚，让所有读者都少走一些弯路。</p>\n<p>如果你有什么好的想法或者问题，可以留言或者关注我的公众号“我做开发那些年”，我们一起交流。</p>\n","excerpt":"","more":"<p><img src=\"/../imgs/build-blog1/blog1.jpg\"></p>\n<p>从2017年写第一篇博客，到现在已经过去8个年头了。</p>\n<p>期间在不同的平台也写过不少的博客，写了又删，删了有些，留下来的其实也没有多少。</p>\n<p>这么多年后，为什么我又和许多人一样，重新开辟自己已经荒芜的自留地？</p>\n<h3 id=\"为什么写博客\"><a href=\"#为什么写博客\" class=\"headerlink\" title=\"为什么写博客\"></a>为什么写博客</h3><p>我清晰的记得，我写第一篇博客时的心情，以及那种纯粹的对知识的分享欲。那是一篇在我解决一个困扰我很久的问题之后写下关于<a href=\"https://zhuanlan.zhihu.com/p/26994950\">虚拟机安装</a>的博客，当时是在知乎上发的。只是让我没想到的是，它至今仍然是我博客中浏览量最高的一篇，有将近30w的浏览量。</p>\n<p>纯粹的知识的分享，以及那种来自他人对自己工作的认同感，以及由此产生的成就感，是一促使一个人坚持写博客的主要动力。</p>\n<p><img src=\"/../imgs/build-blog1/blog2.jpg\"></p>\n<p>写博客锻炼一个人的表达。在写博客的过程中，尤其是刚开始时，刚经常容易提笔忘字，没有想好如何表达。写得久了，表达上也变得变得清晰，变得通畅。</p>\n<p>写博客让人思考，了解自我。写作其实是一件蛮费时间和精力的事情，尤其是当自己需要向别人阐述一件事情，让对方尽可能明白自己在说什么。但写着写着，似乎长时间来，这样的坚持也并没有最初那么难受了。并且，当他人没有理解到自己所表达的意思时，也没有想象中那么郁闷，能够接受自己偶尔不被理解的样。</p>\n<h3 id=\"程序员写博客的必要性\"><a href=\"#程序员写博客的必要性\" class=\"headerlink\" title=\"程序员写博客的必要性\"></a>程序员写博客的必要性</h3><p>一个优秀的程序员往往也是一个好的博主。写博客并不需要多门高大上的内容，也不需要华丽的辞藻堆砌。用简洁易懂的语言，把一件事记录好，表达清楚，就OKay了，就像代码一样。</p>\n<p>开发过程遇见的问题，搭建环境中遇到的各种坑，都可以作为一篇博客或者系列博客的材料。</p>\n<p><img src=\"/../imgs/build-blog1/blog6.jpg\"><br>时间久了，所记录下的一篇篇博客，就不仅仅是简单的博客了，而是自己开发路上成长的最好的见证者。</p>\n<p>当你有时候翻看以前博客，嘴中呢喃‘以前怎么这么菜’，觉得眼前博客拿不出手时，那么就说明你真正进步了，也成长了。</p>\n<h3 id=\"搭建自己的数字自留地\"><a href=\"#搭建自己的数字自留地\" class=\"headerlink\" title=\"搭建自己的数字自留地\"></a>搭建自己的数字自留地</h3><p>如今写博客的平台很多，像大家熟知的博客园、CSND、掘金还有思否等。</p>\n<p>像博客园这种比较有怀旧情怀的，上面其实还是有蛮多干货的，我个人也特别中意里面的一些怀旧博客主题，不过这几年好像整体流量不及其它平台了。</p>\n<p>CSDN的话相对来说对刚刚开始创作博客的人来说比较友好，流量相对来说也大一些，不过毛病也很明显。广告多了些，再就是内容相互抄袭还是比较严重的</p>\n<p>至于像掘金和思否，接触相对较少，所以了解不是别多。不过掘金这几年弄得挺不错的，身边蛮多互联网大佬对这个平台评价都挺蛮好的。</p>\n<p><img src=\"/../imgs/build-blog1/blog4.jpg\"></p>\n<p>虽然平台选择很多，但依然会有很多博主像作者一样，选择自己搭建自己的独立博客。</p>\n<p>不管你是把它打算经营成一个热门博客站点，还是做一个安静记录自己所思所想的树洞，都是你自己说了算。在自己的博客站里，自己就是这里的王。</p>\n<p>在搭建博客站点中，你会学习到许多的知识点，接触和使用到许多搭建站点的工具。在自己经过一番折腾，成功搭建起这块独属于自己的数字自留地的时候，心中也会颇有一番成就感。</p>\n<h3 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h3><p>在这个系列后续的文章中，我将会详细的讲解搭建博客站点的每一个步骤。从技术选型，到本地博客，再到自动化部署，以及如何优雅的实现自己的博客域名，我尽可能的把每一个自己踩过的坑都讲清楚，让所有读者都少走一些弯路。</p>\n<p>如果你有什么好的想法或者问题，可以留言或者关注我的公众号“我做开发那些年”，我们一起交流。</p>\n"},{"title":"搭建个人博客系列--(2) 动手搭建自己的第一个博客站点","date":"2025-05-27T13:02:53.000Z","keywords":["博客搭建","免费博客平台","托管博客","模板建站"],"_content":"\n在上文[什么每个人都该有个数字自留地](./build-personal-blog1.md)中讲解了为什么我们要写博客以及为什么要搭建自己的独立博客，今天我们将要撸起袖子，开始干活了。认真看完本文，按照文中的步骤去做，你将拥有一个属于你自己的博客站点。\n\n## 搭建博客的几种方式\n\n说到博客，不熟悉的人对它的印象可能是微博，QQ空间日志，以及如CSDN，博客园之类的站点的样子，功能丰富，用户上手也快，一部手机就能完成所有的事情。\n\n上面所提到的站点，都是标准的商业型应用了，而作为个人，没有必要浪费过多时间在各种花哨功能构建上。\n\n个人博客，最重要的是内容，是价值输出！\n\n目前呢，搭建个人博客的方式主要有以下几种：\n\n  - **社区平台**：像`博客园`，`CSDN`, `知乎`，`微博`，`公众号`，`QQ空间`等，注册一个账号就Okay了。当然了，既然是社区平台，也就意味着没有独立的网站。\n\n  - **独立博客**: 有自己的网站，博客框架的搭建，内容的发布，都是由自己完成。对未接触过编程的人来说，上手有一定难度。比较适合有一定编程基础，然后又想挑战一下自己那种的同学。\n\n作为一个明日的大佬，自己动手整个独立博客，想必对大家来说也不是什么难事。\n\n## 考虑因素\n\n既然选择建独立博客，那么我们需要考虑以下几个问题了：\n\n  - 是否需要建立数据库，使用前后端配合的方式完成博客的增删改查？\n  - 是否考虑购买服务器，还是进行服务托管?\n  - 打算投入多少时间和金钱去建站?\n \n\n在考虑这些问题的时候，同时问问自己，自己的博客是否需要很多功能，还是作为一个简单记录自己所思所想的自由平台。\n\n个人认为，作为程序员，简洁就是最好的风格！\n\n因此，我更倾向选择的是不使用前后端，使用静态内容托管的方式来搭建自己的博客。正如前面所说的，一个个人博客站重要的是内容输出，戏台子搭得大和漂亮没有多少用，重要的是你的戏是否能够吸引观众。\n\n## 技术选型\n\n既然是使用静态托管平台，那么可供选择的方案有很多：\n  \n  - **[GitHub Pages](https://pages.github.com/)**: 自带域名可 https 访问; 可配置自定义域名\n  - **[Bitbucket Cloud](https://confluence.atlassian.com/bitbucket/publishing-a-website-on-bitbucket-cloud-221449776.html)**: 能且只能通过 https 协议访问; 无法自定义域名\n  - **[GitLab Pages](https://docs.gitlab.com/ee/user/project/pages/index.html)**: 同样跟 GitHub Pages 的功能一样\n  - **[Netlify](https://www.netlify.com/)**: 可以使用 CLI 上传代码; 支持自动构建\n\n在这里，比较推荐 Github Page 和 Netlify, 主要原因有两个：一个是比较能装，另一个是比较能装！\n\n## Github page 建站\n\n下面演示一下Github Page生成一个简单的个人站点名称，Netlify 可以自行探索一下，这里不做讲解。\n\n使用Github Page 建站，首先，你需要有一个Github 账号，如果没有，先去注册一个，注册时记得取个好一点的名字，后面有用。\n\n- **登录github, 新建一个与你名字同名的repository**\n\n登录到Github首页之后，点击右上角 `+` 号，选择 `new repository` 跳转到新建仓库页面。\n\n![step1](https://image.baidu.com/search/down?url=https://tvax4.sinaimg.cn/large/0071fJItgy1i21b6hl5rlj31i70xpe0n.jpg)\n\n其中，`repository name` 一定要是 `你的英文名称.github.io`，比如我的英文名称是`jvxiaome`， 那么我的仓库名称就是 `jvxiaome.github.io`，这个后面也是访问博客站点首页的网址，所以前面说取一个好听的名字，是有道理的。\n\n仓库的可见性选择 `Public`, 另外下面的 `Add a README file` 也可以勾上，会方便一些，至于剩下的内容，看个人需要，不清楚的可以暂时不填，最后确认 `Create repository`。\n\n\n\n![step2](https://image.baidu.com/search/down?url=http://tvax3.sinaimg.cn/large/0071fJItgy1i21ba20naej31aa1ah1ba.jpg)\n\n\n- **编辑一个你的博客主页**\n\n进入到刚刚新建的仓库，点击`add file` 新建一个文件\n\n\n![step3](https://image.baidu.com/search/down?url=http://tvax2.sinaimg.cn/large/0071fJItgy1i21batizraj31gl0ufn95.jpg)\n\n文件名称取名为 `index.html`, 这个文件中包含的就是博客主页的内容了，具体想写什么可以自由发挥\n\n![step4](https://image.baidu.com/search/down?url=http://tvax4.sinaimg.cn/large/0071fJItgy1i21bb808bfj31zr0thgzj.jpg)\n\n写完之后点击 `commit changes` 提交内容到仓库，到这一步，你的博客站就算是基本建立起来了\n![step5](https://image.baidu.com/search/down?url=http://tvax2.sinaimg.cn/large/0071fJItgy1i21bc83oxuj31eu0vyduh.jpg)\n\n\n- **访问验证**\n\n既然博客站点已经建好了，此时是不是特别期待访问自己的博客首页呢。\n\n正如前面所说的，你的仓库名称（你的英文名称.github.io）就是你的博客首页名称，以上面的例子来说，访问 `jvxiaome.github.io` 就能直接看见首页效果了。\n\n虽然整个页面都在诉说着朴素(~~丑~~)，但一点也不影响你拥有一个属于自己博客站点的那份喜悦。都18+了，怎么能没有自己的网站呢。\n\n![step6](https://image.baidu.com/search/down?url=http://tvax3.sinaimg.cn/large/0071fJItgy1i21bcpjfruj310d0k2go1.jpg)\n\n## 写在最后\n\n有了自己的博客网站，还有了域名，而这一切，不是个结束，而是开始。\n\n如何使用工具，使用主题，搭建一个简洁，漂亮的[博客网站](![my-sit](https://image.baidu.com/search/down?url=http://tvax1.sinaimg.cn/large/0071fJItgy1i21bddtgjjj32cu1h8x6q.jpg))，这将是下一篇文中的重点。\n\n\n\n\n\n\n<!-- https://github.com/lmk123/blog/issues/55 -->\n\n","source":"_posts/build-personal-blog2.md","raw":"---\ntitle: 搭建个人博客系列--(2) 动手搭建自己的第一个博客站点\ndate: 2025-05-27 21:02:53\ncategory: 搭建博客\ntags: \n   - 博客搭建\n   - 个人IP\nkeywords: [博客搭建, 免费博客平台, 托管博客, 模板建站]\n---\n\n在上文[什么每个人都该有个数字自留地](./build-personal-blog1.md)中讲解了为什么我们要写博客以及为什么要搭建自己的独立博客，今天我们将要撸起袖子，开始干活了。认真看完本文，按照文中的步骤去做，你将拥有一个属于你自己的博客站点。\n\n## 搭建博客的几种方式\n\n说到博客，不熟悉的人对它的印象可能是微博，QQ空间日志，以及如CSDN，博客园之类的站点的样子，功能丰富，用户上手也快，一部手机就能完成所有的事情。\n\n上面所提到的站点，都是标准的商业型应用了，而作为个人，没有必要浪费过多时间在各种花哨功能构建上。\n\n个人博客，最重要的是内容，是价值输出！\n\n目前呢，搭建个人博客的方式主要有以下几种：\n\n  - **社区平台**：像`博客园`，`CSDN`, `知乎`，`微博`，`公众号`，`QQ空间`等，注册一个账号就Okay了。当然了，既然是社区平台，也就意味着没有独立的网站。\n\n  - **独立博客**: 有自己的网站，博客框架的搭建，内容的发布，都是由自己完成。对未接触过编程的人来说，上手有一定难度。比较适合有一定编程基础，然后又想挑战一下自己那种的同学。\n\n作为一个明日的大佬，自己动手整个独立博客，想必对大家来说也不是什么难事。\n\n## 考虑因素\n\n既然选择建独立博客，那么我们需要考虑以下几个问题了：\n\n  - 是否需要建立数据库，使用前后端配合的方式完成博客的增删改查？\n  - 是否考虑购买服务器，还是进行服务托管?\n  - 打算投入多少时间和金钱去建站?\n \n\n在考虑这些问题的时候，同时问问自己，自己的博客是否需要很多功能，还是作为一个简单记录自己所思所想的自由平台。\n\n个人认为，作为程序员，简洁就是最好的风格！\n\n因此，我更倾向选择的是不使用前后端，使用静态内容托管的方式来搭建自己的博客。正如前面所说的，一个个人博客站重要的是内容输出，戏台子搭得大和漂亮没有多少用，重要的是你的戏是否能够吸引观众。\n\n## 技术选型\n\n既然是使用静态托管平台，那么可供选择的方案有很多：\n  \n  - **[GitHub Pages](https://pages.github.com/)**: 自带域名可 https 访问; 可配置自定义域名\n  - **[Bitbucket Cloud](https://confluence.atlassian.com/bitbucket/publishing-a-website-on-bitbucket-cloud-221449776.html)**: 能且只能通过 https 协议访问; 无法自定义域名\n  - **[GitLab Pages](https://docs.gitlab.com/ee/user/project/pages/index.html)**: 同样跟 GitHub Pages 的功能一样\n  - **[Netlify](https://www.netlify.com/)**: 可以使用 CLI 上传代码; 支持自动构建\n\n在这里，比较推荐 Github Page 和 Netlify, 主要原因有两个：一个是比较能装，另一个是比较能装！\n\n## Github page 建站\n\n下面演示一下Github Page生成一个简单的个人站点名称，Netlify 可以自行探索一下，这里不做讲解。\n\n使用Github Page 建站，首先，你需要有一个Github 账号，如果没有，先去注册一个，注册时记得取个好一点的名字，后面有用。\n\n- **登录github, 新建一个与你名字同名的repository**\n\n登录到Github首页之后，点击右上角 `+` 号，选择 `new repository` 跳转到新建仓库页面。\n\n![step1](https://image.baidu.com/search/down?url=https://tvax4.sinaimg.cn/large/0071fJItgy1i21b6hl5rlj31i70xpe0n.jpg)\n\n其中，`repository name` 一定要是 `你的英文名称.github.io`，比如我的英文名称是`jvxiaome`， 那么我的仓库名称就是 `jvxiaome.github.io`，这个后面也是访问博客站点首页的网址，所以前面说取一个好听的名字，是有道理的。\n\n仓库的可见性选择 `Public`, 另外下面的 `Add a README file` 也可以勾上，会方便一些，至于剩下的内容，看个人需要，不清楚的可以暂时不填，最后确认 `Create repository`。\n\n\n\n![step2](https://image.baidu.com/search/down?url=http://tvax3.sinaimg.cn/large/0071fJItgy1i21ba20naej31aa1ah1ba.jpg)\n\n\n- **编辑一个你的博客主页**\n\n进入到刚刚新建的仓库，点击`add file` 新建一个文件\n\n\n![step3](https://image.baidu.com/search/down?url=http://tvax2.sinaimg.cn/large/0071fJItgy1i21batizraj31gl0ufn95.jpg)\n\n文件名称取名为 `index.html`, 这个文件中包含的就是博客主页的内容了，具体想写什么可以自由发挥\n\n![step4](https://image.baidu.com/search/down?url=http://tvax4.sinaimg.cn/large/0071fJItgy1i21bb808bfj31zr0thgzj.jpg)\n\n写完之后点击 `commit changes` 提交内容到仓库，到这一步，你的博客站就算是基本建立起来了\n![step5](https://image.baidu.com/search/down?url=http://tvax2.sinaimg.cn/large/0071fJItgy1i21bc83oxuj31eu0vyduh.jpg)\n\n\n- **访问验证**\n\n既然博客站点已经建好了，此时是不是特别期待访问自己的博客首页呢。\n\n正如前面所说的，你的仓库名称（你的英文名称.github.io）就是你的博客首页名称，以上面的例子来说，访问 `jvxiaome.github.io` 就能直接看见首页效果了。\n\n虽然整个页面都在诉说着朴素(~~丑~~)，但一点也不影响你拥有一个属于自己博客站点的那份喜悦。都18+了，怎么能没有自己的网站呢。\n\n![step6](https://image.baidu.com/search/down?url=http://tvax3.sinaimg.cn/large/0071fJItgy1i21bcpjfruj310d0k2go1.jpg)\n\n## 写在最后\n\n有了自己的博客网站，还有了域名，而这一切，不是个结束，而是开始。\n\n如何使用工具，使用主题，搭建一个简洁，漂亮的[博客网站](![my-sit](https://image.baidu.com/search/down?url=http://tvax1.sinaimg.cn/large/0071fJItgy1i21bddtgjjj32cu1h8x6q.jpg))，这将是下一篇文中的重点。\n\n\n\n\n\n\n<!-- https://github.com/lmk123/blog/issues/55 -->\n\n","slug":"build-personal-blog2","published":1,"updated":"2025-06-21T14:14:06.636Z","_id":"cmbf62vvl000duoup8jpg6zb0","comments":1,"layout":"post","photos":[],"content":"<p>在上文<a href=\"./build-personal-blog1.md\">什么每个人都该有个数字自留地</a>中讲解了为什么我们要写博客以及为什么要搭建自己的独立博客，今天我们将要撸起袖子，开始干活了。认真看完本文，按照文中的步骤去做，你将拥有一个属于你自己的博客站点。</p>\n<h2 id=\"搭建博客的几种方式\"><a href=\"#搭建博客的几种方式\" class=\"headerlink\" title=\"搭建博客的几种方式\"></a>搭建博客的几种方式</h2><p>说到博客，不熟悉的人对它的印象可能是微博，QQ空间日志，以及如CSDN，博客园之类的站点的样子，功能丰富，用户上手也快，一部手机就能完成所有的事情。</p>\n<p>上面所提到的站点，都是标准的商业型应用了，而作为个人，没有必要浪费过多时间在各种花哨功能构建上。</p>\n<p>个人博客，最重要的是内容，是价值输出！</p>\n<p>目前呢，搭建个人博客的方式主要有以下几种：</p>\n<ul>\n<li><p><strong>社区平台</strong>：像<code>博客园</code>，<code>CSDN</code>, <code>知乎</code>，<code>微博</code>，<code>公众号</code>，<code>QQ空间</code>等，注册一个账号就Okay了。当然了，既然是社区平台，也就意味着没有独立的网站。</p>\n</li>\n<li><p><strong>独立博客</strong>: 有自己的网站，博客框架的搭建，内容的发布，都是由自己完成。对未接触过编程的人来说，上手有一定难度。比较适合有一定编程基础，然后又想挑战一下自己那种的同学。</p>\n</li>\n</ul>\n<p>作为一个明日的大佬，自己动手整个独立博客，想必对大家来说也不是什么难事。</p>\n<h2 id=\"考虑因素\"><a href=\"#考虑因素\" class=\"headerlink\" title=\"考虑因素\"></a>考虑因素</h2><p>既然选择建独立博客，那么我们需要考虑以下几个问题了：</p>\n<ul>\n<li>是否需要建立数据库，使用前后端配合的方式完成博客的增删改查？</li>\n<li>是否考虑购买服务器，还是进行服务托管?</li>\n<li>打算投入多少时间和金钱去建站?</li>\n</ul>\n<p>在考虑这些问题的时候，同时问问自己，自己的博客是否需要很多功能，还是作为一个简单记录自己所思所想的自由平台。</p>\n<p>个人认为，作为程序员，简洁就是最好的风格！</p>\n<p>因此，我更倾向选择的是不使用前后端，使用静态内容托管的方式来搭建自己的博客。正如前面所说的，一个个人博客站重要的是内容输出，戏台子搭得大和漂亮没有多少用，重要的是你的戏是否能够吸引观众。</p>\n<h2 id=\"技术选型\"><a href=\"#技术选型\" class=\"headerlink\" title=\"技术选型\"></a>技术选型</h2><p>既然是使用静态托管平台，那么可供选择的方案有很多：</p>\n<ul>\n<li><strong><a href=\"https://pages.github.com/\">GitHub Pages</a></strong>: 自带域名可 https 访问; 可配置自定义域名</li>\n<li><strong><a href=\"https://confluence.atlassian.com/bitbucket/publishing-a-website-on-bitbucket-cloud-221449776.html\">Bitbucket Cloud</a></strong>: 能且只能通过 https 协议访问; 无法自定义域名</li>\n<li><strong><a href=\"https://docs.gitlab.com/ee/user/project/pages/index.html\">GitLab Pages</a></strong>: 同样跟 GitHub Pages 的功能一样</li>\n<li><strong><a href=\"https://www.netlify.com/\">Netlify</a></strong>: 可以使用 CLI 上传代码; 支持自动构建</li>\n</ul>\n<p>在这里，比较推荐 Github Page 和 Netlify, 主要原因有两个：一个是比较能装，另一个是比较能装！</p>\n<h2 id=\"Github-page-建站\"><a href=\"#Github-page-建站\" class=\"headerlink\" title=\"Github page 建站\"></a>Github page 建站</h2><p>下面演示一下Github Page生成一个简单的个人站点名称，Netlify 可以自行探索一下，这里不做讲解。</p>\n<p>使用Github Page 建站，首先，你需要有一个Github 账号，如果没有，先去注册一个，注册时记得取个好一点的名字，后面有用。</p>\n<ul>\n<li><strong>登录github, 新建一个与你名字同名的repository</strong></li>\n</ul>\n<p>登录到Github首页之后，点击右上角 <code>+</code> 号，选择 <code>new repository</code> 跳转到新建仓库页面。</p>\n<p><img src=\"https://image.baidu.com/search/down?url=https://tvax4.sinaimg.cn/large/0071fJItgy1i21b6hl5rlj31i70xpe0n.jpg\" alt=\"step1\"></p>\n<p>其中，<code>repository name</code> 一定要是 <code>你的英文名称.github.io</code>，比如我的英文名称是<code>jvxiaome</code>， 那么我的仓库名称就是 <code>jvxiaome.github.io</code>，这个后面也是访问博客站点首页的网址，所以前面说取一个好听的名字，是有道理的。</p>\n<p>仓库的可见性选择 <code>Public</code>, 另外下面的 <code>Add a README file</code> 也可以勾上，会方便一些，至于剩下的内容，看个人需要，不清楚的可以暂时不填，最后确认 <code>Create repository</code>。</p>\n<p><img src=\"https://image.baidu.com/search/down?url=http://tvax3.sinaimg.cn/large/0071fJItgy1i21ba20naej31aa1ah1ba.jpg\" alt=\"step2\"></p>\n<ul>\n<li><strong>编辑一个你的博客主页</strong></li>\n</ul>\n<p>进入到刚刚新建的仓库，点击<code>add file</code> 新建一个文件</p>\n<p><img src=\"https://image.baidu.com/search/down?url=http://tvax2.sinaimg.cn/large/0071fJItgy1i21batizraj31gl0ufn95.jpg\" alt=\"step3\"></p>\n<p>文件名称取名为 <code>index.html</code>, 这个文件中包含的就是博客主页的内容了，具体想写什么可以自由发挥</p>\n<p><img src=\"https://image.baidu.com/search/down?url=http://tvax4.sinaimg.cn/large/0071fJItgy1i21bb808bfj31zr0thgzj.jpg\" alt=\"step4\"></p>\n<p>写完之后点击 <code>commit changes</code> 提交内容到仓库，到这一步，你的博客站就算是基本建立起来了<br><img src=\"https://image.baidu.com/search/down?url=http://tvax2.sinaimg.cn/large/0071fJItgy1i21bc83oxuj31eu0vyduh.jpg\" alt=\"step5\"></p>\n<ul>\n<li><strong>访问验证</strong></li>\n</ul>\n<p>既然博客站点已经建好了，此时是不是特别期待访问自己的博客首页呢。</p>\n<p>正如前面所说的，你的仓库名称（你的英文名称.github.io）就是你的博客首页名称，以上面的例子来说，访问 <code>jvxiaome.github.io</code> 就能直接看见首页效果了。</p>\n<p>虽然整个页面都在诉说着朴素(<del>丑</del>)，但一点也不影响你拥有一个属于自己博客站点的那份喜悦。都18+了，怎么能没有自己的网站呢。</p>\n<p><img src=\"https://image.baidu.com/search/down?url=http://tvax3.sinaimg.cn/large/0071fJItgy1i21bcpjfruj310d0k2go1.jpg\" alt=\"step6\"></p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>有了自己的博客网站，还有了域名，而这一切，不是个结束，而是开始。</p>\n<p>如何使用工具，使用主题，搭建一个简洁，漂亮的<a href=\"!%5Bmy-sit%5D(https://image.baidu.com/search/down?url=http://tvax1.sinaimg.cn/large/0071fJItgy1i21bddtgjjj32cu1h8x6q.jpg)\">博客网站</a>，这将是下一篇文中的重点。</p>\n<!-- https://github.com/lmk123/blog/issues/55 -->\n\n","excerpt":"","more":"<p>在上文<a href=\"./build-personal-blog1.md\">什么每个人都该有个数字自留地</a>中讲解了为什么我们要写博客以及为什么要搭建自己的独立博客，今天我们将要撸起袖子，开始干活了。认真看完本文，按照文中的步骤去做，你将拥有一个属于你自己的博客站点。</p>\n<h2 id=\"搭建博客的几种方式\"><a href=\"#搭建博客的几种方式\" class=\"headerlink\" title=\"搭建博客的几种方式\"></a>搭建博客的几种方式</h2><p>说到博客，不熟悉的人对它的印象可能是微博，QQ空间日志，以及如CSDN，博客园之类的站点的样子，功能丰富，用户上手也快，一部手机就能完成所有的事情。</p>\n<p>上面所提到的站点，都是标准的商业型应用了，而作为个人，没有必要浪费过多时间在各种花哨功能构建上。</p>\n<p>个人博客，最重要的是内容，是价值输出！</p>\n<p>目前呢，搭建个人博客的方式主要有以下几种：</p>\n<ul>\n<li><p><strong>社区平台</strong>：像<code>博客园</code>，<code>CSDN</code>, <code>知乎</code>，<code>微博</code>，<code>公众号</code>，<code>QQ空间</code>等，注册一个账号就Okay了。当然了，既然是社区平台，也就意味着没有独立的网站。</p>\n</li>\n<li><p><strong>独立博客</strong>: 有自己的网站，博客框架的搭建，内容的发布，都是由自己完成。对未接触过编程的人来说，上手有一定难度。比较适合有一定编程基础，然后又想挑战一下自己那种的同学。</p>\n</li>\n</ul>\n<p>作为一个明日的大佬，自己动手整个独立博客，想必对大家来说也不是什么难事。</p>\n<h2 id=\"考虑因素\"><a href=\"#考虑因素\" class=\"headerlink\" title=\"考虑因素\"></a>考虑因素</h2><p>既然选择建独立博客，那么我们需要考虑以下几个问题了：</p>\n<ul>\n<li>是否需要建立数据库，使用前后端配合的方式完成博客的增删改查？</li>\n<li>是否考虑购买服务器，还是进行服务托管?</li>\n<li>打算投入多少时间和金钱去建站?</li>\n</ul>\n<p>在考虑这些问题的时候，同时问问自己，自己的博客是否需要很多功能，还是作为一个简单记录自己所思所想的自由平台。</p>\n<p>个人认为，作为程序员，简洁就是最好的风格！</p>\n<p>因此，我更倾向选择的是不使用前后端，使用静态内容托管的方式来搭建自己的博客。正如前面所说的，一个个人博客站重要的是内容输出，戏台子搭得大和漂亮没有多少用，重要的是你的戏是否能够吸引观众。</p>\n<h2 id=\"技术选型\"><a href=\"#技术选型\" class=\"headerlink\" title=\"技术选型\"></a>技术选型</h2><p>既然是使用静态托管平台，那么可供选择的方案有很多：</p>\n<ul>\n<li><strong><a href=\"https://pages.github.com/\">GitHub Pages</a></strong>: 自带域名可 https 访问; 可配置自定义域名</li>\n<li><strong><a href=\"https://confluence.atlassian.com/bitbucket/publishing-a-website-on-bitbucket-cloud-221449776.html\">Bitbucket Cloud</a></strong>: 能且只能通过 https 协议访问; 无法自定义域名</li>\n<li><strong><a href=\"https://docs.gitlab.com/ee/user/project/pages/index.html\">GitLab Pages</a></strong>: 同样跟 GitHub Pages 的功能一样</li>\n<li><strong><a href=\"https://www.netlify.com/\">Netlify</a></strong>: 可以使用 CLI 上传代码; 支持自动构建</li>\n</ul>\n<p>在这里，比较推荐 Github Page 和 Netlify, 主要原因有两个：一个是比较能装，另一个是比较能装！</p>\n<h2 id=\"Github-page-建站\"><a href=\"#Github-page-建站\" class=\"headerlink\" title=\"Github page 建站\"></a>Github page 建站</h2><p>下面演示一下Github Page生成一个简单的个人站点名称，Netlify 可以自行探索一下，这里不做讲解。</p>\n<p>使用Github Page 建站，首先，你需要有一个Github 账号，如果没有，先去注册一个，注册时记得取个好一点的名字，后面有用。</p>\n<ul>\n<li><strong>登录github, 新建一个与你名字同名的repository</strong></li>\n</ul>\n<p>登录到Github首页之后，点击右上角 <code>+</code> 号，选择 <code>new repository</code> 跳转到新建仓库页面。</p>\n<p><img src=\"https://image.baidu.com/search/down?url=https://tvax4.sinaimg.cn/large/0071fJItgy1i21b6hl5rlj31i70xpe0n.jpg\" alt=\"step1\"></p>\n<p>其中，<code>repository name</code> 一定要是 <code>你的英文名称.github.io</code>，比如我的英文名称是<code>jvxiaome</code>， 那么我的仓库名称就是 <code>jvxiaome.github.io</code>，这个后面也是访问博客站点首页的网址，所以前面说取一个好听的名字，是有道理的。</p>\n<p>仓库的可见性选择 <code>Public</code>, 另外下面的 <code>Add a README file</code> 也可以勾上，会方便一些，至于剩下的内容，看个人需要，不清楚的可以暂时不填，最后确认 <code>Create repository</code>。</p>\n<p><img src=\"https://image.baidu.com/search/down?url=http://tvax3.sinaimg.cn/large/0071fJItgy1i21ba20naej31aa1ah1ba.jpg\" alt=\"step2\"></p>\n<ul>\n<li><strong>编辑一个你的博客主页</strong></li>\n</ul>\n<p>进入到刚刚新建的仓库，点击<code>add file</code> 新建一个文件</p>\n<p><img src=\"https://image.baidu.com/search/down?url=http://tvax2.sinaimg.cn/large/0071fJItgy1i21batizraj31gl0ufn95.jpg\" alt=\"step3\"></p>\n<p>文件名称取名为 <code>index.html</code>, 这个文件中包含的就是博客主页的内容了，具体想写什么可以自由发挥</p>\n<p><img src=\"https://image.baidu.com/search/down?url=http://tvax4.sinaimg.cn/large/0071fJItgy1i21bb808bfj31zr0thgzj.jpg\" alt=\"step4\"></p>\n<p>写完之后点击 <code>commit changes</code> 提交内容到仓库，到这一步，你的博客站就算是基本建立起来了<br><img src=\"https://image.baidu.com/search/down?url=http://tvax2.sinaimg.cn/large/0071fJItgy1i21bc83oxuj31eu0vyduh.jpg\" alt=\"step5\"></p>\n<ul>\n<li><strong>访问验证</strong></li>\n</ul>\n<p>既然博客站点已经建好了，此时是不是特别期待访问自己的博客首页呢。</p>\n<p>正如前面所说的，你的仓库名称（你的英文名称.github.io）就是你的博客首页名称，以上面的例子来说，访问 <code>jvxiaome.github.io</code> 就能直接看见首页效果了。</p>\n<p>虽然整个页面都在诉说着朴素(<del>丑</del>)，但一点也不影响你拥有一个属于自己博客站点的那份喜悦。都18+了，怎么能没有自己的网站呢。</p>\n<p><img src=\"https://image.baidu.com/search/down?url=http://tvax3.sinaimg.cn/large/0071fJItgy1i21bcpjfruj310d0k2go1.jpg\" alt=\"step6\"></p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>有了自己的博客网站，还有了域名，而这一切，不是个结束，而是开始。</p>\n<p>如何使用工具，使用主题，搭建一个简洁，漂亮的<a href=\"!%5Bmy-sit%5D(https://image.baidu.com/search/down?url=http://tvax1.sinaimg.cn/large/0071fJItgy1i21bddtgjjj32cu1h8x6q.jpg)\">博客网站</a>，这将是下一篇文中的重点。</p>\n<!-- https://github.com/lmk123/blog/issues/55 -->\n\n"},{"title":"一篇文章搞懂Array,Set和Map异同","date":"2025-05-23T04:40:00.000Z","_content":"\nArray,Set和Map三个作为Javascript中可迭代的集合数据类型，在编程过程中使用的频率也比较高。针对三种数据类型各自的一些特性，本文的内容将从以下几个方面来上述数据类型做一个总结。\n\n-  [**实例的创建**](##实例的创建)\n-  [**数据添加**](##数据添加)\n-  [**数据访问（查找）**](##数据访问（查找）)\n-  [**数据的遍历**](##数据的遍历)\n-  [**类似的功能和一些专有方法**](##类似的功能和一些专有方法)\n-  [**三者之间的转换**](##三者之间的转换)\n-  [**应用场景**](##应用场景)\n\n## 实例的创建\n  Map和Set创建实例的方式是唯一的，只允许通过new调用构造方法来创建一个实例。值得注意的是，Set和Map在调用构造函数的时候，传参都是数组或者可迭代对象，其中Map的传参数组需要时一个键值对数组。当然，传参也是可选的，非必须。\n\n Array相较于前两者，其创建实例的方式要多写，可通过字面方式创建，也可像Map和Set一样通过构造函数来创建。此外使用Array的静态函数Array.from来创建也是非常常见的。例如，通过docuemnt.getElementsByTagName这类方法获取到一个HTMLCollect这样一个类数组，通常会通过Array.from将其装换成一个真正的数组来进行后续的操作。\n\n  ```Javascript\n\n   // 创建map实例\n   let map1 = new Map();\n   let map2 = new Map([['a', 1], ['b', 2]]); //  a=>1, b=>2\n   // 创建set实例\n   let set1 = new Set();\n   let set2 = new Set([1,2])\n\n  // 通过字面量创建数组\n  let arr1 = [1,2,3];\n  // 使用Array静态方法从一个可迭代对象或者类数组中创建数组实例\n  let arr2 = Array.from([4,5]) \n  // 使用Array构造函数\n  let arr3 = new Array([6,7]);\n```\n\n## 数据添加与变更\n\n\n```Javascript\n  // Set的数据操作：添加与删除\n  let set = new Set();\n  set.add(11) // [11]\n  set.add(23) // [11, 23]\n  set.add(11) // [11, 23]\n  set.delete(23) // [11] \n  \n  // Map的数据操作：添加与删除\n  let  map = new Map();\n  map.set('a', 1);   // [a=>1]\n  map.set('b', 2);   // [a=>1, b=>2]\n  map.delete('b');   // [a=>1]\n\n  // Array\n  let arr = [1,2,3]\n  // 在数组末尾添加一个值\n  arr.push(4)       // [1,2,3,4]\n  // 弹出数组末尾的值\n  arr.pop(4)        // [1,2,3]\n  // 在数组头部添加一个值\n  arr.unshift(0)    // [0,1,2,3]\n  // 移除头部的第一个值\n  arr.shift()       // [1,2,3]\n  // 在第二个数（下标1）之后插入一个值‘a’\n  arr.splice(1,0,'a')   // [1,2,'a', 3];\n  // 删除第二个数（下标1）后面1个值，然后插入一个新的值‘b’\n  arr.splice(1,1,'b')   // [1,2,'b',3]\n```\n\n## 数据访问\n  Array和Map都能够访问实例中的特定数据，Array是通过下标，而Map是通过实例方法get, 唯独Set没有方式可以直接访问其中特定数据。其实也不难理解，Set本身不是为了单纯存储数据和访问特殊而生的，因为这些功能Array就可以支持，何必再单出构造一个Set数据结构了。我对此的理解是，Set跟多的是紧紧围绕着数据唯一不重复这一准则来的，它的侧重点是某一数据的有无，而不是数据存在哪里。\n\n  另外，从结构上来说。Set不像Array那样是有序的，所以也无法使用下标来访问，也不像Map那般，每个键对应一个值，所以也无法通过键来访问。故而，Set没有单独访问某一数据的方式。\n\n```Javascript\n  const arr = [1,2,3];\n  const set = new Set(['a', 'b']);\n  const map = new Map([['a', 1], ['b', '2']]);\n  \n  //Array通过下标访问数据\n  console.log(arr[0], arr[2]) // 1, 3\n  //Map使用实例方法get访问数据，参数是键\n  console.log(mpa.get('a))    // 1\n```\n## 数据的遍历\n\n**Set数据的遍历方式**：\n-  keys()   &emsp;&emsp;返回键名迭代器\n-  values() &emsp;返回值迭代器  \n-  entries() &emsp;返回键值迭代器\n-  forEach()\n```Javascript\nconst set = new Set(['a', 'b', 'c']);\n// set每个值对应的key其实也是数据值本身\nconst keyIter = set.keys();\nconsole.log(keyIter.next().value);  // 'a'\nconsole.log(keyIter.next().value);  // 'b'\nconsole.log(keyIter.next().value);  // 'c'\nconsole.log(keyIter.next().value);  // undefined\n\nconst valueIter = set.values();\nfor(let val of valueIter) {\n  console.log(val);                // 'a', 'b', 'c'\n}\n\nconst entriesIter = set.entries();\nfor(let [key, value] of entriesIter) {\n  console(`${key}:${value}`)     // 'a':'a', 'b':'b', 'c':'c'\n}\n\nset.forEach(val => {\n  console.log(val)             // 'a', 'b', 'c'\n})\n```\n</br>\n\n**Map数据的遍历方式**\n-  keys()   &emsp;&emsp;返回键名迭代器\n-  values() &emsp;返回值迭代器  \n-  entries() &emsp;返回键值迭代器\n-  forEach()\n\n```Javascript\nconst map = new Map([['a', 1], ['b', '2']]);\n/**\n* 代码就自己脑补吧，\n* 不能说和Set的方式很像，\n* 只能说真的就是一模一样\n**/\n```\n</br>\n\n**Array数据的遍历方式**\n\nArray遍历数据的方法是最多的，除了下面列举的几个之外，还有some, every,甚至filter, find和findIndex这些方法可以用来遍历数据。使用这些方法需要注意的是其使用的场景，例如map和forEach都可以用来对数组内数据做一些操作，但如果不需要返回值的情况，还是使用forEach方法，而不建议是map，其它方法也是如此。\n\n-  keys()   &emsp;&emsp;返回键名迭代器\n-  values() &emsp;返回值迭代器  \n-  entries() &emsp;返回键值迭代器\n-  map()    &emsp;回调函数，要有返回值\n-  reduce() \n-  forEach()\n-  for...of\n```Javascript\n/**\n* 代码就不写了，偷个懒，不过还是贴心的附上链接\n* https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array\n**/\n```\n\n\n## 类似的功能和一些专有方法\n- **是否包含某个元素**: 数组的includes方法，map和set的has方法，三者的返回值都是布尔值，区别只在于传入的参数。数组和set传入的是值，map传入的是键。\n- **合并两个相同类型的数据**： 数组使用concat方法，合并两个数组值，set使用union方法合并两个集合。map没有专有方法可以用来合并两个map数据，不过可以通过使用new Map([...map1, ...map2])来返回一个合并之后的新map\n- **数据大小**：数组有length属性，map和set有size属性\n- **清空数据**：map和size都可通过clear()方法来清空数据，数组无专有方法，可自己通过修改length值为0或者使用splice方法清空数据。\n\n>关于数组中的includes方法在数组值为一个个对象的时候，这个时候传入的值就只能是对象的引用了。如果作用域内不存在引用的话，判断数组中是否存在某个对象，就只能通过filter, find或者findIndex之类的方法加上数据特征去判断数组中是否存在该对象了。\n\n  \n## 三者之间的转换\n\n\n```Javascript\nconst arr = [1, 3, 4, 4];\nconst arr1 = [['a', 'Kebei']];\nconst map = new Map(['a', 1], ['b', 2]);\nconst set = new Set([1, 5]);\n\n// Array 转 Set\nconst arr2Set = new Set(arr);   // [1, 3, 4];\n// Array 转Map\nconst arr2Map = new Map(arr1);  // {'a' => 'Kebei'}\n\n//Set转Array\nconst set2Arr = Array.from(set);        // [1, 5]\nconst set2Arr2 = [...set];              // [1, 5]\nconst set2Arr3 = set.values()           // [1, 5]\n//Set转Map\nconst set2Map = new Map(set.entries())  // { 1=> 1, 5=>5}\n\n// Map转Array\nconst map2Arr = Array.from(map);     // ['a', 1], ['b', 2]\nconst map2Arr2 = [...map];           // ['a', 1], ['b', 2]\nconst map2Arr3 = map.values()        // ['a', 1], ['b', 2]\n// Map转Set\nconst map2Set = new Set(map.values()) // [1, 2]\n```\n## 应用场景\n</br>\n最常见的一种场景莫过于使用数组与Set之间格式变化进行数据去重\n\n```Javascript\n  const dedup = (arr) => {\n    return [...new Set(arr)]\n  }\n```\n上述方法和之前includes方法也是一样存在无法处理复杂数据类型，对于复杂对象数据，需要根据各自业务场景对重复的数据进行去重策略选择，即在一堆的重复对象中（以id重复为例）保留业务需要的唯一一个数据。\n\n## 总结\n三种数据结构有着各自不同的特性。数组是一个天然的栈，也是一个天然的队列，在三种数据结构中，其实例方法也应用也是最多的，是线性存储中话事人般的存在，也是我们在普通业务场景下的首选。Set数据的唯一性，可以帮助我们在业务场景中快速的进行去重。Map键值对结构的特殊性，以及对键的包容性，能够通过键快速获取到值，也是复杂业务冲常常用的。\n</br>\n\n【资料参考】\n  1. https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array\n  2. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\n  3. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map","source":"_posts/Array-set-map-summary.md","raw":"\n---\ntitle: 一篇文章搞懂Array,Set和Map异同\ndate: 2025-05-23 12:40:00\ntags:\n  - Javascript\n  - Array\n  - Set\n  - Map\n---\n\nArray,Set和Map三个作为Javascript中可迭代的集合数据类型，在编程过程中使用的频率也比较高。针对三种数据类型各自的一些特性，本文的内容将从以下几个方面来上述数据类型做一个总结。\n\n-  [**实例的创建**](##实例的创建)\n-  [**数据添加**](##数据添加)\n-  [**数据访问（查找）**](##数据访问（查找）)\n-  [**数据的遍历**](##数据的遍历)\n-  [**类似的功能和一些专有方法**](##类似的功能和一些专有方法)\n-  [**三者之间的转换**](##三者之间的转换)\n-  [**应用场景**](##应用场景)\n\n## 实例的创建\n  Map和Set创建实例的方式是唯一的，只允许通过new调用构造方法来创建一个实例。值得注意的是，Set和Map在调用构造函数的时候，传参都是数组或者可迭代对象，其中Map的传参数组需要时一个键值对数组。当然，传参也是可选的，非必须。\n\n Array相较于前两者，其创建实例的方式要多写，可通过字面方式创建，也可像Map和Set一样通过构造函数来创建。此外使用Array的静态函数Array.from来创建也是非常常见的。例如，通过docuemnt.getElementsByTagName这类方法获取到一个HTMLCollect这样一个类数组，通常会通过Array.from将其装换成一个真正的数组来进行后续的操作。\n\n  ```Javascript\n\n   // 创建map实例\n   let map1 = new Map();\n   let map2 = new Map([['a', 1], ['b', 2]]); //  a=>1, b=>2\n   // 创建set实例\n   let set1 = new Set();\n   let set2 = new Set([1,2])\n\n  // 通过字面量创建数组\n  let arr1 = [1,2,3];\n  // 使用Array静态方法从一个可迭代对象或者类数组中创建数组实例\n  let arr2 = Array.from([4,5]) \n  // 使用Array构造函数\n  let arr3 = new Array([6,7]);\n```\n\n## 数据添加与变更\n\n\n```Javascript\n  // Set的数据操作：添加与删除\n  let set = new Set();\n  set.add(11) // [11]\n  set.add(23) // [11, 23]\n  set.add(11) // [11, 23]\n  set.delete(23) // [11] \n  \n  // Map的数据操作：添加与删除\n  let  map = new Map();\n  map.set('a', 1);   // [a=>1]\n  map.set('b', 2);   // [a=>1, b=>2]\n  map.delete('b');   // [a=>1]\n\n  // Array\n  let arr = [1,2,3]\n  // 在数组末尾添加一个值\n  arr.push(4)       // [1,2,3,4]\n  // 弹出数组末尾的值\n  arr.pop(4)        // [1,2,3]\n  // 在数组头部添加一个值\n  arr.unshift(0)    // [0,1,2,3]\n  // 移除头部的第一个值\n  arr.shift()       // [1,2,3]\n  // 在第二个数（下标1）之后插入一个值‘a’\n  arr.splice(1,0,'a')   // [1,2,'a', 3];\n  // 删除第二个数（下标1）后面1个值，然后插入一个新的值‘b’\n  arr.splice(1,1,'b')   // [1,2,'b',3]\n```\n\n## 数据访问\n  Array和Map都能够访问实例中的特定数据，Array是通过下标，而Map是通过实例方法get, 唯独Set没有方式可以直接访问其中特定数据。其实也不难理解，Set本身不是为了单纯存储数据和访问特殊而生的，因为这些功能Array就可以支持，何必再单出构造一个Set数据结构了。我对此的理解是，Set跟多的是紧紧围绕着数据唯一不重复这一准则来的，它的侧重点是某一数据的有无，而不是数据存在哪里。\n\n  另外，从结构上来说。Set不像Array那样是有序的，所以也无法使用下标来访问，也不像Map那般，每个键对应一个值，所以也无法通过键来访问。故而，Set没有单独访问某一数据的方式。\n\n```Javascript\n  const arr = [1,2,3];\n  const set = new Set(['a', 'b']);\n  const map = new Map([['a', 1], ['b', '2']]);\n  \n  //Array通过下标访问数据\n  console.log(arr[0], arr[2]) // 1, 3\n  //Map使用实例方法get访问数据，参数是键\n  console.log(mpa.get('a))    // 1\n```\n## 数据的遍历\n\n**Set数据的遍历方式**：\n-  keys()   &emsp;&emsp;返回键名迭代器\n-  values() &emsp;返回值迭代器  \n-  entries() &emsp;返回键值迭代器\n-  forEach()\n```Javascript\nconst set = new Set(['a', 'b', 'c']);\n// set每个值对应的key其实也是数据值本身\nconst keyIter = set.keys();\nconsole.log(keyIter.next().value);  // 'a'\nconsole.log(keyIter.next().value);  // 'b'\nconsole.log(keyIter.next().value);  // 'c'\nconsole.log(keyIter.next().value);  // undefined\n\nconst valueIter = set.values();\nfor(let val of valueIter) {\n  console.log(val);                // 'a', 'b', 'c'\n}\n\nconst entriesIter = set.entries();\nfor(let [key, value] of entriesIter) {\n  console(`${key}:${value}`)     // 'a':'a', 'b':'b', 'c':'c'\n}\n\nset.forEach(val => {\n  console.log(val)             // 'a', 'b', 'c'\n})\n```\n</br>\n\n**Map数据的遍历方式**\n-  keys()   &emsp;&emsp;返回键名迭代器\n-  values() &emsp;返回值迭代器  \n-  entries() &emsp;返回键值迭代器\n-  forEach()\n\n```Javascript\nconst map = new Map([['a', 1], ['b', '2']]);\n/**\n* 代码就自己脑补吧，\n* 不能说和Set的方式很像，\n* 只能说真的就是一模一样\n**/\n```\n</br>\n\n**Array数据的遍历方式**\n\nArray遍历数据的方法是最多的，除了下面列举的几个之外，还有some, every,甚至filter, find和findIndex这些方法可以用来遍历数据。使用这些方法需要注意的是其使用的场景，例如map和forEach都可以用来对数组内数据做一些操作，但如果不需要返回值的情况，还是使用forEach方法，而不建议是map，其它方法也是如此。\n\n-  keys()   &emsp;&emsp;返回键名迭代器\n-  values() &emsp;返回值迭代器  \n-  entries() &emsp;返回键值迭代器\n-  map()    &emsp;回调函数，要有返回值\n-  reduce() \n-  forEach()\n-  for...of\n```Javascript\n/**\n* 代码就不写了，偷个懒，不过还是贴心的附上链接\n* https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array\n**/\n```\n\n\n## 类似的功能和一些专有方法\n- **是否包含某个元素**: 数组的includes方法，map和set的has方法，三者的返回值都是布尔值，区别只在于传入的参数。数组和set传入的是值，map传入的是键。\n- **合并两个相同类型的数据**： 数组使用concat方法，合并两个数组值，set使用union方法合并两个集合。map没有专有方法可以用来合并两个map数据，不过可以通过使用new Map([...map1, ...map2])来返回一个合并之后的新map\n- **数据大小**：数组有length属性，map和set有size属性\n- **清空数据**：map和size都可通过clear()方法来清空数据，数组无专有方法，可自己通过修改length值为0或者使用splice方法清空数据。\n\n>关于数组中的includes方法在数组值为一个个对象的时候，这个时候传入的值就只能是对象的引用了。如果作用域内不存在引用的话，判断数组中是否存在某个对象，就只能通过filter, find或者findIndex之类的方法加上数据特征去判断数组中是否存在该对象了。\n\n  \n## 三者之间的转换\n\n\n```Javascript\nconst arr = [1, 3, 4, 4];\nconst arr1 = [['a', 'Kebei']];\nconst map = new Map(['a', 1], ['b', 2]);\nconst set = new Set([1, 5]);\n\n// Array 转 Set\nconst arr2Set = new Set(arr);   // [1, 3, 4];\n// Array 转Map\nconst arr2Map = new Map(arr1);  // {'a' => 'Kebei'}\n\n//Set转Array\nconst set2Arr = Array.from(set);        // [1, 5]\nconst set2Arr2 = [...set];              // [1, 5]\nconst set2Arr3 = set.values()           // [1, 5]\n//Set转Map\nconst set2Map = new Map(set.entries())  // { 1=> 1, 5=>5}\n\n// Map转Array\nconst map2Arr = Array.from(map);     // ['a', 1], ['b', 2]\nconst map2Arr2 = [...map];           // ['a', 1], ['b', 2]\nconst map2Arr3 = map.values()        // ['a', 1], ['b', 2]\n// Map转Set\nconst map2Set = new Set(map.values()) // [1, 2]\n```\n## 应用场景\n</br>\n最常见的一种场景莫过于使用数组与Set之间格式变化进行数据去重\n\n```Javascript\n  const dedup = (arr) => {\n    return [...new Set(arr)]\n  }\n```\n上述方法和之前includes方法也是一样存在无法处理复杂数据类型，对于复杂对象数据，需要根据各自业务场景对重复的数据进行去重策略选择，即在一堆的重复对象中（以id重复为例）保留业务需要的唯一一个数据。\n\n## 总结\n三种数据结构有着各自不同的特性。数组是一个天然的栈，也是一个天然的队列，在三种数据结构中，其实例方法也应用也是最多的，是线性存储中话事人般的存在，也是我们在普通业务场景下的首选。Set数据的唯一性，可以帮助我们在业务场景中快速的进行去重。Map键值对结构的特殊性，以及对键的包容性，能够通过键快速获取到值，也是复杂业务冲常常用的。\n</br>\n\n【资料参考】\n  1. https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array\n  2. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\n  3. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map","slug":"Array-set-map-summary","published":1,"updated":"2025-05-27T10:17:21.034Z","comments":1,"layout":"post","photos":[],"_id":"cmbkxc9ov0000koup1mpldhh3","content":"<p>Array,Set和Map三个作为Javascript中可迭代的集合数据类型，在编程过程中使用的频率也比较高。针对三种数据类型各自的一些特性，本文的内容将从以下几个方面来上述数据类型做一个总结。</p>\n<ul>\n<li><a href=\"##%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%88%9B%E5%BB%BA\"><strong>实例的创建</strong></a></li>\n<li><a href=\"##%E6%95%B0%E6%8D%AE%E6%B7%BB%E5%8A%A0\"><strong>数据添加</strong></a></li>\n<li><a href=\"##%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%EF%BC%88%E6%9F%A5%E6%89%BE%EF%BC%89\"><strong>数据访问（查找）</strong></a></li>\n<li><a href=\"##%E6%95%B0%E6%8D%AE%E7%9A%84%E9%81%8D%E5%8E%86\"><strong>数据的遍历</strong></a></li>\n<li><a href=\"##%E7%B1%BB%E4%BC%BC%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E4%B8%80%E4%BA%9B%E4%B8%93%E6%9C%89%E6%96%B9%E6%B3%95\"><strong>类似的功能和一些专有方法</strong></a></li>\n<li><a href=\"##%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2\"><strong>三者之间的转换</strong></a></li>\n<li><a href=\"##%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\"><strong>应用场景</strong></a></li>\n</ul>\n<h2 id=\"实例的创建\"><a href=\"#实例的创建\" class=\"headerlink\" title=\"实例的创建\"></a>实例的创建</h2><p>  Map和Set创建实例的方式是唯一的，只允许通过new调用构造方法来创建一个实例。值得注意的是，Set和Map在调用构造函数的时候，传参都是数组或者可迭代对象，其中Map的传参数组需要时一个键值对数组。当然，传参也是可选的，非必须。</p>\n<p> Array相较于前两者，其创建实例的方式要多写，可通过字面方式创建，也可像Map和Set一样通过构造函数来创建。此外使用Array的静态函数Array.from来创建也是非常常见的。例如，通过docuemnt.getElementsByTagName这类方法获取到一个HTMLCollect这样一个类数组，通常会通过Array.from将其装换成一个真正的数组来进行后续的操作。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><br> <span class=\"hljs-comment\">// 创建map实例</span><br> <span class=\"hljs-keyword\">let</span> map1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();<br> <span class=\"hljs-keyword\">let</span> map2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">1</span>], [<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-number\">2</span>]]); <span class=\"hljs-comment\">//  a=&gt;1, b=&gt;2</span><br> <span class=\"hljs-comment\">// 创建set实例</span><br> <span class=\"hljs-keyword\">let</span> set1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>();<br> <span class=\"hljs-keyword\">let</span> set2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>])<br><br><span class=\"hljs-comment\">// 通过字面量创建数组</span><br><span class=\"hljs-keyword\">let</span> arr1 = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>];<br><span class=\"hljs-comment\">// 使用Array静态方法从一个可迭代对象或者类数组中创建数组实例</span><br><span class=\"hljs-keyword\">let</span> arr2 = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>([<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>]) <br><span class=\"hljs-comment\">// 使用Array构造函数</span><br><span class=\"hljs-keyword\">let</span> arr3 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Array</span>([<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">7</span>]);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"数据添加与变更\"><a href=\"#数据添加与变更\" class=\"headerlink\" title=\"数据添加与变更\"></a>数据添加与变更</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">// Set的数据操作：添加与删除</span><br><span class=\"hljs-keyword\">let</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>();<br>set.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">11</span>) <span class=\"hljs-comment\">// [11]</span><br>set.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">23</span>) <span class=\"hljs-comment\">// [11, 23]</span><br>set.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">11</span>) <span class=\"hljs-comment\">// [11, 23]</span><br>set.<span class=\"hljs-title function_\">delete</span>(<span class=\"hljs-number\">23</span>) <span class=\"hljs-comment\">// [11] </span><br><br><span class=\"hljs-comment\">// Map的数据操作：添加与删除</span><br><span class=\"hljs-keyword\">let</span>  map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();<br>map.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">1</span>);   <span class=\"hljs-comment\">// [a=&gt;1]</span><br>map.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-number\">2</span>);   <span class=\"hljs-comment\">// [a=&gt;1, b=&gt;2]</span><br>map.<span class=\"hljs-title function_\">delete</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>);   <span class=\"hljs-comment\">// [a=&gt;1]</span><br><br><span class=\"hljs-comment\">// Array</span><br><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>]<br><span class=\"hljs-comment\">// 在数组末尾添加一个值</span><br>arr.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-number\">4</span>)       <span class=\"hljs-comment\">// [1,2,3,4]</span><br><span class=\"hljs-comment\">// 弹出数组末尾的值</span><br>arr.<span class=\"hljs-title function_\">pop</span>(<span class=\"hljs-number\">4</span>)        <span class=\"hljs-comment\">// [1,2,3]</span><br><span class=\"hljs-comment\">// 在数组头部添加一个值</span><br>arr.<span class=\"hljs-title function_\">unshift</span>(<span class=\"hljs-number\">0</span>)    <span class=\"hljs-comment\">// [0,1,2,3]</span><br><span class=\"hljs-comment\">// 移除头部的第一个值</span><br>arr.<span class=\"hljs-title function_\">shift</span>()       <span class=\"hljs-comment\">// [1,2,3]</span><br><span class=\"hljs-comment\">// 在第二个数（下标1）之后插入一个值‘a’</span><br>arr.<span class=\"hljs-title function_\">splice</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-string\">&#x27;a&#x27;</span>)   <span class=\"hljs-comment\">// [1,2,&#x27;a&#x27;, 3];</span><br><span class=\"hljs-comment\">// 删除第二个数（下标1）后面1个值，然后插入一个新的值‘b’</span><br>arr.<span class=\"hljs-title function_\">splice</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">&#x27;b&#x27;</span>)   <span class=\"hljs-comment\">// [1,2,&#x27;b&#x27;,3]</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"数据访问\"><a href=\"#数据访问\" class=\"headerlink\" title=\"数据访问\"></a>数据访问</h2><p>  Array和Map都能够访问实例中的特定数据，Array是通过下标，而Map是通过实例方法get, 唯独Set没有方式可以直接访问其中特定数据。其实也不难理解，Set本身不是为了单纯存储数据和访问特殊而生的，因为这些功能Array就可以支持，何必再单出构造一个Set数据结构了。我对此的理解是，Set跟多的是紧紧围绕着数据唯一不重复这一准则来的，它的侧重点是某一数据的有无，而不是数据存在哪里。</p>\n<p>  另外，从结构上来说。Set不像Array那样是有序的，所以也无法使用下标来访问，也不像Map那般，每个键对应一个值，所以也无法通过键来访问。故而，Set没有单独访问某一数据的方式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>];<br><span class=\"hljs-keyword\">const</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>]);<br><span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">1</span>], [<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;2&#x27;</span>]]);<br><br><span class=\"hljs-comment\">//Array通过下标访问数据</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(arr[<span class=\"hljs-number\">0</span>], arr[<span class=\"hljs-number\">2</span>]) <span class=\"hljs-comment\">// 1, 3</span><br><span class=\"hljs-comment\">//Map使用实例方法get访问数据，参数是键</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(mpa.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;a))    // 1</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"数据的遍历\"><a href=\"#数据的遍历\" class=\"headerlink\" title=\"数据的遍历\"></a>数据的遍历</h2><p><strong>Set数据的遍历方式</strong>：</p>\n<ul>\n<li>keys()   &emsp;&emsp;返回键名迭代器</li>\n<li>values() &emsp;返回值迭代器  </li>\n<li>entries() &emsp;返回键值迭代器</li>\n<li>forEach()<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">const</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>]);<br><span class=\"hljs-comment\">// set每个值对应的key其实也是数据值本身</span><br><span class=\"hljs-keyword\">const</span> keyIter = set.<span class=\"hljs-title function_\">keys</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(keyIter.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>);  <span class=\"hljs-comment\">// &#x27;a&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(keyIter.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>);  <span class=\"hljs-comment\">// &#x27;b&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(keyIter.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>);  <span class=\"hljs-comment\">// &#x27;c&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(keyIter.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>);  <span class=\"hljs-comment\">// undefined</span><br><br><span class=\"hljs-keyword\">const</span> valueIter = set.<span class=\"hljs-title function_\">values</span>();<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> val <span class=\"hljs-keyword\">of</span> valueIter) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(val);                <span class=\"hljs-comment\">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span><br>&#125;<br><br><span class=\"hljs-keyword\">const</span> entriesIter = set.<span class=\"hljs-title function_\">entries</span>();<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> [key, value] <span class=\"hljs-keyword\">of</span> entriesIter) &#123;<br>  <span class=\"hljs-title function_\">console</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;key&#125;</span>:<span class=\"hljs-subst\">$&#123;value&#125;</span>`</span>)     <span class=\"hljs-comment\">// &#x27;a&#x27;:&#x27;a&#x27;, &#x27;b&#x27;:&#x27;b&#x27;, &#x27;c&#x27;:&#x27;c&#x27;</span><br>&#125;<br><br>set.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">val</span> =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(val)             <span class=\"hljs-comment\">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n</br></li>\n</ul>\n<p><strong>Map数据的遍历方式</strong></p>\n<ul>\n<li>keys()   &emsp;&emsp;返回键名迭代器</li>\n<li>values() &emsp;返回值迭代器  </li>\n<li>entries() &emsp;返回键值迭代器</li>\n<li>forEach()</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">1</span>], [<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;2&#x27;</span>]]);<br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">* 代码就自己脑补吧，</span><br><span class=\"hljs-comment\">* 不能说和Set的方式很像，</span><br><span class=\"hljs-comment\">* 只能说真的就是一模一样</span><br><span class=\"hljs-comment\">**/</span><br></code></pre></td></tr></table></figure>\n</br>\n\n<p><strong>Array数据的遍历方式</strong></p>\n<p>Array遍历数据的方法是最多的，除了下面列举的几个之外，还有some, every,甚至filter, find和findIndex这些方法可以用来遍历数据。使用这些方法需要注意的是其使用的场景，例如map和forEach都可以用来对数组内数据做一些操作，但如果不需要返回值的情况，还是使用forEach方法，而不建议是map，其它方法也是如此。</p>\n<ul>\n<li>keys()   &emsp;&emsp;返回键名迭代器</li>\n<li>values() &emsp;返回值迭代器  </li>\n<li>entries() &emsp;返回键值迭代器</li>\n<li>map()    &emsp;回调函数，要有返回值</li>\n<li>reduce() </li>\n<li>forEach()</li>\n<li>for…of<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">* 代码就不写了，偷个懒，不过还是贴心的附上链接</span><br><span class=\"hljs-comment\">* https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array</span><br><span class=\"hljs-comment\">**/</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"类似的功能和一些专有方法\"><a href=\"#类似的功能和一些专有方法\" class=\"headerlink\" title=\"类似的功能和一些专有方法\"></a>类似的功能和一些专有方法</h2><ul>\n<li><strong>是否包含某个元素</strong>: 数组的includes方法，map和set的has方法，三者的返回值都是布尔值，区别只在于传入的参数。数组和set传入的是值，map传入的是键。</li>\n<li><strong>合并两个相同类型的数据</strong>： 数组使用concat方法，合并两个数组值，set使用union方法合并两个集合。map没有专有方法可以用来合并两个map数据，不过可以通过使用new Map([…map1, …map2])来返回一个合并之后的新map</li>\n<li><strong>数据大小</strong>：数组有length属性，map和set有size属性</li>\n<li><strong>清空数据</strong>：map和size都可通过clear()方法来清空数据，数组无专有方法，可自己通过修改length值为0或者使用splice方法清空数据。</li>\n</ul>\n<blockquote>\n<p>关于数组中的includes方法在数组值为一个个对象的时候，这个时候传入的值就只能是对象的引用了。如果作用域内不存在引用的话，判断数组中是否存在某个对象，就只能通过filter, find或者findIndex之类的方法加上数据特征去判断数组中是否存在该对象了。</p>\n</blockquote>\n<h2 id=\"三者之间的转换\"><a href=\"#三者之间的转换\" class=\"headerlink\" title=\"三者之间的转换\"></a>三者之间的转换</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">4</span>];<br><span class=\"hljs-keyword\">const</span> arr1 = [[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;Kebei&#x27;</span>]];<br><span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">1</span>], [<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-number\">2</span>]);<br><span class=\"hljs-keyword\">const</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>]);<br><br><span class=\"hljs-comment\">// Array 转 Set</span><br><span class=\"hljs-keyword\">const</span> arr2Set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>(arr);   <span class=\"hljs-comment\">// [1, 3, 4];</span><br><span class=\"hljs-comment\">// Array 转Map</span><br><span class=\"hljs-keyword\">const</span> arr2Map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(arr1);  <span class=\"hljs-comment\">// &#123;&#x27;a&#x27; =&gt; &#x27;Kebei&#x27;&#125;</span><br><br><span class=\"hljs-comment\">//Set转Array</span><br><span class=\"hljs-keyword\">const</span> set2Arr = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(set);        <span class=\"hljs-comment\">// [1, 5]</span><br><span class=\"hljs-keyword\">const</span> set2Arr2 = [...set];              <span class=\"hljs-comment\">// [1, 5]</span><br><span class=\"hljs-keyword\">const</span> set2Arr3 = set.<span class=\"hljs-title function_\">values</span>()           <span class=\"hljs-comment\">// [1, 5]</span><br><span class=\"hljs-comment\">//Set转Map</span><br><span class=\"hljs-keyword\">const</span> set2Map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(set.<span class=\"hljs-title function_\">entries</span>())  <span class=\"hljs-comment\">// &#123; 1=&gt; 1, 5=&gt;5&#125;</span><br><br><span class=\"hljs-comment\">// Map转Array</span><br><span class=\"hljs-keyword\">const</span> map2Arr = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(map);     <span class=\"hljs-comment\">// [&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2]</span><br><span class=\"hljs-keyword\">const</span> map2Arr2 = [...map];           <span class=\"hljs-comment\">// [&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2]</span><br><span class=\"hljs-keyword\">const</span> map2Arr3 = map.<span class=\"hljs-title function_\">values</span>()        <span class=\"hljs-comment\">// [&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2]</span><br><span class=\"hljs-comment\">// Map转Set</span><br><span class=\"hljs-keyword\">const</span> map2Set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>(map.<span class=\"hljs-title function_\">values</span>()) <span class=\"hljs-comment\">// [1, 2]</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2></br>\n最常见的一种场景莫过于使用数组与Set之间格式变化进行数据去重\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">dedup</span> = (<span class=\"hljs-params\">arr</span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">return</span> [...<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>(arr)]<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>上述方法和之前includes方法也是一样存在无法处理复杂数据类型，对于复杂对象数据，需要根据各自业务场景对重复的数据进行去重策略选择，即在一堆的重复对象中（以id重复为例）保留业务需要的唯一一个数据。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>三种数据结构有着各自不同的特性。数组是一个天然的栈，也是一个天然的队列，在三种数据结构中，其实例方法也应用也是最多的，是线性存储中话事人般的存在，也是我们在普通业务场景下的首选。Set数据的唯一性，可以帮助我们在业务场景中快速的进行去重。Map键值对结构的特殊性，以及对键的包容性，能够通过键快速获取到值，也是复杂业务冲常常用的。<br></br></p>\n<p>【资料参考】</p>\n<ol>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map</a></li>\n</ol>\n","excerpt":"","more":"<p>Array,Set和Map三个作为Javascript中可迭代的集合数据类型，在编程过程中使用的频率也比较高。针对三种数据类型各自的一些特性，本文的内容将从以下几个方面来上述数据类型做一个总结。</p>\n<ul>\n<li><a href=\"##%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%88%9B%E5%BB%BA\"><strong>实例的创建</strong></a></li>\n<li><a href=\"##%E6%95%B0%E6%8D%AE%E6%B7%BB%E5%8A%A0\"><strong>数据添加</strong></a></li>\n<li><a href=\"##%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%EF%BC%88%E6%9F%A5%E6%89%BE%EF%BC%89\"><strong>数据访问（查找）</strong></a></li>\n<li><a href=\"##%E6%95%B0%E6%8D%AE%E7%9A%84%E9%81%8D%E5%8E%86\"><strong>数据的遍历</strong></a></li>\n<li><a href=\"##%E7%B1%BB%E4%BC%BC%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E4%B8%80%E4%BA%9B%E4%B8%93%E6%9C%89%E6%96%B9%E6%B3%95\"><strong>类似的功能和一些专有方法</strong></a></li>\n<li><a href=\"##%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2\"><strong>三者之间的转换</strong></a></li>\n<li><a href=\"##%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\"><strong>应用场景</strong></a></li>\n</ul>\n<h2 id=\"实例的创建\"><a href=\"#实例的创建\" class=\"headerlink\" title=\"实例的创建\"></a>实例的创建</h2><p>  Map和Set创建实例的方式是唯一的，只允许通过new调用构造方法来创建一个实例。值得注意的是，Set和Map在调用构造函数的时候，传参都是数组或者可迭代对象，其中Map的传参数组需要时一个键值对数组。当然，传参也是可选的，非必须。</p>\n<p> Array相较于前两者，其创建实例的方式要多写，可通过字面方式创建，也可像Map和Set一样通过构造函数来创建。此外使用Array的静态函数Array.from来创建也是非常常见的。例如，通过docuemnt.getElementsByTagName这类方法获取到一个HTMLCollect这样一个类数组，通常会通过Array.from将其装换成一个真正的数组来进行后续的操作。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><br> <span class=\"hljs-comment\">// 创建map实例</span><br> <span class=\"hljs-keyword\">let</span> map1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();<br> <span class=\"hljs-keyword\">let</span> map2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">1</span>], [<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-number\">2</span>]]); <span class=\"hljs-comment\">//  a=&gt;1, b=&gt;2</span><br> <span class=\"hljs-comment\">// 创建set实例</span><br> <span class=\"hljs-keyword\">let</span> set1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>();<br> <span class=\"hljs-keyword\">let</span> set2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>])<br><br><span class=\"hljs-comment\">// 通过字面量创建数组</span><br><span class=\"hljs-keyword\">let</span> arr1 = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>];<br><span class=\"hljs-comment\">// 使用Array静态方法从一个可迭代对象或者类数组中创建数组实例</span><br><span class=\"hljs-keyword\">let</span> arr2 = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>([<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>]) <br><span class=\"hljs-comment\">// 使用Array构造函数</span><br><span class=\"hljs-keyword\">let</span> arr3 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Array</span>([<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">7</span>]);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"数据添加与变更\"><a href=\"#数据添加与变更\" class=\"headerlink\" title=\"数据添加与变更\"></a>数据添加与变更</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">// Set的数据操作：添加与删除</span><br><span class=\"hljs-keyword\">let</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>();<br>set.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">11</span>) <span class=\"hljs-comment\">// [11]</span><br>set.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">23</span>) <span class=\"hljs-comment\">// [11, 23]</span><br>set.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">11</span>) <span class=\"hljs-comment\">// [11, 23]</span><br>set.<span class=\"hljs-title function_\">delete</span>(<span class=\"hljs-number\">23</span>) <span class=\"hljs-comment\">// [11] </span><br><br><span class=\"hljs-comment\">// Map的数据操作：添加与删除</span><br><span class=\"hljs-keyword\">let</span>  map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();<br>map.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">1</span>);   <span class=\"hljs-comment\">// [a=&gt;1]</span><br>map.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-number\">2</span>);   <span class=\"hljs-comment\">// [a=&gt;1, b=&gt;2]</span><br>map.<span class=\"hljs-title function_\">delete</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>);   <span class=\"hljs-comment\">// [a=&gt;1]</span><br><br><span class=\"hljs-comment\">// Array</span><br><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>]<br><span class=\"hljs-comment\">// 在数组末尾添加一个值</span><br>arr.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-number\">4</span>)       <span class=\"hljs-comment\">// [1,2,3,4]</span><br><span class=\"hljs-comment\">// 弹出数组末尾的值</span><br>arr.<span class=\"hljs-title function_\">pop</span>(<span class=\"hljs-number\">4</span>)        <span class=\"hljs-comment\">// [1,2,3]</span><br><span class=\"hljs-comment\">// 在数组头部添加一个值</span><br>arr.<span class=\"hljs-title function_\">unshift</span>(<span class=\"hljs-number\">0</span>)    <span class=\"hljs-comment\">// [0,1,2,3]</span><br><span class=\"hljs-comment\">// 移除头部的第一个值</span><br>arr.<span class=\"hljs-title function_\">shift</span>()       <span class=\"hljs-comment\">// [1,2,3]</span><br><span class=\"hljs-comment\">// 在第二个数（下标1）之后插入一个值‘a’</span><br>arr.<span class=\"hljs-title function_\">splice</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-string\">&#x27;a&#x27;</span>)   <span class=\"hljs-comment\">// [1,2,&#x27;a&#x27;, 3];</span><br><span class=\"hljs-comment\">// 删除第二个数（下标1）后面1个值，然后插入一个新的值‘b’</span><br>arr.<span class=\"hljs-title function_\">splice</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">&#x27;b&#x27;</span>)   <span class=\"hljs-comment\">// [1,2,&#x27;b&#x27;,3]</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"数据访问\"><a href=\"#数据访问\" class=\"headerlink\" title=\"数据访问\"></a>数据访问</h2><p>  Array和Map都能够访问实例中的特定数据，Array是通过下标，而Map是通过实例方法get, 唯独Set没有方式可以直接访问其中特定数据。其实也不难理解，Set本身不是为了单纯存储数据和访问特殊而生的，因为这些功能Array就可以支持，何必再单出构造一个Set数据结构了。我对此的理解是，Set跟多的是紧紧围绕着数据唯一不重复这一准则来的，它的侧重点是某一数据的有无，而不是数据存在哪里。</p>\n<p>  另外，从结构上来说。Set不像Array那样是有序的，所以也无法使用下标来访问，也不像Map那般，每个键对应一个值，所以也无法通过键来访问。故而，Set没有单独访问某一数据的方式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>];<br><span class=\"hljs-keyword\">const</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>]);<br><span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">1</span>], [<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;2&#x27;</span>]]);<br><br><span class=\"hljs-comment\">//Array通过下标访问数据</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(arr[<span class=\"hljs-number\">0</span>], arr[<span class=\"hljs-number\">2</span>]) <span class=\"hljs-comment\">// 1, 3</span><br><span class=\"hljs-comment\">//Map使用实例方法get访问数据，参数是键</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(mpa.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;a))    // 1</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"数据的遍历\"><a href=\"#数据的遍历\" class=\"headerlink\" title=\"数据的遍历\"></a>数据的遍历</h2><p><strong>Set数据的遍历方式</strong>：</p>\n<ul>\n<li>keys()   &emsp;&emsp;返回键名迭代器</li>\n<li>values() &emsp;返回值迭代器  </li>\n<li>entries() &emsp;返回键值迭代器</li>\n<li>forEach()<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">const</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>]);<br><span class=\"hljs-comment\">// set每个值对应的key其实也是数据值本身</span><br><span class=\"hljs-keyword\">const</span> keyIter = set.<span class=\"hljs-title function_\">keys</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(keyIter.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>);  <span class=\"hljs-comment\">// &#x27;a&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(keyIter.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>);  <span class=\"hljs-comment\">// &#x27;b&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(keyIter.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>);  <span class=\"hljs-comment\">// &#x27;c&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(keyIter.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>);  <span class=\"hljs-comment\">// undefined</span><br><br><span class=\"hljs-keyword\">const</span> valueIter = set.<span class=\"hljs-title function_\">values</span>();<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> val <span class=\"hljs-keyword\">of</span> valueIter) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(val);                <span class=\"hljs-comment\">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span><br>&#125;<br><br><span class=\"hljs-keyword\">const</span> entriesIter = set.<span class=\"hljs-title function_\">entries</span>();<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> [key, value] <span class=\"hljs-keyword\">of</span> entriesIter) &#123;<br>  <span class=\"hljs-title function_\">console</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;key&#125;</span>:<span class=\"hljs-subst\">$&#123;value&#125;</span>`</span>)     <span class=\"hljs-comment\">// &#x27;a&#x27;:&#x27;a&#x27;, &#x27;b&#x27;:&#x27;b&#x27;, &#x27;c&#x27;:&#x27;c&#x27;</span><br>&#125;<br><br>set.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">val</span> =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(val)             <span class=\"hljs-comment\">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n</br></li>\n</ul>\n<p><strong>Map数据的遍历方式</strong></p>\n<ul>\n<li>keys()   &emsp;&emsp;返回键名迭代器</li>\n<li>values() &emsp;返回值迭代器  </li>\n<li>entries() &emsp;返回键值迭代器</li>\n<li>forEach()</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">1</span>], [<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;2&#x27;</span>]]);<br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">* 代码就自己脑补吧，</span><br><span class=\"hljs-comment\">* 不能说和Set的方式很像，</span><br><span class=\"hljs-comment\">* 只能说真的就是一模一样</span><br><span class=\"hljs-comment\">**/</span><br></code></pre></td></tr></table></figure>\n</br>\n\n<p><strong>Array数据的遍历方式</strong></p>\n<p>Array遍历数据的方法是最多的，除了下面列举的几个之外，还有some, every,甚至filter, find和findIndex这些方法可以用来遍历数据。使用这些方法需要注意的是其使用的场景，例如map和forEach都可以用来对数组内数据做一些操作，但如果不需要返回值的情况，还是使用forEach方法，而不建议是map，其它方法也是如此。</p>\n<ul>\n<li>keys()   &emsp;&emsp;返回键名迭代器</li>\n<li>values() &emsp;返回值迭代器  </li>\n<li>entries() &emsp;返回键值迭代器</li>\n<li>map()    &emsp;回调函数，要有返回值</li>\n<li>reduce() </li>\n<li>forEach()</li>\n<li>for…of<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">* 代码就不写了，偷个懒，不过还是贴心的附上链接</span><br><span class=\"hljs-comment\">* https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array</span><br><span class=\"hljs-comment\">**/</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"类似的功能和一些专有方法\"><a href=\"#类似的功能和一些专有方法\" class=\"headerlink\" title=\"类似的功能和一些专有方法\"></a>类似的功能和一些专有方法</h2><ul>\n<li><strong>是否包含某个元素</strong>: 数组的includes方法，map和set的has方法，三者的返回值都是布尔值，区别只在于传入的参数。数组和set传入的是值，map传入的是键。</li>\n<li><strong>合并两个相同类型的数据</strong>： 数组使用concat方法，合并两个数组值，set使用union方法合并两个集合。map没有专有方法可以用来合并两个map数据，不过可以通过使用new Map([…map1, …map2])来返回一个合并之后的新map</li>\n<li><strong>数据大小</strong>：数组有length属性，map和set有size属性</li>\n<li><strong>清空数据</strong>：map和size都可通过clear()方法来清空数据，数组无专有方法，可自己通过修改length值为0或者使用splice方法清空数据。</li>\n</ul>\n<blockquote>\n<p>关于数组中的includes方法在数组值为一个个对象的时候，这个时候传入的值就只能是对象的引用了。如果作用域内不存在引用的话，判断数组中是否存在某个对象，就只能通过filter, find或者findIndex之类的方法加上数据特征去判断数组中是否存在该对象了。</p>\n</blockquote>\n<h2 id=\"三者之间的转换\"><a href=\"#三者之间的转换\" class=\"headerlink\" title=\"三者之间的转换\"></a>三者之间的转换</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">4</span>];<br><span class=\"hljs-keyword\">const</span> arr1 = [[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;Kebei&#x27;</span>]];<br><span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">1</span>], [<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-number\">2</span>]);<br><span class=\"hljs-keyword\">const</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>]);<br><br><span class=\"hljs-comment\">// Array 转 Set</span><br><span class=\"hljs-keyword\">const</span> arr2Set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>(arr);   <span class=\"hljs-comment\">// [1, 3, 4];</span><br><span class=\"hljs-comment\">// Array 转Map</span><br><span class=\"hljs-keyword\">const</span> arr2Map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(arr1);  <span class=\"hljs-comment\">// &#123;&#x27;a&#x27; =&gt; &#x27;Kebei&#x27;&#125;</span><br><br><span class=\"hljs-comment\">//Set转Array</span><br><span class=\"hljs-keyword\">const</span> set2Arr = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(set);        <span class=\"hljs-comment\">// [1, 5]</span><br><span class=\"hljs-keyword\">const</span> set2Arr2 = [...set];              <span class=\"hljs-comment\">// [1, 5]</span><br><span class=\"hljs-keyword\">const</span> set2Arr3 = set.<span class=\"hljs-title function_\">values</span>()           <span class=\"hljs-comment\">// [1, 5]</span><br><span class=\"hljs-comment\">//Set转Map</span><br><span class=\"hljs-keyword\">const</span> set2Map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(set.<span class=\"hljs-title function_\">entries</span>())  <span class=\"hljs-comment\">// &#123; 1=&gt; 1, 5=&gt;5&#125;</span><br><br><span class=\"hljs-comment\">// Map转Array</span><br><span class=\"hljs-keyword\">const</span> map2Arr = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(map);     <span class=\"hljs-comment\">// [&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2]</span><br><span class=\"hljs-keyword\">const</span> map2Arr2 = [...map];           <span class=\"hljs-comment\">// [&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2]</span><br><span class=\"hljs-keyword\">const</span> map2Arr3 = map.<span class=\"hljs-title function_\">values</span>()        <span class=\"hljs-comment\">// [&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2]</span><br><span class=\"hljs-comment\">// Map转Set</span><br><span class=\"hljs-keyword\">const</span> map2Set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>(map.<span class=\"hljs-title function_\">values</span>()) <span class=\"hljs-comment\">// [1, 2]</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2></br>\n最常见的一种场景莫过于使用数组与Set之间格式变化进行数据去重\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">dedup</span> = (<span class=\"hljs-params\">arr</span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">return</span> [...<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>(arr)]<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>上述方法和之前includes方法也是一样存在无法处理复杂数据类型，对于复杂对象数据，需要根据各自业务场景对重复的数据进行去重策略选择，即在一堆的重复对象中（以id重复为例）保留业务需要的唯一一个数据。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>三种数据结构有着各自不同的特性。数组是一个天然的栈，也是一个天然的队列，在三种数据结构中，其实例方法也应用也是最多的，是线性存储中话事人般的存在，也是我们在普通业务场景下的首选。Set数据的唯一性，可以帮助我们在业务场景中快速的进行去重。Map键值对结构的特殊性，以及对键的包容性，能够通过键快速获取到值，也是复杂业务冲常常用的。<br></br></p>\n<p>【资料参考】</p>\n<ol>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map</a></li>\n</ol>\n"},{"title":"Vue依赖收集和触发，看这些关键源码","date":"2025-05-23T04:40:00.000Z","_content":"\n从Vue开始较大范围在前端应用开始，关于Vue一些基础知识的讨论和面试问题就在开发圈子里基本上就跟前几年的股票和基金一样，楼下摆摊卖酱香饼的阿姨都能说上几句那种。找过前端开发工作或者正在找开发工作的前端都知道，面试官基本上都有那么几个常问的问题，而网上呢也有那么一套可以用来背诵的“八股文”，自己懂多少没有关系，应付面试官还是够的，可以算是屡试不爽吧。\n\n背诵面试八股文无可厚非的，可以说是每一个找工作的人都干过和必须干的事情，因为我们都要工作，都要恰饭。只有恰上饭，才能去谈些伟大的理想。背“八股文”本是一种捷径，尤其是本身对一门技术不是特别了解的开发者，就是那种刚刚能使用它那种。\n\n在众多关于Vue的面试“八股文”中，今天讲的是其中最常问的一个--Vue中的依赖收集。本文也将从代码层面，讲清楚关于依赖收集的几个问题。\n-  收集的依赖是什么？（what）\n-  怎么收集的依赖？  （how）\n-  什么时候收集？     (when)\n\n至于为什么要收集依赖(why)，现在就可以先告诉答案。**收集依赖，其核心作用是在数据发生变化的时候可以做出相应的动作，比如刷新视图**，为了执行这一动作，我们就得知道是谁在什么时候发生了变化，所以我们要收集依赖。\n\n\n下面我们结合代码，尽可能通俗的讲解关于上述的三个问题：\n\n\n\n在搞清楚依赖收集之前，先把源码中几个概念性的东西说明一下，建议下载[Vue3源码](https://github.com/vuejs/core)进行对照着看：\n-  **Dep**: 本质上是一个Map实例，同时在map实例上绑定一个celanup函数和一个computed属性。\n- **ReactiveEffect**: 相当于2.x版本中的Watcher类, 里头有一个deps数组，用来存dep, 每个实例里面都有一个track_id用来标识唯一性。\n\n- **effect函数**： 里头实例化一个ReactiveEffect对象，同时绑定一些options, 返回值是一个runner,实际上是对ReactiveEffect对象行为的一种业务封装。\n\n下面以一行简单的代码开始关于依赖收集的探索。\n```Javascript\nconst num = ref(1);\n```\n```Javascript\n// packages/reactivity/src/ref.ts\nexport function ref<T>(value: T): Ref<UnwrapRef<T>>\nexport function ref<T = any>(): Ref<T | undefined>\nexport function ref(value?: unknown) {\n  return createRef(value, false)\n}\n```\nref函数主要是对createRef做了一个函数包装，主要内容看到createRef函数。\n\n```Javascript\n// packages/reactivity/src/ref.ts\nfunction createRef(rawValue: unknown, shallow: boolean) {\n  if (isRef(rawValue)) {\n    return rawValue\n  }\n  return new RefImpl(rawValue, shallow)\n}\n```\ncreateRef函数在这里对原始数据rawValue做了一个判断，如果数据本身就是响应式数据了，就直接返回它本身，如果不是，就返回一个实例化的RefImpl对象。\n\n\n```Javascript\n// packages/reactivity/src/ref.ts\nclass RefImpl<T> {\n  private _value: T\n  private _rawValue: T\n\n  public dep?: Dep = undefined\n  public readonly __v_isRef = true\n\n  constructor(\n    value: T,\n    public readonly __v_isShallow: boolean,\n  ) {\n    this._rawValue = __v_isShallow ? value : toRaw(value)\n    this._value = __v_isShallow ? value : toReactive(value)\n  }\n\n  get value() {\n    trackRefValue(this)\n    return this._value\n  }\n\n  set value(newVal) {\n    const useDirectValue =\n      this.__v_isShallow || isShallow(newVal) || isReadonly(newVal)\n    newVal = useDirectValue ? newVal : toRaw(newVal)\n    if (hasChanged(newVal, this._rawValue)) {\n      this._rawValue = newVal\n      this._value = useDirectValue ? newVal : toReactive(newVal)\n      triggerRefValue(this, DirtyLevels.Dirty, newVal)\n    }\n  }\n}\n```\n重点来了，RefImple类里头，才是真正包含了从原始数据变成响应式数据，以及收集依赖的逻辑。在一个refImpl实例中，里面有一个dep对象，初始值是undefined， 这个dep会这trackRefValue函数执行的过程中被赋值。\n\n下面代码从17-21(get value())行，就是依赖收集的过程：当一个ref型响应式数据通过.value访问时，会触发RefImpl实例中的getter。它会首先执行一个trackValue函数，然后再返回_value值，所以接下来重点看关注trackValue函数，所以**依赖是在数据被访问的时候触发的**。\n\n```Javascript\n// packages/reactivity/src/ref.ts\nexport function trackRefValue(ref: RefBase<any>) {\n  if (shouldTrack && activeEffect) {\n    ref = toRaw(ref)\n    trackEffect(\n      activeEffect,\n      (ref.dep ??= createDep(\n        () => (ref.dep = undefined),\n        ref instanceof ComputedRefImpl ? ref : undefined,\n      )),\n      __DEV__\n        ? {\n            target: ref,\n            type: TrackOpTypes.GET,\n            key: 'value',\n          }\n        : void 0,\n    )\n  }\n}u\n```\n\ntrackRefValue函数中有两个变量，shouldTrack和activeEffect，暂时我们不去理会它们，只要知道shouldTrack是一个布尔值，activeEffect是一个RectiveEffect实例。\n\n在shouldTrack值为true且activeEffect有值的情况下，首先会将ref转成原始值，然后再执行trackEffect函数。\n\n在执行trackEffect函数的中，第一个是activeEffect, 在任意时刻它在全局是具有唯一性的；第二个是ref.dep, 其中给ref.dep的赋值函数createDep返回一个Dep实例，前面说过的，本质是个map; 第三个函数是个对象，是关于开发环境下debug的一些配置。\n\n在这里，我们可以看到，之前说个的ref实例中原来是undefined的ref.dep赋值，就在此处。\n\n```Javascript\n// packages/reactivity/src/effect.ts\nexport function trackEffect(\n  effect: ReactiveEffect,\n  dep: Dep,\n  debuggerEventExtraInfo?: DebuggerEventExtraInfo,\n) {\n  if (dep.get(effect) !== effect._trackId) {\n    dep.set(effect, effect._trackId)\n    const oldDep = effect.deps[effect._depsLength]\n    if (oldDep !== dep) {\n      if (oldDep) {\n        cleanupDepEffect(oldDep, effect)\n      }\n      effect.deps[effect._depsLength++] = dep\n    } else {\n      effect._depsLength++\n    }\n    if (__DEV__) {\n      effect.onTrack?.(extend({ effect }, debuggerEventExtraInfo!))\n    }\n  }\n}\n```\ntrackEffect函数绝对是依赖收集重头戏中的重头戏。\n\n首先上来就是一个判断，dep, 也就是ref中的dep，本质是个map，判断里面是否存在对应的effect, 如果没有，就执行接下来的操作。\n\ndep将effect也就是activeEffect作为键，其_trackId作为值添加到dep，**所以我们说的收集的依赖指的就是effect对象**。同时我们得到了一个关于**dep和effect之间的第一关系，即一个dep可以对应多个effect**。\n\n接着，将effects实例中deps数组中最后一个值取出来与当前的dep值进行比对，看是否是同一个值如果不是同一个值，而且oldDep是有值的，那么就执行cleanupDepEffect操作。如果oldDep为空值，就跳过这一步，直接往effect.deps中添加dep。因此，我们在这里得到了关于dep和effect第二个结论，**一个effect可以对应多个dep**。\n\n代码还有一部分，接着往下看，在oldDep不等于当前dep的时候，直接对effec_depsLength进行加操作，也就是说，effect.deps值没有变，但是_depsLength值却超出了deps数组边界的情况，这也就是为什么上面要判断oldDep是否存在的原因。\n\n\n由上面上面两个结论我们可以得出，一个dep中可以对应多个effect, 一个effect也可以对应多个dep, 因此dep和effect的关系是多对多的关系。\n\n### 总结\n\n-  收集的依赖是什么？（what）\n  > 我们常说的收集的依赖是effect对象\n\n-  怎么收集的依赖？  （how）\n > 判断当前数据dep中有没有activeEffct, 没有就加进去。把大象关进冰箱里要几步！！！\n-  什么时候收集？     (when)\n> 在数据被访问时，触发getter，进行依赖收集\n","source":"_posts/Dependencies-collecting-of-vue3.md","raw":"---\ntitle: Vue依赖收集和触发，看这些关键源码\ndate: 2025-05-23 12:40:00\ncategory: Vue源码阅读\ntags:\n  - Vue\n  - 源码阅读\n  - 依赖收集\n---\n\n从Vue开始较大范围在前端应用开始，关于Vue一些基础知识的讨论和面试问题就在开发圈子里基本上就跟前几年的股票和基金一样，楼下摆摊卖酱香饼的阿姨都能说上几句那种。找过前端开发工作或者正在找开发工作的前端都知道，面试官基本上都有那么几个常问的问题，而网上呢也有那么一套可以用来背诵的“八股文”，自己懂多少没有关系，应付面试官还是够的，可以算是屡试不爽吧。\n\n背诵面试八股文无可厚非的，可以说是每一个找工作的人都干过和必须干的事情，因为我们都要工作，都要恰饭。只有恰上饭，才能去谈些伟大的理想。背“八股文”本是一种捷径，尤其是本身对一门技术不是特别了解的开发者，就是那种刚刚能使用它那种。\n\n在众多关于Vue的面试“八股文”中，今天讲的是其中最常问的一个--Vue中的依赖收集。本文也将从代码层面，讲清楚关于依赖收集的几个问题。\n-  收集的依赖是什么？（what）\n-  怎么收集的依赖？  （how）\n-  什么时候收集？     (when)\n\n至于为什么要收集依赖(why)，现在就可以先告诉答案。**收集依赖，其核心作用是在数据发生变化的时候可以做出相应的动作，比如刷新视图**，为了执行这一动作，我们就得知道是谁在什么时候发生了变化，所以我们要收集依赖。\n\n\n下面我们结合代码，尽可能通俗的讲解关于上述的三个问题：\n\n\n\n在搞清楚依赖收集之前，先把源码中几个概念性的东西说明一下，建议下载[Vue3源码](https://github.com/vuejs/core)进行对照着看：\n-  **Dep**: 本质上是一个Map实例，同时在map实例上绑定一个celanup函数和一个computed属性。\n- **ReactiveEffect**: 相当于2.x版本中的Watcher类, 里头有一个deps数组，用来存dep, 每个实例里面都有一个track_id用来标识唯一性。\n\n- **effect函数**： 里头实例化一个ReactiveEffect对象，同时绑定一些options, 返回值是一个runner,实际上是对ReactiveEffect对象行为的一种业务封装。\n\n下面以一行简单的代码开始关于依赖收集的探索。\n```Javascript\nconst num = ref(1);\n```\n```Javascript\n// packages/reactivity/src/ref.ts\nexport function ref<T>(value: T): Ref<UnwrapRef<T>>\nexport function ref<T = any>(): Ref<T | undefined>\nexport function ref(value?: unknown) {\n  return createRef(value, false)\n}\n```\nref函数主要是对createRef做了一个函数包装，主要内容看到createRef函数。\n\n```Javascript\n// packages/reactivity/src/ref.ts\nfunction createRef(rawValue: unknown, shallow: boolean) {\n  if (isRef(rawValue)) {\n    return rawValue\n  }\n  return new RefImpl(rawValue, shallow)\n}\n```\ncreateRef函数在这里对原始数据rawValue做了一个判断，如果数据本身就是响应式数据了，就直接返回它本身，如果不是，就返回一个实例化的RefImpl对象。\n\n\n```Javascript\n// packages/reactivity/src/ref.ts\nclass RefImpl<T> {\n  private _value: T\n  private _rawValue: T\n\n  public dep?: Dep = undefined\n  public readonly __v_isRef = true\n\n  constructor(\n    value: T,\n    public readonly __v_isShallow: boolean,\n  ) {\n    this._rawValue = __v_isShallow ? value : toRaw(value)\n    this._value = __v_isShallow ? value : toReactive(value)\n  }\n\n  get value() {\n    trackRefValue(this)\n    return this._value\n  }\n\n  set value(newVal) {\n    const useDirectValue =\n      this.__v_isShallow || isShallow(newVal) || isReadonly(newVal)\n    newVal = useDirectValue ? newVal : toRaw(newVal)\n    if (hasChanged(newVal, this._rawValue)) {\n      this._rawValue = newVal\n      this._value = useDirectValue ? newVal : toReactive(newVal)\n      triggerRefValue(this, DirtyLevels.Dirty, newVal)\n    }\n  }\n}\n```\n重点来了，RefImple类里头，才是真正包含了从原始数据变成响应式数据，以及收集依赖的逻辑。在一个refImpl实例中，里面有一个dep对象，初始值是undefined， 这个dep会这trackRefValue函数执行的过程中被赋值。\n\n下面代码从17-21(get value())行，就是依赖收集的过程：当一个ref型响应式数据通过.value访问时，会触发RefImpl实例中的getter。它会首先执行一个trackValue函数，然后再返回_value值，所以接下来重点看关注trackValue函数，所以**依赖是在数据被访问的时候触发的**。\n\n```Javascript\n// packages/reactivity/src/ref.ts\nexport function trackRefValue(ref: RefBase<any>) {\n  if (shouldTrack && activeEffect) {\n    ref = toRaw(ref)\n    trackEffect(\n      activeEffect,\n      (ref.dep ??= createDep(\n        () => (ref.dep = undefined),\n        ref instanceof ComputedRefImpl ? ref : undefined,\n      )),\n      __DEV__\n        ? {\n            target: ref,\n            type: TrackOpTypes.GET,\n            key: 'value',\n          }\n        : void 0,\n    )\n  }\n}u\n```\n\ntrackRefValue函数中有两个变量，shouldTrack和activeEffect，暂时我们不去理会它们，只要知道shouldTrack是一个布尔值，activeEffect是一个RectiveEffect实例。\n\n在shouldTrack值为true且activeEffect有值的情况下，首先会将ref转成原始值，然后再执行trackEffect函数。\n\n在执行trackEffect函数的中，第一个是activeEffect, 在任意时刻它在全局是具有唯一性的；第二个是ref.dep, 其中给ref.dep的赋值函数createDep返回一个Dep实例，前面说过的，本质是个map; 第三个函数是个对象，是关于开发环境下debug的一些配置。\n\n在这里，我们可以看到，之前说个的ref实例中原来是undefined的ref.dep赋值，就在此处。\n\n```Javascript\n// packages/reactivity/src/effect.ts\nexport function trackEffect(\n  effect: ReactiveEffect,\n  dep: Dep,\n  debuggerEventExtraInfo?: DebuggerEventExtraInfo,\n) {\n  if (dep.get(effect) !== effect._trackId) {\n    dep.set(effect, effect._trackId)\n    const oldDep = effect.deps[effect._depsLength]\n    if (oldDep !== dep) {\n      if (oldDep) {\n        cleanupDepEffect(oldDep, effect)\n      }\n      effect.deps[effect._depsLength++] = dep\n    } else {\n      effect._depsLength++\n    }\n    if (__DEV__) {\n      effect.onTrack?.(extend({ effect }, debuggerEventExtraInfo!))\n    }\n  }\n}\n```\ntrackEffect函数绝对是依赖收集重头戏中的重头戏。\n\n首先上来就是一个判断，dep, 也就是ref中的dep，本质是个map，判断里面是否存在对应的effect, 如果没有，就执行接下来的操作。\n\ndep将effect也就是activeEffect作为键，其_trackId作为值添加到dep，**所以我们说的收集的依赖指的就是effect对象**。同时我们得到了一个关于**dep和effect之间的第一关系，即一个dep可以对应多个effect**。\n\n接着，将effects实例中deps数组中最后一个值取出来与当前的dep值进行比对，看是否是同一个值如果不是同一个值，而且oldDep是有值的，那么就执行cleanupDepEffect操作。如果oldDep为空值，就跳过这一步，直接往effect.deps中添加dep。因此，我们在这里得到了关于dep和effect第二个结论，**一个effect可以对应多个dep**。\n\n代码还有一部分，接着往下看，在oldDep不等于当前dep的时候，直接对effec_depsLength进行加操作，也就是说，effect.deps值没有变，但是_depsLength值却超出了deps数组边界的情况，这也就是为什么上面要判断oldDep是否存在的原因。\n\n\n由上面上面两个结论我们可以得出，一个dep中可以对应多个effect, 一个effect也可以对应多个dep, 因此dep和effect的关系是多对多的关系。\n\n### 总结\n\n-  收集的依赖是什么？（what）\n  > 我们常说的收集的依赖是effect对象\n\n-  怎么收集的依赖？  （how）\n > 判断当前数据dep中有没有activeEffct, 没有就加进去。把大象关进冰箱里要几步！！！\n-  什么时候收集？     (when)\n> 在数据被访问时，触发getter，进行依赖收集\n","slug":"Dependencies-collecting-of-vue3","published":1,"updated":"2025-06-21T14:15:44.943Z","_id":"cmbkxc9p00001koupe3jv27tn","comments":1,"layout":"post","photos":[],"content":"<p>从Vue开始较大范围在前端应用开始，关于Vue一些基础知识的讨论和面试问题就在开发圈子里基本上就跟前几年的股票和基金一样，楼下摆摊卖酱香饼的阿姨都能说上几句那种。找过前端开发工作或者正在找开发工作的前端都知道，面试官基本上都有那么几个常问的问题，而网上呢也有那么一套可以用来背诵的“八股文”，自己懂多少没有关系，应付面试官还是够的，可以算是屡试不爽吧。</p>\n<p>背诵面试八股文无可厚非的，可以说是每一个找工作的人都干过和必须干的事情，因为我们都要工作，都要恰饭。只有恰上饭，才能去谈些伟大的理想。背“八股文”本是一种捷径，尤其是本身对一门技术不是特别了解的开发者，就是那种刚刚能使用它那种。</p>\n<p>在众多关于Vue的面试“八股文”中，今天讲的是其中最常问的一个–Vue中的依赖收集。本文也将从代码层面，讲清楚关于依赖收集的几个问题。</p>\n<ul>\n<li>收集的依赖是什么？（what）</li>\n<li>怎么收集的依赖？  （how）</li>\n<li>什么时候收集？     (when)</li>\n</ul>\n<p>至于为什么要收集依赖(why)，现在就可以先告诉答案。<strong>收集依赖，其核心作用是在数据发生变化的时候可以做出相应的动作，比如刷新视图</strong>，为了执行这一动作，我们就得知道是谁在什么时候发生了变化，所以我们要收集依赖。</p>\n<p>下面我们结合代码，尽可能通俗的讲解关于上述的三个问题：</p>\n<p>在搞清楚依赖收集之前，先把源码中几个概念性的东西说明一下，建议下载<a href=\"https://github.com/vuejs/core\">Vue3源码</a>进行对照着看：</p>\n<ul>\n<li><p><strong>Dep</strong>: 本质上是一个Map实例，同时在map实例上绑定一个celanup函数和一个computed属性。</p>\n</li>\n<li><p><strong>ReactiveEffect</strong>: 相当于2.x版本中的Watcher类, 里头有一个deps数组，用来存dep, 每个实例里面都有一个track_id用来标识唯一性。</p>\n</li>\n<li><p><strong>effect函数</strong>： 里头实例化一个ReactiveEffect对象，同时绑定一些options, 返回值是一个runner,实际上是对ReactiveEffect对象行为的一种业务封装。</p>\n</li>\n</ul>\n<p>下面以一行简单的代码开始关于依赖收集的探索。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">const</span> num = <span class=\"hljs-title function_\">ref</span>(<span class=\"hljs-number\">1</span>);<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">// packages/reactivity/src/ref.ts</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> ref&lt;T&gt;(<span class=\"hljs-attr\">value</span>: T): <span class=\"hljs-title class_\">Ref</span>&lt;<span class=\"hljs-title class_\">UnwrapRef</span>&lt;T&gt;&gt;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> ref&lt;T = any&gt;(): <span class=\"hljs-title class_\">Ref</span>&lt;T | <span class=\"hljs-literal\">undefined</span>&gt;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">ref</span>(<span class=\"hljs-params\">value?: unknown</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">createRef</span>(value, <span class=\"hljs-literal\">false</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>ref函数主要是对createRef做了一个函数包装，主要内容看到createRef函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">// packages/reactivity/src/ref.ts</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createRef</span>(<span class=\"hljs-params\">rawValue: unknown, shallow: boolean</span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_\">isRef</span>(rawValue)) &#123;<br>    <span class=\"hljs-keyword\">return</span> rawValue<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RefImpl</span>(rawValue, shallow)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>createRef函数在这里对原始数据rawValue做了一个判断，如果数据本身就是响应式数据了，就直接返回它本身，如果不是，就返回一个实例化的RefImpl对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">// packages/reactivity/src/ref.ts</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RefImpl</span>&lt;T&gt; &#123;<br>  private <span class=\"hljs-attr\">_value</span>: T<br>  private <span class=\"hljs-attr\">_rawValue</span>: T<br><br>  public dep?: <span class=\"hljs-title class_\">Dep</span> = <span class=\"hljs-literal\">undefined</span><br>  public readonly __v_isRef = <span class=\"hljs-literal\">true</span><br><br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span><br><span class=\"hljs-params\">    value: T,</span><br><span class=\"hljs-params\">    public readonly __v_isShallow: boolean,</span><br><span class=\"hljs-params\">  </span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_rawValue</span> = __v_isShallow ? value : <span class=\"hljs-title function_\">toRaw</span>(value)<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_value</span> = __v_isShallow ? value : <span class=\"hljs-title function_\">toReactive</span>(value)<br>  &#125;<br><br>  <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title function_\">value</span>() &#123;<br>    <span class=\"hljs-title function_\">trackRefValue</span>(<span class=\"hljs-variable language_\">this</span>)<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_value</span><br>  &#125;<br><br>  <span class=\"hljs-keyword\">set</span> <span class=\"hljs-title function_\">value</span>(<span class=\"hljs-params\">newVal</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> useDirectValue =<br>      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">__v_isShallow</span> || <span class=\"hljs-title function_\">isShallow</span>(newVal) || <span class=\"hljs-title function_\">isReadonly</span>(newVal)<br>    newVal = useDirectValue ? newVal : <span class=\"hljs-title function_\">toRaw</span>(newVal)<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_\">hasChanged</span>(newVal, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_rawValue</span>)) &#123;<br>      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_rawValue</span> = newVal<br>      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_value</span> = useDirectValue ? newVal : <span class=\"hljs-title function_\">toReactive</span>(newVal)<br>      <span class=\"hljs-title function_\">triggerRefValue</span>(<span class=\"hljs-variable language_\">this</span>, <span class=\"hljs-title class_\">DirtyLevels</span>.<span class=\"hljs-property\">Dirty</span>, newVal)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>重点来了，RefImple类里头，才是真正包含了从原始数据变成响应式数据，以及收集依赖的逻辑。在一个refImpl实例中，里面有一个dep对象，初始值是undefined， 这个dep会这trackRefValue函数执行的过程中被赋值。</p>\n<p>下面代码从17-21(get value())行，就是依赖收集的过程：当一个ref型响应式数据通过.value访问时，会触发RefImpl实例中的getter。它会首先执行一个trackValue函数，然后再返回_value值，所以接下来重点看关注trackValue函数，所以<strong>依赖是在数据被访问的时候触发的</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">// packages/reactivity/src/ref.ts</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">trackRefValue</span>(<span class=\"hljs-params\">ref: RefBase&lt;any&gt;</span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (shouldTrack &amp;&amp; activeEffect) &#123;<br>    ref = <span class=\"hljs-title function_\">toRaw</span>(ref)<br>    <span class=\"hljs-title function_\">trackEffect</span>(<br>      activeEffect,<br>      (ref.<span class=\"hljs-property\">dep</span> ??= <span class=\"hljs-title function_\">createDep</span>(<br>        <span class=\"hljs-function\">() =&gt;</span> (ref.<span class=\"hljs-property\">dep</span> = <span class=\"hljs-literal\">undefined</span>),<br>        ref <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">ComputedRefImpl</span> ? ref : <span class=\"hljs-literal\">undefined</span>,<br>      )),<br>      __DEV__<br>        ? &#123;<br>            <span class=\"hljs-attr\">target</span>: ref,<br>            <span class=\"hljs-attr\">type</span>: <span class=\"hljs-title class_\">TrackOpTypes</span>.<span class=\"hljs-property\">GET</span>,<br>            <span class=\"hljs-attr\">key</span>: <span class=\"hljs-string\">&#x27;value&#x27;</span>,<br>          &#125;<br>        : <span class=\"hljs-keyword\">void</span> <span class=\"hljs-number\">0</span>,<br>    )<br>  &#125;<br>&#125;u<br></code></pre></td></tr></table></figure>\n\n<p>trackRefValue函数中有两个变量，shouldTrack和activeEffect，暂时我们不去理会它们，只要知道shouldTrack是一个布尔值，activeEffect是一个RectiveEffect实例。</p>\n<p>在shouldTrack值为true且activeEffect有值的情况下，首先会将ref转成原始值，然后再执行trackEffect函数。</p>\n<p>在执行trackEffect函数的中，第一个是activeEffect, 在任意时刻它在全局是具有唯一性的；第二个是ref.dep, 其中给ref.dep的赋值函数createDep返回一个Dep实例，前面说过的，本质是个map; 第三个函数是个对象，是关于开发环境下debug的一些配置。</p>\n<p>在这里，我们可以看到，之前说个的ref实例中原来是undefined的ref.dep赋值，就在此处。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">// packages/reactivity/src/effect.ts</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">trackEffect</span>(<span class=\"hljs-params\"></span><br><span class=\"hljs-params\">  effect: ReactiveEffect,</span><br><span class=\"hljs-params\">  dep: Dep,</span><br><span class=\"hljs-params\">  debuggerEventExtraInfo?: DebuggerEventExtraInfo,</span><br><span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (dep.<span class=\"hljs-title function_\">get</span>(effect) !== effect.<span class=\"hljs-property\">_trackId</span>) &#123;<br>    dep.<span class=\"hljs-title function_\">set</span>(effect, effect.<span class=\"hljs-property\">_trackId</span>)<br>    <span class=\"hljs-keyword\">const</span> oldDep = effect.<span class=\"hljs-property\">deps</span>[effect.<span class=\"hljs-property\">_depsLength</span>]<br>    <span class=\"hljs-keyword\">if</span> (oldDep !== dep) &#123;<br>      <span class=\"hljs-keyword\">if</span> (oldDep) &#123;<br>        <span class=\"hljs-title function_\">cleanupDepEffect</span>(oldDep, effect)<br>      &#125;<br>      effect.<span class=\"hljs-property\">deps</span>[effect.<span class=\"hljs-property\">_depsLength</span>++] = dep<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      effect.<span class=\"hljs-property\">_depsLength</span>++<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (__DEV__) &#123;<br>      effect.<span class=\"hljs-property\">onTrack</span>?.(<span class=\"hljs-title function_\">extend</span>(&#123; effect &#125;, debuggerEventExtraInfo!))<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>trackEffect函数绝对是依赖收集重头戏中的重头戏。</p>\n<p>首先上来就是一个判断，dep, 也就是ref中的dep，本质是个map，判断里面是否存在对应的effect, 如果没有，就执行接下来的操作。</p>\n<p>dep将effect也就是activeEffect作为键，其_trackId作为值添加到dep，<strong>所以我们说的收集的依赖指的就是effect对象</strong>。同时我们得到了一个关于<strong>dep和effect之间的第一关系，即一个dep可以对应多个effect</strong>。</p>\n<p>接着，将effects实例中deps数组中最后一个值取出来与当前的dep值进行比对，看是否是同一个值如果不是同一个值，而且oldDep是有值的，那么就执行cleanupDepEffect操作。如果oldDep为空值，就跳过这一步，直接往effect.deps中添加dep。因此，我们在这里得到了关于dep和effect第二个结论，<strong>一个effect可以对应多个dep</strong>。</p>\n<p>代码还有一部分，接着往下看，在oldDep不等于当前dep的时候，直接对effec_depsLength进行加操作，也就是说，effect.deps值没有变，但是_depsLength值却超出了deps数组边界的情况，这也就是为什么上面要判断oldDep是否存在的原因。</p>\n<p>由上面上面两个结论我们可以得出，一个dep中可以对应多个effect, 一个effect也可以对应多个dep, 因此dep和effect的关系是多对多的关系。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><p>收集的依赖是什么？（what）</p>\n<blockquote>\n<p>我们常说的收集的依赖是effect对象</p>\n</blockquote>\n</li>\n<li><p>怎么收集的依赖？  （how）</p>\n<blockquote>\n<p>判断当前数据dep中有没有activeEffct, 没有就加进去。把大象关进冰箱里要几步！！！</p>\n</blockquote>\n</li>\n<li><p>什么时候收集？     (when)</p>\n<blockquote>\n<p>在数据被访问时，触发getter，进行依赖收集</p>\n</blockquote>\n</li>\n</ul>\n","excerpt":"","more":"<p>从Vue开始较大范围在前端应用开始，关于Vue一些基础知识的讨论和面试问题就在开发圈子里基本上就跟前几年的股票和基金一样，楼下摆摊卖酱香饼的阿姨都能说上几句那种。找过前端开发工作或者正在找开发工作的前端都知道，面试官基本上都有那么几个常问的问题，而网上呢也有那么一套可以用来背诵的“八股文”，自己懂多少没有关系，应付面试官还是够的，可以算是屡试不爽吧。</p>\n<p>背诵面试八股文无可厚非的，可以说是每一个找工作的人都干过和必须干的事情，因为我们都要工作，都要恰饭。只有恰上饭，才能去谈些伟大的理想。背“八股文”本是一种捷径，尤其是本身对一门技术不是特别了解的开发者，就是那种刚刚能使用它那种。</p>\n<p>在众多关于Vue的面试“八股文”中，今天讲的是其中最常问的一个–Vue中的依赖收集。本文也将从代码层面，讲清楚关于依赖收集的几个问题。</p>\n<ul>\n<li>收集的依赖是什么？（what）</li>\n<li>怎么收集的依赖？  （how）</li>\n<li>什么时候收集？     (when)</li>\n</ul>\n<p>至于为什么要收集依赖(why)，现在就可以先告诉答案。<strong>收集依赖，其核心作用是在数据发生变化的时候可以做出相应的动作，比如刷新视图</strong>，为了执行这一动作，我们就得知道是谁在什么时候发生了变化，所以我们要收集依赖。</p>\n<p>下面我们结合代码，尽可能通俗的讲解关于上述的三个问题：</p>\n<p>在搞清楚依赖收集之前，先把源码中几个概念性的东西说明一下，建议下载<a href=\"https://github.com/vuejs/core\">Vue3源码</a>进行对照着看：</p>\n<ul>\n<li><p><strong>Dep</strong>: 本质上是一个Map实例，同时在map实例上绑定一个celanup函数和一个computed属性。</p>\n</li>\n<li><p><strong>ReactiveEffect</strong>: 相当于2.x版本中的Watcher类, 里头有一个deps数组，用来存dep, 每个实例里面都有一个track_id用来标识唯一性。</p>\n</li>\n<li><p><strong>effect函数</strong>： 里头实例化一个ReactiveEffect对象，同时绑定一些options, 返回值是一个runner,实际上是对ReactiveEffect对象行为的一种业务封装。</p>\n</li>\n</ul>\n<p>下面以一行简单的代码开始关于依赖收集的探索。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">const</span> num = <span class=\"hljs-title function_\">ref</span>(<span class=\"hljs-number\">1</span>);<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">// packages/reactivity/src/ref.ts</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> ref&lt;T&gt;(<span class=\"hljs-attr\">value</span>: T): <span class=\"hljs-title class_\">Ref</span>&lt;<span class=\"hljs-title class_\">UnwrapRef</span>&lt;T&gt;&gt;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> ref&lt;T = any&gt;(): <span class=\"hljs-title class_\">Ref</span>&lt;T | <span class=\"hljs-literal\">undefined</span>&gt;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">ref</span>(<span class=\"hljs-params\">value?: unknown</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">createRef</span>(value, <span class=\"hljs-literal\">false</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>ref函数主要是对createRef做了一个函数包装，主要内容看到createRef函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">// packages/reactivity/src/ref.ts</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createRef</span>(<span class=\"hljs-params\">rawValue: unknown, shallow: boolean</span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_\">isRef</span>(rawValue)) &#123;<br>    <span class=\"hljs-keyword\">return</span> rawValue<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RefImpl</span>(rawValue, shallow)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>createRef函数在这里对原始数据rawValue做了一个判断，如果数据本身就是响应式数据了，就直接返回它本身，如果不是，就返回一个实例化的RefImpl对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">// packages/reactivity/src/ref.ts</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RefImpl</span>&lt;T&gt; &#123;<br>  private <span class=\"hljs-attr\">_value</span>: T<br>  private <span class=\"hljs-attr\">_rawValue</span>: T<br><br>  public dep?: <span class=\"hljs-title class_\">Dep</span> = <span class=\"hljs-literal\">undefined</span><br>  public readonly __v_isRef = <span class=\"hljs-literal\">true</span><br><br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span><br><span class=\"hljs-params\">    value: T,</span><br><span class=\"hljs-params\">    public readonly __v_isShallow: boolean,</span><br><span class=\"hljs-params\">  </span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_rawValue</span> = __v_isShallow ? value : <span class=\"hljs-title function_\">toRaw</span>(value)<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_value</span> = __v_isShallow ? value : <span class=\"hljs-title function_\">toReactive</span>(value)<br>  &#125;<br><br>  <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title function_\">value</span>() &#123;<br>    <span class=\"hljs-title function_\">trackRefValue</span>(<span class=\"hljs-variable language_\">this</span>)<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_value</span><br>  &#125;<br><br>  <span class=\"hljs-keyword\">set</span> <span class=\"hljs-title function_\">value</span>(<span class=\"hljs-params\">newVal</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> useDirectValue =<br>      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">__v_isShallow</span> || <span class=\"hljs-title function_\">isShallow</span>(newVal) || <span class=\"hljs-title function_\">isReadonly</span>(newVal)<br>    newVal = useDirectValue ? newVal : <span class=\"hljs-title function_\">toRaw</span>(newVal)<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_\">hasChanged</span>(newVal, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_rawValue</span>)) &#123;<br>      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_rawValue</span> = newVal<br>      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_value</span> = useDirectValue ? newVal : <span class=\"hljs-title function_\">toReactive</span>(newVal)<br>      <span class=\"hljs-title function_\">triggerRefValue</span>(<span class=\"hljs-variable language_\">this</span>, <span class=\"hljs-title class_\">DirtyLevels</span>.<span class=\"hljs-property\">Dirty</span>, newVal)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>重点来了，RefImple类里头，才是真正包含了从原始数据变成响应式数据，以及收集依赖的逻辑。在一个refImpl实例中，里面有一个dep对象，初始值是undefined， 这个dep会这trackRefValue函数执行的过程中被赋值。</p>\n<p>下面代码从17-21(get value())行，就是依赖收集的过程：当一个ref型响应式数据通过.value访问时，会触发RefImpl实例中的getter。它会首先执行一个trackValue函数，然后再返回_value值，所以接下来重点看关注trackValue函数，所以<strong>依赖是在数据被访问的时候触发的</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">// packages/reactivity/src/ref.ts</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">trackRefValue</span>(<span class=\"hljs-params\">ref: RefBase&lt;any&gt;</span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (shouldTrack &amp;&amp; activeEffect) &#123;<br>    ref = <span class=\"hljs-title function_\">toRaw</span>(ref)<br>    <span class=\"hljs-title function_\">trackEffect</span>(<br>      activeEffect,<br>      (ref.<span class=\"hljs-property\">dep</span> ??= <span class=\"hljs-title function_\">createDep</span>(<br>        <span class=\"hljs-function\">() =&gt;</span> (ref.<span class=\"hljs-property\">dep</span> = <span class=\"hljs-literal\">undefined</span>),<br>        ref <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">ComputedRefImpl</span> ? ref : <span class=\"hljs-literal\">undefined</span>,<br>      )),<br>      __DEV__<br>        ? &#123;<br>            <span class=\"hljs-attr\">target</span>: ref,<br>            <span class=\"hljs-attr\">type</span>: <span class=\"hljs-title class_\">TrackOpTypes</span>.<span class=\"hljs-property\">GET</span>,<br>            <span class=\"hljs-attr\">key</span>: <span class=\"hljs-string\">&#x27;value&#x27;</span>,<br>          &#125;<br>        : <span class=\"hljs-keyword\">void</span> <span class=\"hljs-number\">0</span>,<br>    )<br>  &#125;<br>&#125;u<br></code></pre></td></tr></table></figure>\n\n<p>trackRefValue函数中有两个变量，shouldTrack和activeEffect，暂时我们不去理会它们，只要知道shouldTrack是一个布尔值，activeEffect是一个RectiveEffect实例。</p>\n<p>在shouldTrack值为true且activeEffect有值的情况下，首先会将ref转成原始值，然后再执行trackEffect函数。</p>\n<p>在执行trackEffect函数的中，第一个是activeEffect, 在任意时刻它在全局是具有唯一性的；第二个是ref.dep, 其中给ref.dep的赋值函数createDep返回一个Dep实例，前面说过的，本质是个map; 第三个函数是个对象，是关于开发环境下debug的一些配置。</p>\n<p>在这里，我们可以看到，之前说个的ref实例中原来是undefined的ref.dep赋值，就在此处。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">// packages/reactivity/src/effect.ts</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">trackEffect</span>(<span class=\"hljs-params\"></span><br><span class=\"hljs-params\">  effect: ReactiveEffect,</span><br><span class=\"hljs-params\">  dep: Dep,</span><br><span class=\"hljs-params\">  debuggerEventExtraInfo?: DebuggerEventExtraInfo,</span><br><span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (dep.<span class=\"hljs-title function_\">get</span>(effect) !== effect.<span class=\"hljs-property\">_trackId</span>) &#123;<br>    dep.<span class=\"hljs-title function_\">set</span>(effect, effect.<span class=\"hljs-property\">_trackId</span>)<br>    <span class=\"hljs-keyword\">const</span> oldDep = effect.<span class=\"hljs-property\">deps</span>[effect.<span class=\"hljs-property\">_depsLength</span>]<br>    <span class=\"hljs-keyword\">if</span> (oldDep !== dep) &#123;<br>      <span class=\"hljs-keyword\">if</span> (oldDep) &#123;<br>        <span class=\"hljs-title function_\">cleanupDepEffect</span>(oldDep, effect)<br>      &#125;<br>      effect.<span class=\"hljs-property\">deps</span>[effect.<span class=\"hljs-property\">_depsLength</span>++] = dep<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      effect.<span class=\"hljs-property\">_depsLength</span>++<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (__DEV__) &#123;<br>      effect.<span class=\"hljs-property\">onTrack</span>?.(<span class=\"hljs-title function_\">extend</span>(&#123; effect &#125;, debuggerEventExtraInfo!))<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>trackEffect函数绝对是依赖收集重头戏中的重头戏。</p>\n<p>首先上来就是一个判断，dep, 也就是ref中的dep，本质是个map，判断里面是否存在对应的effect, 如果没有，就执行接下来的操作。</p>\n<p>dep将effect也就是activeEffect作为键，其_trackId作为值添加到dep，<strong>所以我们说的收集的依赖指的就是effect对象</strong>。同时我们得到了一个关于<strong>dep和effect之间的第一关系，即一个dep可以对应多个effect</strong>。</p>\n<p>接着，将effects实例中deps数组中最后一个值取出来与当前的dep值进行比对，看是否是同一个值如果不是同一个值，而且oldDep是有值的，那么就执行cleanupDepEffect操作。如果oldDep为空值，就跳过这一步，直接往effect.deps中添加dep。因此，我们在这里得到了关于dep和effect第二个结论，<strong>一个effect可以对应多个dep</strong>。</p>\n<p>代码还有一部分，接着往下看，在oldDep不等于当前dep的时候，直接对effec_depsLength进行加操作，也就是说，effect.deps值没有变，但是_depsLength值却超出了deps数组边界的情况，这也就是为什么上面要判断oldDep是否存在的原因。</p>\n<p>由上面上面两个结论我们可以得出，一个dep中可以对应多个effect, 一个effect也可以对应多个dep, 因此dep和effect的关系是多对多的关系。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><p>收集的依赖是什么？（what）</p>\n<blockquote>\n<p>我们常说的收集的依赖是effect对象</p>\n</blockquote>\n</li>\n<li><p>怎么收集的依赖？  （how）</p>\n<blockquote>\n<p>判断当前数据dep中有没有activeEffct, 没有就加进去。把大象关进冰箱里要几步！！！</p>\n</blockquote>\n</li>\n<li><p>什么时候收集？     (when)</p>\n<blockquote>\n<p>在数据被访问时，触发getter，进行依赖收集</p>\n</blockquote>\n</li>\n</ul>\n"},{"title":"搭建个人博客系列--(3) Hexo 静态博客搭建实战","date":"2025-06-07T16:21:58.000Z","keywords":["博客搭建","免费博客平台","托管博客","模板建站"],"_content":"\n通过上一篇文章--[动手搭建自己的第一个博客站点](./build-personal-blog2.md)的介绍，相信你已经成功搭建起了自己的第一个博客网站。如果你的动手能力比较强的话，或许还给博客页面做了页面美工，添加了导航等功能。\n\n如果你的博客还停留在手写html的阶段，也没有关系，通过这篇文章，让你在10分钟内学会如何使用工具生成漂亮好看的博客页面。\n\n\n## 什么是 SSG\n\n人类与其他动物的一个显著区别在于，人类擅长制造并使用工具，撰写博客亦是如此。如今，搭建站点撰写博客早已告别了需要手动逐行编写 HTML 代码的 “刀耕火种” 时代，众多优秀工具可供选择，助力我们快速实现更出色的博客呈现效果。\n\n我们知道，一篇博客内容通常都是以HTML的形式存储的，但对于写博客的人来说，其更想要关注的是其内容本身，而不是各种HTML标签的排列组合和样式调整。\n\n![markdown-to-html](../imgs/build-blog3/md2html.png)\n\n那么是否有一种工具，可以让撰写博客的人从书写HTML和各种样式调整中解脱出来，可以直接将纯文本内容转换成带漂亮样式的HTML文件呢？\n\n有的，那就是静态站点生成器（Static Site Generator)。它是一种自动化工具，它通过模板和数据源（如 Markdown 文件、CMS 内容或 API 数据）生成完整的 HTML、CSS 和 JavaScript 文件。与传统动态网站不同，SSG 生成的页面在构建时就已完全渲染，无需在用户访问时依赖数据库或服务器端处理。\n\n\n## 一些常见的SSG工具\n\n下面是一些常见的SSG工具，其中包含一些大家都比较熟悉的，比如Next, Hugo, Jekyll还有Hexo之类的。\n\n![site-generator](../imgs//build-blog3/site-generator.png)\n![site-generator](../imgs//build-blog3/site-generator2.png)\n\n`Next.js`有完整的React生态支持，内置CSS模块化、图像优化和自动代码风格功能, 适合构建复杂交互应用。\n\n`Hugo` 是一块由Go语言开发的超高速静态站点生成器，最大的特点就是，快！\n\n`Jekyll` 算是一款老牌的静态站点生成器了，Github Pages原生就支持，非常适合搞小型项目展示页和个人博客。\n\n`Hexo` 是一款Node.js生态的轻量博客框架，Markdown只有友好，非常适合中文写作。\n\n工具那么多，我独爱Hexo! \n\n## Why Hexo?\n\n在众多的SSG工具中，为什么为独独选择Hexo呢？ 除了是个人接触比较早之外，还有一些其它的深层次的原因。\n\n![hexo](../imgs/build-blog3/hexo.png)\n\n**极低的入门门槛**，只需安装 Node 环境后，通过几条命令即可初始化站点，无需复杂配置。而且中文教程十分丰富，即使是新手，也能在10分钟之内搭建出一个基础博客。\n\n**中文生态友好**，配置文件、错误提示等均为中文，对国内开发者更友好; 社区活跃，中文主题和插件资源丰富。\n\n**灵活扩展，功能丰富**，插件系统完善，通过 npm 安装插件即可扩展功能；主题基于 EJS/Pug/Markdown 模板，支持自定义布局、样式和脚本。\n\n如果你恰好也是一名前端开发工程师，日常开发中必然常常与Node打交道，那么对于自己写Hexo插件和主题是很有优势的，Hexo对于你来说是个很不错的选择。\n\n## 实战操作\n\n前面就说了，即使是新手，也能够在10分钟之内搭建出一个基础博客。如果你正在尝试着跟着步骤做，不妨计时验证一下。\n\n多的话不说了，撸起袖子，开干！\n\n- ### step1: 准备Node环境\n\n  如果之前接触过Node或者已经安装过Node, 可以直接跳过该步骤，直接进入到step2。如果是Node新手，可以按照下面步骤来安装Node。\n  - **方法1：安装包安装**\n\n    a）前往[Node官网](https://nodejs.org/zh-cn/download)下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node安装包”获取。<br>\n    b) 双击安装包，开始安装, 傻瓜式的点击Next.\n\n\n  - **方法2：可移动二进制文件安装**\n\n      a）前往[Node官网](https://nodejs.org/zh-cn/download)下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node独立文件包”获取。<br>\n      b) 将包解压任意目录, 然后将其中的`bin`目录路径配置到环境变量 `path`中\n\n  如安装过程过程中有疑问，可参考详细教程: [Node安装保姆级教程](./install-node.md)\n\n  安装之后，打开命令行窗口，输入 `node -v` 验证，如果出现对应版本号，则说明安装成功了。\n\n- ### step2: 安装Hexo脚手架\n\n全局安装 **Hexo CLI**, 一行命令行就够了。\n\n```\nnpm install hexo-cli -g \n```\n![step2](../imgs//build-blog3/step2.png)\n\n- ### step3: 搭建博客\n\n使用hexo脚手架，完成博客搭建操作\n```\nhexo init my-blog           # 初始化博客目录\ncd my-blog && npm install   # 安装依赖\nnpm run server              # 启动本地预览（http://localhost:4000）\n```\n执行完上述操作之后，在浏览器中输入地址`http://localhost:4000`, 你将看到整个博客的样子，其中包含一篇默认的 `Hello world`博文。\n\n![landscape](../imgs/build-blog3/landscape.png)\n\n如果你想要添加新的博客，执行 `hexo new post 文章标题`即可在 `source/_post`目录下生成一个新的 `.md`文件。如果不熟悉Markdown语法，可以查阅相关资料学习，上手其实挺快的。\n\n\n### step4: 部署到Github Page\n\n执行命令下方命令\n\n``` bash\nhexo generate\n```\n\nhexo将会把所有相关资源文件进行转换，最后所有的资源都都存放在 `public`目录下。将所有文件上传到上一篇文中提到的个人仓库或者使用git命令提交，等待一两分钟，访问自己的博客站点地址，你将看内容已经更新。\n\n\n## 写在最后\n\nHexo 博客的默认主题是 `landscape`, 你也可以尝试着使用其它博客主题，如 `Next`, `Fluid`等。\n\n如果你想对博客站点做些修改，可以通过编辑其根目录下配置文件 `_config.yml` 来进行调整。如果在主题样式上需要做修改，也可以编辑其对应的配置文件，对应的配置文件在 `/themes/主题名称/`中。\n\n关于Hexo更多的配置可查阅其官方文档，里面都有十分详细的介绍。如果个人动手能力比较强，也可以尝试着写一些主题或者插件，那将是一件让你感到成就感满满的事情。\n\n","source":"_posts/build-personal-blog3.md","raw":"---\ntitle: 搭建个人博客系列--(3) Hexo 静态博客搭建实战\ndate: 2025-06-08 00:21:58\ncategory: 搭建博客\ntags: \n   - 博客搭建\n   - 个人IP\nkeywords: [博客搭建, 免费博客平台, 托管博客, 模板建站]\n---\n\n通过上一篇文章--[动手搭建自己的第一个博客站点](./build-personal-blog2.md)的介绍，相信你已经成功搭建起了自己的第一个博客网站。如果你的动手能力比较强的话，或许还给博客页面做了页面美工，添加了导航等功能。\n\n如果你的博客还停留在手写html的阶段，也没有关系，通过这篇文章，让你在10分钟内学会如何使用工具生成漂亮好看的博客页面。\n\n\n## 什么是 SSG\n\n人类与其他动物的一个显著区别在于，人类擅长制造并使用工具，撰写博客亦是如此。如今，搭建站点撰写博客早已告别了需要手动逐行编写 HTML 代码的 “刀耕火种” 时代，众多优秀工具可供选择，助力我们快速实现更出色的博客呈现效果。\n\n我们知道，一篇博客内容通常都是以HTML的形式存储的，但对于写博客的人来说，其更想要关注的是其内容本身，而不是各种HTML标签的排列组合和样式调整。\n\n![markdown-to-html](../imgs/build-blog3/md2html.png)\n\n那么是否有一种工具，可以让撰写博客的人从书写HTML和各种样式调整中解脱出来，可以直接将纯文本内容转换成带漂亮样式的HTML文件呢？\n\n有的，那就是静态站点生成器（Static Site Generator)。它是一种自动化工具，它通过模板和数据源（如 Markdown 文件、CMS 内容或 API 数据）生成完整的 HTML、CSS 和 JavaScript 文件。与传统动态网站不同，SSG 生成的页面在构建时就已完全渲染，无需在用户访问时依赖数据库或服务器端处理。\n\n\n## 一些常见的SSG工具\n\n下面是一些常见的SSG工具，其中包含一些大家都比较熟悉的，比如Next, Hugo, Jekyll还有Hexo之类的。\n\n![site-generator](../imgs//build-blog3/site-generator.png)\n![site-generator](../imgs//build-blog3/site-generator2.png)\n\n`Next.js`有完整的React生态支持，内置CSS模块化、图像优化和自动代码风格功能, 适合构建复杂交互应用。\n\n`Hugo` 是一块由Go语言开发的超高速静态站点生成器，最大的特点就是，快！\n\n`Jekyll` 算是一款老牌的静态站点生成器了，Github Pages原生就支持，非常适合搞小型项目展示页和个人博客。\n\n`Hexo` 是一款Node.js生态的轻量博客框架，Markdown只有友好，非常适合中文写作。\n\n工具那么多，我独爱Hexo! \n\n## Why Hexo?\n\n在众多的SSG工具中，为什么为独独选择Hexo呢？ 除了是个人接触比较早之外，还有一些其它的深层次的原因。\n\n![hexo](../imgs/build-blog3/hexo.png)\n\n**极低的入门门槛**，只需安装 Node 环境后，通过几条命令即可初始化站点，无需复杂配置。而且中文教程十分丰富，即使是新手，也能在10分钟之内搭建出一个基础博客。\n\n**中文生态友好**，配置文件、错误提示等均为中文，对国内开发者更友好; 社区活跃，中文主题和插件资源丰富。\n\n**灵活扩展，功能丰富**，插件系统完善，通过 npm 安装插件即可扩展功能；主题基于 EJS/Pug/Markdown 模板，支持自定义布局、样式和脚本。\n\n如果你恰好也是一名前端开发工程师，日常开发中必然常常与Node打交道，那么对于自己写Hexo插件和主题是很有优势的，Hexo对于你来说是个很不错的选择。\n\n## 实战操作\n\n前面就说了，即使是新手，也能够在10分钟之内搭建出一个基础博客。如果你正在尝试着跟着步骤做，不妨计时验证一下。\n\n多的话不说了，撸起袖子，开干！\n\n- ### step1: 准备Node环境\n\n  如果之前接触过Node或者已经安装过Node, 可以直接跳过该步骤，直接进入到step2。如果是Node新手，可以按照下面步骤来安装Node。\n  - **方法1：安装包安装**\n\n    a）前往[Node官网](https://nodejs.org/zh-cn/download)下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node安装包”获取。<br>\n    b) 双击安装包，开始安装, 傻瓜式的点击Next.\n\n\n  - **方法2：可移动二进制文件安装**\n\n      a）前往[Node官网](https://nodejs.org/zh-cn/download)下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node独立文件包”获取。<br>\n      b) 将包解压任意目录, 然后将其中的`bin`目录路径配置到环境变量 `path`中\n\n  如安装过程过程中有疑问，可参考详细教程: [Node安装保姆级教程](./install-node.md)\n\n  安装之后，打开命令行窗口，输入 `node -v` 验证，如果出现对应版本号，则说明安装成功了。\n\n- ### step2: 安装Hexo脚手架\n\n全局安装 **Hexo CLI**, 一行命令行就够了。\n\n```\nnpm install hexo-cli -g \n```\n![step2](../imgs//build-blog3/step2.png)\n\n- ### step3: 搭建博客\n\n使用hexo脚手架，完成博客搭建操作\n```\nhexo init my-blog           # 初始化博客目录\ncd my-blog && npm install   # 安装依赖\nnpm run server              # 启动本地预览（http://localhost:4000）\n```\n执行完上述操作之后，在浏览器中输入地址`http://localhost:4000`, 你将看到整个博客的样子，其中包含一篇默认的 `Hello world`博文。\n\n![landscape](../imgs/build-blog3/landscape.png)\n\n如果你想要添加新的博客，执行 `hexo new post 文章标题`即可在 `source/_post`目录下生成一个新的 `.md`文件。如果不熟悉Markdown语法，可以查阅相关资料学习，上手其实挺快的。\n\n\n### step4: 部署到Github Page\n\n执行命令下方命令\n\n``` bash\nhexo generate\n```\n\nhexo将会把所有相关资源文件进行转换，最后所有的资源都都存放在 `public`目录下。将所有文件上传到上一篇文中提到的个人仓库或者使用git命令提交，等待一两分钟，访问自己的博客站点地址，你将看内容已经更新。\n\n\n## 写在最后\n\nHexo 博客的默认主题是 `landscape`, 你也可以尝试着使用其它博客主题，如 `Next`, `Fluid`等。\n\n如果你想对博客站点做些修改，可以通过编辑其根目录下配置文件 `_config.yml` 来进行调整。如果在主题样式上需要做修改，也可以编辑其对应的配置文件，对应的配置文件在 `/themes/主题名称/`中。\n\n关于Hexo更多的配置可查阅其官方文档，里面都有十分详细的介绍。如果个人动手能力比较强，也可以尝试着写一些主题或者插件，那将是一件让你感到成就感满满的事情。\n\n","slug":"build-personal-blog3","published":1,"updated":"2025-06-21T14:14:12.585Z","_id":"cmbmg2vsx0000loup2bgwc9c7","comments":1,"layout":"post","photos":[],"content":"<p>通过上一篇文章–<a href=\"./build-personal-blog2.md\">动手搭建自己的第一个博客站点</a>的介绍，相信你已经成功搭建起了自己的第一个博客网站。如果你的动手能力比较强的话，或许还给博客页面做了页面美工，添加了导航等功能。</p>\n<p>如果你的博客还停留在手写html的阶段，也没有关系，通过这篇文章，让你在10分钟内学会如何使用工具生成漂亮好看的博客页面。</p>\n<h2 id=\"什么是-SSG\"><a href=\"#什么是-SSG\" class=\"headerlink\" title=\"什么是 SSG\"></a>什么是 SSG</h2><p>人类与其他动物的一个显著区别在于，人类擅长制造并使用工具，撰写博客亦是如此。如今，搭建站点撰写博客早已告别了需要手动逐行编写 HTML 代码的 “刀耕火种” 时代，众多优秀工具可供选择，助力我们快速实现更出色的博客呈现效果。</p>\n<p>我们知道，一篇博客内容通常都是以HTML的形式存储的，但对于写博客的人来说，其更想要关注的是其内容本身，而不是各种HTML标签的排列组合和样式调整。</p>\n<p><img src=\"/../imgs/build-blog3/md2html.png\" alt=\"markdown-to-html\"></p>\n<p>那么是否有一种工具，可以让撰写博客的人从书写HTML和各种样式调整中解脱出来，可以直接将纯文本内容转换成带漂亮样式的HTML文件呢？</p>\n<p>有的，那就是静态站点生成器（Static Site Generator)。它是一种自动化工具，它通过模板和数据源（如 Markdown 文件、CMS 内容或 API 数据）生成完整的 HTML、CSS 和 JavaScript 文件。与传统动态网站不同，SSG 生成的页面在构建时就已完全渲染，无需在用户访问时依赖数据库或服务器端处理。</p>\n<h2 id=\"一些常见的SSG工具\"><a href=\"#一些常见的SSG工具\" class=\"headerlink\" title=\"一些常见的SSG工具\"></a>一些常见的SSG工具</h2><p>下面是一些常见的SSG工具，其中包含一些大家都比较熟悉的，比如Next, Hugo, Jekyll还有Hexo之类的。</p>\n<p><img src=\"/../imgs/build-blog3/site-generator.png\" alt=\"site-generator\"><br><img src=\"/../imgs/build-blog3/site-generator2.png\" alt=\"site-generator\"></p>\n<p><code>Next.js</code>有完整的React生态支持，内置CSS模块化、图像优化和自动代码风格功能, 适合构建复杂交互应用。</p>\n<p><code>Hugo</code> 是一块由Go语言开发的超高速静态站点生成器，最大的特点就是，快！</p>\n<p><code>Jekyll</code> 算是一款老牌的静态站点生成器了，Github Pages原生就支持，非常适合搞小型项目展示页和个人博客。</p>\n<p><code>Hexo</code> 是一款Node.js生态的轻量博客框架，Markdown只有友好，非常适合中文写作。</p>\n<p>工具那么多，我独爱Hexo! </p>\n<h2 id=\"Why-Hexo\"><a href=\"#Why-Hexo\" class=\"headerlink\" title=\"Why Hexo?\"></a>Why Hexo?</h2><p>在众多的SSG工具中，为什么为独独选择Hexo呢？ 除了是个人接触比较早之外，还有一些其它的深层次的原因。</p>\n<p><img src=\"/../imgs/build-blog3/hexo.png\" alt=\"hexo\"></p>\n<p><strong>极低的入门门槛</strong>，只需安装 Node 环境后，通过几条命令即可初始化站点，无需复杂配置。而且中文教程十分丰富，即使是新手，也能在10分钟之内搭建出一个基础博客。</p>\n<p><strong>中文生态友好</strong>，配置文件、错误提示等均为中文，对国内开发者更友好; 社区活跃，中文主题和插件资源丰富。</p>\n<p><strong>灵活扩展，功能丰富</strong>，插件系统完善，通过 npm 安装插件即可扩展功能；主题基于 EJS&#x2F;Pug&#x2F;Markdown 模板，支持自定义布局、样式和脚本。</p>\n<p>如果你恰好也是一名前端开发工程师，日常开发中必然常常与Node打交道，那么对于自己写Hexo插件和主题是很有优势的，Hexo对于你来说是个很不错的选择。</p>\n<h2 id=\"实战操作\"><a href=\"#实战操作\" class=\"headerlink\" title=\"实战操作\"></a>实战操作</h2><p>前面就说了，即使是新手，也能够在10分钟之内搭建出一个基础博客。如果你正在尝试着跟着步骤做，不妨计时验证一下。</p>\n<p>多的话不说了，撸起袖子，开干！</p>\n<ul>\n<li><h3 id=\"step1-准备Node环境\"><a href=\"#step1-准备Node环境\" class=\"headerlink\" title=\"step1: 准备Node环境\"></a>step1: 准备Node环境</h3><p>如果之前接触过Node或者已经安装过Node, 可以直接跳过该步骤，直接进入到step2。如果是Node新手，可以按照下面步骤来安装Node。</p>\n<ul>\n<li><p><strong>方法1：安装包安装</strong></p>\n<p>a）前往<a href=\"https://nodejs.org/zh-cn/download\">Node官网</a>下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node安装包”获取。<br><br>b) 双击安装包，开始安装, 傻瓜式的点击Next.</p>\n</li>\n<li><p><strong>方法2：可移动二进制文件安装</strong></p>\n<p>  a）前往<a href=\"https://nodejs.org/zh-cn/download\">Node官网</a>下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node独立文件包”获取。<br><br>  b) 将包解压任意目录, 然后将其中的<code>bin</code>目录路径配置到环境变量 <code>path</code>中</p>\n</li>\n</ul>\n<p>如安装过程过程中有疑问，可参考详细教程: <a href=\"./install-node.md\">Node安装保姆级教程</a></p>\n<p>安装之后，打开命令行窗口，输入 <code>node -v</code> 验证，如果出现对应版本号，则说明安装成功了。</p>\n</li>\n<li><h3 id=\"step2-安装Hexo脚手架\"><a href=\"#step2-安装Hexo脚手架\" class=\"headerlink\" title=\"step2: 安装Hexo脚手架\"></a>step2: 安装Hexo脚手架</h3></li>\n</ul>\n<p>全局安装 <strong>Hexo CLI</strong>, 一行命令行就够了。</p>\n<figure class=\"highlight avrasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs avrasm\">npm install hexo-<span class=\"hljs-keyword\">cli</span> -g <br></code></pre></td></tr></table></figure>\n<p><img src=\"/../imgs/build-blog3/step2.png\" alt=\"step2\"></p>\n<ul>\n<li><h3 id=\"step3-搭建博客\"><a href=\"#step3-搭建博客\" class=\"headerlink\" title=\"step3: 搭建博客\"></a>step3: 搭建博客</h3></li>\n</ul>\n<p>使用hexo脚手架，完成博客搭建操作</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">hexo init <span class=\"hljs-keyword\">my</span>-blog           <span class=\"hljs-comment\"># 初始化博客目录</span><br>cd <span class=\"hljs-keyword\">my</span>-blog &amp;&amp; npm install   <span class=\"hljs-comment\"># 安装依赖</span><br>npm <span class=\"hljs-built_in\">run</span> server              <span class=\"hljs-comment\"># 启动本地预览（http://localhost:4000）</span><br></code></pre></td></tr></table></figure>\n<p>执行完上述操作之后，在浏览器中输入地址<code>http://localhost:4000</code>, 你将看到整个博客的样子，其中包含一篇默认的 <code>Hello world</code>博文。</p>\n<p><img src=\"/../imgs/build-blog3/landscape.png\" alt=\"landscape\"></p>\n<p>如果你想要添加新的博客，执行 <code>hexo new post 文章标题</code>即可在 <code>source/_post</code>目录下生成一个新的 <code>.md</code>文件。如果不熟悉Markdown语法，可以查阅相关资料学习，上手其实挺快的。</p>\n<h3 id=\"step4-部署到Github-Page\"><a href=\"#step4-部署到Github-Page\" class=\"headerlink\" title=\"step4: 部署到Github Page\"></a>step4: 部署到Github Page</h3><p>执行命令下方命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">hexo generate<br></code></pre></td></tr></table></figure>\n\n<p>hexo将会把所有相关资源文件进行转换，最后所有的资源都都存放在 <code>public</code>目录下。将所有文件上传到上一篇文中提到的个人仓库或者使用git命令提交，等待一两分钟，访问自己的博客站点地址，你将看内容已经更新。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>Hexo 博客的默认主题是 <code>landscape</code>, 你也可以尝试着使用其它博客主题，如 <code>Next</code>, <code>Fluid</code>等。</p>\n<p>如果你想对博客站点做些修改，可以通过编辑其根目录下配置文件 <code>_config.yml</code> 来进行调整。如果在主题样式上需要做修改，也可以编辑其对应的配置文件，对应的配置文件在 <code>/themes/主题名称/</code>中。</p>\n<p>关于Hexo更多的配置可查阅其官方文档，里面都有十分详细的介绍。如果个人动手能力比较强，也可以尝试着写一些主题或者插件，那将是一件让你感到成就感满满的事情。</p>\n","excerpt":"","more":"<p>通过上一篇文章–<a href=\"./build-personal-blog2.md\">动手搭建自己的第一个博客站点</a>的介绍，相信你已经成功搭建起了自己的第一个博客网站。如果你的动手能力比较强的话，或许还给博客页面做了页面美工，添加了导航等功能。</p>\n<p>如果你的博客还停留在手写html的阶段，也没有关系，通过这篇文章，让你在10分钟内学会如何使用工具生成漂亮好看的博客页面。</p>\n<h2 id=\"什么是-SSG\"><a href=\"#什么是-SSG\" class=\"headerlink\" title=\"什么是 SSG\"></a>什么是 SSG</h2><p>人类与其他动物的一个显著区别在于，人类擅长制造并使用工具，撰写博客亦是如此。如今，搭建站点撰写博客早已告别了需要手动逐行编写 HTML 代码的 “刀耕火种” 时代，众多优秀工具可供选择，助力我们快速实现更出色的博客呈现效果。</p>\n<p>我们知道，一篇博客内容通常都是以HTML的形式存储的，但对于写博客的人来说，其更想要关注的是其内容本身，而不是各种HTML标签的排列组合和样式调整。</p>\n<p><img src=\"/../imgs/build-blog3/md2html.png\" alt=\"markdown-to-html\"></p>\n<p>那么是否有一种工具，可以让撰写博客的人从书写HTML和各种样式调整中解脱出来，可以直接将纯文本内容转换成带漂亮样式的HTML文件呢？</p>\n<p>有的，那就是静态站点生成器（Static Site Generator)。它是一种自动化工具，它通过模板和数据源（如 Markdown 文件、CMS 内容或 API 数据）生成完整的 HTML、CSS 和 JavaScript 文件。与传统动态网站不同，SSG 生成的页面在构建时就已完全渲染，无需在用户访问时依赖数据库或服务器端处理。</p>\n<h2 id=\"一些常见的SSG工具\"><a href=\"#一些常见的SSG工具\" class=\"headerlink\" title=\"一些常见的SSG工具\"></a>一些常见的SSG工具</h2><p>下面是一些常见的SSG工具，其中包含一些大家都比较熟悉的，比如Next, Hugo, Jekyll还有Hexo之类的。</p>\n<p><img src=\"/../imgs/build-blog3/site-generator.png\" alt=\"site-generator\"><br><img src=\"/../imgs/build-blog3/site-generator2.png\" alt=\"site-generator\"></p>\n<p><code>Next.js</code>有完整的React生态支持，内置CSS模块化、图像优化和自动代码风格功能, 适合构建复杂交互应用。</p>\n<p><code>Hugo</code> 是一块由Go语言开发的超高速静态站点生成器，最大的特点就是，快！</p>\n<p><code>Jekyll</code> 算是一款老牌的静态站点生成器了，Github Pages原生就支持，非常适合搞小型项目展示页和个人博客。</p>\n<p><code>Hexo</code> 是一款Node.js生态的轻量博客框架，Markdown只有友好，非常适合中文写作。</p>\n<p>工具那么多，我独爱Hexo! </p>\n<h2 id=\"Why-Hexo\"><a href=\"#Why-Hexo\" class=\"headerlink\" title=\"Why Hexo?\"></a>Why Hexo?</h2><p>在众多的SSG工具中，为什么为独独选择Hexo呢？ 除了是个人接触比较早之外，还有一些其它的深层次的原因。</p>\n<p><img src=\"/../imgs/build-blog3/hexo.png\" alt=\"hexo\"></p>\n<p><strong>极低的入门门槛</strong>，只需安装 Node 环境后，通过几条命令即可初始化站点，无需复杂配置。而且中文教程十分丰富，即使是新手，也能在10分钟之内搭建出一个基础博客。</p>\n<p><strong>中文生态友好</strong>，配置文件、错误提示等均为中文，对国内开发者更友好; 社区活跃，中文主题和插件资源丰富。</p>\n<p><strong>灵活扩展，功能丰富</strong>，插件系统完善，通过 npm 安装插件即可扩展功能；主题基于 EJS&#x2F;Pug&#x2F;Markdown 模板，支持自定义布局、样式和脚本。</p>\n<p>如果你恰好也是一名前端开发工程师，日常开发中必然常常与Node打交道，那么对于自己写Hexo插件和主题是很有优势的，Hexo对于你来说是个很不错的选择。</p>\n<h2 id=\"实战操作\"><a href=\"#实战操作\" class=\"headerlink\" title=\"实战操作\"></a>实战操作</h2><p>前面就说了，即使是新手，也能够在10分钟之内搭建出一个基础博客。如果你正在尝试着跟着步骤做，不妨计时验证一下。</p>\n<p>多的话不说了，撸起袖子，开干！</p>\n<ul>\n<li><h3 id=\"step1-准备Node环境\"><a href=\"#step1-准备Node环境\" class=\"headerlink\" title=\"step1: 准备Node环境\"></a>step1: 准备Node环境</h3><p>如果之前接触过Node或者已经安装过Node, 可以直接跳过该步骤，直接进入到step2。如果是Node新手，可以按照下面步骤来安装Node。</p>\n<ul>\n<li><p><strong>方法1：安装包安装</strong></p>\n<p>a）前往<a href=\"https://nodejs.org/zh-cn/download\">Node官网</a>下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node安装包”获取。<br><br>b) 双击安装包，开始安装, 傻瓜式的点击Next.</p>\n</li>\n<li><p><strong>方法2：可移动二进制文件安装</strong></p>\n<p>  a）前往<a href=\"https://nodejs.org/zh-cn/download\">Node官网</a>下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node独立文件包”获取。<br><br>  b) 将包解压任意目录, 然后将其中的<code>bin</code>目录路径配置到环境变量 <code>path</code>中</p>\n</li>\n</ul>\n<p>如安装过程过程中有疑问，可参考详细教程: <a href=\"./install-node.md\">Node安装保姆级教程</a></p>\n<p>安装之后，打开命令行窗口，输入 <code>node -v</code> 验证，如果出现对应版本号，则说明安装成功了。</p>\n</li>\n<li><h3 id=\"step2-安装Hexo脚手架\"><a href=\"#step2-安装Hexo脚手架\" class=\"headerlink\" title=\"step2: 安装Hexo脚手架\"></a>step2: 安装Hexo脚手架</h3></li>\n</ul>\n<p>全局安装 <strong>Hexo CLI</strong>, 一行命令行就够了。</p>\n<figure class=\"highlight avrasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs avrasm\">npm install hexo-<span class=\"hljs-keyword\">cli</span> -g <br></code></pre></td></tr></table></figure>\n<p><img src=\"/../imgs/build-blog3/step2.png\" alt=\"step2\"></p>\n<ul>\n<li><h3 id=\"step3-搭建博客\"><a href=\"#step3-搭建博客\" class=\"headerlink\" title=\"step3: 搭建博客\"></a>step3: 搭建博客</h3></li>\n</ul>\n<p>使用hexo脚手架，完成博客搭建操作</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">hexo init <span class=\"hljs-keyword\">my</span>-blog           <span class=\"hljs-comment\"># 初始化博客目录</span><br>cd <span class=\"hljs-keyword\">my</span>-blog &amp;&amp; npm install   <span class=\"hljs-comment\"># 安装依赖</span><br>npm <span class=\"hljs-built_in\">run</span> server              <span class=\"hljs-comment\"># 启动本地预览（http://localhost:4000）</span><br></code></pre></td></tr></table></figure>\n<p>执行完上述操作之后，在浏览器中输入地址<code>http://localhost:4000</code>, 你将看到整个博客的样子，其中包含一篇默认的 <code>Hello world</code>博文。</p>\n<p><img src=\"/../imgs/build-blog3/landscape.png\" alt=\"landscape\"></p>\n<p>如果你想要添加新的博客，执行 <code>hexo new post 文章标题</code>即可在 <code>source/_post</code>目录下生成一个新的 <code>.md</code>文件。如果不熟悉Markdown语法，可以查阅相关资料学习，上手其实挺快的。</p>\n<h3 id=\"step4-部署到Github-Page\"><a href=\"#step4-部署到Github-Page\" class=\"headerlink\" title=\"step4: 部署到Github Page\"></a>step4: 部署到Github Page</h3><p>执行命令下方命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">hexo generate<br></code></pre></td></tr></table></figure>\n\n<p>hexo将会把所有相关资源文件进行转换，最后所有的资源都都存放在 <code>public</code>目录下。将所有文件上传到上一篇文中提到的个人仓库或者使用git命令提交，等待一两分钟，访问自己的博客站点地址，你将看内容已经更新。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>Hexo 博客的默认主题是 <code>landscape</code>, 你也可以尝试着使用其它博客主题，如 <code>Next</code>, <code>Fluid</code>等。</p>\n<p>如果你想对博客站点做些修改，可以通过编辑其根目录下配置文件 <code>_config.yml</code> 来进行调整。如果在主题样式上需要做修改，也可以编辑其对应的配置文件，对应的配置文件在 <code>/themes/主题名称/</code>中。</p>\n<p>关于Hexo更多的配置可查阅其官方文档，里面都有十分详细的介绍。如果个人动手能力比较强，也可以尝试着写一些主题或者插件，那将是一件让你感到成就感满满的事情。</p>\n"},{"title":"Node安装保姆级教程","date":"2025-06-08T10:08:43.000Z","keywords":["Node安装，如何安装Node","Windows上安装Node"],"_content":"\n## 方法1：安装包安装\n\n- **step1**: 前往[Node官网](https://nodejs.org/zh-cn/download)下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node安装包”获取。\n![Node安装](../imgs/build-blog3/NodeSite.png)\n\n- **step2** 双击安装包，开始安装, 傻瓜式的点击 `Next`.\n![Node安装](../imgs/build-blog3/Node1.png)\n\n  点击 `next`\n  ![Node安装](../imgs/build-blog3/Node2.png)\n\n  如果你不想Node默认安装在C盘目录下，可以在这一步修改安装盘\n![Node安装](../imgs/build-blog3/Node3.png)\n\n  点击 `next`\n![Node安装](../imgs/build-blog3/Node4.png)\n\n  点击 `Install`\n![Node安装](../imgs/build-blog3/Node5.png)\n\n## 方法2：可移动二进制文件安装\n\n- **step1**: 前往[Node官网](https://nodejs.org/zh-cn/download)下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node独立文件包”获取。<br>\n- **step2**: 将包解压任意目录，如我的是 在`D:\\software_install\\develop`下\n![Node安装](../imgs/build-blog3/Node-folder.png)\n- **step3**: 将Node目录下的 `bin`下的配置到window环境变量中\n  a) win+s，搜索 `环境变量`, 点击`编辑系统环境变量`\n\n  ![环境变量](../imgs/build-blog3/environment1.png)\n\n  b) 点击`环境变量`\n  ![环境变量](../imgs/build-blog3/environment2.png)\n  \n  c) 找到 `path`, 点击 `编辑`\n  ![环境变量](../imgs/build-blog3/environment3.png)\n\n  d) 点击 `浏览`\n  ![环境变量](../imgs/build-blog3/environment4.png)\n\n  e) 选择 step2 中解压的目录路径\n  ![环境变量](../imgs/build-blog3/environment5.png)\n\n  最后点击 `确定`关闭所有窗口，将环境变量保存应用。\n\n## 安装验证\n\n打开DOS窗口，输入 `node -v`, 查看是否输出对应的 Node 版本号，如果有，则说明安装成功。如果报错，则重新检查安装步骤是否出错，如果需要，重新安装。\n\n![环境变量](../imgs/build-blog3/success.png)\n","source":"_posts/install-node.md","raw":"---\ntitle: Node安装保姆级教程\ndate: 2025-06-08 18:08:43\ncategory: Web开发\ntags: [Node安装, npm]\nkeywords: [Node安装，如何安装Node, Windows上安装Node]\n---\n\n## 方法1：安装包安装\n\n- **step1**: 前往[Node官网](https://nodejs.org/zh-cn/download)下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node安装包”获取。\n![Node安装](../imgs/build-blog3/NodeSite.png)\n\n- **step2** 双击安装包，开始安装, 傻瓜式的点击 `Next`.\n![Node安装](../imgs/build-blog3/Node1.png)\n\n  点击 `next`\n  ![Node安装](../imgs/build-blog3/Node2.png)\n\n  如果你不想Node默认安装在C盘目录下，可以在这一步修改安装盘\n![Node安装](../imgs/build-blog3/Node3.png)\n\n  点击 `next`\n![Node安装](../imgs/build-blog3/Node4.png)\n\n  点击 `Install`\n![Node安装](../imgs/build-blog3/Node5.png)\n\n## 方法2：可移动二进制文件安装\n\n- **step1**: 前往[Node官网](https://nodejs.org/zh-cn/download)下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node独立文件包”获取。<br>\n- **step2**: 将包解压任意目录，如我的是 在`D:\\software_install\\develop`下\n![Node安装](../imgs/build-blog3/Node-folder.png)\n- **step3**: 将Node目录下的 `bin`下的配置到window环境变量中\n  a) win+s，搜索 `环境变量`, 点击`编辑系统环境变量`\n\n  ![环境变量](../imgs/build-blog3/environment1.png)\n\n  b) 点击`环境变量`\n  ![环境变量](../imgs/build-blog3/environment2.png)\n  \n  c) 找到 `path`, 点击 `编辑`\n  ![环境变量](../imgs/build-blog3/environment3.png)\n\n  d) 点击 `浏览`\n  ![环境变量](../imgs/build-blog3/environment4.png)\n\n  e) 选择 step2 中解压的目录路径\n  ![环境变量](../imgs/build-blog3/environment5.png)\n\n  最后点击 `确定`关闭所有窗口，将环境变量保存应用。\n\n## 安装验证\n\n打开DOS窗口，输入 `node -v`, 查看是否输出对应的 Node 版本号，如果有，则说明安装成功。如果报错，则重新检查安装步骤是否出错，如果需要，重新安装。\n\n![环境变量](../imgs/build-blog3/success.png)\n","slug":"install-node","published":1,"updated":"2025-06-21T14:16:30.563Z","_id":"cmbni3a1f0003loup86tygfqi","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"方法1：安装包安装\"><a href=\"#方法1：安装包安装\" class=\"headerlink\" title=\"方法1：安装包安装\"></a>方法1：安装包安装</h2><ul>\n<li><p><strong>step1</strong>: 前往<a href=\"https://nodejs.org/zh-cn/download\">Node官网</a>下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node安装包”获取。<br><img src=\"/../imgs/build-blog3/NodeSite.png\" alt=\"Node安装\"></p>\n</li>\n<li><p><strong>step2</strong> 双击安装包，开始安装, 傻瓜式的点击 <code>Next</code>.<br><img src=\"/../imgs/build-blog3/Node1.png\" alt=\"Node安装\"></p>\n<p>点击 <code>next</code><br><img src=\"/../imgs/build-blog3/Node2.png\" alt=\"Node安装\"></p>\n<p>如果你不想Node默认安装在C盘目录下，可以在这一步修改安装盘</p>\n</li>\n</ul>\n<p><img src=\"/../imgs/build-blog3/Node3.png\" alt=\"Node安装\"></p>\n<p>  点击 <code>next</code><br><img src=\"/../imgs/build-blog3/Node4.png\" alt=\"Node安装\"></p>\n<p>  点击 <code>Install</code><br><img src=\"/../imgs/build-blog3/Node5.png\" alt=\"Node安装\"></p>\n<h2 id=\"方法2：可移动二进制文件安装\"><a href=\"#方法2：可移动二进制文件安装\" class=\"headerlink\" title=\"方法2：可移动二进制文件安装\"></a>方法2：可移动二进制文件安装</h2><ul>\n<li><p><strong>step1</strong>: 前往<a href=\"https://nodejs.org/zh-cn/download\">Node官网</a>下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node独立文件包”获取。<br></p>\n</li>\n<li><p><strong>step2</strong>: 将包解压任意目录，如我的是 在<code>D:\\software_install\\develop</code>下<br><img src=\"/../imgs/build-blog3/Node-folder.png\" alt=\"Node安装\"></p>\n</li>\n<li><p><strong>step3</strong>: 将Node目录下的 <code>bin</code>下的配置到window环境变量中<br>a) win+s，搜索 <code>环境变量</code>, 点击<code>编辑系统环境变量</code></p>\n<p><img src=\"/../imgs/build-blog3/environment1.png\" alt=\"环境变量\"></p>\n<p>b) 点击<code>环境变量</code><br><img src=\"/../imgs/build-blog3/environment2.png\" alt=\"环境变量\"></p>\n<p>c) 找到 <code>path</code>, 点击 <code>编辑</code><br><img src=\"/../imgs/build-blog3/environment3.png\" alt=\"环境变量\"></p>\n<p>d) 点击 <code>浏览</code><br><img src=\"/../imgs/build-blog3/environment4.png\" alt=\"环境变量\"></p>\n<p>e) 选择 step2 中解压的目录路径<br><img src=\"/../imgs/build-blog3/environment5.png\" alt=\"环境变量\"></p>\n<p>最后点击 <code>确定</code>关闭所有窗口，将环境变量保存应用。</p>\n</li>\n</ul>\n<h2 id=\"安装验证\"><a href=\"#安装验证\" class=\"headerlink\" title=\"安装验证\"></a>安装验证</h2><p>打开DOS窗口，输入 <code>node -v</code>, 查看是否输出对应的 Node 版本号，如果有，则说明安装成功。如果报错，则重新检查安装步骤是否出错，如果需要，重新安装。</p>\n<p><img src=\"/../imgs/build-blog3/success.png\" alt=\"环境变量\"></p>\n","excerpt":"","more":"<h2 id=\"方法1：安装包安装\"><a href=\"#方法1：安装包安装\" class=\"headerlink\" title=\"方法1：安装包安装\"></a>方法1：安装包安装</h2><ul>\n<li><p><strong>step1</strong>: 前往<a href=\"https://nodejs.org/zh-cn/download\">Node官网</a>下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node安装包”获取。<br><img src=\"/../imgs/build-blog3/NodeSite.png\" alt=\"Node安装\"></p>\n</li>\n<li><p><strong>step2</strong> 双击安装包，开始安装, 傻瓜式的点击 <code>Next</code>.<br><img src=\"/../imgs/build-blog3/Node1.png\" alt=\"Node安装\"></p>\n<p>点击 <code>next</code><br><img src=\"/../imgs/build-blog3/Node2.png\" alt=\"Node安装\"></p>\n<p>如果你不想Node默认安装在C盘目录下，可以在这一步修改安装盘</p>\n</li>\n</ul>\n<p><img src=\"/../imgs/build-blog3/Node3.png\" alt=\"Node安装\"></p>\n<p>  点击 <code>next</code><br><img src=\"/../imgs/build-blog3/Node4.png\" alt=\"Node安装\"></p>\n<p>  点击 <code>Install</code><br><img src=\"/../imgs/build-blog3/Node5.png\" alt=\"Node安装\"></p>\n<h2 id=\"方法2：可移动二进制文件安装\"><a href=\"#方法2：可移动二进制文件安装\" class=\"headerlink\" title=\"方法2：可移动二进制文件安装\"></a>方法2：可移动二进制文件安装</h2><ul>\n<li><p><strong>step1</strong>: 前往<a href=\"https://nodejs.org/zh-cn/download\">Node官网</a>下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node独立文件包”获取。<br></p>\n</li>\n<li><p><strong>step2</strong>: 将包解压任意目录，如我的是 在<code>D:\\software_install\\develop</code>下<br><img src=\"/../imgs/build-blog3/Node-folder.png\" alt=\"Node安装\"></p>\n</li>\n<li><p><strong>step3</strong>: 将Node目录下的 <code>bin</code>下的配置到window环境变量中<br>a) win+s，搜索 <code>环境变量</code>, 点击<code>编辑系统环境变量</code></p>\n<p><img src=\"/../imgs/build-blog3/environment1.png\" alt=\"环境变量\"></p>\n<p>b) 点击<code>环境变量</code><br><img src=\"/../imgs/build-blog3/environment2.png\" alt=\"环境变量\"></p>\n<p>c) 找到 <code>path</code>, 点击 <code>编辑</code><br><img src=\"/../imgs/build-blog3/environment3.png\" alt=\"环境变量\"></p>\n<p>d) 点击 <code>浏览</code><br><img src=\"/../imgs/build-blog3/environment4.png\" alt=\"环境变量\"></p>\n<p>e) 选择 step2 中解压的目录路径<br><img src=\"/../imgs/build-blog3/environment5.png\" alt=\"环境变量\"></p>\n<p>最后点击 <code>确定</code>关闭所有窗口，将环境变量保存应用。</p>\n</li>\n</ul>\n<h2 id=\"安装验证\"><a href=\"#安装验证\" class=\"headerlink\" title=\"安装验证\"></a>安装验证</h2><p>打开DOS窗口，输入 <code>node -v</code>, 查看是否输出对应的 Node 版本号，如果有，则说明安装成功。如果报错，则重新检查安装步骤是否出错，如果需要，重新安装。</p>\n<p><img src=\"/../imgs/build-blog3/success.png\" alt=\"环境变量\"></p>\n"},{"title":"搭建个人博客系列--(4) 利用Github Actions自动构建博客","date":"2025-06-14T07:37:45.000Z","keywords":["Github Actions","博客搭建","免费博客平台","托管博客","模板建站"],"_content":"\n经过前面的系列文章的学习和实践，相信你已经成功的利用Hexo构建自己的博客并且部署到了Github上。\n\n目前整个发布博客的流程是，用markdown文件写好博客，然后使用Hexo编译成html, 最后将public下的内容部署到github上。整个过程虽然不复杂，但每次都要重新在本地编译然后上传，多少有些繁琐。\n\n这个时候我们可以寻求一种方法，实现博客自动编译和内容的部署，它就是 **Github Actions**。\n\n## 什么是Github Actions?\n\nGitHub Actions 是 GitHub 提供的 持续集成与持续部署（CI/CD）平台，允许开发者直接在 GitHub 仓库中自动化构建、测试、打包、发布代码，实现软件开发流程的自动化。通过定义 YAML 格式的配置文件（称为 Workflow），开发者可以定制化代码仓库的自动化工作流程，例如代码提交时自动运行测试、合并分支时自动部署到服务器等。\n\n## 核心概念\n\n### Workflow（工作流）\n- 一个 Workflow 是一个自动化流程，由一个或多个 Job 组成，通过 YAML 文件（.github/workflows/ 目录下）定义。\n\n- 可以配置 Workflow 在特定事件（如代码推送、Pull Request 创建、Issue 评论等）触发，或按计划定期运行。\n\n### Job（任务）\n\n- 一个 Job 是 Workflow 中的独立任务，包含一系列 Step，默认在一个虚拟机（Runner）上运行。\n- Jobs 可以并行或按顺序执行，支持定义依赖关系（如 Job B 等待 Job A 完成）。\n\n### Step（步骤）\n\n- Step 是 Job 中的最小执行单元，可以是运行 Shell 命令（如 npm install）或调用 Action（预定义的功能模块）。\n\n- 例如：拉取代码、安装依赖、运行测试、部署到服务器等。\n\n### Action（动作）\n\n- 可复用的代码模块，用于完成特定功能（如检出代码、设置环境、发送通知等）。\n\n- GitHub Marketplace 提供大量公开 Actions（如 actions/checkout、actions/setup-node），开发者也可自定义 Actions。\n\n## 举个例子\n\n以下是一个简单的 Workflow 配置（.github/workflows/node.js.yml），用于在 Node.js 项目中执行测试：\n\n```\nname: Node.js CI\non: [push] # 当代码推送时触发\n\njobs:\n  build:\n    runs-on: ubuntu-latest # 使用 Ubuntu 最新版虚拟机\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4 # 拉取代码到 Runner\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: 20 # 指定 Node.js 版本\n\n      - name: Install dependencies\n        run: npm install # 运行 Shell 命令安装依赖\n\n      - name: Run tests\n        run: npm test # 运行测试脚本\n```\n\n## 编写自动编译并部署博客脚本\n\n如果需要实现博客的自动化部署，那么有两个步骤要走，一是在push新内容的时候编译，二是编译之后部署到Github pages上。\n\n### 编译博客\n\n在之前的内容中，我们知道编译markdown文件成html文件使用的命令是 `hexo build`, 后来我们又将其写入到 `package.json`里的`scripts`中并取名为 `build`, 那么在执行编译的时候可以使用 `npm run build`来替代之前的命令。\n\n下面我们开始来写自动化脚本，首先在根目录下新建一个`./github/workflows/update-blogs.yml`文件，整体框架可以参考上面例子，因为使用的都是 Node 环境。\n\n完成一个build操作，要执行的操作分4步骤\n - 拉取代码\n - 配置Node环境\n - 安装依赖\n - 执行编译操作\n - 上传编译内容\n```\nname: automaticly update blogs\non: \n branches:\n  - master # master分支\njobs:\n  build:\n    runs-on: ubuntu-latest # 使用 Ubuntu 最新版虚拟机\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4 # 拉取代码到 Runner\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: 20 # 指定 Node.js 版本\n\n      - name: Install dependencies\n        run: |\n          npm install\n          npm install -g hexo-cli\n\n      - name: Run build\n        run: npm run build # 运行编译操作\n      \n      - name: Upload Pages artifact\n        uses: actions/upload-pages-artifact@v3 # 上传public目录内容\n        with:\n          path: ./public\n\n```\n\n修改点：\n\n- 不想任意分支提交都执行该操作，所以选择  `master` 分支有提交的时候执行。\n\n- 安装依赖依赖，需要在全局安装 `hexo-cli`\n\n- 上传内容使用的是Github Actions 官方的一个专用 Action: actions/upload-pages-aartifact, 主要用于 将静态网站文件打包并上传为 GitHub Pages 部署所需的 “工件”。\n\n\n### 部署博客\n\n在成功编译博客之后，也是通过一个官方的Action来实现博客内容的部署\n\n```\nname: automaticly update blogs\non: \n branches:\n  - master # master分支\njobs:\n  build:\n    ...\n\n  # 部署博客  \n  deploy:\n    needs: build   # 依赖上一个build操作\n    permissions:   # # 需授予 Pages 写入权限和生成部署令牌的权限\n      pages: write\n      id-token: write\n    environment:\n      name: github-pages\n      url: ${{ steps.deployment.outputs.page_url }}\n    runs-on: ubuntu-latest\n    steps:         # 使用actions 部署\n      - name: Deploy to GitHub Pages\n        id: deployment\n        uses: actions/deploy-pages@v4\n\n```\n\n## 测试验证\n\n编写完脚本之后，提交代码至 `master` 分支，在Github对应的仓库分支上可以看见已经有对应的workflow，如作者的脚本配置。\n\n![actions](../imgs/build-blog4/actions.png)\n\n如果左侧出现刚才脚本的名称 `automaticly update blogs`, 则说明已经配置成功了，可以通过提交内容到 master分支来检验脚本的执行情况。\n\n\n## 写在最后\n\n到目前为止，整个搭建个人博客系列文章已经实现了个人博客站点的搭建和自动化部署，相信此时的你也搭建好了自己的博客站点。\n\n正如之前所说，博客站点最重要的就是价值输出，也就是要勤写内容。但是有时候，酒香也怕巷子深，如何让更多的人看到自己写的文章，增加个人影响力，这将是后面将要讨论的问题，请持续关注！","source":"_posts/build-personal-blog4.md","raw":"---\ntitle: 搭建个人博客系列--(4) 利用Github Actions自动构建博客\ndate: 2025-06-14 15:37:45\ncategory: 搭建博客\ntags: \n   - 博客搭建\n   - 个人IP\nkeywords: [Github Actions, 博客搭建, 免费博客平台, 托管博客, 模板建站]\n---\n\n经过前面的系列文章的学习和实践，相信你已经成功的利用Hexo构建自己的博客并且部署到了Github上。\n\n目前整个发布博客的流程是，用markdown文件写好博客，然后使用Hexo编译成html, 最后将public下的内容部署到github上。整个过程虽然不复杂，但每次都要重新在本地编译然后上传，多少有些繁琐。\n\n这个时候我们可以寻求一种方法，实现博客自动编译和内容的部署，它就是 **Github Actions**。\n\n## 什么是Github Actions?\n\nGitHub Actions 是 GitHub 提供的 持续集成与持续部署（CI/CD）平台，允许开发者直接在 GitHub 仓库中自动化构建、测试、打包、发布代码，实现软件开发流程的自动化。通过定义 YAML 格式的配置文件（称为 Workflow），开发者可以定制化代码仓库的自动化工作流程，例如代码提交时自动运行测试、合并分支时自动部署到服务器等。\n\n## 核心概念\n\n### Workflow（工作流）\n- 一个 Workflow 是一个自动化流程，由一个或多个 Job 组成，通过 YAML 文件（.github/workflows/ 目录下）定义。\n\n- 可以配置 Workflow 在特定事件（如代码推送、Pull Request 创建、Issue 评论等）触发，或按计划定期运行。\n\n### Job（任务）\n\n- 一个 Job 是 Workflow 中的独立任务，包含一系列 Step，默认在一个虚拟机（Runner）上运行。\n- Jobs 可以并行或按顺序执行，支持定义依赖关系（如 Job B 等待 Job A 完成）。\n\n### Step（步骤）\n\n- Step 是 Job 中的最小执行单元，可以是运行 Shell 命令（如 npm install）或调用 Action（预定义的功能模块）。\n\n- 例如：拉取代码、安装依赖、运行测试、部署到服务器等。\n\n### Action（动作）\n\n- 可复用的代码模块，用于完成特定功能（如检出代码、设置环境、发送通知等）。\n\n- GitHub Marketplace 提供大量公开 Actions（如 actions/checkout、actions/setup-node），开发者也可自定义 Actions。\n\n## 举个例子\n\n以下是一个简单的 Workflow 配置（.github/workflows/node.js.yml），用于在 Node.js 项目中执行测试：\n\n```\nname: Node.js CI\non: [push] # 当代码推送时触发\n\njobs:\n  build:\n    runs-on: ubuntu-latest # 使用 Ubuntu 最新版虚拟机\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4 # 拉取代码到 Runner\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: 20 # 指定 Node.js 版本\n\n      - name: Install dependencies\n        run: npm install # 运行 Shell 命令安装依赖\n\n      - name: Run tests\n        run: npm test # 运行测试脚本\n```\n\n## 编写自动编译并部署博客脚本\n\n如果需要实现博客的自动化部署，那么有两个步骤要走，一是在push新内容的时候编译，二是编译之后部署到Github pages上。\n\n### 编译博客\n\n在之前的内容中，我们知道编译markdown文件成html文件使用的命令是 `hexo build`, 后来我们又将其写入到 `package.json`里的`scripts`中并取名为 `build`, 那么在执行编译的时候可以使用 `npm run build`来替代之前的命令。\n\n下面我们开始来写自动化脚本，首先在根目录下新建一个`./github/workflows/update-blogs.yml`文件，整体框架可以参考上面例子，因为使用的都是 Node 环境。\n\n完成一个build操作，要执行的操作分4步骤\n - 拉取代码\n - 配置Node环境\n - 安装依赖\n - 执行编译操作\n - 上传编译内容\n```\nname: automaticly update blogs\non: \n branches:\n  - master # master分支\njobs:\n  build:\n    runs-on: ubuntu-latest # 使用 Ubuntu 最新版虚拟机\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4 # 拉取代码到 Runner\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: 20 # 指定 Node.js 版本\n\n      - name: Install dependencies\n        run: |\n          npm install\n          npm install -g hexo-cli\n\n      - name: Run build\n        run: npm run build # 运行编译操作\n      \n      - name: Upload Pages artifact\n        uses: actions/upload-pages-artifact@v3 # 上传public目录内容\n        with:\n          path: ./public\n\n```\n\n修改点：\n\n- 不想任意分支提交都执行该操作，所以选择  `master` 分支有提交的时候执行。\n\n- 安装依赖依赖，需要在全局安装 `hexo-cli`\n\n- 上传内容使用的是Github Actions 官方的一个专用 Action: actions/upload-pages-aartifact, 主要用于 将静态网站文件打包并上传为 GitHub Pages 部署所需的 “工件”。\n\n\n### 部署博客\n\n在成功编译博客之后，也是通过一个官方的Action来实现博客内容的部署\n\n```\nname: automaticly update blogs\non: \n branches:\n  - master # master分支\njobs:\n  build:\n    ...\n\n  # 部署博客  \n  deploy:\n    needs: build   # 依赖上一个build操作\n    permissions:   # # 需授予 Pages 写入权限和生成部署令牌的权限\n      pages: write\n      id-token: write\n    environment:\n      name: github-pages\n      url: ${{ steps.deployment.outputs.page_url }}\n    runs-on: ubuntu-latest\n    steps:         # 使用actions 部署\n      - name: Deploy to GitHub Pages\n        id: deployment\n        uses: actions/deploy-pages@v4\n\n```\n\n## 测试验证\n\n编写完脚本之后，提交代码至 `master` 分支，在Github对应的仓库分支上可以看见已经有对应的workflow，如作者的脚本配置。\n\n![actions](../imgs/build-blog4/actions.png)\n\n如果左侧出现刚才脚本的名称 `automaticly update blogs`, 则说明已经配置成功了，可以通过提交内容到 master分支来检验脚本的执行情况。\n\n\n## 写在最后\n\n到目前为止，整个搭建个人博客系列文章已经实现了个人博客站点的搭建和自动化部署，相信此时的你也搭建好了自己的博客站点。\n\n正如之前所说，博客站点最重要的就是价值输出，也就是要勤写内容。但是有时候，酒香也怕巷子深，如何让更多的人看到自己写的文章，增加个人影响力，这将是后面将要讨论的问题，请持续关注！","slug":"build-personal-blog4","published":1,"updated":"2025-06-21T14:14:16.816Z","_id":"cmc0k7zum0000iwupcmfjci7e","comments":1,"layout":"post","photos":[],"content":"<p>经过前面的系列文章的学习和实践，相信你已经成功的利用Hexo构建自己的博客并且部署到了Github上。</p>\n<p>目前整个发布博客的流程是，用markdown文件写好博客，然后使用Hexo编译成html, 最后将public下的内容部署到github上。整个过程虽然不复杂，但每次都要重新在本地编译然后上传，多少有些繁琐。</p>\n<p>这个时候我们可以寻求一种方法，实现博客自动编译和内容的部署，它就是 <strong>Github Actions</strong>。</p>\n<h2 id=\"什么是Github-Actions\"><a href=\"#什么是Github-Actions\" class=\"headerlink\" title=\"什么是Github Actions?\"></a>什么是Github Actions?</h2><p>GitHub Actions 是 GitHub 提供的 持续集成与持续部署（CI&#x2F;CD）平台，允许开发者直接在 GitHub 仓库中自动化构建、测试、打包、发布代码，实现软件开发流程的自动化。通过定义 YAML 格式的配置文件（称为 Workflow），开发者可以定制化代码仓库的自动化工作流程，例如代码提交时自动运行测试、合并分支时自动部署到服务器等。</p>\n<h2 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h2><h3 id=\"Workflow（工作流）\"><a href=\"#Workflow（工作流）\" class=\"headerlink\" title=\"Workflow（工作流）\"></a>Workflow（工作流）</h3><ul>\n<li><p>一个 Workflow 是一个自动化流程，由一个或多个 Job 组成，通过 YAML 文件（.github&#x2F;workflows&#x2F; 目录下）定义。</p>\n</li>\n<li><p>可以配置 Workflow 在特定事件（如代码推送、Pull Request 创建、Issue 评论等）触发，或按计划定期运行。</p>\n</li>\n</ul>\n<h3 id=\"Job（任务）\"><a href=\"#Job（任务）\" class=\"headerlink\" title=\"Job（任务）\"></a>Job（任务）</h3><ul>\n<li>一个 Job 是 Workflow 中的独立任务，包含一系列 Step，默认在一个虚拟机（Runner）上运行。</li>\n<li>Jobs 可以并行或按顺序执行，支持定义依赖关系（如 Job B 等待 Job A 完成）。</li>\n</ul>\n<h3 id=\"Step（步骤）\"><a href=\"#Step（步骤）\" class=\"headerlink\" title=\"Step（步骤）\"></a>Step（步骤）</h3><ul>\n<li><p>Step 是 Job 中的最小执行单元，可以是运行 Shell 命令（如 npm install）或调用 Action（预定义的功能模块）。</p>\n</li>\n<li><p>例如：拉取代码、安装依赖、运行测试、部署到服务器等。</p>\n</li>\n</ul>\n<h3 id=\"Action（动作）\"><a href=\"#Action（动作）\" class=\"headerlink\" title=\"Action（动作）\"></a>Action（动作）</h3><ul>\n<li><p>可复用的代码模块，用于完成特定功能（如检出代码、设置环境、发送通知等）。</p>\n</li>\n<li><p>GitHub Marketplace 提供大量公开 Actions（如 actions&#x2F;checkout、actions&#x2F;setup-node），开发者也可自定义 Actions。</p>\n</li>\n</ul>\n<h2 id=\"举个例子\"><a href=\"#举个例子\" class=\"headerlink\" title=\"举个例子\"></a>举个例子</h2><p>以下是一个简单的 Workflow 配置（.github&#x2F;workflows&#x2F;node.js.yml），用于在 Node.js 项目中执行测试：</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nix\"><span class=\"hljs-params\">name:</span> Node.js CI<br><span class=\"hljs-params\">on:</span> [push] <span class=\"hljs-comment\"># 当代码推送时触发</span><br><br><span class=\"hljs-params\">jobs:</span><br>  <span class=\"hljs-params\">build:</span><br>    <span class=\"hljs-params\">runs-on:</span> ubuntu-latest <span class=\"hljs-comment\"># 使用 Ubuntu 最新版虚拟机</span><br>    <span class=\"hljs-params\">steps:</span><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Checkout code<br>        <span class=\"hljs-params\">uses:</span> actions<span class=\"hljs-operator\">/</span>checkout@v4 <span class=\"hljs-comment\"># 拉取代码到 Runner</span><br><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Set up Node.js<br>        <span class=\"hljs-params\">uses:</span> actions<span class=\"hljs-operator\">/</span>setup-node@v4<br>        <span class=\"hljs-params\">with:</span><br>          <span class=\"hljs-params\">node-version:</span> <span class=\"hljs-number\">20</span> <span class=\"hljs-comment\"># 指定 Node.js 版本</span><br><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Install dependencies<br>        <span class=\"hljs-params\">run:</span> npm install <span class=\"hljs-comment\"># 运行 Shell 命令安装依赖</span><br><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Run tests<br>        <span class=\"hljs-params\">run:</span> npm test <span class=\"hljs-comment\"># 运行测试脚本</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"编写自动编译并部署博客脚本\"><a href=\"#编写自动编译并部署博客脚本\" class=\"headerlink\" title=\"编写自动编译并部署博客脚本\"></a>编写自动编译并部署博客脚本</h2><p>如果需要实现博客的自动化部署，那么有两个步骤要走，一是在push新内容的时候编译，二是编译之后部署到Github pages上。</p>\n<h3 id=\"编译博客\"><a href=\"#编译博客\" class=\"headerlink\" title=\"编译博客\"></a>编译博客</h3><p>在之前的内容中，我们知道编译markdown文件成html文件使用的命令是 <code>hexo build</code>, 后来我们又将其写入到 <code>package.json</code>里的<code>scripts</code>中并取名为 <code>build</code>, 那么在执行编译的时候可以使用 <code>npm run build</code>来替代之前的命令。</p>\n<p>下面我们开始来写自动化脚本，首先在根目录下新建一个<code>./github/workflows/update-blogs.yml</code>文件，整体框架可以参考上面例子，因为使用的都是 Node 环境。</p>\n<p>完成一个build操作，要执行的操作分4步骤</p>\n<ul>\n<li>拉取代码</li>\n<li>配置Node环境</li>\n<li>安装依赖</li>\n<li>执行编译操作</li>\n<li>上传编译内容<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nix\"><span class=\"hljs-params\">name:</span> automaticly update blogs<br><span class=\"hljs-params\">on:</span> <br> <span class=\"hljs-params\">branches:</span><br>  <span class=\"hljs-operator\">-</span> master <span class=\"hljs-comment\"># master分支</span><br><span class=\"hljs-params\">jobs:</span><br>  <span class=\"hljs-params\">build:</span><br>    <span class=\"hljs-params\">runs-on:</span> ubuntu-latest <span class=\"hljs-comment\"># 使用 Ubuntu 最新版虚拟机</span><br>    <span class=\"hljs-params\">steps:</span><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Checkout code<br>        <span class=\"hljs-params\">uses:</span> actions<span class=\"hljs-operator\">/</span>checkout@v4 <span class=\"hljs-comment\"># 拉取代码到 Runner</span><br><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Set up Node.js<br>        <span class=\"hljs-params\">uses:</span> actions<span class=\"hljs-operator\">/</span>setup-node@v4<br>        <span class=\"hljs-params\">with:</span><br>          <span class=\"hljs-params\">node-version:</span> <span class=\"hljs-number\">20</span> <span class=\"hljs-comment\"># 指定 Node.js 版本</span><br><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Install dependencies<br>        <span class=\"hljs-params\">run:</span> |<br>          npm install<br>          npm install <span class=\"hljs-operator\">-</span>g hexo-cli<br><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Run build<br>        <span class=\"hljs-params\">run:</span> npm run build <span class=\"hljs-comment\"># 运行编译操作</span><br>      <br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Upload Pages artifact<br>        <span class=\"hljs-params\">uses:</span> actions<span class=\"hljs-operator\">/</span>upload-pages-artifact@v3 <span class=\"hljs-comment\"># 上传public目录内容</span><br>        <span class=\"hljs-params\">with:</span><br>          <span class=\"hljs-params\">path:</span> <span class=\"hljs-symbol\">./public</span><br><br></code></pre></td></tr></table></figure></li>\n</ul>\n<p>修改点：</p>\n<ul>\n<li><p>不想任意分支提交都执行该操作，所以选择  <code>master</code> 分支有提交的时候执行。</p>\n</li>\n<li><p>安装依赖依赖，需要在全局安装 <code>hexo-cli</code></p>\n</li>\n<li><p>上传内容使用的是Github Actions 官方的一个专用 Action: actions&#x2F;upload-pages-aartifact, 主要用于 将静态网站文件打包并上传为 GitHub Pages 部署所需的 “工件”。</p>\n</li>\n</ul>\n<h3 id=\"部署博客\"><a href=\"#部署博客\" class=\"headerlink\" title=\"部署博客\"></a>部署博客</h3><p>在成功编译博客之后，也是通过一个官方的Action来实现博客内容的部署</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nix\"><span class=\"hljs-params\">name:</span> automaticly update blogs<br><span class=\"hljs-params\">on:</span> <br> <span class=\"hljs-params\">branches:</span><br>  <span class=\"hljs-operator\">-</span> master <span class=\"hljs-comment\"># master分支</span><br><span class=\"hljs-params\">jobs:</span><br>  <span class=\"hljs-params\">build:</span><br>    ...<br><br>  <span class=\"hljs-comment\"># 部署博客  </span><br>  <span class=\"hljs-params\">deploy:</span><br>    <span class=\"hljs-params\">needs:</span> build   <span class=\"hljs-comment\"># 依赖上一个build操作</span><br>    <span class=\"hljs-params\">permissions:</span>   <span class=\"hljs-comment\"># # 需授予 Pages 写入权限和生成部署令牌的权限</span><br>      <span class=\"hljs-params\">pages:</span> write<br>      <span class=\"hljs-params\">id-token:</span> write<br>    <span class=\"hljs-params\">environment:</span><br>      <span class=\"hljs-params\">name:</span> github-pages<br>      <span class=\"hljs-params\">url:</span> $&#123;&#123; steps.deployment.outputs.page_url &#125;&#125;<br>    <span class=\"hljs-params\">runs-on:</span> ubuntu-latest<br>    <span class=\"hljs-params\">steps:</span>         <span class=\"hljs-comment\"># 使用actions 部署</span><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Deploy to GitHub Pages<br>        <span class=\"hljs-params\">id:</span> deployment<br>        <span class=\"hljs-params\">uses:</span> actions<span class=\"hljs-operator\">/</span>deploy-pages@v4<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"测试验证\"><a href=\"#测试验证\" class=\"headerlink\" title=\"测试验证\"></a>测试验证</h2><p>编写完脚本之后，提交代码至 <code>master</code> 分支，在Github对应的仓库分支上可以看见已经有对应的workflow，如作者的脚本配置。</p>\n<p><img src=\"/../imgs/build-blog4/actions.png\" alt=\"actions\"></p>\n<p>如果左侧出现刚才脚本的名称 <code>automaticly update blogs</code>, 则说明已经配置成功了，可以通过提交内容到 master分支来检验脚本的执行情况。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>到目前为止，整个搭建个人博客系列文章已经实现了个人博客站点的搭建和自动化部署，相信此时的你也搭建好了自己的博客站点。</p>\n<p>正如之前所说，博客站点最重要的就是价值输出，也就是要勤写内容。但是有时候，酒香也怕巷子深，如何让更多的人看到自己写的文章，增加个人影响力，这将是后面将要讨论的问题，请持续关注！</p>\n","excerpt":"","more":"<p>经过前面的系列文章的学习和实践，相信你已经成功的利用Hexo构建自己的博客并且部署到了Github上。</p>\n<p>目前整个发布博客的流程是，用markdown文件写好博客，然后使用Hexo编译成html, 最后将public下的内容部署到github上。整个过程虽然不复杂，但每次都要重新在本地编译然后上传，多少有些繁琐。</p>\n<p>这个时候我们可以寻求一种方法，实现博客自动编译和内容的部署，它就是 <strong>Github Actions</strong>。</p>\n<h2 id=\"什么是Github-Actions\"><a href=\"#什么是Github-Actions\" class=\"headerlink\" title=\"什么是Github Actions?\"></a>什么是Github Actions?</h2><p>GitHub Actions 是 GitHub 提供的 持续集成与持续部署（CI&#x2F;CD）平台，允许开发者直接在 GitHub 仓库中自动化构建、测试、打包、发布代码，实现软件开发流程的自动化。通过定义 YAML 格式的配置文件（称为 Workflow），开发者可以定制化代码仓库的自动化工作流程，例如代码提交时自动运行测试、合并分支时自动部署到服务器等。</p>\n<h2 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h2><h3 id=\"Workflow（工作流）\"><a href=\"#Workflow（工作流）\" class=\"headerlink\" title=\"Workflow（工作流）\"></a>Workflow（工作流）</h3><ul>\n<li><p>一个 Workflow 是一个自动化流程，由一个或多个 Job 组成，通过 YAML 文件（.github&#x2F;workflows&#x2F; 目录下）定义。</p>\n</li>\n<li><p>可以配置 Workflow 在特定事件（如代码推送、Pull Request 创建、Issue 评论等）触发，或按计划定期运行。</p>\n</li>\n</ul>\n<h3 id=\"Job（任务）\"><a href=\"#Job（任务）\" class=\"headerlink\" title=\"Job（任务）\"></a>Job（任务）</h3><ul>\n<li>一个 Job 是 Workflow 中的独立任务，包含一系列 Step，默认在一个虚拟机（Runner）上运行。</li>\n<li>Jobs 可以并行或按顺序执行，支持定义依赖关系（如 Job B 等待 Job A 完成）。</li>\n</ul>\n<h3 id=\"Step（步骤）\"><a href=\"#Step（步骤）\" class=\"headerlink\" title=\"Step（步骤）\"></a>Step（步骤）</h3><ul>\n<li><p>Step 是 Job 中的最小执行单元，可以是运行 Shell 命令（如 npm install）或调用 Action（预定义的功能模块）。</p>\n</li>\n<li><p>例如：拉取代码、安装依赖、运行测试、部署到服务器等。</p>\n</li>\n</ul>\n<h3 id=\"Action（动作）\"><a href=\"#Action（动作）\" class=\"headerlink\" title=\"Action（动作）\"></a>Action（动作）</h3><ul>\n<li><p>可复用的代码模块，用于完成特定功能（如检出代码、设置环境、发送通知等）。</p>\n</li>\n<li><p>GitHub Marketplace 提供大量公开 Actions（如 actions&#x2F;checkout、actions&#x2F;setup-node），开发者也可自定义 Actions。</p>\n</li>\n</ul>\n<h2 id=\"举个例子\"><a href=\"#举个例子\" class=\"headerlink\" title=\"举个例子\"></a>举个例子</h2><p>以下是一个简单的 Workflow 配置（.github&#x2F;workflows&#x2F;node.js.yml），用于在 Node.js 项目中执行测试：</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nix\"><span class=\"hljs-params\">name:</span> Node.js CI<br><span class=\"hljs-params\">on:</span> [push] <span class=\"hljs-comment\"># 当代码推送时触发</span><br><br><span class=\"hljs-params\">jobs:</span><br>  <span class=\"hljs-params\">build:</span><br>    <span class=\"hljs-params\">runs-on:</span> ubuntu-latest <span class=\"hljs-comment\"># 使用 Ubuntu 最新版虚拟机</span><br>    <span class=\"hljs-params\">steps:</span><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Checkout code<br>        <span class=\"hljs-params\">uses:</span> actions<span class=\"hljs-operator\">/</span>checkout@v4 <span class=\"hljs-comment\"># 拉取代码到 Runner</span><br><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Set up Node.js<br>        <span class=\"hljs-params\">uses:</span> actions<span class=\"hljs-operator\">/</span>setup-node@v4<br>        <span class=\"hljs-params\">with:</span><br>          <span class=\"hljs-params\">node-version:</span> <span class=\"hljs-number\">20</span> <span class=\"hljs-comment\"># 指定 Node.js 版本</span><br><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Install dependencies<br>        <span class=\"hljs-params\">run:</span> npm install <span class=\"hljs-comment\"># 运行 Shell 命令安装依赖</span><br><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Run tests<br>        <span class=\"hljs-params\">run:</span> npm test <span class=\"hljs-comment\"># 运行测试脚本</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"编写自动编译并部署博客脚本\"><a href=\"#编写自动编译并部署博客脚本\" class=\"headerlink\" title=\"编写自动编译并部署博客脚本\"></a>编写自动编译并部署博客脚本</h2><p>如果需要实现博客的自动化部署，那么有两个步骤要走，一是在push新内容的时候编译，二是编译之后部署到Github pages上。</p>\n<h3 id=\"编译博客\"><a href=\"#编译博客\" class=\"headerlink\" title=\"编译博客\"></a>编译博客</h3><p>在之前的内容中，我们知道编译markdown文件成html文件使用的命令是 <code>hexo build</code>, 后来我们又将其写入到 <code>package.json</code>里的<code>scripts</code>中并取名为 <code>build</code>, 那么在执行编译的时候可以使用 <code>npm run build</code>来替代之前的命令。</p>\n<p>下面我们开始来写自动化脚本，首先在根目录下新建一个<code>./github/workflows/update-blogs.yml</code>文件，整体框架可以参考上面例子，因为使用的都是 Node 环境。</p>\n<p>完成一个build操作，要执行的操作分4步骤</p>\n<ul>\n<li>拉取代码</li>\n<li>配置Node环境</li>\n<li>安装依赖</li>\n<li>执行编译操作</li>\n<li>上传编译内容<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nix\"><span class=\"hljs-params\">name:</span> automaticly update blogs<br><span class=\"hljs-params\">on:</span> <br> <span class=\"hljs-params\">branches:</span><br>  <span class=\"hljs-operator\">-</span> master <span class=\"hljs-comment\"># master分支</span><br><span class=\"hljs-params\">jobs:</span><br>  <span class=\"hljs-params\">build:</span><br>    <span class=\"hljs-params\">runs-on:</span> ubuntu-latest <span class=\"hljs-comment\"># 使用 Ubuntu 最新版虚拟机</span><br>    <span class=\"hljs-params\">steps:</span><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Checkout code<br>        <span class=\"hljs-params\">uses:</span> actions<span class=\"hljs-operator\">/</span>checkout@v4 <span class=\"hljs-comment\"># 拉取代码到 Runner</span><br><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Set up Node.js<br>        <span class=\"hljs-params\">uses:</span> actions<span class=\"hljs-operator\">/</span>setup-node@v4<br>        <span class=\"hljs-params\">with:</span><br>          <span class=\"hljs-params\">node-version:</span> <span class=\"hljs-number\">20</span> <span class=\"hljs-comment\"># 指定 Node.js 版本</span><br><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Install dependencies<br>        <span class=\"hljs-params\">run:</span> |<br>          npm install<br>          npm install <span class=\"hljs-operator\">-</span>g hexo-cli<br><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Run build<br>        <span class=\"hljs-params\">run:</span> npm run build <span class=\"hljs-comment\"># 运行编译操作</span><br>      <br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Upload Pages artifact<br>        <span class=\"hljs-params\">uses:</span> actions<span class=\"hljs-operator\">/</span>upload-pages-artifact@v3 <span class=\"hljs-comment\"># 上传public目录内容</span><br>        <span class=\"hljs-params\">with:</span><br>          <span class=\"hljs-params\">path:</span> <span class=\"hljs-symbol\">./public</span><br><br></code></pre></td></tr></table></figure></li>\n</ul>\n<p>修改点：</p>\n<ul>\n<li><p>不想任意分支提交都执行该操作，所以选择  <code>master</code> 分支有提交的时候执行。</p>\n</li>\n<li><p>安装依赖依赖，需要在全局安装 <code>hexo-cli</code></p>\n</li>\n<li><p>上传内容使用的是Github Actions 官方的一个专用 Action: actions&#x2F;upload-pages-aartifact, 主要用于 将静态网站文件打包并上传为 GitHub Pages 部署所需的 “工件”。</p>\n</li>\n</ul>\n<h3 id=\"部署博客\"><a href=\"#部署博客\" class=\"headerlink\" title=\"部署博客\"></a>部署博客</h3><p>在成功编译博客之后，也是通过一个官方的Action来实现博客内容的部署</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nix\"><span class=\"hljs-params\">name:</span> automaticly update blogs<br><span class=\"hljs-params\">on:</span> <br> <span class=\"hljs-params\">branches:</span><br>  <span class=\"hljs-operator\">-</span> master <span class=\"hljs-comment\"># master分支</span><br><span class=\"hljs-params\">jobs:</span><br>  <span class=\"hljs-params\">build:</span><br>    ...<br><br>  <span class=\"hljs-comment\"># 部署博客  </span><br>  <span class=\"hljs-params\">deploy:</span><br>    <span class=\"hljs-params\">needs:</span> build   <span class=\"hljs-comment\"># 依赖上一个build操作</span><br>    <span class=\"hljs-params\">permissions:</span>   <span class=\"hljs-comment\"># # 需授予 Pages 写入权限和生成部署令牌的权限</span><br>      <span class=\"hljs-params\">pages:</span> write<br>      <span class=\"hljs-params\">id-token:</span> write<br>    <span class=\"hljs-params\">environment:</span><br>      <span class=\"hljs-params\">name:</span> github-pages<br>      <span class=\"hljs-params\">url:</span> $&#123;&#123; steps.deployment.outputs.page_url &#125;&#125;<br>    <span class=\"hljs-params\">runs-on:</span> ubuntu-latest<br>    <span class=\"hljs-params\">steps:</span>         <span class=\"hljs-comment\"># 使用actions 部署</span><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Deploy to GitHub Pages<br>        <span class=\"hljs-params\">id:</span> deployment<br>        <span class=\"hljs-params\">uses:</span> actions<span class=\"hljs-operator\">/</span>deploy-pages@v4<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"测试验证\"><a href=\"#测试验证\" class=\"headerlink\" title=\"测试验证\"></a>测试验证</h2><p>编写完脚本之后，提交代码至 <code>master</code> 分支，在Github对应的仓库分支上可以看见已经有对应的workflow，如作者的脚本配置。</p>\n<p><img src=\"/../imgs/build-blog4/actions.png\" alt=\"actions\"></p>\n<p>如果左侧出现刚才脚本的名称 <code>automaticly update blogs</code>, 则说明已经配置成功了，可以通过提交内容到 master分支来检验脚本的执行情况。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>到目前为止，整个搭建个人博客系列文章已经实现了个人博客站点的搭建和自动化部署，相信此时的你也搭建好了自己的博客站点。</p>\n<p>正如之前所说，博客站点最重要的就是价值输出，也就是要勤写内容。但是有时候，酒香也怕巷子深，如何让更多的人看到自己写的文章，增加个人影响力，这将是后面将要讨论的问题，请持续关注！</p>\n"},{"title":"为什么团队总在写烂代码？因为 “背锅侠” 根本不存在","date":"2025-06-25T10:20:41.000Z","keywords":["Vue","组件"],"_content":"\n > CV: Copy & Paste, 复制的意思\n\n### 草台班子的代码现状：烂却能跑的魔幻现实\n\n做开发越久，你就越能感受到“这个世界，就是个巨大的草台班子”这句话的含金量。很多看似不错的项目，其代码质量和整理设计往往都经不起推敲。\n\n项目中的冗余代码堆砌，不做修改的暴力复制，混乱的逻辑判断，以及令人作呕的文件命名，有时候自己都会不禁发出灵魂拷问：\n\n“这东西能跑起来吗？ 这东西为什么能跑起来？”\n\n可是，没有人一开始就是奔着要把整个项目写烂为目的的吧？ 没有吧！ 但事实就是这样啊，它虽然很烂，但它能用。虽然它能用，但也是真的烂。\n\nWhy? Tell me why?\n\n![](../imgs/bad-code/en.jfif)\n\n###  熵增的起点：一次复制、一个else if的蝴蝶效应\n\n它肯定不是一开始就是这么烂的，但随着时间的推移，版本的迭代，似乎有种 力量在不断地将他慢慢往变烂的的方向推。而且随着时间的变长，作为项目的开发者，能够明显的感觉到这种力量越来越强，整个项目的维护成本也越来越高。\n\n而这一些，最初可能只是一次简单的代码复制，文件拷贝，也可能只是在原来的判断逻辑上加了一条 `else if` 判断语句...\n\n而做这些的原因，可能是一次的需求变更，也可能是新特性的加入，又或是一次错误的代码优化，但最终的结果是一样的--整个项目的复杂度提高了，代码混乱程度也变高了，换句话来说就是，整个项目的**熵**增加了。\n\n### 协作困境：通用性在功能优先主义下的妥协\n\n对于一个生命周期还没有走到成熟那步的项目来说，需求点的增加和改动是必然的。而需求点的增加和改动，对原有代码的通用性造成的影响有时候是破坏性的。\n\n而在保证项目功能优先的情况下，开发者往往会选择通过牺牲一定通用性来实现对应的功能。虽然可以通过提升组件抽象层次来保证组件的通用性，但这种设计上下多个层次的改动，工作量会比前者多出很多。\n\n而且对于一个多人协作开发的项目而言，每个人并非对指定组件或者模块负责，而是对某些功能点负责，因此在维护组件通用的积极性并没有那么强。\n\n于是今天少一点通用性，明天少一点通用性，直到有一天，协同开发的同事小明需要使用该组件，但是又涉及到内部改动，不好评估改动对整个项目带来的影响。索性生死看淡，不符就干，直接来个CV操作。\n\n至此，回归到了CV的路上。\n\n\n###  伪组件化陷阱：看似复用，实则埋雷\n\n通常，我们对弈是否要将一部分代码抽取成一个模块或者组件的判断还是比较朴素的。\n\n比如，有一段判断逻辑，如果有在3个或3个以上地方出现，这个时候我们就可以考虑将其抽取成一个函数。对于组件也是一样，频繁出现内容相近的表单，也可以封装成一个公共组件。\n\n为什么说这种判断依据比较朴素呢？ 通过一定参数或者内部逻辑适配，使得一个组件能够在多个地方应用，在开发是确实方便了很多。但是，这一操作本身可能就破坏了组件的单一性职责，而且其内部代码将比原来三者中任意一个都负责。\n\n而且，**通过简单适配出来的组件，其本身的通用性在复杂多变的需求面前是十分脆弱的**。\n\n### 烂代码的本质：团队责任感的集体缺位\n\n不可否认，一个项目在功能变复杂的过程中，其代码的复杂程度是会对应增加的，代码烂的程度也会增加。但比较可悲的是，我们往往总是把这种结果归咎于事情本身，而不是管理机制和人。\n\n每一位开发者都在关注着自己手头上的功能，“人和代码，有一个能跑就行”，把手头上的功能做完即可。 整个团队中，没有人需要为项目的烂代码兜底，因为它不是烂在自己手上的。\n\n**责任感的缺位，导致烂代码就像癌细胞一样逐渐扩散到整个项目**。“能用就行，能跑就行，现就这样吧，之前又不是我写的”，这样的思想侵蚀着开发者的责任感。\n\n按理说，每个项目的代码都是有代码审查环节，但在实际操作中，代码审查者往往都是起一个橡皮图章的作用，要么根本没有参与到开发中，要么就是随便瞅两眼后便何如代码。代码审查，本该是把好代码质量的一道重要的门，但却形同虚设，这样又怎能保证代码的质量呢？\n\n组件的通用性差，代码乱复制，冗余代码堆砌...这些烂代码的现象，其实也都是表象。说到底，**项目代码的烂，本质是研发团队管理机制和责任感的烂**。\n\n先说到这吧，散了散了...","source":"_posts/component-versatility.md","raw":"---\ntitle: 为什么团队总在写烂代码？因为 “背锅侠” 根本不存在\ndate: 2025-06-25 18:20:41\ntags: [Vue, 组件]\nkeywords: [Vue, 组件]\ncategory: Web开发\n---\n\n > CV: Copy & Paste, 复制的意思\n\n### 草台班子的代码现状：烂却能跑的魔幻现实\n\n做开发越久，你就越能感受到“这个世界，就是个巨大的草台班子”这句话的含金量。很多看似不错的项目，其代码质量和整理设计往往都经不起推敲。\n\n项目中的冗余代码堆砌，不做修改的暴力复制，混乱的逻辑判断，以及令人作呕的文件命名，有时候自己都会不禁发出灵魂拷问：\n\n“这东西能跑起来吗？ 这东西为什么能跑起来？”\n\n可是，没有人一开始就是奔着要把整个项目写烂为目的的吧？ 没有吧！ 但事实就是这样啊，它虽然很烂，但它能用。虽然它能用，但也是真的烂。\n\nWhy? Tell me why?\n\n![](../imgs/bad-code/en.jfif)\n\n###  熵增的起点：一次复制、一个else if的蝴蝶效应\n\n它肯定不是一开始就是这么烂的，但随着时间的推移，版本的迭代，似乎有种 力量在不断地将他慢慢往变烂的的方向推。而且随着时间的变长，作为项目的开发者，能够明显的感觉到这种力量越来越强，整个项目的维护成本也越来越高。\n\n而这一些，最初可能只是一次简单的代码复制，文件拷贝，也可能只是在原来的判断逻辑上加了一条 `else if` 判断语句...\n\n而做这些的原因，可能是一次的需求变更，也可能是新特性的加入，又或是一次错误的代码优化，但最终的结果是一样的--整个项目的复杂度提高了，代码混乱程度也变高了，换句话来说就是，整个项目的**熵**增加了。\n\n### 协作困境：通用性在功能优先主义下的妥协\n\n对于一个生命周期还没有走到成熟那步的项目来说，需求点的增加和改动是必然的。而需求点的增加和改动，对原有代码的通用性造成的影响有时候是破坏性的。\n\n而在保证项目功能优先的情况下，开发者往往会选择通过牺牲一定通用性来实现对应的功能。虽然可以通过提升组件抽象层次来保证组件的通用性，但这种设计上下多个层次的改动，工作量会比前者多出很多。\n\n而且对于一个多人协作开发的项目而言，每个人并非对指定组件或者模块负责，而是对某些功能点负责，因此在维护组件通用的积极性并没有那么强。\n\n于是今天少一点通用性，明天少一点通用性，直到有一天，协同开发的同事小明需要使用该组件，但是又涉及到内部改动，不好评估改动对整个项目带来的影响。索性生死看淡，不符就干，直接来个CV操作。\n\n至此，回归到了CV的路上。\n\n\n###  伪组件化陷阱：看似复用，实则埋雷\n\n通常，我们对弈是否要将一部分代码抽取成一个模块或者组件的判断还是比较朴素的。\n\n比如，有一段判断逻辑，如果有在3个或3个以上地方出现，这个时候我们就可以考虑将其抽取成一个函数。对于组件也是一样，频繁出现内容相近的表单，也可以封装成一个公共组件。\n\n为什么说这种判断依据比较朴素呢？ 通过一定参数或者内部逻辑适配，使得一个组件能够在多个地方应用，在开发是确实方便了很多。但是，这一操作本身可能就破坏了组件的单一性职责，而且其内部代码将比原来三者中任意一个都负责。\n\n而且，**通过简单适配出来的组件，其本身的通用性在复杂多变的需求面前是十分脆弱的**。\n\n### 烂代码的本质：团队责任感的集体缺位\n\n不可否认，一个项目在功能变复杂的过程中，其代码的复杂程度是会对应增加的，代码烂的程度也会增加。但比较可悲的是，我们往往总是把这种结果归咎于事情本身，而不是管理机制和人。\n\n每一位开发者都在关注着自己手头上的功能，“人和代码，有一个能跑就行”，把手头上的功能做完即可。 整个团队中，没有人需要为项目的烂代码兜底，因为它不是烂在自己手上的。\n\n**责任感的缺位，导致烂代码就像癌细胞一样逐渐扩散到整个项目**。“能用就行，能跑就行，现就这样吧，之前又不是我写的”，这样的思想侵蚀着开发者的责任感。\n\n按理说，每个项目的代码都是有代码审查环节，但在实际操作中，代码审查者往往都是起一个橡皮图章的作用，要么根本没有参与到开发中，要么就是随便瞅两眼后便何如代码。代码审查，本该是把好代码质量的一道重要的门，但却形同虚设，这样又怎能保证代码的质量呢？\n\n组件的通用性差，代码乱复制，冗余代码堆砌...这些烂代码的现象，其实也都是表象。说到底，**项目代码的烂，本质是研发团队管理机制和责任感的烂**。\n\n先说到这吧，散了散了...","slug":"component-versatility","published":1,"updated":"2025-06-25T14:43:24.225Z","_id":"cmcbtzcuy00042gup8b7mgn4o","comments":1,"layout":"post","photos":[],"content":"<blockquote>\n<p>CV: Copy &amp; Paste, 复制的意思</p>\n</blockquote>\n<h3 id=\"草台班子的代码现状：烂却能跑的魔幻现实\"><a href=\"#草台班子的代码现状：烂却能跑的魔幻现实\" class=\"headerlink\" title=\"草台班子的代码现状：烂却能跑的魔幻现实\"></a>草台班子的代码现状：烂却能跑的魔幻现实</h3><p>做开发越久，你就越能感受到“这个世界，就是个巨大的草台班子”这句话的含金量。很多看似不错的项目，其代码质量和整理设计往往都经不起推敲。</p>\n<p>项目中的冗余代码堆砌，不做修改的暴力复制，混乱的逻辑判断，以及令人作呕的文件命名，有时候自己都会不禁发出灵魂拷问：</p>\n<p>“这东西能跑起来吗？ 这东西为什么能跑起来？”</p>\n<p>可是，没有人一开始就是奔着要把整个项目写烂为目的的吧？ 没有吧！ 但事实就是这样啊，它虽然很烂，但它能用。虽然它能用，但也是真的烂。</p>\n<p>Why? Tell me why?</p>\n<p><img src=\"/../imgs/bad-code/en.jfif\"></p>\n<h3 id=\"熵增的起点：一次复制、一个else-if的蝴蝶效应\"><a href=\"#熵增的起点：一次复制、一个else-if的蝴蝶效应\" class=\"headerlink\" title=\"熵增的起点：一次复制、一个else if的蝴蝶效应\"></a>熵增的起点：一次复制、一个else if的蝴蝶效应</h3><p>它肯定不是一开始就是这么烂的，但随着时间的推移，版本的迭代，似乎有种 力量在不断地将他慢慢往变烂的的方向推。而且随着时间的变长，作为项目的开发者，能够明显的感觉到这种力量越来越强，整个项目的维护成本也越来越高。</p>\n<p>而这一些，最初可能只是一次简单的代码复制，文件拷贝，也可能只是在原来的判断逻辑上加了一条 <code>else if</code> 判断语句…</p>\n<p>而做这些的原因，可能是一次的需求变更，也可能是新特性的加入，又或是一次错误的代码优化，但最终的结果是一样的–整个项目的复杂度提高了，代码混乱程度也变高了，换句话来说就是，整个项目的<strong>熵</strong>增加了。</p>\n<h3 id=\"协作困境：通用性在功能优先主义下的妥协\"><a href=\"#协作困境：通用性在功能优先主义下的妥协\" class=\"headerlink\" title=\"协作困境：通用性在功能优先主义下的妥协\"></a>协作困境：通用性在功能优先主义下的妥协</h3><p>对于一个生命周期还没有走到成熟那步的项目来说，需求点的增加和改动是必然的。而需求点的增加和改动，对原有代码的通用性造成的影响有时候是破坏性的。</p>\n<p>而在保证项目功能优先的情况下，开发者往往会选择通过牺牲一定通用性来实现对应的功能。虽然可以通过提升组件抽象层次来保证组件的通用性，但这种设计上下多个层次的改动，工作量会比前者多出很多。</p>\n<p>而且对于一个多人协作开发的项目而言，每个人并非对指定组件或者模块负责，而是对某些功能点负责，因此在维护组件通用的积极性并没有那么强。</p>\n<p>于是今天少一点通用性，明天少一点通用性，直到有一天，协同开发的同事小明需要使用该组件，但是又涉及到内部改动，不好评估改动对整个项目带来的影响。索性生死看淡，不符就干，直接来个CV操作。</p>\n<p>至此，回归到了CV的路上。</p>\n<h3 id=\"伪组件化陷阱：看似复用，实则埋雷\"><a href=\"#伪组件化陷阱：看似复用，实则埋雷\" class=\"headerlink\" title=\"伪组件化陷阱：看似复用，实则埋雷\"></a>伪组件化陷阱：看似复用，实则埋雷</h3><p>通常，我们对弈是否要将一部分代码抽取成一个模块或者组件的判断还是比较朴素的。</p>\n<p>比如，有一段判断逻辑，如果有在3个或3个以上地方出现，这个时候我们就可以考虑将其抽取成一个函数。对于组件也是一样，频繁出现内容相近的表单，也可以封装成一个公共组件。</p>\n<p>为什么说这种判断依据比较朴素呢？ 通过一定参数或者内部逻辑适配，使得一个组件能够在多个地方应用，在开发是确实方便了很多。但是，这一操作本身可能就破坏了组件的单一性职责，而且其内部代码将比原来三者中任意一个都负责。</p>\n<p>而且，<strong>通过简单适配出来的组件，其本身的通用性在复杂多变的需求面前是十分脆弱的</strong>。</p>\n<h3 id=\"烂代码的本质：团队责任感的集体缺位\"><a href=\"#烂代码的本质：团队责任感的集体缺位\" class=\"headerlink\" title=\"烂代码的本质：团队责任感的集体缺位\"></a>烂代码的本质：团队责任感的集体缺位</h3><p>不可否认，一个项目在功能变复杂的过程中，其代码的复杂程度是会对应增加的，代码烂的程度也会增加。但比较可悲的是，我们往往总是把这种结果归咎于事情本身，而不是管理机制和人。</p>\n<p>每一位开发者都在关注着自己手头上的功能，“人和代码，有一个能跑就行”，把手头上的功能做完即可。 整个团队中，没有人需要为项目的烂代码兜底，因为它不是烂在自己手上的。</p>\n<p><strong>责任感的缺位，导致烂代码就像癌细胞一样逐渐扩散到整个项目</strong>。“能用就行，能跑就行，现就这样吧，之前又不是我写的”，这样的思想侵蚀着开发者的责任感。</p>\n<p>按理说，每个项目的代码都是有代码审查环节，但在实际操作中，代码审查者往往都是起一个橡皮图章的作用，要么根本没有参与到开发中，要么就是随便瞅两眼后便何如代码。代码审查，本该是把好代码质量的一道重要的门，但却形同虚设，这样又怎能保证代码的质量呢？</p>\n<p>组件的通用性差，代码乱复制，冗余代码堆砌…这些烂代码的现象，其实也都是表象。说到底，<strong>项目代码的烂，本质是研发团队管理机制和责任感的烂</strong>。</p>\n<p>先说到这吧，散了散了…</p>\n","excerpt":"","more":"<blockquote>\n<p>CV: Copy &amp; Paste, 复制的意思</p>\n</blockquote>\n<h3 id=\"草台班子的代码现状：烂却能跑的魔幻现实\"><a href=\"#草台班子的代码现状：烂却能跑的魔幻现实\" class=\"headerlink\" title=\"草台班子的代码现状：烂却能跑的魔幻现实\"></a>草台班子的代码现状：烂却能跑的魔幻现实</h3><p>做开发越久，你就越能感受到“这个世界，就是个巨大的草台班子”这句话的含金量。很多看似不错的项目，其代码质量和整理设计往往都经不起推敲。</p>\n<p>项目中的冗余代码堆砌，不做修改的暴力复制，混乱的逻辑判断，以及令人作呕的文件命名，有时候自己都会不禁发出灵魂拷问：</p>\n<p>“这东西能跑起来吗？ 这东西为什么能跑起来？”</p>\n<p>可是，没有人一开始就是奔着要把整个项目写烂为目的的吧？ 没有吧！ 但事实就是这样啊，它虽然很烂，但它能用。虽然它能用，但也是真的烂。</p>\n<p>Why? Tell me why?</p>\n<p><img src=\"/../imgs/bad-code/en.jfif\"></p>\n<h3 id=\"熵增的起点：一次复制、一个else-if的蝴蝶效应\"><a href=\"#熵增的起点：一次复制、一个else-if的蝴蝶效应\" class=\"headerlink\" title=\"熵增的起点：一次复制、一个else if的蝴蝶效应\"></a>熵增的起点：一次复制、一个else if的蝴蝶效应</h3><p>它肯定不是一开始就是这么烂的，但随着时间的推移，版本的迭代，似乎有种 力量在不断地将他慢慢往变烂的的方向推。而且随着时间的变长，作为项目的开发者，能够明显的感觉到这种力量越来越强，整个项目的维护成本也越来越高。</p>\n<p>而这一些，最初可能只是一次简单的代码复制，文件拷贝，也可能只是在原来的判断逻辑上加了一条 <code>else if</code> 判断语句…</p>\n<p>而做这些的原因，可能是一次的需求变更，也可能是新特性的加入，又或是一次错误的代码优化，但最终的结果是一样的–整个项目的复杂度提高了，代码混乱程度也变高了，换句话来说就是，整个项目的<strong>熵</strong>增加了。</p>\n<h3 id=\"协作困境：通用性在功能优先主义下的妥协\"><a href=\"#协作困境：通用性在功能优先主义下的妥协\" class=\"headerlink\" title=\"协作困境：通用性在功能优先主义下的妥协\"></a>协作困境：通用性在功能优先主义下的妥协</h3><p>对于一个生命周期还没有走到成熟那步的项目来说，需求点的增加和改动是必然的。而需求点的增加和改动，对原有代码的通用性造成的影响有时候是破坏性的。</p>\n<p>而在保证项目功能优先的情况下，开发者往往会选择通过牺牲一定通用性来实现对应的功能。虽然可以通过提升组件抽象层次来保证组件的通用性，但这种设计上下多个层次的改动，工作量会比前者多出很多。</p>\n<p>而且对于一个多人协作开发的项目而言，每个人并非对指定组件或者模块负责，而是对某些功能点负责，因此在维护组件通用的积极性并没有那么强。</p>\n<p>于是今天少一点通用性，明天少一点通用性，直到有一天，协同开发的同事小明需要使用该组件，但是又涉及到内部改动，不好评估改动对整个项目带来的影响。索性生死看淡，不符就干，直接来个CV操作。</p>\n<p>至此，回归到了CV的路上。</p>\n<h3 id=\"伪组件化陷阱：看似复用，实则埋雷\"><a href=\"#伪组件化陷阱：看似复用，实则埋雷\" class=\"headerlink\" title=\"伪组件化陷阱：看似复用，实则埋雷\"></a>伪组件化陷阱：看似复用，实则埋雷</h3><p>通常，我们对弈是否要将一部分代码抽取成一个模块或者组件的判断还是比较朴素的。</p>\n<p>比如，有一段判断逻辑，如果有在3个或3个以上地方出现，这个时候我们就可以考虑将其抽取成一个函数。对于组件也是一样，频繁出现内容相近的表单，也可以封装成一个公共组件。</p>\n<p>为什么说这种判断依据比较朴素呢？ 通过一定参数或者内部逻辑适配，使得一个组件能够在多个地方应用，在开发是确实方便了很多。但是，这一操作本身可能就破坏了组件的单一性职责，而且其内部代码将比原来三者中任意一个都负责。</p>\n<p>而且，<strong>通过简单适配出来的组件，其本身的通用性在复杂多变的需求面前是十分脆弱的</strong>。</p>\n<h3 id=\"烂代码的本质：团队责任感的集体缺位\"><a href=\"#烂代码的本质：团队责任感的集体缺位\" class=\"headerlink\" title=\"烂代码的本质：团队责任感的集体缺位\"></a>烂代码的本质：团队责任感的集体缺位</h3><p>不可否认，一个项目在功能变复杂的过程中，其代码的复杂程度是会对应增加的，代码烂的程度也会增加。但比较可悲的是，我们往往总是把这种结果归咎于事情本身，而不是管理机制和人。</p>\n<p>每一位开发者都在关注着自己手头上的功能，“人和代码，有一个能跑就行”，把手头上的功能做完即可。 整个团队中，没有人需要为项目的烂代码兜底，因为它不是烂在自己手上的。</p>\n<p><strong>责任感的缺位，导致烂代码就像癌细胞一样逐渐扩散到整个项目</strong>。“能用就行，能跑就行，现就这样吧，之前又不是我写的”，这样的思想侵蚀着开发者的责任感。</p>\n<p>按理说，每个项目的代码都是有代码审查环节，但在实际操作中，代码审查者往往都是起一个橡皮图章的作用，要么根本没有参与到开发中，要么就是随便瞅两眼后便何如代码。代码审查，本该是把好代码质量的一道重要的门，但却形同虚设，这样又怎能保证代码的质量呢？</p>\n<p>组件的通用性差，代码乱复制，冗余代码堆砌…这些烂代码的现象，其实也都是表象。说到底，<strong>项目代码的烂，本质是研发团队管理机制和责任感的烂</strong>。</p>\n<p>先说到这吧，散了散了…</p>\n"},{"title":"JavaScript的\"数值计算困局\"：生态缺位下的破局之路","date":"2025-06-27T14:36:13.000Z","keywords":["Web开发，Node"],"_content":"\n\n**背景**：最近在尝试使用Node折腾一下图像处理相关的操作，以往使用Python处理时常常都会搭配使用numpy库，它在数值和矩阵等计算方面的性能是不用多说的，但在Node生态下却很难找到类似的替代方案，又是有了此文。\n\n\n在Node.js的世界里，写一个矩阵乘法函数或许只需百行代码，但要构建一个能与NumPy媲美的科学计算库，却堪比在沙漠中种树——技术的种子早已埋下，缺乏的是滋养生态的绿洲。这不是语言能力的边界，而是一场关于开发者选择的博弈。\n\n## 一、被误解的\"技术原罪\"\n当开发者争论\"JS能否做科学计算\"时，往往忽略了一个事实：V8引擎的浮点运算性能早已超越多数脚本语言。**类型化数组**配合SIMD.js（通过WebAssembly实现），能让矩阵乘法达到C语言90%的效率；Node.js的N-API允许无缝绑定Fortran数值库，就像**stdlib项目**所展示的那样。ES6引入的类与模块系统，虽未直接赋能数值计算，却为构建复杂数据结构提供了基础设施。\n\n真正的技术瓶颈藏在细节里。比如，JS至今缺乏原生的64位整数数组，这让金融计算场景颇为棘手；复数类型的缺失，也让信号处理库的开发绕道而行。但这些都不是不可逾越的高墙——TypeScript可以通过类型声明模拟，原生插件能够补充底层能力。正如用JS实现FFT算法的开发者所言：\"不是不能写，而是写完后发现，愿意用的人太少。\"\n\n## 二、生态循环的\"死亡螺旋\"\n在Python社区，一个NumPy的bug可能引发百人协作修复；而在JS世界，即便写出性能媲美的ndarray库，也可能面临\"无人问津\"的尴尬。这种差距源于两个恶性循环：\n\n### 人才的\"用脚投票\"\n数据科学家更熟悉Python的SciPy生态，前端开发者擅长的DOM操作与数值计算需求错位。就像PHP开发者转向全栈时更易选择Node.js，数值计算领域的专家天然倾向于已有成熟工具的语言。某开源JS数学库维护者坦言：\"我花3个月优化的矩阵求逆算法，不如Python同行一个星期的Stack Overflow答疑获得的关注多。\"\n\n### 库作者的\"收益悖论\"\n优秀的数值计算库需要持续打磨——这既包括算法优化，也需要完善的文档和教程。但JS生态的\"快餐文化\"让深度投入变得稀缺：一个实现K-means聚类的NPM包可能有2000+下载，但愿意提交文档翻译的贡献者不到5人。这种\"用得多、养得少\"的现状，让库作者难以获得持续创作的动力。\n\n## 三、破局的\"星星之火\"\n转机正在边缘地带悄然发生。在边缘计算场景，Node.js的低延迟特性催生了实时数据处理需求：某物联网公司用JS编写的信号滤波算法，在边缘设备上实现了比Python快30%的处理速度；WebAssembly的普及，让TensorFlow.js能在浏览器中直接运行轻量化模型，这种\"计算可视化一体\"的体验，正是Python生态难以复制的优势。\n\n更值得关注的是工具链的进化。TypeScript的类型系统正在重塑JS的工程能力——某数值计算库通过严格的类型定义，让线性代数操作的错误率下降70%；Vite等构建工具的普及，让JS库的打包体积缩小60%，降低了科学计算库的集成成本。这些变化正在吸引跨界开发者：一位从Julia转投JS的计算生物学家表示：\"现在用JS写的分子动力学模拟，调试效率比编译型语言高5倍。\"\n\n## 四、未来的\"第三条路\"\nJS的数值计算生态不会重复Python的路径，而是走出自己的特色：在浏览器端，WebGPU与WebAssembly的结合，正在孕育\"可视化即计算\"的新范式——用户在Canvas上绘制的图表，背后可能运行着百万级的矩阵运算；在服务端，Node.js的分布式特性让大规模数值计算可以无缝融入微服务架构，某金融公司已用此方案实现了实时风控模型的动态部署。\n\n这场生态突围的关键，在于找到JS的\"不可替代性\"。当Python开发者还在为环境配置发愁时，JS开发者已经通过CDN让数值计算库秒级加载；当R语言的图表需要导出才能分享时，JS的D3.js正在浏览器中实现交互式数据分析。这些差异化体验，正在吸引越来越多\"非典型\"开发者——他们未必精通算法，但擅长将计算能力转化为用户可见的价值。\n\n在JS的世界里，数值计算的未来不是复刻NumPy，而是创造属于自己的\"计算原语\"。当某天，前端开发者能用熟悉的语法操作多维数组，后端工程师可以轻松将数值计算嵌入API，这场迟到的生态革命才算真正完成。而此刻，那些在荒芜中播种的开发者，正在书写着这段历史的序章。","source":"_posts/node-numpy.md","raw":"---\ntitle: JavaScript的\"数值计算困局\"：生态缺位下的破局之路\ndate: 2025-06-27 22:36:13\ntags: [Web开发，Node, packages]\nkeywords: [Web开发，Node]\n---\n\n\n**背景**：最近在尝试使用Node折腾一下图像处理相关的操作，以往使用Python处理时常常都会搭配使用numpy库，它在数值和矩阵等计算方面的性能是不用多说的，但在Node生态下却很难找到类似的替代方案，又是有了此文。\n\n\n在Node.js的世界里，写一个矩阵乘法函数或许只需百行代码，但要构建一个能与NumPy媲美的科学计算库，却堪比在沙漠中种树——技术的种子早已埋下，缺乏的是滋养生态的绿洲。这不是语言能力的边界，而是一场关于开发者选择的博弈。\n\n## 一、被误解的\"技术原罪\"\n当开发者争论\"JS能否做科学计算\"时，往往忽略了一个事实：V8引擎的浮点运算性能早已超越多数脚本语言。**类型化数组**配合SIMD.js（通过WebAssembly实现），能让矩阵乘法达到C语言90%的效率；Node.js的N-API允许无缝绑定Fortran数值库，就像**stdlib项目**所展示的那样。ES6引入的类与模块系统，虽未直接赋能数值计算，却为构建复杂数据结构提供了基础设施。\n\n真正的技术瓶颈藏在细节里。比如，JS至今缺乏原生的64位整数数组，这让金融计算场景颇为棘手；复数类型的缺失，也让信号处理库的开发绕道而行。但这些都不是不可逾越的高墙——TypeScript可以通过类型声明模拟，原生插件能够补充底层能力。正如用JS实现FFT算法的开发者所言：\"不是不能写，而是写完后发现，愿意用的人太少。\"\n\n## 二、生态循环的\"死亡螺旋\"\n在Python社区，一个NumPy的bug可能引发百人协作修复；而在JS世界，即便写出性能媲美的ndarray库，也可能面临\"无人问津\"的尴尬。这种差距源于两个恶性循环：\n\n### 人才的\"用脚投票\"\n数据科学家更熟悉Python的SciPy生态，前端开发者擅长的DOM操作与数值计算需求错位。就像PHP开发者转向全栈时更易选择Node.js，数值计算领域的专家天然倾向于已有成熟工具的语言。某开源JS数学库维护者坦言：\"我花3个月优化的矩阵求逆算法，不如Python同行一个星期的Stack Overflow答疑获得的关注多。\"\n\n### 库作者的\"收益悖论\"\n优秀的数值计算库需要持续打磨——这既包括算法优化，也需要完善的文档和教程。但JS生态的\"快餐文化\"让深度投入变得稀缺：一个实现K-means聚类的NPM包可能有2000+下载，但愿意提交文档翻译的贡献者不到5人。这种\"用得多、养得少\"的现状，让库作者难以获得持续创作的动力。\n\n## 三、破局的\"星星之火\"\n转机正在边缘地带悄然发生。在边缘计算场景，Node.js的低延迟特性催生了实时数据处理需求：某物联网公司用JS编写的信号滤波算法，在边缘设备上实现了比Python快30%的处理速度；WebAssembly的普及，让TensorFlow.js能在浏览器中直接运行轻量化模型，这种\"计算可视化一体\"的体验，正是Python生态难以复制的优势。\n\n更值得关注的是工具链的进化。TypeScript的类型系统正在重塑JS的工程能力——某数值计算库通过严格的类型定义，让线性代数操作的错误率下降70%；Vite等构建工具的普及，让JS库的打包体积缩小60%，降低了科学计算库的集成成本。这些变化正在吸引跨界开发者：一位从Julia转投JS的计算生物学家表示：\"现在用JS写的分子动力学模拟，调试效率比编译型语言高5倍。\"\n\n## 四、未来的\"第三条路\"\nJS的数值计算生态不会重复Python的路径，而是走出自己的特色：在浏览器端，WebGPU与WebAssembly的结合，正在孕育\"可视化即计算\"的新范式——用户在Canvas上绘制的图表，背后可能运行着百万级的矩阵运算；在服务端，Node.js的分布式特性让大规模数值计算可以无缝融入微服务架构，某金融公司已用此方案实现了实时风控模型的动态部署。\n\n这场生态突围的关键，在于找到JS的\"不可替代性\"。当Python开发者还在为环境配置发愁时，JS开发者已经通过CDN让数值计算库秒级加载；当R语言的图表需要导出才能分享时，JS的D3.js正在浏览器中实现交互式数据分析。这些差异化体验，正在吸引越来越多\"非典型\"开发者——他们未必精通算法，但擅长将计算能力转化为用户可见的价值。\n\n在JS的世界里，数值计算的未来不是复刻NumPy，而是创造属于自己的\"计算原语\"。当某天，前端开发者能用熟悉的语法操作多维数组，后端工程师可以轻松将数值计算嵌入API，这场迟到的生态革命才算真正完成。而此刻，那些在荒芜中播种的开发者，正在书写着这段历史的序章。","slug":"node-numpy","published":1,"updated":"2025-06-27T14:52:38.779Z","comments":1,"layout":"post","photos":[],"_id":"cmcexlrxm0000bcupenyp0yis","content":"<p><strong>背景</strong>：最近在尝试使用Node折腾一下图像处理相关的操作，以往使用Python处理时常常都会搭配使用numpy库，它在数值和矩阵等计算方面的性能是不用多说的，但在Node生态下却很难找到类似的替代方案，又是有了此文。</p>\n<p>在Node.js的世界里，写一个矩阵乘法函数或许只需百行代码，但要构建一个能与NumPy媲美的科学计算库，却堪比在沙漠中种树——技术的种子早已埋下，缺乏的是滋养生态的绿洲。这不是语言能力的边界，而是一场关于开发者选择的博弈。</p>\n<h2 id=\"一、被误解的”技术原罪”\"><a href=\"#一、被误解的”技术原罪”\" class=\"headerlink\" title=\"一、被误解的”技术原罪”\"></a>一、被误解的”技术原罪”</h2><p>当开发者争论”JS能否做科学计算”时，往往忽略了一个事实：V8引擎的浮点运算性能早已超越多数脚本语言。<strong>类型化数组</strong>配合SIMD.js（通过WebAssembly实现），能让矩阵乘法达到C语言90%的效率；Node.js的N-API允许无缝绑定Fortran数值库，就像<strong>stdlib项目</strong>所展示的那样。ES6引入的类与模块系统，虽未直接赋能数值计算，却为构建复杂数据结构提供了基础设施。</p>\n<p>真正的技术瓶颈藏在细节里。比如，JS至今缺乏原生的64位整数数组，这让金融计算场景颇为棘手；复数类型的缺失，也让信号处理库的开发绕道而行。但这些都不是不可逾越的高墙——TypeScript可以通过类型声明模拟，原生插件能够补充底层能力。正如用JS实现FFT算法的开发者所言：”不是不能写，而是写完后发现，愿意用的人太少。”</p>\n<h2 id=\"二、生态循环的”死亡螺旋”\"><a href=\"#二、生态循环的”死亡螺旋”\" class=\"headerlink\" title=\"二、生态循环的”死亡螺旋”\"></a>二、生态循环的”死亡螺旋”</h2><p>在Python社区，一个NumPy的bug可能引发百人协作修复；而在JS世界，即便写出性能媲美的ndarray库，也可能面临”无人问津”的尴尬。这种差距源于两个恶性循环：</p>\n<h3 id=\"人才的”用脚投票”\"><a href=\"#人才的”用脚投票”\" class=\"headerlink\" title=\"人才的”用脚投票”\"></a>人才的”用脚投票”</h3><p>数据科学家更熟悉Python的SciPy生态，前端开发者擅长的DOM操作与数值计算需求错位。就像PHP开发者转向全栈时更易选择Node.js，数值计算领域的专家天然倾向于已有成熟工具的语言。某开源JS数学库维护者坦言：”我花3个月优化的矩阵求逆算法，不如Python同行一个星期的Stack Overflow答疑获得的关注多。”</p>\n<h3 id=\"库作者的”收益悖论”\"><a href=\"#库作者的”收益悖论”\" class=\"headerlink\" title=\"库作者的”收益悖论”\"></a>库作者的”收益悖论”</h3><p>优秀的数值计算库需要持续打磨——这既包括算法优化，也需要完善的文档和教程。但JS生态的”快餐文化”让深度投入变得稀缺：一个实现K-means聚类的NPM包可能有2000+下载，但愿意提交文档翻译的贡献者不到5人。这种”用得多、养得少”的现状，让库作者难以获得持续创作的动力。</p>\n<h2 id=\"三、破局的”星星之火”\"><a href=\"#三、破局的”星星之火”\" class=\"headerlink\" title=\"三、破局的”星星之火”\"></a>三、破局的”星星之火”</h2><p>转机正在边缘地带悄然发生。在边缘计算场景，Node.js的低延迟特性催生了实时数据处理需求：某物联网公司用JS编写的信号滤波算法，在边缘设备上实现了比Python快30%的处理速度；WebAssembly的普及，让TensorFlow.js能在浏览器中直接运行轻量化模型，这种”计算可视化一体”的体验，正是Python生态难以复制的优势。</p>\n<p>更值得关注的是工具链的进化。TypeScript的类型系统正在重塑JS的工程能力——某数值计算库通过严格的类型定义，让线性代数操作的错误率下降70%；Vite等构建工具的普及，让JS库的打包体积缩小60%，降低了科学计算库的集成成本。这些变化正在吸引跨界开发者：一位从Julia转投JS的计算生物学家表示：”现在用JS写的分子动力学模拟，调试效率比编译型语言高5倍。”</p>\n<h2 id=\"四、未来的”第三条路”\"><a href=\"#四、未来的”第三条路”\" class=\"headerlink\" title=\"四、未来的”第三条路”\"></a>四、未来的”第三条路”</h2><p>JS的数值计算生态不会重复Python的路径，而是走出自己的特色：在浏览器端，WebGPU与WebAssembly的结合，正在孕育”可视化即计算”的新范式——用户在Canvas上绘制的图表，背后可能运行着百万级的矩阵运算；在服务端，Node.js的分布式特性让大规模数值计算可以无缝融入微服务架构，某金融公司已用此方案实现了实时风控模型的动态部署。</p>\n<p>这场生态突围的关键，在于找到JS的”不可替代性”。当Python开发者还在为环境配置发愁时，JS开发者已经通过CDN让数值计算库秒级加载；当R语言的图表需要导出才能分享时，JS的D3.js正在浏览器中实现交互式数据分析。这些差异化体验，正在吸引越来越多”非典型”开发者——他们未必精通算法，但擅长将计算能力转化为用户可见的价值。</p>\n<p>在JS的世界里，数值计算的未来不是复刻NumPy，而是创造属于自己的”计算原语”。当某天，前端开发者能用熟悉的语法操作多维数组，后端工程师可以轻松将数值计算嵌入API，这场迟到的生态革命才算真正完成。而此刻，那些在荒芜中播种的开发者，正在书写着这段历史的序章。</p>\n","excerpt":"","more":"<p><strong>背景</strong>：最近在尝试使用Node折腾一下图像处理相关的操作，以往使用Python处理时常常都会搭配使用numpy库，它在数值和矩阵等计算方面的性能是不用多说的，但在Node生态下却很难找到类似的替代方案，又是有了此文。</p>\n<p>在Node.js的世界里，写一个矩阵乘法函数或许只需百行代码，但要构建一个能与NumPy媲美的科学计算库，却堪比在沙漠中种树——技术的种子早已埋下，缺乏的是滋养生态的绿洲。这不是语言能力的边界，而是一场关于开发者选择的博弈。</p>\n<h2 id=\"一、被误解的”技术原罪”\"><a href=\"#一、被误解的”技术原罪”\" class=\"headerlink\" title=\"一、被误解的”技术原罪”\"></a>一、被误解的”技术原罪”</h2><p>当开发者争论”JS能否做科学计算”时，往往忽略了一个事实：V8引擎的浮点运算性能早已超越多数脚本语言。<strong>类型化数组</strong>配合SIMD.js（通过WebAssembly实现），能让矩阵乘法达到C语言90%的效率；Node.js的N-API允许无缝绑定Fortran数值库，就像<strong>stdlib项目</strong>所展示的那样。ES6引入的类与模块系统，虽未直接赋能数值计算，却为构建复杂数据结构提供了基础设施。</p>\n<p>真正的技术瓶颈藏在细节里。比如，JS至今缺乏原生的64位整数数组，这让金融计算场景颇为棘手；复数类型的缺失，也让信号处理库的开发绕道而行。但这些都不是不可逾越的高墙——TypeScript可以通过类型声明模拟，原生插件能够补充底层能力。正如用JS实现FFT算法的开发者所言：”不是不能写，而是写完后发现，愿意用的人太少。”</p>\n<h2 id=\"二、生态循环的”死亡螺旋”\"><a href=\"#二、生态循环的”死亡螺旋”\" class=\"headerlink\" title=\"二、生态循环的”死亡螺旋”\"></a>二、生态循环的”死亡螺旋”</h2><p>在Python社区，一个NumPy的bug可能引发百人协作修复；而在JS世界，即便写出性能媲美的ndarray库，也可能面临”无人问津”的尴尬。这种差距源于两个恶性循环：</p>\n<h3 id=\"人才的”用脚投票”\"><a href=\"#人才的”用脚投票”\" class=\"headerlink\" title=\"人才的”用脚投票”\"></a>人才的”用脚投票”</h3><p>数据科学家更熟悉Python的SciPy生态，前端开发者擅长的DOM操作与数值计算需求错位。就像PHP开发者转向全栈时更易选择Node.js，数值计算领域的专家天然倾向于已有成熟工具的语言。某开源JS数学库维护者坦言：”我花3个月优化的矩阵求逆算法，不如Python同行一个星期的Stack Overflow答疑获得的关注多。”</p>\n<h3 id=\"库作者的”收益悖论”\"><a href=\"#库作者的”收益悖论”\" class=\"headerlink\" title=\"库作者的”收益悖论”\"></a>库作者的”收益悖论”</h3><p>优秀的数值计算库需要持续打磨——这既包括算法优化，也需要完善的文档和教程。但JS生态的”快餐文化”让深度投入变得稀缺：一个实现K-means聚类的NPM包可能有2000+下载，但愿意提交文档翻译的贡献者不到5人。这种”用得多、养得少”的现状，让库作者难以获得持续创作的动力。</p>\n<h2 id=\"三、破局的”星星之火”\"><a href=\"#三、破局的”星星之火”\" class=\"headerlink\" title=\"三、破局的”星星之火”\"></a>三、破局的”星星之火”</h2><p>转机正在边缘地带悄然发生。在边缘计算场景，Node.js的低延迟特性催生了实时数据处理需求：某物联网公司用JS编写的信号滤波算法，在边缘设备上实现了比Python快30%的处理速度；WebAssembly的普及，让TensorFlow.js能在浏览器中直接运行轻量化模型，这种”计算可视化一体”的体验，正是Python生态难以复制的优势。</p>\n<p>更值得关注的是工具链的进化。TypeScript的类型系统正在重塑JS的工程能力——某数值计算库通过严格的类型定义，让线性代数操作的错误率下降70%；Vite等构建工具的普及，让JS库的打包体积缩小60%，降低了科学计算库的集成成本。这些变化正在吸引跨界开发者：一位从Julia转投JS的计算生物学家表示：”现在用JS写的分子动力学模拟，调试效率比编译型语言高5倍。”</p>\n<h2 id=\"四、未来的”第三条路”\"><a href=\"#四、未来的”第三条路”\" class=\"headerlink\" title=\"四、未来的”第三条路”\"></a>四、未来的”第三条路”</h2><p>JS的数值计算生态不会重复Python的路径，而是走出自己的特色：在浏览器端，WebGPU与WebAssembly的结合，正在孕育”可视化即计算”的新范式——用户在Canvas上绘制的图表，背后可能运行着百万级的矩阵运算；在服务端，Node.js的分布式特性让大规模数值计算可以无缝融入微服务架构，某金融公司已用此方案实现了实时风控模型的动态部署。</p>\n<p>这场生态突围的关键，在于找到JS的”不可替代性”。当Python开发者还在为环境配置发愁时，JS开发者已经通过CDN让数值计算库秒级加载；当R语言的图表需要导出才能分享时，JS的D3.js正在浏览器中实现交互式数据分析。这些差异化体验，正在吸引越来越多”非典型”开发者——他们未必精通算法，但擅长将计算能力转化为用户可见的价值。</p>\n<p>在JS的世界里，数值计算的未来不是复刻NumPy，而是创造属于自己的”计算原语”。当某天，前端开发者能用熟悉的语法操作多维数组，后端工程师可以轻松将数值计算嵌入API，这场迟到的生态革命才算真正完成。而此刻，那些在荒芜中播种的开发者，正在书写着这段历史的序章。</p>\n"},{"title":"一文读懂 Cookie、Session 和 Token：原理、区别与应用场景","date":"2025-07-01T13:15:32.000Z","keywords":["Cookie","Session","Token"],"_content":"\n# 一文读懂Cookie、Session和Token：原理、区别与应用场景\n咱上网冲浪的时候，天天和各种网站、APP打交道。但HTTP协议有个“毛病”——它记性不好，每次请求都像第一次见面，根本不记得之前和你聊过啥。为了解决这个问题，程序员们整出了**Cookie**、**Session**和**Token**这三个“神器”，它们就像我们在网络世界的身份证、通行证，帮服务器记住你是谁，都干了啥。今天咱就唠唠这仨到底是干啥的，有啥不一样！\n\n## 一、Cookie、Session和Token都干啥用？\n### 1.1 Cookie：浏览器帮你记事儿的小本本\nCookie就是服务器给浏览器塞的小纸条，存的都是些用户信息，像登录状态、浏览偏好啥的。举个例子，你第一次进某个网站，选了中文界面、深色模式，下次再访问，网站秒变你喜欢的样子，这背后就是Cookie在偷偷“记笔记”。不过这小纸条存你电脑里，容易被人偷看，所以得小心点用！\n\n### 1.2 Session：服务器的专属“私人档案库”\nSession相当于是服务器自己的“小账本”，专门用来存用户的会话数据。当你登录网站，服务器就给你开个“档案袋”，把你购物车有啥、订单到哪一步了这些信息全塞进去。但它咋知道这份档案归谁呢？靠的就是Cookie里的Session ID，相当于档案编号，浏览器每次带着编号来，服务器一看就知道：“哦！原来是你！”\n\n### 1.3 Token：万能通行令牌\nToken就是服务器发的一串乱码“令牌”，你拿着它去访问网站的各种服务，就像拿着身份证证明“我是我”。Token最大的好处是不用服务器记太多东西，你每次来，它只需要验证令牌是真是假就行。现在流行的前后端分离、第三方登录，基本都靠Token“打天下”，移动端APP更是离了它不行。\n\n## 二、Cookie、Session和Token，到底咋区分？\n### 2.1 都藏在哪？能存多少东西？\nCookie就住你电脑里，浏览器帮你保管。不过它个头很小气，一般不能超过4KB，而且一个网站最多也就存50个左右。\nSession住在服务器那边，理论上想存多少存多少，但服务器空间有限，存太多也顶不住。\nToken呢，既可以放在客户端（比如APP里），也能在每次请求的时候跟着一起“跑”，大小没严格限制，通常几百字节。\n\n### 2.2 安不安全？容易被偷吗？\nCookie因为在客户端，就像放在桌子上的纸条，很容易被人篡改。不过可以给它加把锁：\n- `HttpOnly`让JavaScript读不到它\n- `Secure`保证它只在安全的HTTPS通道里传送\n- `SameSite`防止被别人“冒名顶替”发请求\n\nSession数据在服务器，相对安全些，但要是Session ID被坏人搞到手，也能冒充你。\nToken用签名加密，一般改不了，但一旦被偷，坏人也能用，所以得设个有效期，到期就作废。\n\n### 2.3 怎么在网络里“传送”？\n- Cookie最“自觉”，浏览器每次发请求，都会自动把相关的Cookie带上，除非你特意限制它。\n- Session得靠Cookie帮忙传递Session ID，虽然也能藏在URL里，但容易暴露，不太安全。\n- Token就比较“自由”，常见的是放在请求头的`Authorization`字段里，也能塞到请求体或URL里，全看开发者咋安排。\n\n### 2.4 能用多久？啥时候过期？\n- Cookie想“活”多久，由服务器说了算。设置了`expires`或`max-age`，它就是“长寿型”，到期才失效；不设置的话，浏览器一关，它就“凉凉”。\n- Session和Cookie里的Session ID绑在一起，服务器还会设个“闲置超时”，比如30分钟没操作，直接清空档案。\n- Token出生的时候就被定好了“保质期”（像JWT的`exp`字段），过期就得重新申请新令牌。\n\n### 2.5 能不能适应复杂的网络环境？\n要是网站用的是分布式系统（多个服务器协同工作），Cookie + Session组合就有点“吃力”。因为Session存在服务器里，多个服务器之间得同步数据，不然容易“认不出”用户。\nToken就没这烦恼，它不需要服务器存啥，验证一下令牌是真是假就行，特别适合微服务、跨域这种复杂场景。\n\n## 三、生活里都在哪见过它们？\n### 3.1 Cookie的“日常工作”\n- 刷新闻的时候，为啥总给你推爱看的内容？Cookie在“搞事情”！它记住了你的兴趣标签。\n- 还有电商网站没登录时加进购物车的商品，也是Cookie临时存着。不过拿Cookie做广告追踪得小心，一不小心就违反隐私规定了。\n\n### 3.2 Session的“用武之地”\n电商平台的购物车、订单状态，后台管理系统的用户权限，在线聊天的实时状态……这些对安全性、实时性要求高的场景，都是Session的主场。服务器随时能查看、修改你的会话数据，还能强制你下线，安全感拉满！\n\n### 3.3 Token的“高光时刻”\n- 现在很多网站支持微信、GitHub一键登录，靠的就是Token在不同平台间“传话”。\n- 前后端分离项目里，前端和后端不在一个域名下，Token能轻松实现跨域认证。\n- 还有手机APP，没Cookie可用，Token就是它唯一的“身份认证官”。\n\n## 四、到底该选谁？\n简单来说：\n- Cookie适合存点小偏好、临时数据\n- Session适合对安全要求高、需要集中管理的场景\n- Token则是跨域、移动端、微服务的“心头好”\n\n实际开发中，大家经常把它们搭配着用，比如用Cookie传Session ID，或者把Token藏在Cookie里，增强安全性。具体咋选，还得根据业务需求，综合考虑安全、性能这些因素，找到最适合的方案！\n\n要是你对哪个部分还有疑问，或者想知道更多实战技巧，欢迎随时来唠嗑！ ","source":"_posts/cookie-session-token.md","raw":"---\ntitle: 一文读懂 Cookie、Session 和 Token：原理、区别与应用场景\ndate: 2025-07-01 21:15:32\ntags: [Cookie, Session, Token]\nkeywords: [Cookie, Session, Token]\ncategory: [Web开发, 网络安全]\n---\n\n# 一文读懂Cookie、Session和Token：原理、区别与应用场景\n咱上网冲浪的时候，天天和各种网站、APP打交道。但HTTP协议有个“毛病”——它记性不好，每次请求都像第一次见面，根本不记得之前和你聊过啥。为了解决这个问题，程序员们整出了**Cookie**、**Session**和**Token**这三个“神器”，它们就像我们在网络世界的身份证、通行证，帮服务器记住你是谁，都干了啥。今天咱就唠唠这仨到底是干啥的，有啥不一样！\n\n## 一、Cookie、Session和Token都干啥用？\n### 1.1 Cookie：浏览器帮你记事儿的小本本\nCookie就是服务器给浏览器塞的小纸条，存的都是些用户信息，像登录状态、浏览偏好啥的。举个例子，你第一次进某个网站，选了中文界面、深色模式，下次再访问，网站秒变你喜欢的样子，这背后就是Cookie在偷偷“记笔记”。不过这小纸条存你电脑里，容易被人偷看，所以得小心点用！\n\n### 1.2 Session：服务器的专属“私人档案库”\nSession相当于是服务器自己的“小账本”，专门用来存用户的会话数据。当你登录网站，服务器就给你开个“档案袋”，把你购物车有啥、订单到哪一步了这些信息全塞进去。但它咋知道这份档案归谁呢？靠的就是Cookie里的Session ID，相当于档案编号，浏览器每次带着编号来，服务器一看就知道：“哦！原来是你！”\n\n### 1.3 Token：万能通行令牌\nToken就是服务器发的一串乱码“令牌”，你拿着它去访问网站的各种服务，就像拿着身份证证明“我是我”。Token最大的好处是不用服务器记太多东西，你每次来，它只需要验证令牌是真是假就行。现在流行的前后端分离、第三方登录，基本都靠Token“打天下”，移动端APP更是离了它不行。\n\n## 二、Cookie、Session和Token，到底咋区分？\n### 2.1 都藏在哪？能存多少东西？\nCookie就住你电脑里，浏览器帮你保管。不过它个头很小气，一般不能超过4KB，而且一个网站最多也就存50个左右。\nSession住在服务器那边，理论上想存多少存多少，但服务器空间有限，存太多也顶不住。\nToken呢，既可以放在客户端（比如APP里），也能在每次请求的时候跟着一起“跑”，大小没严格限制，通常几百字节。\n\n### 2.2 安不安全？容易被偷吗？\nCookie因为在客户端，就像放在桌子上的纸条，很容易被人篡改。不过可以给它加把锁：\n- `HttpOnly`让JavaScript读不到它\n- `Secure`保证它只在安全的HTTPS通道里传送\n- `SameSite`防止被别人“冒名顶替”发请求\n\nSession数据在服务器，相对安全些，但要是Session ID被坏人搞到手，也能冒充你。\nToken用签名加密，一般改不了，但一旦被偷，坏人也能用，所以得设个有效期，到期就作废。\n\n### 2.3 怎么在网络里“传送”？\n- Cookie最“自觉”，浏览器每次发请求，都会自动把相关的Cookie带上，除非你特意限制它。\n- Session得靠Cookie帮忙传递Session ID，虽然也能藏在URL里，但容易暴露，不太安全。\n- Token就比较“自由”，常见的是放在请求头的`Authorization`字段里，也能塞到请求体或URL里，全看开发者咋安排。\n\n### 2.4 能用多久？啥时候过期？\n- Cookie想“活”多久，由服务器说了算。设置了`expires`或`max-age`，它就是“长寿型”，到期才失效；不设置的话，浏览器一关，它就“凉凉”。\n- Session和Cookie里的Session ID绑在一起，服务器还会设个“闲置超时”，比如30分钟没操作，直接清空档案。\n- Token出生的时候就被定好了“保质期”（像JWT的`exp`字段），过期就得重新申请新令牌。\n\n### 2.5 能不能适应复杂的网络环境？\n要是网站用的是分布式系统（多个服务器协同工作），Cookie + Session组合就有点“吃力”。因为Session存在服务器里，多个服务器之间得同步数据，不然容易“认不出”用户。\nToken就没这烦恼，它不需要服务器存啥，验证一下令牌是真是假就行，特别适合微服务、跨域这种复杂场景。\n\n## 三、生活里都在哪见过它们？\n### 3.1 Cookie的“日常工作”\n- 刷新闻的时候，为啥总给你推爱看的内容？Cookie在“搞事情”！它记住了你的兴趣标签。\n- 还有电商网站没登录时加进购物车的商品，也是Cookie临时存着。不过拿Cookie做广告追踪得小心，一不小心就违反隐私规定了。\n\n### 3.2 Session的“用武之地”\n电商平台的购物车、订单状态，后台管理系统的用户权限，在线聊天的实时状态……这些对安全性、实时性要求高的场景，都是Session的主场。服务器随时能查看、修改你的会话数据，还能强制你下线，安全感拉满！\n\n### 3.3 Token的“高光时刻”\n- 现在很多网站支持微信、GitHub一键登录，靠的就是Token在不同平台间“传话”。\n- 前后端分离项目里，前端和后端不在一个域名下，Token能轻松实现跨域认证。\n- 还有手机APP，没Cookie可用，Token就是它唯一的“身份认证官”。\n\n## 四、到底该选谁？\n简单来说：\n- Cookie适合存点小偏好、临时数据\n- Session适合对安全要求高、需要集中管理的场景\n- Token则是跨域、移动端、微服务的“心头好”\n\n实际开发中，大家经常把它们搭配着用，比如用Cookie传Session ID，或者把Token藏在Cookie里，增强安全性。具体咋选，还得根据业务需求，综合考虑安全、性能这些因素，找到最适合的方案！\n\n要是你对哪个部分还有疑问，或者想知道更多实战技巧，欢迎随时来唠嗑！ ","slug":"cookie-session-token","published":1,"updated":"2025-07-01T13:19:14.805Z","comments":1,"layout":"post","photos":[],"_id":"cmckk1h8m0000ioup68xi86ww","content":"<h1 id=\"一文读懂Cookie、Session和Token：原理、区别与应用场景\"><a href=\"#一文读懂Cookie、Session和Token：原理、区别与应用场景\" class=\"headerlink\" title=\"一文读懂Cookie、Session和Token：原理、区别与应用场景\"></a>一文读懂Cookie、Session和Token：原理、区别与应用场景</h1><p>咱上网冲浪的时候，天天和各种网站、APP打交道。但HTTP协议有个“毛病”——它记性不好，每次请求都像第一次见面，根本不记得之前和你聊过啥。为了解决这个问题，程序员们整出了<strong>Cookie</strong>、<strong>Session</strong>和<strong>Token</strong>这三个“神器”，它们就像我们在网络世界的身份证、通行证，帮服务器记住你是谁，都干了啥。今天咱就唠唠这仨到底是干啥的，有啥不一样！</p>\n<h2 id=\"一、Cookie、Session和Token都干啥用？\"><a href=\"#一、Cookie、Session和Token都干啥用？\" class=\"headerlink\" title=\"一、Cookie、Session和Token都干啥用？\"></a>一、Cookie、Session和Token都干啥用？</h2><h3 id=\"1-1-Cookie：浏览器帮你记事儿的小本本\"><a href=\"#1-1-Cookie：浏览器帮你记事儿的小本本\" class=\"headerlink\" title=\"1.1 Cookie：浏览器帮你记事儿的小本本\"></a>1.1 Cookie：浏览器帮你记事儿的小本本</h3><p>Cookie就是服务器给浏览器塞的小纸条，存的都是些用户信息，像登录状态、浏览偏好啥的。举个例子，你第一次进某个网站，选了中文界面、深色模式，下次再访问，网站秒变你喜欢的样子，这背后就是Cookie在偷偷“记笔记”。不过这小纸条存你电脑里，容易被人偷看，所以得小心点用！</p>\n<h3 id=\"1-2-Session：服务器的专属“私人档案库”\"><a href=\"#1-2-Session：服务器的专属“私人档案库”\" class=\"headerlink\" title=\"1.2 Session：服务器的专属“私人档案库”\"></a>1.2 Session：服务器的专属“私人档案库”</h3><p>Session相当于是服务器自己的“小账本”，专门用来存用户的会话数据。当你登录网站，服务器就给你开个“档案袋”，把你购物车有啥、订单到哪一步了这些信息全塞进去。但它咋知道这份档案归谁呢？靠的就是Cookie里的Session ID，相当于档案编号，浏览器每次带着编号来，服务器一看就知道：“哦！原来是你！”</p>\n<h3 id=\"1-3-Token：万能通行令牌\"><a href=\"#1-3-Token：万能通行令牌\" class=\"headerlink\" title=\"1.3 Token：万能通行令牌\"></a>1.3 Token：万能通行令牌</h3><p>Token就是服务器发的一串乱码“令牌”，你拿着它去访问网站的各种服务，就像拿着身份证证明“我是我”。Token最大的好处是不用服务器记太多东西，你每次来，它只需要验证令牌是真是假就行。现在流行的前后端分离、第三方登录，基本都靠Token“打天下”，移动端APP更是离了它不行。</p>\n<h2 id=\"二、Cookie、Session和Token，到底咋区分？\"><a href=\"#二、Cookie、Session和Token，到底咋区分？\" class=\"headerlink\" title=\"二、Cookie、Session和Token，到底咋区分？\"></a>二、Cookie、Session和Token，到底咋区分？</h2><h3 id=\"2-1-都藏在哪？能存多少东西？\"><a href=\"#2-1-都藏在哪？能存多少东西？\" class=\"headerlink\" title=\"2.1 都藏在哪？能存多少东西？\"></a>2.1 都藏在哪？能存多少东西？</h3><p>Cookie就住你电脑里，浏览器帮你保管。不过它个头很小气，一般不能超过4KB，而且一个网站最多也就存50个左右。<br>Session住在服务器那边，理论上想存多少存多少，但服务器空间有限，存太多也顶不住。<br>Token呢，既可以放在客户端（比如APP里），也能在每次请求的时候跟着一起“跑”，大小没严格限制，通常几百字节。</p>\n<h3 id=\"2-2-安不安全？容易被偷吗？\"><a href=\"#2-2-安不安全？容易被偷吗？\" class=\"headerlink\" title=\"2.2 安不安全？容易被偷吗？\"></a>2.2 安不安全？容易被偷吗？</h3><p>Cookie因为在客户端，就像放在桌子上的纸条，很容易被人篡改。不过可以给它加把锁：</p>\n<ul>\n<li><code>HttpOnly</code>让JavaScript读不到它</li>\n<li><code>Secure</code>保证它只在安全的HTTPS通道里传送</li>\n<li><code>SameSite</code>防止被别人“冒名顶替”发请求</li>\n</ul>\n<p>Session数据在服务器，相对安全些，但要是Session ID被坏人搞到手，也能冒充你。<br>Token用签名加密，一般改不了，但一旦被偷，坏人也能用，所以得设个有效期，到期就作废。</p>\n<h3 id=\"2-3-怎么在网络里“传送”？\"><a href=\"#2-3-怎么在网络里“传送”？\" class=\"headerlink\" title=\"2.3 怎么在网络里“传送”？\"></a>2.3 怎么在网络里“传送”？</h3><ul>\n<li>Cookie最“自觉”，浏览器每次发请求，都会自动把相关的Cookie带上，除非你特意限制它。</li>\n<li>Session得靠Cookie帮忙传递Session ID，虽然也能藏在URL里，但容易暴露，不太安全。</li>\n<li>Token就比较“自由”，常见的是放在请求头的<code>Authorization</code>字段里，也能塞到请求体或URL里，全看开发者咋安排。</li>\n</ul>\n<h3 id=\"2-4-能用多久？啥时候过期？\"><a href=\"#2-4-能用多久？啥时候过期？\" class=\"headerlink\" title=\"2.4 能用多久？啥时候过期？\"></a>2.4 能用多久？啥时候过期？</h3><ul>\n<li>Cookie想“活”多久，由服务器说了算。设置了<code>expires</code>或<code>max-age</code>，它就是“长寿型”，到期才失效；不设置的话，浏览器一关，它就“凉凉”。</li>\n<li>Session和Cookie里的Session ID绑在一起，服务器还会设个“闲置超时”，比如30分钟没操作，直接清空档案。</li>\n<li>Token出生的时候就被定好了“保质期”（像JWT的<code>exp</code>字段），过期就得重新申请新令牌。</li>\n</ul>\n<h3 id=\"2-5-能不能适应复杂的网络环境？\"><a href=\"#2-5-能不能适应复杂的网络环境？\" class=\"headerlink\" title=\"2.5 能不能适应复杂的网络环境？\"></a>2.5 能不能适应复杂的网络环境？</h3><p>要是网站用的是分布式系统（多个服务器协同工作），Cookie + Session组合就有点“吃力”。因为Session存在服务器里，多个服务器之间得同步数据，不然容易“认不出”用户。<br>Token就没这烦恼，它不需要服务器存啥，验证一下令牌是真是假就行，特别适合微服务、跨域这种复杂场景。</p>\n<h2 id=\"三、生活里都在哪见过它们？\"><a href=\"#三、生活里都在哪见过它们？\" class=\"headerlink\" title=\"三、生活里都在哪见过它们？\"></a>三、生活里都在哪见过它们？</h2><h3 id=\"3-1-Cookie的“日常工作”\"><a href=\"#3-1-Cookie的“日常工作”\" class=\"headerlink\" title=\"3.1 Cookie的“日常工作”\"></a>3.1 Cookie的“日常工作”</h3><ul>\n<li>刷新闻的时候，为啥总给你推爱看的内容？Cookie在“搞事情”！它记住了你的兴趣标签。</li>\n<li>还有电商网站没登录时加进购物车的商品，也是Cookie临时存着。不过拿Cookie做广告追踪得小心，一不小心就违反隐私规定了。</li>\n</ul>\n<h3 id=\"3-2-Session的“用武之地”\"><a href=\"#3-2-Session的“用武之地”\" class=\"headerlink\" title=\"3.2 Session的“用武之地”\"></a>3.2 Session的“用武之地”</h3><p>电商平台的购物车、订单状态，后台管理系统的用户权限，在线聊天的实时状态……这些对安全性、实时性要求高的场景，都是Session的主场。服务器随时能查看、修改你的会话数据，还能强制你下线，安全感拉满！</p>\n<h3 id=\"3-3-Token的“高光时刻”\"><a href=\"#3-3-Token的“高光时刻”\" class=\"headerlink\" title=\"3.3 Token的“高光时刻”\"></a>3.3 Token的“高光时刻”</h3><ul>\n<li>现在很多网站支持微信、GitHub一键登录，靠的就是Token在不同平台间“传话”。</li>\n<li>前后端分离项目里，前端和后端不在一个域名下，Token能轻松实现跨域认证。</li>\n<li>还有手机APP，没Cookie可用，Token就是它唯一的“身份认证官”。</li>\n</ul>\n<h2 id=\"四、到底该选谁？\"><a href=\"#四、到底该选谁？\" class=\"headerlink\" title=\"四、到底该选谁？\"></a>四、到底该选谁？</h2><p>简单来说：</p>\n<ul>\n<li>Cookie适合存点小偏好、临时数据</li>\n<li>Session适合对安全要求高、需要集中管理的场景</li>\n<li>Token则是跨域、移动端、微服务的“心头好”</li>\n</ul>\n<p>实际开发中，大家经常把它们搭配着用，比如用Cookie传Session ID，或者把Token藏在Cookie里，增强安全性。具体咋选，还得根据业务需求，综合考虑安全、性能这些因素，找到最适合的方案！</p>\n<p>要是你对哪个部分还有疑问，或者想知道更多实战技巧，欢迎随时来唠嗑！ </p>\n","excerpt":"","more":"<h1 id=\"一文读懂Cookie、Session和Token：原理、区别与应用场景\"><a href=\"#一文读懂Cookie、Session和Token：原理、区别与应用场景\" class=\"headerlink\" title=\"一文读懂Cookie、Session和Token：原理、区别与应用场景\"></a>一文读懂Cookie、Session和Token：原理、区别与应用场景</h1><p>咱上网冲浪的时候，天天和各种网站、APP打交道。但HTTP协议有个“毛病”——它记性不好，每次请求都像第一次见面，根本不记得之前和你聊过啥。为了解决这个问题，程序员们整出了<strong>Cookie</strong>、<strong>Session</strong>和<strong>Token</strong>这三个“神器”，它们就像我们在网络世界的身份证、通行证，帮服务器记住你是谁，都干了啥。今天咱就唠唠这仨到底是干啥的，有啥不一样！</p>\n<h2 id=\"一、Cookie、Session和Token都干啥用？\"><a href=\"#一、Cookie、Session和Token都干啥用？\" class=\"headerlink\" title=\"一、Cookie、Session和Token都干啥用？\"></a>一、Cookie、Session和Token都干啥用？</h2><h3 id=\"1-1-Cookie：浏览器帮你记事儿的小本本\"><a href=\"#1-1-Cookie：浏览器帮你记事儿的小本本\" class=\"headerlink\" title=\"1.1 Cookie：浏览器帮你记事儿的小本本\"></a>1.1 Cookie：浏览器帮你记事儿的小本本</h3><p>Cookie就是服务器给浏览器塞的小纸条，存的都是些用户信息，像登录状态、浏览偏好啥的。举个例子，你第一次进某个网站，选了中文界面、深色模式，下次再访问，网站秒变你喜欢的样子，这背后就是Cookie在偷偷“记笔记”。不过这小纸条存你电脑里，容易被人偷看，所以得小心点用！</p>\n<h3 id=\"1-2-Session：服务器的专属“私人档案库”\"><a href=\"#1-2-Session：服务器的专属“私人档案库”\" class=\"headerlink\" title=\"1.2 Session：服务器的专属“私人档案库”\"></a>1.2 Session：服务器的专属“私人档案库”</h3><p>Session相当于是服务器自己的“小账本”，专门用来存用户的会话数据。当你登录网站，服务器就给你开个“档案袋”，把你购物车有啥、订单到哪一步了这些信息全塞进去。但它咋知道这份档案归谁呢？靠的就是Cookie里的Session ID，相当于档案编号，浏览器每次带着编号来，服务器一看就知道：“哦！原来是你！”</p>\n<h3 id=\"1-3-Token：万能通行令牌\"><a href=\"#1-3-Token：万能通行令牌\" class=\"headerlink\" title=\"1.3 Token：万能通行令牌\"></a>1.3 Token：万能通行令牌</h3><p>Token就是服务器发的一串乱码“令牌”，你拿着它去访问网站的各种服务，就像拿着身份证证明“我是我”。Token最大的好处是不用服务器记太多东西，你每次来，它只需要验证令牌是真是假就行。现在流行的前后端分离、第三方登录，基本都靠Token“打天下”，移动端APP更是离了它不行。</p>\n<h2 id=\"二、Cookie、Session和Token，到底咋区分？\"><a href=\"#二、Cookie、Session和Token，到底咋区分？\" class=\"headerlink\" title=\"二、Cookie、Session和Token，到底咋区分？\"></a>二、Cookie、Session和Token，到底咋区分？</h2><h3 id=\"2-1-都藏在哪？能存多少东西？\"><a href=\"#2-1-都藏在哪？能存多少东西？\" class=\"headerlink\" title=\"2.1 都藏在哪？能存多少东西？\"></a>2.1 都藏在哪？能存多少东西？</h3><p>Cookie就住你电脑里，浏览器帮你保管。不过它个头很小气，一般不能超过4KB，而且一个网站最多也就存50个左右。<br>Session住在服务器那边，理论上想存多少存多少，但服务器空间有限，存太多也顶不住。<br>Token呢，既可以放在客户端（比如APP里），也能在每次请求的时候跟着一起“跑”，大小没严格限制，通常几百字节。</p>\n<h3 id=\"2-2-安不安全？容易被偷吗？\"><a href=\"#2-2-安不安全？容易被偷吗？\" class=\"headerlink\" title=\"2.2 安不安全？容易被偷吗？\"></a>2.2 安不安全？容易被偷吗？</h3><p>Cookie因为在客户端，就像放在桌子上的纸条，很容易被人篡改。不过可以给它加把锁：</p>\n<ul>\n<li><code>HttpOnly</code>让JavaScript读不到它</li>\n<li><code>Secure</code>保证它只在安全的HTTPS通道里传送</li>\n<li><code>SameSite</code>防止被别人“冒名顶替”发请求</li>\n</ul>\n<p>Session数据在服务器，相对安全些，但要是Session ID被坏人搞到手，也能冒充你。<br>Token用签名加密，一般改不了，但一旦被偷，坏人也能用，所以得设个有效期，到期就作废。</p>\n<h3 id=\"2-3-怎么在网络里“传送”？\"><a href=\"#2-3-怎么在网络里“传送”？\" class=\"headerlink\" title=\"2.3 怎么在网络里“传送”？\"></a>2.3 怎么在网络里“传送”？</h3><ul>\n<li>Cookie最“自觉”，浏览器每次发请求，都会自动把相关的Cookie带上，除非你特意限制它。</li>\n<li>Session得靠Cookie帮忙传递Session ID，虽然也能藏在URL里，但容易暴露，不太安全。</li>\n<li>Token就比较“自由”，常见的是放在请求头的<code>Authorization</code>字段里，也能塞到请求体或URL里，全看开发者咋安排。</li>\n</ul>\n<h3 id=\"2-4-能用多久？啥时候过期？\"><a href=\"#2-4-能用多久？啥时候过期？\" class=\"headerlink\" title=\"2.4 能用多久？啥时候过期？\"></a>2.4 能用多久？啥时候过期？</h3><ul>\n<li>Cookie想“活”多久，由服务器说了算。设置了<code>expires</code>或<code>max-age</code>，它就是“长寿型”，到期才失效；不设置的话，浏览器一关，它就“凉凉”。</li>\n<li>Session和Cookie里的Session ID绑在一起，服务器还会设个“闲置超时”，比如30分钟没操作，直接清空档案。</li>\n<li>Token出生的时候就被定好了“保质期”（像JWT的<code>exp</code>字段），过期就得重新申请新令牌。</li>\n</ul>\n<h3 id=\"2-5-能不能适应复杂的网络环境？\"><a href=\"#2-5-能不能适应复杂的网络环境？\" class=\"headerlink\" title=\"2.5 能不能适应复杂的网络环境？\"></a>2.5 能不能适应复杂的网络环境？</h3><p>要是网站用的是分布式系统（多个服务器协同工作），Cookie + Session组合就有点“吃力”。因为Session存在服务器里，多个服务器之间得同步数据，不然容易“认不出”用户。<br>Token就没这烦恼，它不需要服务器存啥，验证一下令牌是真是假就行，特别适合微服务、跨域这种复杂场景。</p>\n<h2 id=\"三、生活里都在哪见过它们？\"><a href=\"#三、生活里都在哪见过它们？\" class=\"headerlink\" title=\"三、生活里都在哪见过它们？\"></a>三、生活里都在哪见过它们？</h2><h3 id=\"3-1-Cookie的“日常工作”\"><a href=\"#3-1-Cookie的“日常工作”\" class=\"headerlink\" title=\"3.1 Cookie的“日常工作”\"></a>3.1 Cookie的“日常工作”</h3><ul>\n<li>刷新闻的时候，为啥总给你推爱看的内容？Cookie在“搞事情”！它记住了你的兴趣标签。</li>\n<li>还有电商网站没登录时加进购物车的商品，也是Cookie临时存着。不过拿Cookie做广告追踪得小心，一不小心就违反隐私规定了。</li>\n</ul>\n<h3 id=\"3-2-Session的“用武之地”\"><a href=\"#3-2-Session的“用武之地”\" class=\"headerlink\" title=\"3.2 Session的“用武之地”\"></a>3.2 Session的“用武之地”</h3><p>电商平台的购物车、订单状态，后台管理系统的用户权限，在线聊天的实时状态……这些对安全性、实时性要求高的场景，都是Session的主场。服务器随时能查看、修改你的会话数据，还能强制你下线，安全感拉满！</p>\n<h3 id=\"3-3-Token的“高光时刻”\"><a href=\"#3-3-Token的“高光时刻”\" class=\"headerlink\" title=\"3.3 Token的“高光时刻”\"></a>3.3 Token的“高光时刻”</h3><ul>\n<li>现在很多网站支持微信、GitHub一键登录，靠的就是Token在不同平台间“传话”。</li>\n<li>前后端分离项目里，前端和后端不在一个域名下，Token能轻松实现跨域认证。</li>\n<li>还有手机APP，没Cookie可用，Token就是它唯一的“身份认证官”。</li>\n</ul>\n<h2 id=\"四、到底该选谁？\"><a href=\"#四、到底该选谁？\" class=\"headerlink\" title=\"四、到底该选谁？\"></a>四、到底该选谁？</h2><p>简单来说：</p>\n<ul>\n<li>Cookie适合存点小偏好、临时数据</li>\n<li>Session适合对安全要求高、需要集中管理的场景</li>\n<li>Token则是跨域、移动端、微服务的“心头好”</li>\n</ul>\n<p>实际开发中，大家经常把它们搭配着用，比如用Cookie传Session ID，或者把Token藏在Cookie里，增强安全性。具体咋选，还得根据业务需求，综合考虑安全、性能这些因素，找到最适合的方案！</p>\n<p>要是你对哪个部分还有疑问，或者想知道更多实战技巧，欢迎随时来唠嗑！ </p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cmb6cfzp200082wup6kkdbh2b","category_id":"cmc6bkbeh00009wup9dwxcteb","_id":"cmc6bkbej00019wupetl0f1i9"},{"post_id":"cmbkxc9p00001koupe3jv27tn","category_id":"cmcbtzcup00002gup8w90c81j","_id":"cmcbtzcux00022gupghekgn82"},{"post_id":"cmbf62vvl000duoup8jpg6zb0","category_id":"cmc6bkbeh00009wup9dwxcteb","_id":"cmcbtzcuy00052gup6p4jc3et"},{"post_id":"cmbmg2vsx0000loup2bgwc9c7","category_id":"cmc6bkbeh00009wup9dwxcteb","_id":"cmcbtzcuz00062gup2qfu8k77"},{"post_id":"cmb0qjkpr000250up21mk5ky1","category_id":"cmcbtzcuv00012gup1hcads2f","_id":"cmcbtzcv000092gupg9u1aiz1"},{"post_id":"cmc0k7zum0000iwupcmfjci7e","category_id":"cmc6bkbeh00009wup9dwxcteb","_id":"cmcbtzcv0000a2gup43jf4xjf"},{"post_id":"cmcbtzcuy00042gup8b7mgn4o","category_id":"cmcbtzcuv00012gup1hcads2f","_id":"cmcbtzcv0000b2gup81g91she"},{"post_id":"cmb0qjkps000350up5hzhbjyl","category_id":"cmcbtzcux00032gup1x8e8jv9","_id":"cmcbtzcv1000d2gupepjx726k"},{"post_id":"cmb0qjkpt000450upatq31y8w","category_id":"cmcbtzcuv00012gup1hcads2f","_id":"cmcbtzcv1000f2gup9bz0dfu0"},{"post_id":"cmbni3a1f0003loup86tygfqi","category_id":"cmcbtzcuv00012gup1hcads2f","_id":"cmcbtzcv2000g2gup2w4khx62"},{"post_id":"cmckk1h8m0000ioup68xi86ww","category_id":"cmcbtzcuv00012gup1hcads2f","_id":"cmckk1h8t0004ioup20dx49pn"},{"post_id":"cmckk1h8m0000ioup68xi86ww","category_id":"cmckk1h8s0002ioup5v5243m1","_id":"cmckk1h8u0006ioupc83r0vw1"}],"PostTag":[{"post_id":"cmb6cfzp200082wup6kkdbh2b","tag_id":"cmb6cfzp300092wup9fpwexjc","_id":"cmb6cfzp3000b2wup6mt74cq0"},{"post_id":"cmb6cfzp200082wup6kkdbh2b","tag_id":"cmb6cfzp3000a2wup8g2385yb","_id":"cmb6cfzp4000c2wupea9s5kb8"},{"post_id":"cmb0qjkps000350up5hzhbjyl","tag_id":"cmbf62vvg0003uoup2o7zedgq","_id":"cmbf62vvh0009uoup72ef6c3z"},{"post_id":"cmb0qjkps000350up5hzhbjyl","tag_id":"cmbf62vvh0006uoup0d5m5abw","_id":"cmbf62vvh000auoup9dav49pj"},{"post_id":"cmb0qjkps000350up5hzhbjyl","tag_id":"cmbf62vvh0008uoup48omfr5u","_id":"cmbf62vvh000buoupabscd2mo"},{"post_id":"cmbf62vvl000duoup8jpg6zb0","tag_id":"cmb6cfzp300092wup9fpwexjc","_id":"cmbf62vvm000fuoupcdjedekl"},{"post_id":"cmbf62vvl000duoup8jpg6zb0","tag_id":"cmb6cfzp3000a2wup8g2385yb","_id":"cmbf62vvm000guoupbnc40kqn"},{"post_id":"cmb0qjkpt000450upatq31y8w","tag_id":"cmbf62vvk000cuoup58no4wg9","_id":"cmbf62vvm000iuoupd0c6aile"},{"post_id":"cmb0qjkpt000450upatq31y8w","tag_id":"cmbf62vvl000euoup01xd6gv8","_id":"cmbf62vvm000juoupeao4b54n"},{"post_id":"cmb0qjkpt000450upatq31y8w","tag_id":"cmbf62vvm000huoup9pzoe7pi","_id":"cmbf62vvm000kuoupg4w76bop"},{"post_id":"cmbkxc9ov0000koup1mpldhh3","tag_id":"cmb6cfzoz00002wupdyqs1vk1","_id":"cmbkxc9p20002koup31h77j44"},{"post_id":"cmbkxc9ov0000koup1mpldhh3","tag_id":"cmb6cfzp000012wupag44c8zo","_id":"cmbkxc9p20003kouph363203r"},{"post_id":"cmbkxc9ov0000koup1mpldhh3","tag_id":"cmb6cfzp100022wup8md954bi","_id":"cmbkxc9p20004koupe1p669ck"},{"post_id":"cmbkxc9ov0000koup1mpldhh3","tag_id":"cmb6cfzp100032wup85ts5je3","_id":"cmbkxc9p20005koup22a5dk71"},{"post_id":"cmbkxc9p00001koupe3jv27tn","tag_id":"cmbf62vve0000uoup3ixh4wp3","_id":"cmbkxc9p30006koupbykufueq"},{"post_id":"cmbkxc9p00001koupe3jv27tn","tag_id":"cmbf62vvg0001uoupb5206syj","_id":"cmbkxc9p30007koup7jwv0x9u"},{"post_id":"cmbkxc9p00001koupe3jv27tn","tag_id":"cmbf62vvg0002uoupdhpb5dtb","_id":"cmbkxc9p30008kouperbk499s"},{"post_id":"cmbmg2vsx0000loup2bgwc9c7","tag_id":"cmb6cfzp300092wup9fpwexjc","_id":"cmbmg2vsy0001loup9kl45x79"},{"post_id":"cmbmg2vsx0000loup2bgwc9c7","tag_id":"cmb6cfzp3000a2wup8g2385yb","_id":"cmbmg2vsy0002loup4c9lak8v"},{"post_id":"cmbni3a1f0003loup86tygfqi","tag_id":"cmbnpx65w0000h4upb6wi0i49","_id":"cmbnpx65x0002h4upcnqvhpz2"},{"post_id":"cmbni3a1f0003loup86tygfqi","tag_id":"cmbnpx65x0001h4upcb4re4cb","_id":"cmbnpx65y0003h4upfrjm2brz"},{"post_id":"cmc0k7zum0000iwupcmfjci7e","tag_id":"cmb6cfzp300092wup9fpwexjc","_id":"cmc0k7zuq0001iwup7m363e06"},{"post_id":"cmc0k7zum0000iwupcmfjci7e","tag_id":"cmb6cfzp3000a2wup8g2385yb","_id":"cmc0k7zuq0002iwup69df77p0"},{"post_id":"cmcbtzcuy00042gup8b7mgn4o","tag_id":"cmbf62vve0000uoup3ixh4wp3","_id":"cmcbtzcv0000c2gupenojh3y0"},{"post_id":"cmcbtzcuy00042gup8b7mgn4o","tag_id":"cmcbtzcuz00082gup0v4i7zk2","_id":"cmcbtzcv1000e2gup0hw41yn7"},{"post_id":"cmcexlrxm0000bcupenyp0yis","tag_id":"cmcexlrxn0001bcup7uj2bqen","_id":"cmcexlrxq0003bcupar1yhrxn"},{"post_id":"cmcexlrxm0000bcupenyp0yis","tag_id":"cmcexlrxp0002bcupamhsgwl8","_id":"cmcexlrxq0004bcup33uc9hjq"},{"post_id":"cmckk1h8m0000ioup68xi86ww","tag_id":"cmckk1h8q0001ioup9kw52rrn","_id":"cmckk1h8u0007ioup87on1p55"},{"post_id":"cmckk1h8m0000ioup68xi86ww","tag_id":"cmckk1h8t0003ioup81h67c3q","_id":"cmckk1h8u0008ioupbgkebiwe"},{"post_id":"cmckk1h8m0000ioup68xi86ww","tag_id":"cmckk1h8u0005ioup85mfglxq","_id":"cmckk1h8u0009ioup21154a92"}],"Tag":[{"name":"Javascript","_id":"cmb6cfzoz00002wupdyqs1vk1"},{"name":"Array","_id":"cmb6cfzp000012wupag44c8zo"},{"name":"Set","_id":"cmb6cfzp100022wup8md954bi"},{"name":"Map","_id":"cmb6cfzp100032wup85ts5je3"},{"name":"博客搭建","_id":"cmb6cfzp300092wup9fpwexjc"},{"name":"个人IP","_id":"cmb6cfzp3000a2wup8g2385yb"},{"name":"Vue","_id":"cmbf62vve0000uoup3ixh4wp3"},{"name":"源码阅读","_id":"cmbf62vvg0001uoupb5206syj"},{"name":"依赖收集","_id":"cmbf62vvg0002uoupdhpb5dtb"},{"name":"小程序","_id":"cmbf62vvg0003uoup2o7zedgq"},{"name":"微信云","_id":"cmbf62vvh0006uoup0d5m5abw"},{"name":"对象存储","_id":"cmbf62vvh0008uoup48omfr5u"},{"name":"Vite","_id":"cmbf62vvk000cuoup58no4wg9"},{"name":"Proxy","_id":"cmbf62vvl000euoup01xd6gv8"},{"name":"error","_id":"cmbf62vvm000huoup9pzoe7pi"},{"name":"Node安装","_id":"cmbnpx65w0000h4upb6wi0i49"},{"name":"npm","_id":"cmbnpx65x0001h4upcb4re4cb"},{"name":"组件","_id":"cmcbtzcuz00082gup0v4i7zk2"},{"name":"Web开发，Node","_id":"cmcexlrxn0001bcup7uj2bqen"},{"name":"packages","_id":"cmcexlrxp0002bcupamhsgwl8"},{"name":"Cookie","_id":"cmckk1h8q0001ioup9kw52rrn"},{"name":"Session","_id":"cmckk1h8t0003ioup81h67c3q"},{"name":"Token","_id":"cmckk1h8u0005ioup85mfglxq"}]}}