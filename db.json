{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/fluid.png","path":"img/fluid.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/boot.js","path":"js/boot.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/events.js","path":"js/events.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/plugins.js","path":"js/plugins.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/umami-view.js","path":"js/umami-view.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/drawn.jpg","path":"img/drawn.jpg","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/wild-fire.jpg","path":"img/wild-fire.jpg","modified":0,"renderable":1},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/baidu_verify_codeva-fVR3SShMVh.html","path":"baidu_verify_codeva-fVR3SShMVh.html","modified":0,"renderable":0},{"_id":"themes/fluid/source/img/favicon.jpg","path":"img/favicon.jpg","modified":0,"renderable":1},{"_id":"source/imgs/微信云对象存储..png","path":"imgs/微信云对象存储..png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog1/blog2.jpg","path":"imgs/build-blog1/blog2.jpg","modified":0,"renderable":0},{"_id":"source/imgs/build-blog1/blog1.jpg","path":"imgs/build-blog1/blog1.jpg","modified":0,"renderable":0},{"_id":"source/imgs/build-blog1/blog3.jpg","path":"imgs/build-blog1/blog3.jpg","modified":0,"renderable":0},{"_id":"source/imgs/build-blog1/blog4.jpg","path":"imgs/build-blog1/blog4.jpg","modified":0,"renderable":0},{"_id":"source/imgs/build-blog1/blog5.jpg","path":"imgs/build-blog1/blog5.jpg","modified":0,"renderable":0},{"_id":"source/imgs/build-blog1/blog6.jpg","path":"imgs/build-blog1/blog6.jpg","modified":0,"renderable":0},{"_id":"source/imgs/build-blogs2/my-sit.png","path":"imgs/build-blogs2/my-sit.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blogs2/step3.png","path":"imgs/build-blogs2/step3.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blogs2/step1.png","path":"imgs/build-blogs2/step1.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blogs2/step2.png","path":"imgs/build-blogs2/step2.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blogs2/step4.png","path":"imgs/build-blogs2/step4.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blogs2/step5.png","path":"imgs/build-blogs2/step5.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blogs2/step6.png","path":"imgs/build-blogs2/step6.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog1/step1.png","path":"imgs/build-blog1/step1.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/site-generator.png","path":"imgs/build-blog3/site-generator.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/site-generator2.png","path":"imgs/build-blog3/site-generator2.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/Node1.png","path":"imgs/build-blog3/Node1.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/Node2.png","path":"imgs/build-blog3/Node2.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/Node3.png","path":"imgs/build-blog3/Node3.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/Node4.png","path":"imgs/build-blog3/Node4.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/Node5.png","path":"imgs/build-blog3/Node5.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/NodeSite.png","path":"imgs/build-blog3/NodeSite.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/Node-folder.png","path":"imgs/build-blog3/Node-folder.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/step2.png","path":"imgs/build-blog3/step2.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/landscape.png","path":"imgs/build-blog3/landscape.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/environment1.png","path":"imgs/build-blog3/environment1.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/environment2.png","path":"imgs/build-blog3/environment2.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/environment3.png","path":"imgs/build-blog3/environment3.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/environment4.png","path":"imgs/build-blog3/environment4.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/environment5.png","path":"imgs/build-blog3/environment5.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/success.png","path":"imgs/build-blog3/success.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/md2html.png","path":"imgs/build-blog3/md2html.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/hexo.png","path":"imgs/build-blog3/hexo.png","modified":0,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":0,"renderable":0},{"_id":"source/b9845fe647a6579b4eb9925de54a5832.txt","path":"b9845fe647a6579b4eb9925de54a5832.txt","modified":0,"renderable":0},{"_id":"source/BingSiteAuth.xml","path":"BingSiteAuth.xml","modified":0,"renderable":0},{"_id":"source/imgs/build-blog4/actions.png","path":"imgs/build-blog4/actions.png","modified":0,"renderable":0},{"_id":"source/imgs/bad-code/en.jfif","path":"imgs/bad-code/en.jfif","modified":0,"renderable":0},{"_id":"source/imgs/web-history/CSS.png","path":"imgs/web-history/CSS.png","modified":0,"renderable":0},{"_id":"source/imgs/web-history/Javascript.png","path":"imgs/web-history/Javascript.png","modified":0,"renderable":0},{"_id":"source/imgs/web-history/PHP.png","path":"imgs/web-history/PHP.png","modified":0,"renderable":0},{"_id":"source/imgs/web-history/Jquery.png","path":"imgs/web-history/Jquery.png","modified":0,"renderable":0},{"_id":"source/imgs/web-history/TIM.png","path":"imgs/web-history/TIM.png","modified":0,"renderable":0},{"_id":"source/imgs/web-history/Vue.png","path":"imgs/web-history/Vue.png","modified":0,"renderable":0},{"_id":"source/imgs/web-history/first-web.jpg","path":"imgs/web-history/first-web.jpg","modified":0,"renderable":0},{"_id":"source/imgs/web-history/mvvm.jpg","path":"imgs/web-history/mvvm.jpg","modified":0,"renderable":0},{"_id":"source/imgs/daemon/panel.png","path":"imgs/daemon/panel.png","modified":0,"renderable":0},{"_id":"source/imgs/daemon/success.png","path":"imgs/daemon/success.png","modified":0,"renderable":0},{"_id":"source/imgs/daemon/logs.png","path":"imgs/daemon/logs.png","modified":0,"renderable":0},{"_id":"source/imgs/feature-of-fe/code.jpg","path":"imgs/feature-of-fe/code.jpg","modified":0,"renderable":0},{"_id":"source/imgs/feature-of-fe/design.jpg","path":"imgs/feature-of-fe/design.jpg","modified":0,"renderable":0},{"_id":"source/imgs/feature-of-fe/lang.jpeg","path":"imgs/feature-of-fe/lang.jpeg","modified":0,"renderable":0},{"_id":"source/imgs/feature-of-fe/tauri.png","path":"imgs/feature-of-fe/tauri.png","modified":0,"renderable":0},{"_id":"source/imgs/logo.png","path":"imgs/logo.png","modified":0,"renderable":0},{"_id":"source/imgs/logo2.jpg","path":"imgs/logo2.jpg","modified":0,"renderable":0},{"_id":"source/imgs/logo3.png","path":"imgs/logo3.png","modified":0,"renderable":0},{"_id":"source/imgs/react-vs-vue/learning-curves.jpg","path":"imgs/react-vs-vue/learning-curves.jpg","modified":0,"renderable":0},{"_id":"source/imgs/react-vs-vue/react-typescript.png","path":"imgs/react-vs-vue/react-typescript.png","modified":0,"renderable":0},{"_id":"source/imgs/react-vs-vue/react-vs-vue.png","path":"imgs/react-vs-vue/react-vs-vue.png","modified":0,"renderable":0},{"_id":"source/imgs/react-vs-vue/state.png","path":"imgs/react-vs-vue/state.png","modified":0,"renderable":0},{"_id":"source/imgs/react-vs-vue/vue-sfc.png","path":"imgs/react-vs-vue/vue-sfc.png","modified":0,"renderable":0},{"_id":"source/imgs/closure/example.png","path":"imgs/closure/example.png","modified":0,"renderable":0},{"_id":"source/imgs/closure/closure.png","path":"imgs/closure/closure.png","modified":0,"renderable":0},{"_id":"source/imgs/storage/guide2.png","path":"imgs/storage/guide2.png","modified":0,"renderable":0},{"_id":"source/imgs/storage/guide1.png","path":"imgs/storage/guide1.png","modified":0,"renderable":0},{"_id":"source/imgs/storage/guide3.png","path":"imgs/storage/guide3.png","modified":0,"renderable":0},{"_id":"source/imgs/storage/guide4.png","path":"imgs/storage/guide4.png","modified":0,"renderable":0},{"_id":"source/imgs/wxprogram/code.png","path":"imgs/wxprogram/code.png","modified":0,"renderable":0},{"_id":"source/imgs/storage/guide5.png","path":"imgs/storage/guide5.png","modified":0,"renderable":0},{"_id":"source/imgs/wxprogram/guide.png","path":"imgs/wxprogram/guide.png","modified":0,"renderable":0},{"_id":"source/imgs/wxprogram/result.png","path":"imgs/wxprogram/result.png","modified":0,"renderable":0},{"_id":"source/imgs/wxprogram/home.png","path":"imgs/wxprogram/home.png","modified":0,"renderable":0},{"_id":"source/imgs/wxprogram/微信小程序.png","path":"imgs/wxprogram/微信小程序.png","modified":0,"renderable":0},{"_id":"source/imgs/prototype/banner.png","path":"imgs/prototype/banner.png","modified":0,"renderable":0},{"_id":"source/imgs/baners/node.png","path":"imgs/baners/node.png","modified":0,"renderable":0},{"_id":"source/imgs/baners/numpy-in-node.jfif","path":"imgs/baners/numpy-in-node.jfif","modified":0,"renderable":0},{"_id":"source/imgs/baners/pinia.png","path":"imgs/baners/pinia.png","modified":0,"renderable":0},{"_id":"source/imgs/baners/team.jfif","path":"imgs/baners/team.jfif","modified":0,"renderable":0},{"_id":"source/imgs/baners/security.jfif","path":"imgs/baners/security.jfif","modified":0,"renderable":0},{"_id":"source/imgs/daemon/640.jfif","path":"imgs/daemon/640.jfif","modified":0,"renderable":0}],"Cache":[{"_id":"source/about/index.md","hash":"364ec52c99b2cc1874316e9ae5da6d564fd88671","modified":1750168462433},{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1747930697042},{"_id":"themes/fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1747229156000},{"_id":"themes/fluid/.editorconfig","hash":"b595159772f3ee1ef5e6780ce307270e741cb309","modified":1748000395336},{"_id":"themes/fluid/.gitattributes","hash":"3e00e1fb043438cd820d94ee3dc9ffb6718996f3","modified":1748000395336},{"_id":"themes/fluid/.gitignore","hash":"9ede98b8d9dca802f82f651afb3b0366d69f05f1","modified":1748000395339},{"_id":"themes/fluid/.eslintrc","hash":"3df89453e1f63051fafc90f16a8d83951050e316","modified":1748000395336},{"_id":"themes/fluid/package.json","hash":"fd6756866314aaf4b15d734a83b85aa09aa0b5ed","modified":1748000395362},{"_id":"themes/fluid/README_en.md","hash":"85656f2a23cc5e31420f0118bf5541b6e9f058b6","modified":1748000395341},{"_id":"themes/fluid/languages/en.yml","hash":"415e3403182e1282386f28b9d61343f147519163","modified":1748000395342},{"_id":"themes/fluid/README.md","hash":"b4bb8c50c0ce719b8cb37b7e3a899a9a1322c4fa","modified":1748000395340},{"_id":"themes/fluid/LICENSE","hash":"511e49f0bd8282a0d002c527474da8e1e5add393","modified":1748000395340},{"_id":"themes/fluid/languages/de.yml","hash":"f814263ded504cb4c50a8b66157bdd71f553be1b","modified":1748000395342},{"_id":"themes/fluid/languages/eo.yml","hash":"314b97a7e68093328675acfd308d839b1d772ac9","modified":1748000395342},{"_id":"themes/fluid/languages/es.yml","hash":"0ad94ddf1ca868a67b5b84aed257a30572962210","modified":1748000395343},{"_id":"themes/fluid/_config.yml","hash":"1ca96e7e827043470e59752c8b99453fe4d15751","modified":1756205895971},{"_id":"themes/fluid/layout/404.ejs","hash":"c49974dcbda02fe720498398e9778826335459c0","modified":1748000395344},{"_id":"themes/fluid/languages/ru.yml","hash":"998112b384b574e0e29c6ea16e4c1ebce1c15a4c","modified":1748000395343},{"_id":"themes/fluid/languages/ja.yml","hash":"65a90f294f6c73245e8250e87d124630ad10b389","modified":1748000395343},{"_id":"themes/fluid/languages/zh-CN.yml","hash":"497b3dea5058f718da225a7a443e916da895ea10","modified":1748000395343},{"_id":"themes/fluid/layout/archive.ejs","hash":"c524ce76747042ec2f9ed8d5025f80e01b462b3b","modified":1748000395359},{"_id":"themes/fluid/languages/zh-HK.yml","hash":"05418d0bca261de386872be65027bf4498758788","modified":1748000395344},{"_id":"themes/fluid/languages/zh-TW.yml","hash":"ded0621e63b1f8b241be21f6e9b52d4f36edbcd0","modified":1748000395344},{"_id":"themes/fluid/layout/categories.ejs","hash":"838a68e210bddfca6d4ba070e1e2f1ca53cb7d06","modified":1748000395360},{"_id":"themes/fluid/layout/category.ejs","hash":"264f68cbf826787e683a30e1377c56c0895c7386","modified":1748000395360},{"_id":"themes/fluid/layout/about.ejs","hash":"2f3ea36713f0fa91d8d61d39fcf9e584372de818","modified":1748000395359},{"_id":"themes/fluid/layout/page.ejs","hash":"8ba210724c023d45a4564415762f3da299bd1d0e","modified":1748000395361},{"_id":"themes/fluid/layout/index.ejs","hash":"dde1f6a27c8d09c38850a691089937f181b6c035","modified":1748000395360},{"_id":"themes/fluid/.github/workflows/cr.yaml","hash":"fc31c7c6692424af1e08cd5e273a5a5814f9c577","modified":1748000395339},{"_id":"themes/fluid/layout/layout.ejs","hash":"d4ffeb7eff398dea154340794bd277f75ddeedef","modified":1748000395361},{"_id":"themes/fluid/layout/tag.ejs","hash":"e87fc58829ea214ac16e8e4f13cd5c389133697b","modified":1748000395362},{"_id":"themes/fluid/layout/links.ejs","hash":"fbed4b3d1e475b3de9d8ce05362abcc658a53408","modified":1748000395361},{"_id":"themes/fluid/.github/workflows/limit.yaml","hash":"bdbdb66da69ab7353b546f02150a6792f4787975","modified":1748000395339},{"_id":"themes/fluid/.github/workflows/publish.yaml","hash":"dcdbe1698a6ee61f741c29ef560f859f66ffa32c","modified":1748000395339},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"7db378613df2b7d13e8c428c006399a879a4a852","modified":1748000395338},{"_id":"themes/fluid/layout/post.ejs","hash":"c8da695dc1b01b715909ae6f1052ccaebdf9db4c","modified":1748000395361},{"_id":"themes/fluid/layout/tags.ejs","hash":"b7c1a6d8fc1097fc16d2300260297013cb692153","modified":1748000395362},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"7d7c1e5a1da6b4f7be6685beb4798ec76d5efd31","modified":1748000395337},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"fea63a9a5c3befd8783705eed09adf1b596a6203","modified":1748000395337},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"5cc30e7b6e7b77c8b40b182ba02a5d93d37d2fc2","modified":1748000395338},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"07e24578c25fcaca94618fd86569887dadf7a276","modified":1748000395338},{"_id":"themes/fluid/layout/_partials/category-chains.ejs","hash":"508254a648d8597e62e4012c8beab44bfa82e904","modified":1748000395345},{"_id":"themes/fluid/layout/_partials/archive-list.ejs","hash":"78c34e32746041f23678669bbadfbede15e4c6d2","modified":1748000395345},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question.md","hash":"102213e5d6790d060c0e26b4a3a7ec744d753c52","modified":1748000395338},{"_id":"themes/fluid/layout/_partials/comments.ejs","hash":"1ce9094faec6204949cdaf604aaf9200787e4218","modified":1748000395346},{"_id":"themes/fluid/layout/_partials/category-list.ejs","hash":"0c14869e15f7dc615c8353765569644238f38f2d","modified":1748000395345},{"_id":"themes/fluid/layout/_partials/footer.ejs","hash":"6bb3335b5486d4bee2ed42f8bef57903066bc234","modified":1748000395350},{"_id":"themes/fluid/layout/_partials/header.ejs","hash":"3668304d08c48b68d532532921a12069a2736150","modified":1748000395352},{"_id":"themes/fluid/layout/_partials/css.ejs","hash":"901280e6fb3194c30542751d04f27e78b42d3c6f","modified":1748000395350},{"_id":"themes/fluid/layout/_partials/head.ejs","hash":"a0bcbbfc34efaef3b23c6b531e7f3201f2eab2dd","modified":1748000395351},{"_id":"themes/fluid/scripts/events/index.js","hash":"6c3b24207e4ea3ae4edeb715af40ef23711b92b9","modified":1748000395363},{"_id":"themes/fluid/scripts/filters/default-injects.js","hash":"3d30c722b9e24c33577d6fab822628841fadf992","modified":1748000395366},{"_id":"themes/fluid/layout/_partials/paginator.ejs","hash":"0d443f23c459787338917900f50fec1c8b3b3bdd","modified":1748000395353},{"_id":"themes/fluid/scripts/generators/index-generator.js","hash":"3550976efc94500284795f13485f5a1765fc120b","modified":1748000395367},{"_id":"themes/fluid/scripts/filters/locals.js","hash":"2340a576635b16fd2456b3494f5afe89cd7764db","modified":1748000395366},{"_id":"themes/fluid/layout/_partials/markdown-plugins.ejs","hash":"b5cd435b27f090939b6051bef41a38a3376044ac","modified":1748000395353},{"_id":"themes/fluid/scripts/filters/post-filter.js","hash":"67637461e3f94f9e9675369eb7ff015355d9ec54","modified":1748000395367},{"_id":"themes/fluid/scripts/generators/local-search.js","hash":"33427308ca29f1d76336c83e704571c9de75df02","modified":1748000395367},{"_id":"themes/fluid/scripts/generators/pages.js","hash":"3fb72d3c2224c32d861a6e8a85e78a8b67e6a244","modified":1748000395368},{"_id":"themes/fluid/scripts/tags/button.js","hash":"e1d0caed12e7cd9a35cf64272c41854b2901a58f","modified":1748000395371},{"_id":"themes/fluid/source/css/highlight-dark.styl","hash":"c74d7aed425d20f2fa096f386a9521b67b9ab269","modified":1748000395389},{"_id":"themes/fluid/layout/_partials/scripts.ejs","hash":"89fc9f663a1091911b79ab9697c09446d16184f9","modified":1748000395358},{"_id":"themes/fluid/layout/_partials/search.ejs","hash":"57a0f61242d9ce2bd2c51b2f84193f6dc1377ef9","modified":1748000395359},{"_id":"themes/fluid/scripts/tags/checkbox.js","hash":"1ff4ea054f2c735dfaccb0be90f1708a2a750bc8","modified":1748000395372},{"_id":"themes/fluid/source/css/highlight.styl","hash":"57ce8b8f95ab1f40612a9dce1793de5ab9b4bbfc","modified":1748000395390},{"_id":"themes/fluid/scripts/tags/fold.js","hash":"a93e2603021ad38714e870399767bea24e7cbe3e","modified":1748000395372},{"_id":"themes/fluid/scripts/tags/label.js","hash":"6c5916d86c63795c7e910bf614b0e7ece5073702","modified":1748000395373},{"_id":"themes/fluid/source/css/main.styl","hash":"9e9171325bb7148c11ceee283d00c137c8a1c5c5","modified":1748000395390},{"_id":"themes/fluid/scripts/tags/group-image.js","hash":"cc176cc1d7e7cc28cedf8397ae748c691d140be2","modified":1748000395372},{"_id":"themes/fluid/scripts/tags/note.js","hash":"e300ec4ee6c63464859ab000e987bf8dd7db4025","modified":1748000395373},{"_id":"themes/fluid/source/css/gitalk.css","hash":"1fe60b2ab1d704f5a4f55e700dca5b8785fb390e","modified":1748000395389},{"_id":"themes/fluid/scripts/tags/mermaid.js","hash":"dbfe59fde77d87b1d7d0c46480a2a729010988eb","modified":1748000395373},{"_id":"themes/fluid/scripts/helpers/date.js","hash":"9bc9ba08d1d871394ee1c3a1cc2f21dc343f515a","modified":1748000395368},{"_id":"themes/fluid/scripts/helpers/import.js","hash":"f9821f7789ea6f069977a8c642aa5ccb6d19077c","modified":1748000395369},{"_id":"themes/fluid/scripts/helpers/engine.js","hash":"96af7e55fdbe0819bacc554ecbfe42375a088df6","modified":1748000395368},{"_id":"themes/fluid/scripts/helpers/export-config.js","hash":"14a207a7d4e329382ab5d4e1da1ef85ff043daba","modified":1748000395368},{"_id":"themes/fluid/scripts/helpers/injects.js","hash":"9219d59c51930c7a82fcde918d6efbc5aa572ea2","modified":1748000395369},{"_id":"themes/fluid/scripts/helpers/page.js","hash":"49b2c6449d7be35739c6cfea3cab4e790580983a","modified":1748000395369},{"_id":"themes/fluid/scripts/helpers/scope.js","hash":"3b67d50050158423c8fa47f1de6aedcfe916637b","modified":1748000395370},{"_id":"themes/fluid/scripts/helpers/url.js","hash":"f713ddb6c8018ec7b96d3567057f1f932609beea","modified":1748000395370},{"_id":"themes/fluid/scripts/helpers/utils.js","hash":"f57be245e6e7228673e1dec3a3477e731492c5c1","modified":1748000395370},{"_id":"themes/fluid/scripts/helpers/wordcount.js","hash":"0bb33314aa5cfe326ab9bb14b545e343e4db4193","modified":1748000395371},{"_id":"themes/fluid/scripts/utils/compare-versions.js","hash":"37f90bd4e35ce49457dc2a348b9f66e0b242c014","modified":1748000395374},{"_id":"themes/fluid/scripts/utils/crypto.js","hash":"474b00a57f43dbe7bc2876d637ece4214d016c06","modified":1748000395374},{"_id":"themes/fluid/scripts/utils/object.js","hash":"3e03b534e2e92a6e17567b006d7e3eaad4b37598","modified":1748000395374},{"_id":"themes/fluid/scripts/utils/resolve.js","hash":"a5d70005913ab03cea0a0dc601097628b4dbd5a8","modified":1748000395375},{"_id":"themes/fluid/scripts/utils/url-join.js","hash":"dbdb10b23fcd3928e86a4cb46fa3455e060b4aa0","modified":1748000395375},{"_id":"themes/fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1747229156000},{"_id":"themes/fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1747229156000},{"_id":"themes/fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1747229156000},{"_id":"themes/fluid/source/js/boot.js","hash":"33bb7c8255d2e3c93a1bea8c9221399b3a868a63","modified":1748000395393},{"_id":"themes/fluid/source/js/img-lazyload.js","hash":"67f6250f98b36a6599ea982d11cbb060c5ffb92a","modified":1748000395394},{"_id":"themes/fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1747229156000},{"_id":"themes/fluid/source/js/color-schema.js","hash":"e7addcc88eb73dec4a9a8641a4bb68966a38a65d","modified":1748000395393},{"_id":"themes/fluid/source/js/events.js","hash":"3efd602cdb694902d6e74c4eb1e5bd70120ac5b1","modified":1748000395394},{"_id":"themes/fluid/source/js/leancloud.js","hash":"e9ad1b5659f0af867174687daa0ecf4375e40b75","modified":1748000395394},{"_id":"themes/fluid/source/js/local-search.js","hash":"491021125d2579e841c83f36d3ab790d1eab9d1e","modified":1748000395395},{"_id":"themes/fluid/source/js/plugins.js","hash":"753c2cf95f2659fef80277b895f4da10c8888c72","modified":1748000395395},{"_id":"themes/fluid/source/js/umami-view.js","hash":"370ab30ab88c596d85327dbd7db3bafd49489fdd","modified":1748000395395},{"_id":"themes/fluid/layout/_partials/comments/changyan.ejs","hash":"0c410ef79785897c8de3da333b057a2936fd569b","modified":1748000395346},{"_id":"themes/fluid/source/xml/local-search.xml","hash":"85fcc23b4db654a7f91fc55b6fb0442bb3ed3a9a","modified":1748000395396},{"_id":"themes/fluid/source/js/utils.js","hash":"9d0423db40a787f3b19968205b9ed92a848c9153","modified":1748000395396},{"_id":"themes/fluid/layout/_partials/comments/discuss.ejs","hash":"d400e5721af28cefecaf50b46c82dcdde4cda4a8","modified":1748000395347},{"_id":"themes/fluid/layout/_partials/comments/cusdis.ejs","hash":"1e93ca89777e4beb0f0e5cb70e03aab48e958542","modified":1748000395346},{"_id":"themes/fluid/layout/_partials/comments/gitalk.ejs","hash":"7f04e5c22821bb94da791973d9c6692b03bac81d","modified":1748000395347},{"_id":"themes/fluid/layout/_partials/comments/livere.ejs","hash":"bcceafab01fe695c59951d939f7cef502f3d7b48","modified":1748000395348},{"_id":"themes/fluid/layout/_partials/comments/giscus.ejs","hash":"66995ec9dab10ed35c2a775010c447113c6848d4","modified":1748000395347},{"_id":"themes/fluid/layout/_partials/comments/disqus.ejs","hash":"79ec17eec6e15076c685688e740230e92c66efa9","modified":1748000395347},{"_id":"themes/fluid/layout/_partials/header/banner.ejs","hash":"a84d8dcb44f5f6289ef09db4d02ab14de72c2c87","modified":1748000395352},{"_id":"themes/fluid/layout/_partials/comments/remark42.ejs","hash":"45c879768b40ba56af62e18ad54bffbf73a6f3a1","modified":1748000395348},{"_id":"themes/fluid/layout/_partials/comments/twikoo.ejs","hash":"938eb60413ae8af83ffeaba4d85df88387cdd5be","modified":1748000395349},{"_id":"themes/fluid/layout/_partials/comments/utterances.ejs","hash":"d7bcc183fc31af643e7835b13da10fe2ab8614ce","modified":1748000395349},{"_id":"themes/fluid/layout/_partials/comments/valine.ejs","hash":"ef04d4fc3f26588ae9d8712938d648304fc05455","modified":1748000395349},{"_id":"themes/fluid/layout/_partials/comments/waline.ejs","hash":"df6bae1a93827991049f7a33f6a69681c60eab0e","modified":1748000395349},{"_id":"themes/fluid/layout/_partials/header/navigation.ejs","hash":"e5219b14410066bf8ab491379aca797304b4a914","modified":1748000395352},{"_id":"themes/fluid/layout/_partials/footer/statistics.ejs","hash":"047bece1db5cdf96cb78a44c6420ce3e92e6a9ca","modified":1748000395351},{"_id":"themes/fluid/layout/_partials/footer/beian.ejs","hash":"77d0c9df31a22ed8a3e341637bde4165a11a7ce9","modified":1748000395351},{"_id":"themes/fluid/layout/_partials/plugins/code-widget.ejs","hash":"03c7c69fbb1754fdccfa18671aac23b8637b869e","modified":1748000395354},{"_id":"themes/fluid/layout/_partials/plugins/analytics.ejs","hash":"f8fe8e58b83f627db82c0dbeb663389efc33c1c6","modified":1748000395353},{"_id":"themes/fluid/layout/_partials/plugins/encrypt.ejs","hash":"018cab52ff696a6c78ebc01e10237a90a0c33603","modified":1748000395354},{"_id":"themes/fluid/layout/_partials/plugins/fancybox.ejs","hash":"3900e54ade140e0e49c571a1955f0b1f3a59b281","modified":1748000395354},{"_id":"themes/fluid/layout/_partials/plugins/anchorjs.ejs","hash":"8a4ea62c46f9a75c94096a27b2d3f5c10a2f82e5","modified":1748000395354},{"_id":"themes/fluid/layout/_partials/plugins/highlight.ejs","hash":"502b99e19e496825df7032ca2b0b1a95ebb2b357","modified":1748000395355},{"_id":"themes/fluid/layout/_partials/plugins/mermaid.ejs","hash":"110e45e2d3433178f00f482adc863110f90c46d6","modified":1748000395355},{"_id":"themes/fluid/layout/_partials/plugins/nprogress.ejs","hash":"47c1df255aa552ad71ef3e57deca46530a8f2802","modified":1748000395356},{"_id":"themes/fluid/layout/_partials/post/category-bar.ejs","hash":"551ffae43844925beb099c85a9e6d8d9fcbf8086","modified":1748000395356},{"_id":"themes/fluid/layout/_partials/post/meta-bottom.ejs","hash":"f0cb813cd03642c9b68cff8b6669f73a61dd10f8","modified":1748000395357},{"_id":"themes/fluid/layout/_partials/plugins/math.ejs","hash":"d0f06fb482e3a8f9a53dfd94c4e4a65a43f1ff34","modified":1748000395355},{"_id":"themes/fluid/layout/_partials/plugins/moment.ejs","hash":"acc72c3284fe906a4505132c3d9a4720d80e6fcb","modified":1748000395355},{"_id":"themes/fluid/layout/_partials/plugins/typed.ejs","hash":"42850952e8f5858497fe774c2aff87b6563ab01e","modified":1748000395356},{"_id":"themes/fluid/layout/_partials/post/sidebar-left.ejs","hash":"db4ecdcc762bb1b1bae5060f0baa6115174779ff","modified":1748000395357},{"_id":"themes/fluid/scripts/events/lib/compatible-configs.js","hash":"31208a0db986ba864f756a8ec806b7d254440f9b","modified":1748000395363},{"_id":"themes/fluid/layout/_partials/post/copyright.ejs","hash":"26905d5862b1531ebcc175af15178dabeecc81c8","modified":1748000395357},{"_id":"themes/fluid/layout/_partials/post/sidebar-right.ejs","hash":"2507cdad08f61cf8c1d9b0ca7f4f1dc8c4e5841b","modified":1748000395358},{"_id":"themes/fluid/layout/_partials/post/meta-top.ejs","hash":"73827074db4e0fc3d52c51a76285df87aa5e5a7f","modified":1748000395357},{"_id":"themes/fluid/scripts/events/lib/footnote.js","hash":"9b1934c61dc78622a07da554413f6ad31854576d","modified":1748000395364},{"_id":"themes/fluid/scripts/events/lib/hello.js","hash":"da987411ae4a4e6896a9b8af1fce6209192af28e","modified":1748000395364},{"_id":"themes/fluid/layout/_partials/post/toc.ejs","hash":"1b1eb4c8e163a5d909e86da76ef778948e0e0b77","modified":1748000395358},{"_id":"themes/fluid/scripts/events/lib/highlight.js","hash":"d103e4bf612b2445bb136712d57b81e784a313e2","modified":1748000395364},{"_id":"themes/fluid/scripts/events/lib/injects.js","hash":"92123b7280695b4ac6650f5e1d7fa0d772c71f5b","modified":1748000395365},{"_id":"themes/fluid/scripts/events/lib/lazyload.js","hash":"c9696633f77dd8055e900497469f9e64eca4d97f","modified":1748000395365},{"_id":"themes/fluid/source/css/_functions/base.styl","hash":"171697018fd384fce0834875ca94b91f16564cac","modified":1748000395376},{"_id":"themes/fluid/scripts/events/lib/merge-configs.js","hash":"ec6bf395ccad3dd41f29dc0080aeabf413e30fd9","modified":1748000395366},{"_id":"themes/fluid/source/css/_mixins/base.styl","hash":"046979dbd8cdabd21d89f9c1d8f1bb3f2fd06d6f","modified":1748000395376},{"_id":"themes/fluid/source/css/_pages/pages.styl","hash":"92c062cf55457b6549497244d09ec34e9c0c95c2","modified":1748000395388},{"_id":"themes/fluid/source/css/_pages/_about/about.styl","hash":"8ba5fb6a8ced1de6f7893184bf12f4021fe22595","modified":1748000395377},{"_id":"themes/fluid/source/css/_pages/_archive/archive.styl","hash":"e3846fb429f6732bd15fde40f7c28b3492d786c8","modified":1748000395377},{"_id":"themes/fluid/source/css/_variables/base.styl","hash":"9ea66cf79f1e4356b6b402bc3dc5fb55c9862f1f","modified":1748000395389},{"_id":"themes/fluid/source/css/_pages/_category/category-bar.styl","hash":"f35415bd86b5c26fbc71728048d9e1481263554f","modified":1748000395384},{"_id":"themes/fluid/source/css/_pages/_base/base.styl","hash":"cd255079553985722ee80fb1833f6507dde52194","modified":1748000395383},{"_id":"themes/fluid/source/css/_pages/_base/color-schema.styl","hash":"66d5b045c0e54001d3c98c5901d72590fe08acc4","modified":1748000395383},{"_id":"themes/fluid/source/css/_pages/_base/inline.styl","hash":"96c3bb95dea4b3d3ecd20b810a674bfcef04870c","modified":1748000395383},{"_id":"themes/fluid/source/css/_pages/_base/print.styl","hash":"571bd018e914bd0f7c5f89df874b5937937e5fa6","modified":1748000395384},{"_id":"themes/fluid/source/css/_pages/_base/keyframes.styl","hash":"58a7f8f2baea2d58cf5f7edfc91314ee5d7156ca","modified":1748000395383},{"_id":"themes/fluid/source/css/_pages/_index/index.styl","hash":"bac20c8fb20276b08972df5ecc7a5850a72393f4","modified":1748000395385},{"_id":"themes/fluid/source/css/_pages/_category/category-chain.styl","hash":"4263f7b930e6b57e13295d17fd3745a9e5c52494","modified":1748000395384},{"_id":"themes/fluid/source/css/_pages/_category/category-list.styl","hash":"d3aeb7bf22d52d7dde59b292090ef8b46943718a","modified":1748000395385},{"_id":"themes/fluid/source/css/_pages/_links/links.styl","hash":"d3ef491fd449d89a1b95801dee788a5d9bec4320","modified":1748000395385},{"_id":"themes/fluid/source/css/_pages/_post/highlight.styl","hash":"d73cccb65eaa804910884df17442e34736b3f4fb","modified":1748000395386},{"_id":"themes/fluid/source/css/_pages/_post/comment.styl","hash":"1fc96d09d52d9502e84e4e2a8d482ea45e8b81ea","modified":1748000395386},{"_id":"themes/fluid/source/css/_pages/_tag/tags.styl","hash":"29e9b72cfda2f2baf9cf2597fcd7f9e66303a9bd","modified":1748000395388},{"_id":"themes/fluid/source/css/_pages/_post/markdown.styl","hash":"2d12f23b46d0ce07ae810bc4f5635c490a098fa4","modified":1748000395387},{"_id":"themes/fluid/source/css/_pages/_post/post-page.styl","hash":"6a35a450bd0a12f68fd92aac3f88b23475a98d46","modified":1748000395387},{"_id":"themes/fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"26d65475b1c52a61115044db8883df6739c3a473","modified":1748000395378},{"_id":"themes/fluid/source/css/_pages/_post/post-tag.styl","hash":"31c64c3fae4a0fc4747d8afeb72f7a9667c5326c","modified":1748000395387},{"_id":"themes/fluid/source/css/_pages/_base/_widget/board.styl","hash":"1068d71721baeed76bf0176f9b964d36b5764c9f","modified":1748000395378},{"_id":"themes/fluid/source/css/_pages/_base/_widget/banner.styl","hash":"80301db38e448e40e88bb34d0128628b0809b243","modified":1748000395378},{"_id":"themes/fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"417a7388b39c0203178b0032e151febd66a0e9f3","modified":1748000395379},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"41935973a66c14ab2bea0539d4b1f15c62534fa4","modified":1748000395380},{"_id":"themes/fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"3ac1eb36e124adef607775aa505386d5680960e2","modified":1748000395379},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footer.styl","hash":"e6f5921ff9009c1853e7db30c482bc1682433ed9","modified":1748000395379},{"_id":"themes/fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"48799d3148ef6493be0e05897c635124e9b05d03","modified":1748000395381},{"_id":"themes/fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"8fad325e411bc83c8ebdc4115015477eed5f60da","modified":1748000395381},{"_id":"themes/fluid/source/css/_pages/_base/_widget/header.styl","hash":"88c3c2d99a097142a87eeec0c7c65a3789f25117","modified":1748000395380},{"_id":"themes/fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"f4ae7cbf2f10f459de7864f8e642553b587df889","modified":1748000395381},{"_id":"themes/fluid/source/css/_pages/_base/_widget/modal.styl","hash":"0ca6171ce262339e0e36cfea0978b554d87ae7fc","modified":1748000395380},{"_id":"themes/fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"04447d3b673be84a1af1dc57933a3c41dd7c0cfe","modified":1748000395381},{"_id":"themes/fluid/source/css/_pages/_base/_widget/search.styl","hash":"1f4e678d7219815ab62de1b92ec75e021247f90b","modified":1748000395382},{"_id":"themes/fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"e4dbbbb1a2508a72bc04680552d7ebbea0eed0fe","modified":1748000395382},{"_id":"themes/fluid/source/css/_pages/_base/_widget/toc.styl","hash":"5defef321e3e933fe84f3f2ca481c88f55381fb0","modified":1748000395382},{"_id":"themes/fluid/source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1747229156000},{"_id":"source/_posts/Array-set-map summary.md","hash":"36e53f01c4d0cd6b6f8100879302ebfe2f5f4ab4","modified":1748339859500},{"_id":"source/_posts/Dependencies-collecting of vue3.md","hash":"3cd52b2c0a9f4d73a52e0a6c277dd0097b73af59","modified":1748341041034},{"_id":"source/_posts/Differences-between-two-kinds-inherit-approches.md","hash":"ac525492c30241456bdf98946b0da402d8962c4d","modified":1750515374913},{"_id":"source/_posts/Vite-server-error.md","hash":"c07a5fa240f0986d682e67da5e09ff77c8ee50e8","modified":1750515416740},{"_id":"source/_posts/Manage-wx-could-service.md","hash":"2d53f528712b111a646a8f086e2d277023b925af","modified":1750515404677},{"_id":"public/local-search.xml","hash":"947b9f39ccdca841cb12dab02b2201e12a45134a","modified":1749475390375},{"_id":"public/about/index.html","hash":"a60cbf77a80e2519d2ca1da35b18d1229f15c113","modified":1749810743260},{"_id":"public/archives/index.html","hash":"6289737198577aba4144ad61fea5b78ea961be0d","modified":1749810743260},{"_id":"public/archives/2025/index.html","hash":"8b7350d817ba07193ee3d6a1446a60ccce146f97","modified":1749810743260},{"_id":"public/archives/2025/05/index.html","hash":"298a5f3d70097cacae6eb79555de0b1211d490c0","modified":1749810743260},{"_id":"public/404.html","hash":"6cb75f8d6165349e79d0c7318db154dd3294377c","modified":1749810743260},{"_id":"public/tags/index.html","hash":"46e78f961e252e68dcb2d4bda28d9e315d598575","modified":1749810743260},{"_id":"public/categories/index.html","hash":"b482e9495303a051eab82a210c774de2ab99f412","modified":1749810743260},{"_id":"public/links/index.html","hash":"8195d3ce63c82fbe0b188f3e42c7de151beb2b04","modified":1749810743260},{"_id":"public/2025/05/23/Vite-server-error/index.html","hash":"309bbba15bc120ee37ef672b31243fb7fd474c47","modified":1748071533101},{"_id":"public/2025/05/23/Dependencies-collecting of vue3/index.html","hash":"5725e4d0e48383682516d632deeba5180d76c7d0","modified":1748071533101},{"_id":"public/2025/05/23/Differences-between-two-kinds-inherit-approches/index.html","hash":"c54ad69352b37b3086d1a6f5a2d7f2c54a82a319","modified":1748071533101},{"_id":"public/2025/05/23/Manage-wx-could-service/index.html","hash":"41393f6be44e648e529f056f75ede8793ddc3ba6","modified":1748071533101},{"_id":"public/2025/05/23/Array-set-map summary/index.html","hash":"786108c45cedfb827bc7bc43814969e754cd7090","modified":1748071533101},{"_id":"public/index.html","hash":"12afc221f68e82ce035bf16a740210d9ae2b8d1c","modified":1749810743260},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1749475390375},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1749475390375},{"_id":"public/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1749475390375},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1749475390375},{"_id":"public/xml/local-search.xml","hash":"85fcc23b4db654a7f91fc55b6fb0442bb3ed3a9a","modified":1749475390375},{"_id":"public/css/highlight-dark.css","hash":"902294bada4323c0f51502d67cba8c3a0298952f","modified":1749475390375},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1749475390375},{"_id":"public/css/highlight.css","hash":"04d4ddbb5e1d1007447c2fe293ee05aae9b9563e","modified":1749475390375},{"_id":"public/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1749475390375},{"_id":"public/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1749475390375},{"_id":"public/js/color-schema.js","hash":"1ef88c881b9f942deadde3d890387b94c617342a","modified":1749475390375},{"_id":"public/js/events.js","hash":"6869811f67e4c3de3edfa4b08464bb242b97a402","modified":1749475390375},{"_id":"public/js/local-search.js","hash":"b9945f76f8682f3ec32edfb285b26eb559f7b7e8","modified":1749475390375},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1749475390375},{"_id":"public/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1749475390375},{"_id":"public/js/utils.js","hash":"b82e7c289a66dfd36064470fd41c0e96fc598b43","modified":1749475390375},{"_id":"public/js/umami-view.js","hash":"33c4b3883fa747604074ad3921606eeeaeb50716","modified":1749475390375},{"_id":"public/css/main.css","hash":"14ebd9b515085666cee29bbcbe362ad3604ab62a","modified":1749475390375},{"_id":"public/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1749475390375},{"_id":"themes/fluid/source/img/drawn.jpg","hash":"a8afab014b63afa5e2c043eb7b50ecba6b03edfb","modified":1748007916979},{"_id":"themes/fluid/source/img/wild-fire.jpg","hash":"a032903bb422e1d524a190a19b02b0031dc87b91","modified":1749654949932},{"_id":"source/CNAME","hash":"d675053c77f7d0d901b00e800fba6471d1083778","modified":1749478124195},{"_id":"source/baidu_verify_codeva-fVR3SShMVh.html","hash":"09e554351f969b229ae91d76101bae10651bb03e","modified":1748071350688},{"_id":"public/CNAME","hash":"d675053c77f7d0d901b00e800fba6471d1083778","modified":1749566624299},{"_id":"public/baidu_verify_codeva-fVR3SShMVh.html","hash":"09e554351f969b229ae91d76101bae10651bb03e","modified":1749475390375},{"_id":"public/img/drawn.jpg","hash":"a8afab014b63afa5e2c043eb7b50ecba6b03edfb","modified":1749475390375},{"_id":"public/img/wild-fire.jpg","hash":"82061013d2890c5b73b0b5eee565836c13e5223a","modified":1749475390375},{"_id":"public/sitemap.xml","hash":"bcab51d74c4616eaa7ad5bd1e916741fa52c2abd","modified":1749810743260},{"_id":"themes/fluid/source/img/favicon.jpg","hash":"4d9939b7432e3123a74eb5ed0826decfa218654e","modified":1742396857314},{"_id":"source/imgs/微信云对象存储..png","hash":"7b056d08b21247c00d5cbd834717fb39d98cb9ec","modified":1742395108314},{"_id":"source/_imgs/微信云对象存储..png","hash":"7b056d08b21247c00d5cbd834717fb39d98cb9ec","modified":1742395108314},{"_id":"source/_posts/build-personal-blog-1.md","hash":"ce1e4de8c412297c576cd57c7d7176dca36c69fc","modified":1756203276206},{"_id":"source/imgs/build-blog1/blog1.jpg","hash":"cd119385d9f85524aeb92a1c3cdac16ca712118f","modified":1748271496822},{"_id":"source/imgs/build-blog1/blog2.jpg","hash":"088f470ce2f0c902c5115d1e4891f473a6445d55","modified":1748272050586},{"_id":"source/imgs/build-blog1/blog4.jpg","hash":"bc8543254d3656f309148392d9145f26ba13d79c","modified":1748272272567},{"_id":"source/imgs/build-blog1/blog5.jpg","hash":"9bee4e5c47c165fe9d6398bc7c1da75a9d94b730","modified":1748272314963},{"_id":"source/imgs/build-blog1/blog6.jpg","hash":"077be667affcb34f66cba6385aa759c0e37b3a2d","modified":1748272596664},{"_id":"source/imgs/build-blog1/blog3.jpg","hash":"20f8f6d4a7e06e9f33cbd43d5a45e09a4b477081","modified":1748272066872},{"_id":"source/_posts/build-personal-blog2.md","hash":"9da5d15d9544b126b0b9b65a60c6d66a457ce3e7","modified":1756203322050},{"_id":"source/imgs/build-blogs2/step6.png","hash":"86d9ba02ef7752faa3e24aaef96077948158029e","modified":1748793429848},{"_id":"source/imgs/build-blogs2/step3.png","hash":"2b02a0b60c175b40b26bcab15a4ced3b98cf3e0b","modified":1748792345120},{"_id":"source/imgs/build-blogs2/step2.png","hash":"d3986fd605c513604b613b33fffe08558b533cc2","modified":1748791166898},{"_id":"source/imgs/build-blogs2/step4.png","hash":"29c14be4e9e80b8635d499750f5194cfa6b5acd2","modified":1748792483283},{"_id":"source/imgs/build-blogs2/step5.png","hash":"a5c84254c295a7d601e0018ac4b3037099f606d3","modified":1748792530326},{"_id":"source/imgs/build-blogs2/step1.png","hash":"db8d892d97fbc6980c201f5ec38a3f7a24bd85c3","modified":1748791038005},{"_id":"source/imgs/build-blog1/step1.png","hash":"711d482f34bc57def949dca2218da0a1e3f6bc9a","modified":1748789955181},{"_id":"source/imgs/build-blogs2/my-sit.png","hash":"cf76b3e7a36c6cf1d27efa4d40f63439f561f3ea","modified":1748794050495},{"_id":"source/_posts/Array-set-map-summary.md","hash":"36e53f01c4d0cd6b6f8100879302ebfe2f5f4ab4","modified":1748341041034},{"_id":"source/_posts/Dependencies-collecting-of-vue3.md","hash":"23b30f23d8950924b3dfa2568d14c149070e6c19","modified":1750515344943},{"_id":"source/_posts/build-personal-blog3.md","hash":"989f6947aeb5f8bcb14772358d02fd20b8d82a2b","modified":1756203397605},{"_id":"source/_posts/install-node.md","hash":"41e1e34333830887130fab76207628f597e1d6b7","modified":1756205527157},{"_id":"source/imgs/build-blog3/Node3.png","hash":"97193904adddd2b64a742b36d4ac28052fc68117","modified":1749376123921},{"_id":"source/imgs/build-blog3/Node1.png","hash":"591ef5e5fdb097108293f893a631501931e67b38","modified":1749376075356},{"_id":"source/imgs/build-blog3/Node4.png","hash":"f5c3cfad516dd22e56ed076181feb8fc1366e8b8","modified":1749376186987},{"_id":"source/imgs/build-blog3/Node5.png","hash":"3fd0511638d580b100a713ea6113195f798fb71e","modified":1749376235077},{"_id":"source/imgs/build-blog3/Node2.png","hash":"614523f08d105749081b439f647461a137fcbc6c","modified":1749376096117},{"_id":"source/imgs/build-blog3/Node-folder.png","hash":"ffde5efeff9f43940e304e0ddb41359d9ca5a669","modified":1749377154488},{"_id":"source/imgs/build-blog3/step2.png","hash":"f5f6e40335355783484b68f65af0084e8e24673d","modified":1749378859093},{"_id":"source/imgs/build-blog3/NodeSite.png","hash":"f329461b13550c1d5250051abb17f8f86dbb525d","modified":1749376642259},{"_id":"source/imgs/build-blog3/site-generator.png","hash":"ac0ac0acf6baf61cd8f4f1e7224a9a073b7487cc","modified":1749373197931},{"_id":"source/imgs/build-blog3/site-generator2.png","hash":"fd7f96858fa44b04a3889a70128f060f51a8f5d7","modified":1749373231119},{"_id":"source/imgs/build-blog3/landscape.png","hash":"004c644178862bb6b1a88f2aec28c2c798a5f297","modified":1749381480640},{"_id":"source/imgs/build-blog3/hexo.png","hash":"24ab106e07dc9e398585bb6cc8a97e0bf835524c","modified":1749474595463},{"_id":"source/imgs/build-blog3/success.png","hash":"bf98fd9d229170cf98f0bc36a997df939a60c894","modified":1749474595487},{"_id":"source/imgs/build-blog3/environment3.png","hash":"b781ebc267a5f2356718ed7cc4d69bf0ddf50a95","modified":1749474595459},{"_id":"source/imgs/build-blog3/environment2.png","hash":"6742c24212564b134aa4450dab74360bdd581832","modified":1749474595455},{"_id":"source/imgs/build-blog3/environment5.png","hash":"00b40562694443e0b0be7303a9c8bac4e92ef0d0","modified":1749474595463},{"_id":"source/imgs/build-blog3/environment4.png","hash":"dba3ff701e1101b3176a524b82561ab581c391d5","modified":1749474595459},{"_id":"source/imgs/build-blog3/md2html.png","hash":"7c7eae0c82cb87699e3540c85d07454ff1a1668f","modified":1749474595475},{"_id":"source/imgs/build-blog3/environment1.png","hash":"dabc596a066194027aec024f042d060ea00e2fed","modified":1749474595451},{"_id":"source/robot.txt","hash":"85504474b6ea499f464150f39b13dd09c09353ae","modified":1749478196270},{"_id":"public/baidu_urls.txt","hash":"6f807e83ebc10ef39022f28374fcb452e15d0d15","modified":1749810743260},{"_id":"public/archives/2025/06/index.html","hash":"c9b297c61720314ce7cdd7c98f94dfbfd5e06c69","modified":1749810743260},{"_id":"public/tags/Javascript/index.html","hash":"7b773c8bf5b1b2b05092a08d3cfc62cb9252e47f","modified":1749810743260},{"_id":"public/tags/Array/index.html","hash":"01cfb57b481e136e1a64c0374688138c5f3156e0","modified":1749810743260},{"_id":"public/tags/Set/index.html","hash":"b36ebc92ac131008561c17aefa433c4b0a8c1eec","modified":1749810743260},{"_id":"public/tags/Map/index.html","hash":"8b9772c03d0e82c518c7be1d1971f1e72c881474","modified":1749810743260},{"_id":"public/tags/博客搭建/index.html","hash":"9ddd17d6816737b8823afa13e74163f3455c0af1","modified":1749810743260},{"_id":"public/tags/个人IP/index.html","hash":"8e8fb8bc52f44d6e4afb9352945dd4d63b7a681e","modified":1749810743260},{"_id":"public/tags/Vue/index.html","hash":"81da78d2265f361999afb2dab5bf1b0ae6cf61cf","modified":1749810743260},{"_id":"public/tags/源码阅读/index.html","hash":"4874c5c6341ead53b520bd629eaa00954927d59d","modified":1749810743260},{"_id":"public/tags/依赖收集/index.html","hash":"31b8df578129bd05668346cff0ece1bc1d897566","modified":1749810743260},{"_id":"public/tags/小程序/index.html","hash":"43f1d7649e351e512400297333d2bcdaa7e1ef9f","modified":1749810743260},{"_id":"public/tags/微信云/index.html","hash":"04929fcb2ecc00563bb1b675900d7322bdfe506a","modified":1749810743260},{"_id":"public/tags/对象存储/index.html","hash":"381f34c38e7b8df1870a3e314ac079bb8518d056","modified":1749810743260},{"_id":"public/tags/Vite/index.html","hash":"ac963974f495cf2547aaef6aba0af7118dd58712","modified":1749810743260},{"_id":"public/tags/Proxy/index.html","hash":"361493da5dbbcab59289647b7b7ed6dab558b2fb","modified":1749810743260},{"_id":"public/tags/error/index.html","hash":"0781a7be95480ef3b36ecdd18da69feb0dce3737","modified":1749810743260},{"_id":"public/posts/install-node.html","hash":"3ceeab4203cfffde9d4143b7d5e3a1181817b746","modified":1749810743260},{"_id":"public/posts/build-personal-blog3.html","hash":"d3fc42356a24af241d69e7b5d26e04080e9bf826","modified":1749810743260},{"_id":"public/posts/build-personal-blog2.html","hash":"f6b869e429d29162f52e8bfa81e054a3a427ae13","modified":1749810743260},{"_id":"public/posts/build-personal-blog-1.html","hash":"b092603f7a8b34c28bfade591abca7b5f9a1e6e7","modified":1749810743260},{"_id":"public/posts/Differences-between-two-kinds-inherit-approches.html","hash":"4784e937ae208a27de85b6eefa1d0c75c52e42a6","modified":1749810743260},{"_id":"public/posts/Manage-wx-could-service.html","hash":"8f53960ba2465339ba296489dcb975329af55ad7","modified":1749810743260},{"_id":"public/posts/Vite-server-error.html","hash":"3aeb337dfa6107a2692b39154ab08d6ed8d6b113","modified":1749810743260},{"_id":"public/posts/Array-set-map-summary.html","hash":"58fbacfb3cdce037635b189ea033462261b0382c","modified":1749810743260},{"_id":"public/posts/Dependencies-collecting-of-vue3.html","hash":"174de09d990e327fe28b1f45df06ad75dd758cd9","modified":1749810743260},{"_id":"public/tags/Node安装/index.html","hash":"bc9e120a1ec84657397fd62ad97a29faed8e516e","modified":1749810743260},{"_id":"public/tags/npm/index.html","hash":"60bc7838da9cfa4c640b72964ce1db5bb4e5aebb","modified":1749810743260},{"_id":"public/imgs/微信云对象存储..png","hash":"7b056d08b21247c00d5cbd834717fb39d98cb9ec","modified":1749475390375},{"_id":"public/img/favicon.jpg","hash":"4d9939b7432e3123a74eb5ed0826decfa218654e","modified":1749475390375},{"_id":"public/imgs/build-blogs2/step6.png","hash":"86d9ba02ef7752faa3e24aaef96077948158029e","modified":1749475390375},{"_id":"public/imgs/build-blog3/Node1.png","hash":"591ef5e5fdb097108293f893a631501931e67b38","modified":1749475390375},{"_id":"public/imgs/build-blog3/Node2.png","hash":"614523f08d105749081b439f647461a137fcbc6c","modified":1749475390375},{"_id":"public/imgs/build-blog3/Node3.png","hash":"97193904adddd2b64a742b36d4ac28052fc68117","modified":1749475390375},{"_id":"public/imgs/build-blog3/Node4.png","hash":"f5c3cfad516dd22e56ed076181feb8fc1366e8b8","modified":1749475390375},{"_id":"public/imgs/build-blog3/Node5.png","hash":"3fd0511638d580b100a713ea6113195f798fb71e","modified":1749475390375},{"_id":"public/imgs/build-blog3/step2.png","hash":"f5f6e40335355783484b68f65af0084e8e24673d","modified":1749475390375},{"_id":"public/robot.txt","hash":"85504474b6ea499f464150f39b13dd09c09353ae","modified":1749566624299},{"_id":"public/imgs/build-blog3/success.png","hash":"bf98fd9d229170cf98f0bc36a997df939a60c894","modified":1749475390375},{"_id":"public/imgs/build-blog3/hexo.png","hash":"24ab106e07dc9e398585bb6cc8a97e0bf835524c","modified":1749475390375},{"_id":"public/imgs/build-blogs2/step3.png","hash":"2b02a0b60c175b40b26bcab15a4ced3b98cf3e0b","modified":1749475390375},{"_id":"public/imgs/build-blog3/environment2.png","hash":"6742c24212564b134aa4450dab74360bdd581832","modified":1749475390375},{"_id":"public/imgs/build-blog3/environment4.png","hash":"dba3ff701e1101b3176a524b82561ab581c391d5","modified":1749475390375},{"_id":"public/imgs/build-blog3/environment3.png","hash":"b781ebc267a5f2356718ed7cc4d69bf0ddf50a95","modified":1749475390375},{"_id":"public/imgs/build-blog3/md2html.png","hash":"7c7eae0c82cb87699e3540c85d07454ff1a1668f","modified":1749475390375},{"_id":"public/imgs/build-blog3/environment5.png","hash":"00b40562694443e0b0be7303a9c8bac4e92ef0d0","modified":1749475390375},{"_id":"public/imgs/build-blogs2/step4.png","hash":"29c14be4e9e80b8635d499750f5194cfa6b5acd2","modified":1749475390375},{"_id":"public/imgs/build-blogs2/step5.png","hash":"a5c84254c295a7d601e0018ac4b3037099f606d3","modified":1749475390375},{"_id":"public/imgs/build-blogs2/step2.png","hash":"d3986fd605c513604b613b33fffe08558b533cc2","modified":1749475390375},{"_id":"public/imgs/build-blog3/site-generator.png","hash":"ac0ac0acf6baf61cd8f4f1e7224a9a073b7487cc","modified":1749475390375},{"_id":"public/imgs/build-blog3/Node-folder.png","hash":"ffde5efeff9f43940e304e0ddb41359d9ca5a669","modified":1749475390375},{"_id":"public/imgs/build-blogs2/step1.png","hash":"db8d892d97fbc6980c201f5ec38a3f7a24bd85c3","modified":1749475390375},{"_id":"public/imgs/build-blog3/site-generator2.png","hash":"fd7f96858fa44b04a3889a70128f060f51a8f5d7","modified":1749475390375},{"_id":"public/imgs/build-blog3/NodeSite.png","hash":"f329461b13550c1d5250051abb17f8f86dbb525d","modified":1749475390375},{"_id":"public/imgs/build-blog1/blog5.jpg","hash":"9bee4e5c47c165fe9d6398bc7c1da75a9d94b730","modified":1749475390375},{"_id":"public/imgs/build-blog1/blog1.jpg","hash":"cd119385d9f85524aeb92a1c3cdac16ca712118f","modified":1749475390375},{"_id":"public/imgs/build-blog1/step1.png","hash":"711d482f34bc57def949dca2218da0a1e3f6bc9a","modified":1749475390375},{"_id":"public/imgs/build-blog1/blog2.jpg","hash":"088f470ce2f0c902c5115d1e4891f473a6445d55","modified":1749475390375},{"_id":"public/imgs/build-blog3/environment1.png","hash":"dabc596a066194027aec024f042d060ea00e2fed","modified":1749475390375},{"_id":"public/imgs/build-blog1/blog4.jpg","hash":"bc8543254d3656f309148392d9145f26ba13d79c","modified":1749475390375},{"_id":"public/imgs/build-blog3/landscape.png","hash":"004c644178862bb6b1a88f2aec28c2c798a5f297","modified":1749475390375},{"_id":"public/imgs/build-blog1/blog6.jpg","hash":"077be667affcb34f66cba6385aa759c0e37b3a2d","modified":1749475390375},{"_id":"public/imgs/build-blog1/blog3.jpg","hash":"20f8f6d4a7e06e9f33cbd43d5a45e09a4b477081","modified":1749475390375},{"_id":"public/imgs/build-blogs2/my-sit.png","hash":"cf76b3e7a36c6cf1d27efa4d40f63439f561f3ea","modified":1749475390375},{"_id":"source/robots.txt","hash":"6b7a2f0efb2c683cc187a15d7116e0512abb49db","modified":1750166927517},{"_id":"source/b9845fe647a6579b4eb9925de54a5832.txt","hash":"0c0d17b5ae2a2d38d7f2816c34c3fcfa428905cd","modified":1749811078175},{"_id":"public/b9845fe647a6579b4eb9925de54a5832.txt","hash":"0c0d17b5ae2a2d38d7f2816c34c3fcfa428905cd","modified":1749811080846},{"_id":"source/BingSiteAuth.xml","hash":"f2d151fb6d0d33ba6f3085c226173a069f7a44b3","modified":1749822925946},{"_id":"source/_posts/build-personal-blog4.md","hash":"c4f720bdb45a455c3bbd6b1e5f409054ca62daca","modified":1756203472503},{"_id":"source/imgs/build-blog4/actions.png","hash":"1b70af9d8e9d18633673ce52232de076a1183c5c","modified":1749998280512},{"_id":"source/_posts/component-versatility.md","hash":"6548e5262592a0b0dc432a842b988e97dc5792c5","modified":1756205485343},{"_id":"source/_posts/node-numpy.md","hash":"9cb5abc87e2e9ad12548b4b4f2b8011c0a6cced9","modified":1756205323926},{"_id":"source/imgs/bad-code/en.jfif","hash":"188a8854a6bc25f91bd11fdafc4c0e1677facce3","modified":1750860915463},{"_id":"source/_posts/cookie-session-token.md","hash":"ceac46ba870ee8f5bd0ada36220dbc9452ef4a07","modified":1756205245358},{"_id":"source/_posts/from-vuex-to-pinia.md","hash":"995019992999e361529a41b1f5edc091736d40d5","modified":1756205094544},{"_id":"source/_posts/web-history.md","hash":"94ee3ef8b8058ef6045c14bd14c22181c6f3abf6","modified":1756204979644},{"_id":"source/imgs/web-history/Jquery.png","hash":"7eeff8a957fa4310749a0539f1d4c5171d70bac6","modified":1752130958000},{"_id":"source/imgs/web-history/mvvm.jpg","hash":"f93e7beac9c523011765dbc86c30ecdbcda749ef","modified":1752130958000},{"_id":"source/imgs/web-history/Vue.png","hash":"31ee1ee2bf2549c94e49fcb2bd0973e6fd22e983","modified":1752130958000},{"_id":"source/imgs/web-history/Javascript.png","hash":"bb5ce5f403fa84dc917e67c5e8bcef99d847c55a","modified":1752130958000},{"_id":"source/imgs/web-history/first-web.jpg","hash":"0385aea7f11a5bd36064b023be7db33446bee564","modified":1752130958000},{"_id":"source/imgs/web-history/TIM.png","hash":"3764af453e357422acd111028d0604c16c24f31e","modified":1752130958000},{"_id":"source/imgs/web-history/PHP.png","hash":"ddc971427b31f16b2849c5ef365cd5783b6e8e60","modified":1752130958000},{"_id":"source/imgs/web-history/CSS.png","hash":"68722626e90661e58d8d70aea0d4c7ef7f205310","modified":1752130958000},{"_id":"source/_posts/create-daemond-with-node.md","hash":"18c4cf9e0a6aecf22e40e24812499153c95f738a","modified":1756204878347},{"_id":"source/imgs/daemon/logs.png","hash":"a52b8162631181b06240065140b18a2fd151af7b","modified":1752676512894},{"_id":"source/imgs/daemon/success.png","hash":"3705a479ee1f7732005745010fdb932d5770bccb","modified":1752676334367},{"_id":"source/imgs/daemon/panel.png","hash":"dbb9bcdc3ce3e1dd68cd00a895cb6eb9682a56fc","modified":1752676664056},{"_id":"source/_posts/future-of-front-end-development.md","hash":"7ce24098e6119da7bf32085d8f4b626ecf91bb6d","modified":1756204573808},{"_id":"source/imgs/feature-of-fe/lang.jpeg","hash":"842a2fac1442e1bc153b9ce382dc7199cbbb2ef6","modified":1753802527737},{"_id":"source/imgs/feature-of-fe/tauri.png","hash":"1eccc2041fd297f37242b596c423ad3a0ab00a92","modified":1753803111348},{"_id":"source/imgs/feature-of-fe/design.jpg","hash":"2f9ee72f52f923d28c6fa84d307b9aa361d05b30","modified":1753802354727},{"_id":"source/imgs/feature-of-fe/code.jpg","hash":"014831bca5aee59361946f39581694ff202ca432","modified":1753802388536},{"_id":"source/_posts/vue-vs-react.md","hash":"b12d3a8f811217caa903995f595df553d27e461a","modified":1756204484957},{"_id":"source/imgs/react-vs-vue/state.png","hash":"476d3196cc29af23a0d9d622ce0276b93b8419ac","modified":1754812127803},{"_id":"source/imgs/logo2.jpg","hash":"43db145f370066b409657f6cbc72066b9a80ab9b","modified":1754793304886},{"_id":"source/imgs/react-vs-vue/vue-sfc.png","hash":"2f9c75b3df25cf3b39aa238fc638e4c87210f3fe","modified":1754812007972},{"_id":"source/imgs/react-vs-vue/learning-curves.jpg","hash":"a96e5d140b329ef4d315be86bfdcc5fef61bc74b","modified":1754812249178},{"_id":"source/imgs/react-vs-vue/react-typescript.png","hash":"ffb5e383ec31e82b598f2f36958bed31043f2dcc","modified":1754812163909},{"_id":"source/imgs/react-vs-vue/react-vs-vue.png","hash":"11b26c61e83179607579b7cb46f9be895ecc18e7","modified":1754811783954},{"_id":"source/imgs/logo.png","hash":"dfe5c04010702e83ca532f263ee05475ad4972b7","modified":1754793331996},{"_id":"source/imgs/logo3.png","hash":"4a231b2e2619c10f6221916531b3fe616a1d990c","modified":1754793332004},{"_id":"source/_posts/closure.md","hash":"bc69c16db68ce3948a59d970ed35c396e12883b4","modified":1756204460653},{"_id":"source/imgs/closure/example.png","hash":"39c4e640211ae404aff09e786f4eaabaeafd111e","modified":1755177199407},{"_id":"source/_posts/my-first-miniprogram.md","hash":"71ab8e3f7a5633c3fe8423140ecafca32d710c63","modified":1756204372772},{"_id":"source/imgs/storage/guide2.png","hash":"d22bc8b48c052328c915ceedf3197f2ecad7c421","modified":1755524478343},{"_id":"source/imgs/storage/guide3.png","hash":"bb0e7b63867574111fbf56c272f1a9c120dd8091","modified":1755524495773},{"_id":"source/imgs/storage/guide1.png","hash":"40063f5727247047c17e15278db7cd9d8676ec16","modified":1755524462497},{"_id":"source/imgs/storage/guide5.png","hash":"5352338be3c9d037db61f06f85012f237a33bc2e","modified":1755524526328},{"_id":"source/imgs/storage/guide4.png","hash":"ca818923e0710d7dce22a4b9efd7fe132554a5ef","modified":1755524510231},{"_id":"source/imgs/wxprogram/微信小程序.png","hash":"85328f753a67e28325e1238116d58dc4196b3b55","modified":1755782493793},{"_id":"source/imgs/wxprogram/home.png","hash":"f64667e8ed97af94d71caae78ced11a04eb627db","modified":1755781406325},{"_id":"source/imgs/wxprogram/guide.png","hash":"9abb5734938fc9d2b9f22441fb1cbbb903bda3d5","modified":1755781468570},{"_id":"source/imgs/wxprogram/code.png","hash":"957787d277d208385220438a53f8fa20a78bef86","modified":1755782305966},{"_id":"source/imgs/wxprogram/result.png","hash":"575adc55fd5bcbe6b43fd4c235720eda36a763c4","modified":1755781585939},{"_id":"source/imgs/closure/closure.png","hash":"f5ffcdaf87cac085f01ad2aedbc05ced0a834b9a","modified":1755178395213},{"_id":"source/_posts/prototype-in-js.md","hash":"d7f4463d1486301b788a591210080e13dacbefbb","modified":1756203659250},{"_id":"source/imgs/prototype/banner.png","hash":"c6ebbbc76a0cd9f2bd6686920bbc784bceeb75f2","modified":1756133212845},{"_id":"source/_posts/last-popular-article.md","hash":"8f0c2368d05d833bc7f0521f6c4c16c9687cb60e","modified":1756822984597},{"_id":"source/imgs/baners/numpy-in-node.jfif","hash":"e8608b8747d462372f6408d9a50520611cdfd1d6","modified":1756205300972},{"_id":"source/imgs/baners/team.jfif","hash":"7d1bdd0f22c5f4b5bed862053a7dc3d6d557057e","modified":1756205453672},{"_id":"source/imgs/baners/security.jfif","hash":"50868db14ab1cace7811692132c9f5a528600ce1","modified":1756205192630},{"_id":"source/imgs/baners/pinia.png","hash":"8cb6221ba32b09859f0dbd0b7aa63237790b0c5f","modified":1756205075751},{"_id":"source/imgs/daemon/640.jfif","hash":"5404707c6f2e2394dd6262503c827b464fa7d14d","modified":1756204838017},{"_id":"source/imgs/baners/node.png","hash":"179615e8d144bb30aefca1270d517dbf82ea6338","modified":1756205508214},{"_id":"source/_posts/self-improve.md","hash":"c5dc7f03a9bb81370abe98a5bed3d001cf236a75","modified":1760625404383},{"_id":"source/_posts/about-software-charges.md","hash":"caab9c8504140333526a5577ad0c25800f99716b","modified":1758718037888},{"_id":"source/_posts/bottleneck-porid.md","hash":"0c6035b414887af17bfb4f78e7e5639c67aa2d5b","modified":1760884393103}],"Category":[{"name":"搭建博客","_id":"cmc6bkbeh00009wup9dwxcteb"},{"name":"Vue源码阅读","_id":"cmcbtzcup00002gup8w90c81j"},{"name":"Web开发","_id":"cmcbtzcuv00012gup1hcads2f"},{"name":"小程序开发","_id":"cmcbtzcux00032gup1x8e8jv9"},{"name":"网络安全","parent":"cmcbtzcuv00012gup1hcads2f","_id":"cmckk1h8s0002ioup5v5243m1"}],"Data":[],"Page":[{"title":"about","date":"2025-05-23T04:55:03.000Z","_content":"## Hi there 👋 ![](https://komarev.com/ghpvc/?username=jvxiao&color=blue&style=plastic)\n\n<!--\n**jvxiao/jvxiao** is a ✨ _special_ ✨ repository because its `README.md` (this file) appears on your GitHub profile.\n\nHere are some ideas to get you started:\n\n- 🔭 I’m currently working on ...\n- 🌱 I’m currently learning ...\n- 👯 I’m looking to collaborate on ...\n- 🤔 I’m looking for help with ...\n- 💬 Ask me about ...\n- 📫 How to reach me: ... \n- 😄 Pronouns: ...\n- ⚡ Fun fact: ...\n-->\n\nHi, I am Jovin Xiao, as known as jvxiao, a full-time front-end developer. In the past few years, I have mainly used Vue and Node to complete my development work. \n\nIn my spare time, I enjoy learning new things and creating some very interesting projects. If you like my projects, please don't hesitate to give me a star or kindly consider [sponsoring me by afdian](https://afdian.com/a/jvxiao).\n\nFeel free to contact me.\n\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2025-05-23 12:55:03\n---\n## Hi there 👋 ![](https://komarev.com/ghpvc/?username=jvxiao&color=blue&style=plastic)\n\n<!--\n**jvxiao/jvxiao** is a ✨ _special_ ✨ repository because its `README.md` (this file) appears on your GitHub profile.\n\nHere are some ideas to get you started:\n\n- 🔭 I’m currently working on ...\n- 🌱 I’m currently learning ...\n- 👯 I’m looking to collaborate on ...\n- 🤔 I’m looking for help with ...\n- 💬 Ask me about ...\n- 📫 How to reach me: ... \n- 😄 Pronouns: ...\n- ⚡ Fun fact: ...\n-->\n\nHi, I am Jovin Xiao, as known as jvxiao, a full-time front-end developer. In the past few years, I have mainly used Vue and Node to complete my development work. \n\nIn my spare time, I enjoy learning new things and creating some very interesting projects. If you like my projects, please don't hesitate to give me a star or kindly consider [sponsoring me by afdian](https://afdian.com/a/jvxiao).\n\nFeel free to contact me.\n\n","updated":"2025-06-17T13:54:22.433Z","path":"about/index.html","_id":"cmb0bvn9s0001hwupchmoepb5","comments":1,"layout":"page","content":"<h2 id=\"Hi-there-👋\"><a href=\"#Hi-there-👋\" class=\"headerlink\" title=\"Hi there 👋 \"></a>Hi there 👋 <img src=\"https://komarev.com/ghpvc/?username=jvxiao&color=blue&style=plastic\"></h2><!--\n**jvxiao/jvxiao** is a ✨ _special_ ✨ repository because its `README.md` (this file) appears on your GitHub profile.\n\nHere are some ideas to get you started:\n\n- 🔭 I’m currently working on ...\n- 🌱 I’m currently learning ...\n- 👯 I’m looking to collaborate on ...\n- 🤔 I’m looking for help with ...\n- 💬 Ask me about ...\n- 📫 How to reach me: ... \n- 😄 Pronouns: ...\n- ⚡ Fun fact: ...\n-->\n\n<p>Hi, I am Jovin Xiao, as known as jvxiao, a full-time front-end developer. In the past few years, I have mainly used Vue and Node to complete my development work. </p>\n<p>In my spare time, I enjoy learning new things and creating some very interesting projects. If you like my projects, please don’t hesitate to give me a star or kindly consider <a href=\"https://afdian.com/a/jvxiao\">sponsoring me by afdian</a>.</p>\n<p>Feel free to contact me.</p>\n","excerpt":"","more":"<h2 id=\"Hi-there-👋\"><a href=\"#Hi-there-👋\" class=\"headerlink\" title=\"Hi there 👋 \"></a>Hi there 👋 <img src=\"https://komarev.com/ghpvc/?username=jvxiao&color=blue&style=plastic\"></h2><!--\n**jvxiao/jvxiao** is a ✨ _special_ ✨ repository because its `README.md` (this file) appears on your GitHub profile.\n\nHere are some ideas to get you started:\n\n- 🔭 I’m currently working on ...\n- 🌱 I’m currently learning ...\n- 👯 I’m looking to collaborate on ...\n- 🤔 I’m looking for help with ...\n- 💬 Ask me about ...\n- 📫 How to reach me: ... \n- 😄 Pronouns: ...\n- ⚡ Fun fact: ...\n-->\n\n<p>Hi, I am Jovin Xiao, as known as jvxiao, a full-time front-end developer. In the past few years, I have mainly used Vue and Node to complete my development work. </p>\n<p>In my spare time, I enjoy learning new things and creating some very interesting projects. If you like my projects, please don’t hesitate to give me a star or kindly consider <a href=\"https://afdian.com/a/jvxiao\">sponsoring me by afdian</a>.</p>\n<p>Feel free to contact me.</p>\n"}],"Post":[{"title":"Javascript中两种不同的继承方式对比","date":"2025-05-23T04:40:00.000Z","targs":["Javascript","继承"],"_content":"\n# Dog.prototype = new Animal() 和 Dog.prototype.proto = Animal.prototype的两种继承方式的区别\n\n\n## 1. Dog.prototype = new Animal()\n\n### 语法和机制\n- **​目的**：通过创建 Animal 的实例来继承其原型链。\n- ​**底层逻辑**：将 Dog.prototype 替换为一个新的 Animal 实例。\n- **​原型链结构**：\n\n```javascript\nDog.prototype → Animal 实例 → Animal.prototype → Object.prototype → null\n```\n\n因此，Dog 的实例通过原型链可以访问 Animal 实例的属性和 Animal.prototype 的方法。\n\n### ​特点\n\n- **​调用父类构造函数**： 会执行 Animal() 构造函数，初始化父类属性（如 this.name)\n- **继承实例属性**：Dog.prototype 会包含 Animal 实例的属性（如 name），即使这些属性是实例级别的。\n\n- **覆盖原有原型**：替换 Dog.prototype 后，原先定义在 Dog.prototype 上的方法会被丢失，需重新添加。\n​- **constructor 问题**：Dog.prototype.constructor 会指向 Animal，需手动修正：\n``` javascript\n  Dog.prototype.constructor = Dog;\n```\n​示例\n``` javascript\n  function Animal() { this.name = \"Animal\"; }\n  Animal.prototype.eat = function() { console.log(\"Eat\"); };\n\n  function Dog() {}\n  Dog.prototype = new Animal(); // 继承\n  Dog.prototype.constructor = Dog; // 修复 constructor\n\n  const dog = new Dog();\n  console.log(dog.name); // \"Animal\"（继承自 Animal 实例）\n  dog.eat();           // \"Eat\"（继承自 Animal.prototype）\n```\n\n## ​2. Dog.prototype.proto = Animal.prototype\n\n### ​语法和机制\n\n- ​目的：直接让 Dog.prototype 的 proto 属性（即 __proto__）指向 Animal.prototype。\n\n- ​底层逻辑：修改 Dog.prototype 的原型链。\n\n​-  原型链结构：\n```javascript\n  Dog.prototype → Animal.prototype → Object.prototype → null\n```\n\n因此，Dog 的实例直接通过原型链访问 Animal.prototype 的方法，但不会继承 Animal 实例的属性。\n### ​特点\n\n- **​不调用父类构造函数**：不会执行 Animal()，避免副作用（如初始化逻辑）。\n\n​- **仅继承原型方法**：Dog 的实例只能访问 Animal.prototype 的方法，无法获取 Animal 实例的属性（如 name）。\n\n- **​保留原有原型**：不会覆盖 Dog.prototype 上已定义的方法。\n\n- **​非标准操作**：直接修改 proto（或 __proto__）是非标准的，可能影响性能，推荐用 Object.setPrototypeOf()：\n```javascript\nObject.setPrototypeOf(Dog.prototype, Animal.prototype);\n```\n​示例\n```javascript\nfunction Animal() { this.name = \"Animal\"; }\nAnimal.prototype.eat = function() { console.log(\"Eat\"); };\n\nfunction Dog() {}\nDog.prototype.proto = Animal.prototype; // 直接修改 proto\n\nconst dog = new Dog();\nconsole.log(dog.name); // undefined（未继承 Animal 实例属性）\ndog.eat();           // \"Eat\"（继承自 Animal.prototype）\n\n```\n\n### ​关键区别总结\n\n### ​**关键区别总结**\n\n| ​**特性**                | `Dog.prototype = new Animal()`                          | `Dog.prototype.__proto__ = Animal.prototype`         |\n|-------------------------|--------------------------------------------------------|-----------------------------------------------------|\n| ​**调用父类构造函数**     | ✅ 是（执行 `Animal()`，初始化父类实例属性）            | ❌ 否（直接链接原型，不调用构造函数）                 |\n| ​**继承实例属性**         | ✅ 是（继承 `Animal` 实例的属性，如 `this.name`）       | ❌ 否（仅继承原型方法，不包含实例属性）               |\n| ​**覆盖原型对象**         | ✅ 是（完全替换 `Dog.prototype` 为新实例）             | ❌ 否（仅修改原型的 `__proto__`，保留原有属性和方法） |\n| ​**constructor修正**    | ✅ 需手动修复（`Dog.prototype.constructor = Dog`）     | ✅ 通常无需修复（原型链未改变构造函数引用）           |\n| ​**兼容性**               | ⚠️ 传统写法，但可能引发副作用（如多余属性继承）       | ⚠️ 非标准操作（直接修改 `__proto__` 可能影响性能）   |\n| ​**推荐程度**             | ❌ 不推荐（问题多，已过时）                             | ⚠️ 慎用（可用 `Object.setPrototypeOf()` 替代）         |\n| ​**原型链结构**           | `Dog.prototype → Animal 实例 → Animal.prototype`         | `Dog.prototype → Animal.prototype → Object.prototype`   |\n| ​**是否继承父类方法**     | ✅ 是（通过 `Animal.prototype`）                       | ✅ 是（直接链接到 `Animal.prototype`）                |\n| ​**是否继承父类实例方法** | ❌ 否（仅继承原型方法，实例属性不会被继承）             | ❌ 否（同上）                                        |\n| ​**典型用途**             | 早期原型链继承（已不推荐）                            | 理论原型链扩展（极少使用，多用 `Object.create()`）   |\n| ​**替代方案**             | `Object.create(Animal.prototype)` + 手动初始化属性     | `Object.setPrototypeOf(Dog.prototype, Animal.prototype)` |\n| ​**ES6 推荐写法**         | `class Dog extends Animal {}`                           | `class Dog extends Animal {}`                         |\n\n### 补充说明\n- ​**Dog.prototype = new Animal() 的问题**：\n\n  - 强制调用父类构造函数，可能导致不必要的初始化逻辑（如 Animal 的 this.name）。\n  - 会将父类实例的属性（如 name）提升为 Dog.prototype 的属性，导致所有子类实例共享这些属性（可能引发意外行为）。\n\n- ​**Dog.prototype.__proto__ = Animal.prototype 的问题**：\n\n  - ​非标准操作：虽然浏览器支持，但 __proto__ 是内部属性，直接修改可能导致性能下降或兼容性问题。\n  - ​无法继承父类构造函数：子类实例仍需通过 new Dog() 创建，不会自动调用父类构造函数。\n\n\n### ​现代替代方案：\n\n​**Object.create()**：\n```javascript\nDog.prototype = Object.create(Animal.prototype);\nDog.prototype.constructor = Dog;\n```\n直接继承 Animal.prototype，不调用父类构造函数，更安全高效。\n\n​ES6 class 语法：\n```javascript\nclass Dog extends Animal {}\n```\n自动处理原型链和构造函数继承，代码更简洁清晰。","source":"_posts/Differences-between-two-kinds-inherit-approches.md","raw":"\n---\ntitle: Javascript中两种不同的继承方式对比\ndate: 2025-05-23 12:40:00\ncategory: Web开发\ntargs:\n  - Javascript\n  - 继承\n---\n\n# Dog.prototype = new Animal() 和 Dog.prototype.proto = Animal.prototype的两种继承方式的区别\n\n\n## 1. Dog.prototype = new Animal()\n\n### 语法和机制\n- **​目的**：通过创建 Animal 的实例来继承其原型链。\n- ​**底层逻辑**：将 Dog.prototype 替换为一个新的 Animal 实例。\n- **​原型链结构**：\n\n```javascript\nDog.prototype → Animal 实例 → Animal.prototype → Object.prototype → null\n```\n\n因此，Dog 的实例通过原型链可以访问 Animal 实例的属性和 Animal.prototype 的方法。\n\n### ​特点\n\n- **​调用父类构造函数**： 会执行 Animal() 构造函数，初始化父类属性（如 this.name)\n- **继承实例属性**：Dog.prototype 会包含 Animal 实例的属性（如 name），即使这些属性是实例级别的。\n\n- **覆盖原有原型**：替换 Dog.prototype 后，原先定义在 Dog.prototype 上的方法会被丢失，需重新添加。\n​- **constructor 问题**：Dog.prototype.constructor 会指向 Animal，需手动修正：\n``` javascript\n  Dog.prototype.constructor = Dog;\n```\n​示例\n``` javascript\n  function Animal() { this.name = \"Animal\"; }\n  Animal.prototype.eat = function() { console.log(\"Eat\"); };\n\n  function Dog() {}\n  Dog.prototype = new Animal(); // 继承\n  Dog.prototype.constructor = Dog; // 修复 constructor\n\n  const dog = new Dog();\n  console.log(dog.name); // \"Animal\"（继承自 Animal 实例）\n  dog.eat();           // \"Eat\"（继承自 Animal.prototype）\n```\n\n## ​2. Dog.prototype.proto = Animal.prototype\n\n### ​语法和机制\n\n- ​目的：直接让 Dog.prototype 的 proto 属性（即 __proto__）指向 Animal.prototype。\n\n- ​底层逻辑：修改 Dog.prototype 的原型链。\n\n​-  原型链结构：\n```javascript\n  Dog.prototype → Animal.prototype → Object.prototype → null\n```\n\n因此，Dog 的实例直接通过原型链访问 Animal.prototype 的方法，但不会继承 Animal 实例的属性。\n### ​特点\n\n- **​不调用父类构造函数**：不会执行 Animal()，避免副作用（如初始化逻辑）。\n\n​- **仅继承原型方法**：Dog 的实例只能访问 Animal.prototype 的方法，无法获取 Animal 实例的属性（如 name）。\n\n- **​保留原有原型**：不会覆盖 Dog.prototype 上已定义的方法。\n\n- **​非标准操作**：直接修改 proto（或 __proto__）是非标准的，可能影响性能，推荐用 Object.setPrototypeOf()：\n```javascript\nObject.setPrototypeOf(Dog.prototype, Animal.prototype);\n```\n​示例\n```javascript\nfunction Animal() { this.name = \"Animal\"; }\nAnimal.prototype.eat = function() { console.log(\"Eat\"); };\n\nfunction Dog() {}\nDog.prototype.proto = Animal.prototype; // 直接修改 proto\n\nconst dog = new Dog();\nconsole.log(dog.name); // undefined（未继承 Animal 实例属性）\ndog.eat();           // \"Eat\"（继承自 Animal.prototype）\n\n```\n\n### ​关键区别总结\n\n### ​**关键区别总结**\n\n| ​**特性**                | `Dog.prototype = new Animal()`                          | `Dog.prototype.__proto__ = Animal.prototype`         |\n|-------------------------|--------------------------------------------------------|-----------------------------------------------------|\n| ​**调用父类构造函数**     | ✅ 是（执行 `Animal()`，初始化父类实例属性）            | ❌ 否（直接链接原型，不调用构造函数）                 |\n| ​**继承实例属性**         | ✅ 是（继承 `Animal` 实例的属性，如 `this.name`）       | ❌ 否（仅继承原型方法，不包含实例属性）               |\n| ​**覆盖原型对象**         | ✅ 是（完全替换 `Dog.prototype` 为新实例）             | ❌ 否（仅修改原型的 `__proto__`，保留原有属性和方法） |\n| ​**constructor修正**    | ✅ 需手动修复（`Dog.prototype.constructor = Dog`）     | ✅ 通常无需修复（原型链未改变构造函数引用）           |\n| ​**兼容性**               | ⚠️ 传统写法，但可能引发副作用（如多余属性继承）       | ⚠️ 非标准操作（直接修改 `__proto__` 可能影响性能）   |\n| ​**推荐程度**             | ❌ 不推荐（问题多，已过时）                             | ⚠️ 慎用（可用 `Object.setPrototypeOf()` 替代）         |\n| ​**原型链结构**           | `Dog.prototype → Animal 实例 → Animal.prototype`         | `Dog.prototype → Animal.prototype → Object.prototype`   |\n| ​**是否继承父类方法**     | ✅ 是（通过 `Animal.prototype`）                       | ✅ 是（直接链接到 `Animal.prototype`）                |\n| ​**是否继承父类实例方法** | ❌ 否（仅继承原型方法，实例属性不会被继承）             | ❌ 否（同上）                                        |\n| ​**典型用途**             | 早期原型链继承（已不推荐）                            | 理论原型链扩展（极少使用，多用 `Object.create()`）   |\n| ​**替代方案**             | `Object.create(Animal.prototype)` + 手动初始化属性     | `Object.setPrototypeOf(Dog.prototype, Animal.prototype)` |\n| ​**ES6 推荐写法**         | `class Dog extends Animal {}`                           | `class Dog extends Animal {}`                         |\n\n### 补充说明\n- ​**Dog.prototype = new Animal() 的问题**：\n\n  - 强制调用父类构造函数，可能导致不必要的初始化逻辑（如 Animal 的 this.name）。\n  - 会将父类实例的属性（如 name）提升为 Dog.prototype 的属性，导致所有子类实例共享这些属性（可能引发意外行为）。\n\n- ​**Dog.prototype.__proto__ = Animal.prototype 的问题**：\n\n  - ​非标准操作：虽然浏览器支持，但 __proto__ 是内部属性，直接修改可能导致性能下降或兼容性问题。\n  - ​无法继承父类构造函数：子类实例仍需通过 new Dog() 创建，不会自动调用父类构造函数。\n\n\n### ​现代替代方案：\n\n​**Object.create()**：\n```javascript\nDog.prototype = Object.create(Animal.prototype);\nDog.prototype.constructor = Dog;\n```\n直接继承 Animal.prototype，不调用父类构造函数，更安全高效。\n\n​ES6 class 语法：\n```javascript\nclass Dog extends Animal {}\n```\n自动处理原型链和构造函数继承，代码更简洁清晰。","slug":"Differences-between-two-kinds-inherit-approches","published":1,"updated":"2025-06-21T14:16:14.913Z","_id":"cmb0qjkpr000250up21mk5ky1","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"Dog-prototype-new-Animal-和-Dog-prototype-proto-Animal-prototype的两种继承方式的区别\"><a href=\"#Dog-prototype-new-Animal-和-Dog-prototype-proto-Animal-prototype的两种继承方式的区别\" class=\"headerlink\" title=\"Dog.prototype &#x3D; new Animal() 和 Dog.prototype.proto &#x3D; Animal.prototype的两种继承方式的区别\"></a>Dog.prototype &#x3D; new Animal() 和 Dog.prototype.proto &#x3D; Animal.prototype的两种继承方式的区别</h1><h2 id=\"1-Dog-prototype-new-Animal\"><a href=\"#1-Dog-prototype-new-Animal\" class=\"headerlink\" title=\"1. Dog.prototype &#x3D; new Animal()\"></a>1. Dog.prototype &#x3D; new Animal()</h2><h3 id=\"语法和机制\"><a href=\"#语法和机制\" class=\"headerlink\" title=\"语法和机制\"></a>语法和机制</h3><ul>\n<li><strong>​目的</strong>：通过创建 Animal 的实例来继承其原型链。</li>\n<li>​<strong>底层逻辑</strong>：将 Dog.prototype 替换为一个新的 Animal 实例。</li>\n<li><strong>​原型链结构</strong>：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> → <span class=\"hljs-title class_\">Animal</span> 实例 → <span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> → <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> → <span class=\"hljs-literal\">null</span><br></code></pre></td></tr></table></figure>\n\n<p>因此，Dog 的实例通过原型链可以访问 Animal 实例的属性和 Animal.prototype 的方法。</p>\n<h3 id=\"​特点\"><a href=\"#​特点\" class=\"headerlink\" title=\"​特点\"></a>​特点</h3><ul>\n<li><p><strong>​调用父类构造函数</strong>： 会执行 Animal() 构造函数，初始化父类属性（如 this.name)</p>\n</li>\n<li><p><strong>继承实例属性</strong>：Dog.prototype 会包含 Animal 实例的属性（如 name），即使这些属性是实例级别的。</p>\n</li>\n<li><p><strong>覆盖原有原型</strong>：替换 Dog.prototype 后，原先定义在 Dog.prototype 上的方法会被丢失，需重新添加。<br>​- <strong>constructor 问题</strong>：Dog.prototype.constructor 会指向 Animal，需手动修正：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">constructor</span> = <span class=\"hljs-title class_\">Dog</span>;<br></code></pre></td></tr></table></figure>\n<p>​示例</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Animal</span>(<span class=\"hljs-params\"></span>) &#123; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = <span class=\"hljs-string\">&quot;Animal&quot;</span>; &#125;<br><span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">eat</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;Eat&quot;</span>); &#125;;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Dog</span>(<span class=\"hljs-params\"></span>) &#123;&#125;<br><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Animal</span>(); <span class=\"hljs-comment\">// 继承</span><br><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">constructor</span> = <span class=\"hljs-title class_\">Dog</span>; <span class=\"hljs-comment\">// 修复 constructor</span><br><br><span class=\"hljs-keyword\">const</span> dog = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Dog</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(dog.<span class=\"hljs-property\">name</span>); <span class=\"hljs-comment\">// &quot;Animal&quot;（继承自 Animal 实例）</span><br>dog.<span class=\"hljs-title function_\">eat</span>();           <span class=\"hljs-comment\">// &quot;Eat&quot;（继承自 Animal.prototype）</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"​2-Dog-prototype-proto-Animal-prototype\"><a href=\"#​2-Dog-prototype-proto-Animal-prototype\" class=\"headerlink\" title=\"​2. Dog.prototype.proto &#x3D; Animal.prototype\"></a>​2. Dog.prototype.proto &#x3D; Animal.prototype</h2><h3 id=\"​语法和机制\"><a href=\"#​语法和机制\" class=\"headerlink\" title=\"​语法和机制\"></a>​语法和机制</h3><ul>\n<li><p>​目的：直接让 Dog.prototype 的 proto 属性（即 __proto__）指向 Animal.prototype。</p>\n</li>\n<li><p>​底层逻辑：修改 Dog.prototype 的原型链。</p>\n</li>\n</ul>\n<p>​-  原型链结构：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> → <span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> → <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> → <span class=\"hljs-literal\">null</span><br></code></pre></td></tr></table></figure>\n\n<p>因此，Dog 的实例直接通过原型链访问 Animal.prototype 的方法，但不会继承 Animal 实例的属性。</p>\n<h3 id=\"​特点-1\"><a href=\"#​特点-1\" class=\"headerlink\" title=\"​特点\"></a>​特点</h3><ul>\n<li><strong>​不调用父类构造函数</strong>：不会执行 Animal()，避免副作用（如初始化逻辑）。</li>\n</ul>\n<p>​- <strong>仅继承原型方法</strong>：Dog 的实例只能访问 Animal.prototype 的方法，无法获取 Animal 实例的属性（如 name）。</p>\n<ul>\n<li><p><strong>​保留原有原型</strong>：不会覆盖 Dog.prototype 上已定义的方法。</p>\n</li>\n<li><p><strong>​非标准操作</strong>：直接修改 proto（或 __proto__）是非标准的，可能影响性能，推荐用 Object.setPrototypeOf()：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">setPrototypeOf</span>(<span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>, <span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);<br></code></pre></td></tr></table></figure>\n<p>​示例</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Animal</span>(<span class=\"hljs-params\"></span>) &#123; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = <span class=\"hljs-string\">&quot;Animal&quot;</span>; &#125;<br><span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">eat</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;Eat&quot;</span>); &#125;;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Dog</span>(<span class=\"hljs-params\"></span>) &#123;&#125;<br><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">proto</span> = <span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>; <span class=\"hljs-comment\">// 直接修改 proto</span><br><br><span class=\"hljs-keyword\">const</span> dog = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Dog</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(dog.<span class=\"hljs-property\">name</span>); <span class=\"hljs-comment\">// undefined（未继承 Animal 实例属性）</span><br>dog.<span class=\"hljs-title function_\">eat</span>();           <span class=\"hljs-comment\">// &quot;Eat&quot;（继承自 Animal.prototype）</span><br><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"​关键区别总结\"><a href=\"#​关键区别总结\" class=\"headerlink\" title=\"​关键区别总结\"></a>​关键区别总结</h3><h3 id=\"​关键区别总结-1\"><a href=\"#​关键区别总结-1\" class=\"headerlink\" title=\"​关键区别总结\"></a>​<strong>关键区别总结</strong></h3><table>\n<thead>\n<tr>\n<th>​<strong>特性</strong></th>\n<th><code>Dog.prototype = new Animal()</code></th>\n<th><code>Dog.prototype.__proto__ = Animal.prototype</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>​<strong>调用父类构造函数</strong></td>\n<td>✅ 是（执行 <code>Animal()</code>，初始化父类实例属性）</td>\n<td>❌ 否（直接链接原型，不调用构造函数）</td>\n</tr>\n<tr>\n<td>​<strong>继承实例属性</strong></td>\n<td>✅ 是（继承 <code>Animal</code> 实例的属性，如 <code>this.name</code>）</td>\n<td>❌ 否（仅继承原型方法，不包含实例属性）</td>\n</tr>\n<tr>\n<td>​<strong>覆盖原型对象</strong></td>\n<td>✅ 是（完全替换 <code>Dog.prototype</code> 为新实例）</td>\n<td>❌ 否（仅修改原型的 <code>__proto__</code>，保留原有属性和方法）</td>\n</tr>\n<tr>\n<td>​<strong>constructor修正</strong></td>\n<td>✅ 需手动修复（<code>Dog.prototype.constructor = Dog</code>）</td>\n<td>✅ 通常无需修复（原型链未改变构造函数引用）</td>\n</tr>\n<tr>\n<td>​<strong>兼容性</strong></td>\n<td>⚠️ 传统写法，但可能引发副作用（如多余属性继承）</td>\n<td>⚠️ 非标准操作（直接修改 <code>__proto__</code> 可能影响性能）</td>\n</tr>\n<tr>\n<td>​<strong>推荐程度</strong></td>\n<td>❌ 不推荐（问题多，已过时）</td>\n<td>⚠️ 慎用（可用 <code>Object.setPrototypeOf()</code> 替代）</td>\n</tr>\n<tr>\n<td>​<strong>原型链结构</strong></td>\n<td><code>Dog.prototype → Animal 实例 → Animal.prototype</code></td>\n<td><code>Dog.prototype → Animal.prototype → Object.prototype</code></td>\n</tr>\n<tr>\n<td>​<strong>是否继承父类方法</strong></td>\n<td>✅ 是（通过 <code>Animal.prototype</code>）</td>\n<td>✅ 是（直接链接到 <code>Animal.prototype</code>）</td>\n</tr>\n<tr>\n<td>​<strong>是否继承父类实例方法</strong></td>\n<td>❌ 否（仅继承原型方法，实例属性不会被继承）</td>\n<td>❌ 否（同上）</td>\n</tr>\n<tr>\n<td>​<strong>典型用途</strong></td>\n<td>早期原型链继承（已不推荐）</td>\n<td>理论原型链扩展（极少使用，多用 <code>Object.create()</code>）</td>\n</tr>\n<tr>\n<td>​<strong>替代方案</strong></td>\n<td><code>Object.create(Animal.prototype)</code> + 手动初始化属性</td>\n<td><code>Object.setPrototypeOf(Dog.prototype, Animal.prototype)</code></td>\n</tr>\n<tr>\n<td>​<strong>ES6 推荐写法</strong></td>\n<td><code>class Dog extends Animal &#123;&#125;</code></td>\n<td><code>class Dog extends Animal &#123;&#125;</code></td>\n</tr>\n</tbody></table>\n<h3 id=\"补充说明\"><a href=\"#补充说明\" class=\"headerlink\" title=\"补充说明\"></a>补充说明</h3><ul>\n<li><p>​<strong>Dog.prototype &#x3D; new Animal() 的问题</strong>：</p>\n<ul>\n<li>强制调用父类构造函数，可能导致不必要的初始化逻辑（如 Animal 的 this.name）。</li>\n<li>会将父类实例的属性（如 name）提升为 Dog.prototype 的属性，导致所有子类实例共享这些属性（可能引发意外行为）。</li>\n</ul>\n</li>\n<li><p>​<strong>Dog.prototype.<strong>proto</strong> &#x3D; Animal.prototype 的问题</strong>：</p>\n<ul>\n<li>​非标准操作：虽然浏览器支持，但 <strong>proto</strong> 是内部属性，直接修改可能导致性能下降或兼容性问题。</li>\n<li>​无法继承父类构造函数：子类实例仍需通过 new Dog() 创建，不会自动调用父类构造函数。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"​现代替代方案：\"><a href=\"#​现代替代方案：\" class=\"headerlink\" title=\"​现代替代方案：\"></a>​现代替代方案：</h3><p>​**Object.create()**：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(<span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);<br><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">constructor</span> = <span class=\"hljs-title class_\">Dog</span>;<br></code></pre></td></tr></table></figure>\n<p>直接继承 Animal.prototype，不调用父类构造函数，更安全高效。</p>\n<p>​ES6 class 语法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Dog</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Animal</span> &#123;&#125;<br></code></pre></td></tr></table></figure>\n<p>自动处理原型链和构造函数继承，代码更简洁清晰。</p>\n","excerpt":"","more":"<h1 id=\"Dog-prototype-new-Animal-和-Dog-prototype-proto-Animal-prototype的两种继承方式的区别\"><a href=\"#Dog-prototype-new-Animal-和-Dog-prototype-proto-Animal-prototype的两种继承方式的区别\" class=\"headerlink\" title=\"Dog.prototype &#x3D; new Animal() 和 Dog.prototype.proto &#x3D; Animal.prototype的两种继承方式的区别\"></a>Dog.prototype &#x3D; new Animal() 和 Dog.prototype.proto &#x3D; Animal.prototype的两种继承方式的区别</h1><h2 id=\"1-Dog-prototype-new-Animal\"><a href=\"#1-Dog-prototype-new-Animal\" class=\"headerlink\" title=\"1. Dog.prototype &#x3D; new Animal()\"></a>1. Dog.prototype &#x3D; new Animal()</h2><h3 id=\"语法和机制\"><a href=\"#语法和机制\" class=\"headerlink\" title=\"语法和机制\"></a>语法和机制</h3><ul>\n<li><strong>​目的</strong>：通过创建 Animal 的实例来继承其原型链。</li>\n<li>​<strong>底层逻辑</strong>：将 Dog.prototype 替换为一个新的 Animal 实例。</li>\n<li><strong>​原型链结构</strong>：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> → <span class=\"hljs-title class_\">Animal</span> 实例 → <span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> → <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> → <span class=\"hljs-literal\">null</span><br></code></pre></td></tr></table></figure>\n\n<p>因此，Dog 的实例通过原型链可以访问 Animal 实例的属性和 Animal.prototype 的方法。</p>\n<h3 id=\"​特点\"><a href=\"#​特点\" class=\"headerlink\" title=\"​特点\"></a>​特点</h3><ul>\n<li><p><strong>​调用父类构造函数</strong>： 会执行 Animal() 构造函数，初始化父类属性（如 this.name)</p>\n</li>\n<li><p><strong>继承实例属性</strong>：Dog.prototype 会包含 Animal 实例的属性（如 name），即使这些属性是实例级别的。</p>\n</li>\n<li><p><strong>覆盖原有原型</strong>：替换 Dog.prototype 后，原先定义在 Dog.prototype 上的方法会被丢失，需重新添加。<br>​- <strong>constructor 问题</strong>：Dog.prototype.constructor 会指向 Animal，需手动修正：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">constructor</span> = <span class=\"hljs-title class_\">Dog</span>;<br></code></pre></td></tr></table></figure>\n<p>​示例</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Animal</span>(<span class=\"hljs-params\"></span>) &#123; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = <span class=\"hljs-string\">&quot;Animal&quot;</span>; &#125;<br><span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">eat</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;Eat&quot;</span>); &#125;;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Dog</span>(<span class=\"hljs-params\"></span>) &#123;&#125;<br><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Animal</span>(); <span class=\"hljs-comment\">// 继承</span><br><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">constructor</span> = <span class=\"hljs-title class_\">Dog</span>; <span class=\"hljs-comment\">// 修复 constructor</span><br><br><span class=\"hljs-keyword\">const</span> dog = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Dog</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(dog.<span class=\"hljs-property\">name</span>); <span class=\"hljs-comment\">// &quot;Animal&quot;（继承自 Animal 实例）</span><br>dog.<span class=\"hljs-title function_\">eat</span>();           <span class=\"hljs-comment\">// &quot;Eat&quot;（继承自 Animal.prototype）</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"​2-Dog-prototype-proto-Animal-prototype\"><a href=\"#​2-Dog-prototype-proto-Animal-prototype\" class=\"headerlink\" title=\"​2. Dog.prototype.proto &#x3D; Animal.prototype\"></a>​2. Dog.prototype.proto &#x3D; Animal.prototype</h2><h3 id=\"​语法和机制\"><a href=\"#​语法和机制\" class=\"headerlink\" title=\"​语法和机制\"></a>​语法和机制</h3><ul>\n<li><p>​目的：直接让 Dog.prototype 的 proto 属性（即 __proto__）指向 Animal.prototype。</p>\n</li>\n<li><p>​底层逻辑：修改 Dog.prototype 的原型链。</p>\n</li>\n</ul>\n<p>​-  原型链结构：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> → <span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> → <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> → <span class=\"hljs-literal\">null</span><br></code></pre></td></tr></table></figure>\n\n<p>因此，Dog 的实例直接通过原型链访问 Animal.prototype 的方法，但不会继承 Animal 实例的属性。</p>\n<h3 id=\"​特点-1\"><a href=\"#​特点-1\" class=\"headerlink\" title=\"​特点\"></a>​特点</h3><ul>\n<li><strong>​不调用父类构造函数</strong>：不会执行 Animal()，避免副作用（如初始化逻辑）。</li>\n</ul>\n<p>​- <strong>仅继承原型方法</strong>：Dog 的实例只能访问 Animal.prototype 的方法，无法获取 Animal 实例的属性（如 name）。</p>\n<ul>\n<li><p><strong>​保留原有原型</strong>：不会覆盖 Dog.prototype 上已定义的方法。</p>\n</li>\n<li><p><strong>​非标准操作</strong>：直接修改 proto（或 __proto__）是非标准的，可能影响性能，推荐用 Object.setPrototypeOf()：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">setPrototypeOf</span>(<span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>, <span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);<br></code></pre></td></tr></table></figure>\n<p>​示例</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Animal</span>(<span class=\"hljs-params\"></span>) &#123; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = <span class=\"hljs-string\">&quot;Animal&quot;</span>; &#125;<br><span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">eat</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;Eat&quot;</span>); &#125;;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Dog</span>(<span class=\"hljs-params\"></span>) &#123;&#125;<br><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">proto</span> = <span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>; <span class=\"hljs-comment\">// 直接修改 proto</span><br><br><span class=\"hljs-keyword\">const</span> dog = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Dog</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(dog.<span class=\"hljs-property\">name</span>); <span class=\"hljs-comment\">// undefined（未继承 Animal 实例属性）</span><br>dog.<span class=\"hljs-title function_\">eat</span>();           <span class=\"hljs-comment\">// &quot;Eat&quot;（继承自 Animal.prototype）</span><br><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"​关键区别总结\"><a href=\"#​关键区别总结\" class=\"headerlink\" title=\"​关键区别总结\"></a>​关键区别总结</h3><h3 id=\"​关键区别总结-1\"><a href=\"#​关键区别总结-1\" class=\"headerlink\" title=\"​关键区别总结\"></a>​<strong>关键区别总结</strong></h3><table>\n<thead>\n<tr>\n<th>​<strong>特性</strong></th>\n<th><code>Dog.prototype = new Animal()</code></th>\n<th><code>Dog.prototype.__proto__ = Animal.prototype</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>​<strong>调用父类构造函数</strong></td>\n<td>✅ 是（执行 <code>Animal()</code>，初始化父类实例属性）</td>\n<td>❌ 否（直接链接原型，不调用构造函数）</td>\n</tr>\n<tr>\n<td>​<strong>继承实例属性</strong></td>\n<td>✅ 是（继承 <code>Animal</code> 实例的属性，如 <code>this.name</code>）</td>\n<td>❌ 否（仅继承原型方法，不包含实例属性）</td>\n</tr>\n<tr>\n<td>​<strong>覆盖原型对象</strong></td>\n<td>✅ 是（完全替换 <code>Dog.prototype</code> 为新实例）</td>\n<td>❌ 否（仅修改原型的 <code>__proto__</code>，保留原有属性和方法）</td>\n</tr>\n<tr>\n<td>​<strong>constructor修正</strong></td>\n<td>✅ 需手动修复（<code>Dog.prototype.constructor = Dog</code>）</td>\n<td>✅ 通常无需修复（原型链未改变构造函数引用）</td>\n</tr>\n<tr>\n<td>​<strong>兼容性</strong></td>\n<td>⚠️ 传统写法，但可能引发副作用（如多余属性继承）</td>\n<td>⚠️ 非标准操作（直接修改 <code>__proto__</code> 可能影响性能）</td>\n</tr>\n<tr>\n<td>​<strong>推荐程度</strong></td>\n<td>❌ 不推荐（问题多，已过时）</td>\n<td>⚠️ 慎用（可用 <code>Object.setPrototypeOf()</code> 替代）</td>\n</tr>\n<tr>\n<td>​<strong>原型链结构</strong></td>\n<td><code>Dog.prototype → Animal 实例 → Animal.prototype</code></td>\n<td><code>Dog.prototype → Animal.prototype → Object.prototype</code></td>\n</tr>\n<tr>\n<td>​<strong>是否继承父类方法</strong></td>\n<td>✅ 是（通过 <code>Animal.prototype</code>）</td>\n<td>✅ 是（直接链接到 <code>Animal.prototype</code>）</td>\n</tr>\n<tr>\n<td>​<strong>是否继承父类实例方法</strong></td>\n<td>❌ 否（仅继承原型方法，实例属性不会被继承）</td>\n<td>❌ 否（同上）</td>\n</tr>\n<tr>\n<td>​<strong>典型用途</strong></td>\n<td>早期原型链继承（已不推荐）</td>\n<td>理论原型链扩展（极少使用，多用 <code>Object.create()</code>）</td>\n</tr>\n<tr>\n<td>​<strong>替代方案</strong></td>\n<td><code>Object.create(Animal.prototype)</code> + 手动初始化属性</td>\n<td><code>Object.setPrototypeOf(Dog.prototype, Animal.prototype)</code></td>\n</tr>\n<tr>\n<td>​<strong>ES6 推荐写法</strong></td>\n<td><code>class Dog extends Animal &#123;&#125;</code></td>\n<td><code>class Dog extends Animal &#123;&#125;</code></td>\n</tr>\n</tbody></table>\n<h3 id=\"补充说明\"><a href=\"#补充说明\" class=\"headerlink\" title=\"补充说明\"></a>补充说明</h3><ul>\n<li><p>​<strong>Dog.prototype &#x3D; new Animal() 的问题</strong>：</p>\n<ul>\n<li>强制调用父类构造函数，可能导致不必要的初始化逻辑（如 Animal 的 this.name）。</li>\n<li>会将父类实例的属性（如 name）提升为 Dog.prototype 的属性，导致所有子类实例共享这些属性（可能引发意外行为）。</li>\n</ul>\n</li>\n<li><p>​<strong>Dog.prototype.<strong>proto</strong> &#x3D; Animal.prototype 的问题</strong>：</p>\n<ul>\n<li>​非标准操作：虽然浏览器支持，但 <strong>proto</strong> 是内部属性，直接修改可能导致性能下降或兼容性问题。</li>\n<li>​无法继承父类构造函数：子类实例仍需通过 new Dog() 创建，不会自动调用父类构造函数。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"​现代替代方案：\"><a href=\"#​现代替代方案：\" class=\"headerlink\" title=\"​现代替代方案：\"></a>​现代替代方案：</h3><p>​**Object.create()**：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(<span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);<br><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">constructor</span> = <span class=\"hljs-title class_\">Dog</span>;<br></code></pre></td></tr></table></figure>\n<p>直接继承 Animal.prototype，不调用父类构造函数，更安全高效。</p>\n<p>​ES6 class 语法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Dog</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Animal</span> &#123;&#125;<br></code></pre></td></tr></table></figure>\n<p>自动处理原型链和构造函数继承，代码更简洁清晰。</p>\n"},{"title":"关于微信云托管对象存储那点事","date":"2025-05-23T04:40:00.000Z","_content":"最近在鼓捣一个关于图像处理相关的小程序，出于快速开发考虑，在后台开发这块，没有选择走传统的后台部署服务。毕竟，购买云服务器，注册购买域名以及备案等一系列操作下来，也够让人心累。\n\n这次选择的是微信开发的平台的云托管，至于为什么走的不是云函数开发，其中就涉及到了开发语言的选择--python, 如果改用javascript重写一下，成本有点高，所以最终方案选择云托管。\n\n在按照云托管的部署流程一通走下来后，everything is fine. But...\n\n离大谱的，接口请求和响应，居然不能超过1M, 而我这程序就是关于图像处理的，动不动图片大小就会超过1M。如果非要限制用户图片大小限制在1M以下，太过影响用户体验。\n\n此外我还想过，在用户端使用图像压缩，但图像太大压缩也会存在超过1M的情况，另外清晰度也会受到影响。\n\n在微信开发社区和各个IT论坛找了一圈下来，其实没有比较好的解决方案，最终都需要经过一个中间对象存储的过程。\n\n也就是先将图片上传到云上，让后将图片对象的id作为接口入参传入，后台需要使用到图片的时候根据图片id下载即可，然后将处理后的图片，又要上传回云上，返回给客户端新的图片的id，客户端可以根据图片id来获取资源。如下图\n\n<!-- ![处理流程](./imgs/微信云对象存储..png) -->\n<div align=\"center\">\n    <img src=\"/imgs/微信云对象存储..png\" width=\"80%\" height=\"20%\" alt=\"处理流程\"/>\n</div>\n\n\n\n对象存储云平台其实很多，例如比较有名的比如七牛，阿里，还有腾讯云自己的。我这里采用了微信云对象存储，具体的使用呢可以参考 [微信云托管对象存储](https://developers.weixin.qq.com/minigame/dev/wxcloudrun/src/guide/storage/manage.html)，相应的开发手册可以参考[对象存储-服务端和其他客户端](https://developers.weixin.qq.com/minigame/dev/wxcloudrun/src/development/storage/service/)\n\n\n为了在后续的开发中更好处理类似的情况，我将微信云托管对象存储做成了一个模块，具体实现情况如下。\n\n首先，需要从自己的小程序或者和云托管平台获取到以下三个重要参数：\n\n- **APPID** ： \"your-wechat-appid\"\n- **SECRET**： \"your-wechat-secret\"\n- **ENV_ID**： \"your-cloud-env-id\"\n\n- ### 文件上传 (获取token-获取元数据-上传COS)\n\n微信开放平台如果第三方调用对应接口的话，都是需要鉴权了，所以首先我们需要获取到token值。\n\n``` Python\ndef _refresh_access_token(self):\n        \"\"\"获取或刷新access_token\"\"\"\n        url = \"https://api.weixin.qq.com/cgi-bin/token\"\n        params = {\n            \"grant_type\": \"client_credential\",\n            \"appid\": self.appid,\n            \"secret\": self.secret\n        }\n        response = requests.get(url, params=params, verify=False).json()\n        if 'access_token' in response:\n            self.access_token = response['access_token']\n            self.token_expires = time.time() + response['expires_in'] - 300  # 提前5分钟刷新\n        else:\n            raise Exception(f\"获取access_token失败: {response}\")\n```\n\n\n文件上传可以分成2步：**1获取上传元数据，2上传文件到COS**。\n\n获取元数据可以理解为向平台发送请求，获取一个用来存放一个文件（存储对象）的一个URL地址, 上传文件到COS可以则可以理解成将资源放到上一步生成的URL地址上，经此，文件才算真正的上传成功了。\n\n``` Python\n    def upload_file(self, local_path, cloud_path):\n        \"\"\"\n        上传本地文件到微信云存储\n        :param local_path: 本地文件路径\n        :param cloud_path: 云端存储路径（如：'images/example.jpg'）\n        :return: 文件ID（用于后续下载）\n        \"\"\"\n        self._ensure_access_token()\n        \n        # 1. 获取上传元数据\n        upload_meta_url = \"https://api.weixin.qq.com/tcb/uploadfile\"\n        params = {\"access_token\": self.access_token}\n        payload = {\"env\": self.env, \"path\": cloud_path}\n        response = requests.post(upload_meta_url, params=params, json=payload,verify=False).json()\n        print(payload, params)\n        if response.get('errcode', 0) != 0:\n            raise Exception(f\"上传元数据获取失败: {response}\")\n        \n        # 2. 上传文件到COS\n        cos_url = response['url']\n       \n        key = cloud_path.split('/')[-1]\n        print(key)\n        files = {\n            \"Signature\":(None,response['authorization']),\n            \"x-cos-meta-fileid\": (None, response['cos_file_id']),\n            \"x-cos-security-token\": (None,response['token']),\n            \"key\": (None, cloud_path),\n            'file':(key, open(local_path, 'rb')),\n        }\n\n        upload_resp = requests.post(cos_url, files=files, verify=False)\n        if upload_resp.status_code != 204:\n            raise Exception(f\"COS上传失败: {upload_resp.text}\", upload_resp)\n       \n        return response['file_id']\n```\n\n\n- ### 文件下载\n\n下载文件相对简单一些，直接调用微信开放平台对外提供的批量下载接口，当然对应的token也是需要的，这部分就不做赘述，代码实现可以参考下方。\n\n``` Python \n\ndef download_file(self, file_id, local_path):\n        \"\"\"\n        从微信云存储下载文件\n        :param file_id: 文件ID（上传时返回的file_id）\n        :param local_path: 本地存储路径\n        \"\"\"\n        self._ensure_access_token()\n        \n        # 1. 获取下载链接\n        download_meta_url = \"https://api.weixin.qq.com/tcb/batchdownloadfile\"\n        params = {\"access_token\": self.access_token}\n        payload = {\n            \"env\": self.env,\n            \"file_list\": [{\"fileid\": file_id, \"max_age\": 7200}]\n        }\n        response = requests.post(download_meta_url, params=params, json=payload, verify=False).json()\n        \n        if response.get('errcode', 0) != 0:\n            raise Exception(f\"下载元数据获取失败: {response}\")\n        \n        file_info = response['file_list'][0]\n        if file_info['status'] != 0:\n            raise Exception(f\"下载错误: {file_info['errmsg']}\")\n        \n        # 2. 下载文件\n        download_resp = requests.get(file_info['download_url'], verify=False)\n        if download_resp.status_code != 200:\n            raise Exception(\"文件下载失败\")\n        \n        with open(local_path, 'wb') as f:\n            f.write(download_resp.content)\n            \n        return True\n```\n\n以上就是微信云托管上对象存储的上传和下载的实现了。为了方便，我们可以将功能在一个类中实现。此外，考虑到token获取接口是有限制的，每天的调用次数是2000次，而每个token的有效时间是2小时，因此可以重复利用已有token。\n\n最终，完整的代码实现如下：\n\n``` Python\n# wx-cloud-storage.py\n# description: 微信云托管对象存储管理模块\nimport requests\nimport time\n\nclass WeChatCloudStorage:\n    def __init__(self, appid, secret, env):\n        self.appid = appid\n        self.secret = secret\n        self.env = env\n        self.access_token = None\n        self.token_expires = 0  # Token过期时间戳\n\n    def _refresh_access_token(self):\n        \"\"\"获取或刷新access_token\"\"\"\n        url = \"https://api.weixin.qq.com/cgi-bin/token\"\n        params = {\n            \"grant_type\": \"client_credential\",\n            \"appid\": self.appid,\n            \"secret\": self.secret\n        }\n        response = requests.get(url, params=params, verify=False).json()\n        if 'access_token' in response:\n            self.access_token = response['access_token']\n            self.token_expires = time.time() + response['expires_in'] - 300  # 提前5分钟刷新\n        else:\n            raise Exception(f\"获取access_token失败: {response}\")\n\n    def _ensure_access_token(self):\n        \"\"\"确保access_token有效\"\"\"\n        if time.time() >= self.token_expires or not self.access_token:\n            self._refresh_access_token()\n\n    def upload_file(self, local_path, cloud_path):\n        \"\"\"\n        上传本地文件到微信云存储\n        :param local_path: 本地文件路径\n        :param cloud_path: 云端存储路径（如：'images/example.jpg'）\n        :return: 文件ID（用于后续下载）\n        \"\"\"\n        self._ensure_access_token()\n        \n        # 1. 获取上传元数据\n        upload_meta_url = \"https://api.weixin.qq.com/tcb/uploadfile\"\n        params = {\"access_token\": self.access_token}\n        payload = {\"env\": self.env, \"path\": cloud_path}\n        response = requests.post(upload_meta_url, params=params, json=payload,verify=False).json()\n        print(payload, params)\n        if response.get('errcode', 0) != 0:\n            raise Exception(f\"上传元数据获取失败: {response}\")\n        \n        # 2. 上传文件到COS\n        cos_url = response['url']\n       \n        key = cloud_path.split('/')[-1]\n        print(key)\n        files = {\n            \"Signature\":(None,response['authorization']),\n            \"x-cos-meta-fileid\": (None, response['cos_file_id']),\n            \"x-cos-security-token\": (None,response['token']),\n            \"key\": (None, cloud_path),\n            'file':(key, open(local_path, 'rb')),\n        }\n\n        upload_resp = requests.post(cos_url, files=files, verify=False)\n        if upload_resp.status_code != 204:\n            raise Exception(f\"COS上传失败: {upload_resp.text}\", upload_resp)\n       \n        return response['file_id']\n\n    def download_file(self, file_id, local_path):\n        \"\"\"\n        从微信云存储下载文件\n        :param file_id: 文件ID（上传时返回的file_id）\n        :param local_path: 本地存储路径\n        \"\"\"\n        self._ensure_access_token()\n        \n        # 1. 获取下载链接\n        download_meta_url = \"https://api.weixin.qq.com/tcb/batchdownloadfile\"\n        params = {\"access_token\": self.access_token}\n        payload = {\n            \"env\": self.env,\n            \"file_list\": [{\"fileid\": file_id, \"max_age\": 7200}]\n        }\n        response = requests.post(download_meta_url, params=params, json=payload, verify=False).json()\n        \n        if response.get('errcode', 0) != 0:\n            raise Exception(f\"下载元数据获取失败: {response}\")\n        \n        file_info = response['file_list'][0]\n        if file_info['status'] != 0:\n            raise Exception(f\"下载错误: {file_info['errmsg']}\")\n        \n        # 2. 下载文件\n        download_resp = requests.get(file_info['download_url'], verify=False)\n        if download_resp.status_code != 200:\n            raise Exception(\"文件下载失败\")\n        \n        with open(local_path, 'wb') as f:\n            f.write(download_resp.content)\n            \n        return True\n\n# 使用示例\nif __name__ == \"__main__\":\n    # 配置信息（需要替换为实际值）\n    APPID = \"your-wechat-appid\"\n    SECRET = \"your-wechat-secret\"\n    ENV_ID = \"your-cloud-env-id\"\n   \n    # 上传示例\n    storage = WeChatCloudStorage(APPID, SECRET, ENV_ID)\n    try:\n        file_id = storage.upload_file(\"../test.png\", \"image/test2.png\")\n        print(f\"文件上传成功，File ID: {file_id}\")\n    except Exception as e:\n        print(f\"上传失败: {e}\")\n    # 下载示例\n    try:\n        storage.download_file(file_id, \"downloaded_image.jpg\")\n        print(\"文件下载成功\")\n    except Exception as e:\n        print(f\"下载失败: {e}\")\n\n\n```\n\n以上就是关于对象存储管理相关的内容了，如果你在开发类似的功能过程中有类似的idea或者遇到一些难搞的坑，欢迎一起讨论。","source":"_posts/Manage-wx-could-service.md","raw":"---\ntitle: 关于微信云托管对象存储那点事\ndate: 2025-05-23 12:40:00\ncategory: 小程序开发\ntags:\n    - 小程序\n    - 微信云\n    - 对象存储\n---\n最近在鼓捣一个关于图像处理相关的小程序，出于快速开发考虑，在后台开发这块，没有选择走传统的后台部署服务。毕竟，购买云服务器，注册购买域名以及备案等一系列操作下来，也够让人心累。\n\n这次选择的是微信开发的平台的云托管，至于为什么走的不是云函数开发，其中就涉及到了开发语言的选择--python, 如果改用javascript重写一下，成本有点高，所以最终方案选择云托管。\n\n在按照云托管的部署流程一通走下来后，everything is fine. But...\n\n离大谱的，接口请求和响应，居然不能超过1M, 而我这程序就是关于图像处理的，动不动图片大小就会超过1M。如果非要限制用户图片大小限制在1M以下，太过影响用户体验。\n\n此外我还想过，在用户端使用图像压缩，但图像太大压缩也会存在超过1M的情况，另外清晰度也会受到影响。\n\n在微信开发社区和各个IT论坛找了一圈下来，其实没有比较好的解决方案，最终都需要经过一个中间对象存储的过程。\n\n也就是先将图片上传到云上，让后将图片对象的id作为接口入参传入，后台需要使用到图片的时候根据图片id下载即可，然后将处理后的图片，又要上传回云上，返回给客户端新的图片的id，客户端可以根据图片id来获取资源。如下图\n\n<!-- ![处理流程](./imgs/微信云对象存储..png) -->\n<div align=\"center\">\n    <img src=\"/imgs/微信云对象存储..png\" width=\"80%\" height=\"20%\" alt=\"处理流程\"/>\n</div>\n\n\n\n对象存储云平台其实很多，例如比较有名的比如七牛，阿里，还有腾讯云自己的。我这里采用了微信云对象存储，具体的使用呢可以参考 [微信云托管对象存储](https://developers.weixin.qq.com/minigame/dev/wxcloudrun/src/guide/storage/manage.html)，相应的开发手册可以参考[对象存储-服务端和其他客户端](https://developers.weixin.qq.com/minigame/dev/wxcloudrun/src/development/storage/service/)\n\n\n为了在后续的开发中更好处理类似的情况，我将微信云托管对象存储做成了一个模块，具体实现情况如下。\n\n首先，需要从自己的小程序或者和云托管平台获取到以下三个重要参数：\n\n- **APPID** ： \"your-wechat-appid\"\n- **SECRET**： \"your-wechat-secret\"\n- **ENV_ID**： \"your-cloud-env-id\"\n\n- ### 文件上传 (获取token-获取元数据-上传COS)\n\n微信开放平台如果第三方调用对应接口的话，都是需要鉴权了，所以首先我们需要获取到token值。\n\n``` Python\ndef _refresh_access_token(self):\n        \"\"\"获取或刷新access_token\"\"\"\n        url = \"https://api.weixin.qq.com/cgi-bin/token\"\n        params = {\n            \"grant_type\": \"client_credential\",\n            \"appid\": self.appid,\n            \"secret\": self.secret\n        }\n        response = requests.get(url, params=params, verify=False).json()\n        if 'access_token' in response:\n            self.access_token = response['access_token']\n            self.token_expires = time.time() + response['expires_in'] - 300  # 提前5分钟刷新\n        else:\n            raise Exception(f\"获取access_token失败: {response}\")\n```\n\n\n文件上传可以分成2步：**1获取上传元数据，2上传文件到COS**。\n\n获取元数据可以理解为向平台发送请求，获取一个用来存放一个文件（存储对象）的一个URL地址, 上传文件到COS可以则可以理解成将资源放到上一步生成的URL地址上，经此，文件才算真正的上传成功了。\n\n``` Python\n    def upload_file(self, local_path, cloud_path):\n        \"\"\"\n        上传本地文件到微信云存储\n        :param local_path: 本地文件路径\n        :param cloud_path: 云端存储路径（如：'images/example.jpg'）\n        :return: 文件ID（用于后续下载）\n        \"\"\"\n        self._ensure_access_token()\n        \n        # 1. 获取上传元数据\n        upload_meta_url = \"https://api.weixin.qq.com/tcb/uploadfile\"\n        params = {\"access_token\": self.access_token}\n        payload = {\"env\": self.env, \"path\": cloud_path}\n        response = requests.post(upload_meta_url, params=params, json=payload,verify=False).json()\n        print(payload, params)\n        if response.get('errcode', 0) != 0:\n            raise Exception(f\"上传元数据获取失败: {response}\")\n        \n        # 2. 上传文件到COS\n        cos_url = response['url']\n       \n        key = cloud_path.split('/')[-1]\n        print(key)\n        files = {\n            \"Signature\":(None,response['authorization']),\n            \"x-cos-meta-fileid\": (None, response['cos_file_id']),\n            \"x-cos-security-token\": (None,response['token']),\n            \"key\": (None, cloud_path),\n            'file':(key, open(local_path, 'rb')),\n        }\n\n        upload_resp = requests.post(cos_url, files=files, verify=False)\n        if upload_resp.status_code != 204:\n            raise Exception(f\"COS上传失败: {upload_resp.text}\", upload_resp)\n       \n        return response['file_id']\n```\n\n\n- ### 文件下载\n\n下载文件相对简单一些，直接调用微信开放平台对外提供的批量下载接口，当然对应的token也是需要的，这部分就不做赘述，代码实现可以参考下方。\n\n``` Python \n\ndef download_file(self, file_id, local_path):\n        \"\"\"\n        从微信云存储下载文件\n        :param file_id: 文件ID（上传时返回的file_id）\n        :param local_path: 本地存储路径\n        \"\"\"\n        self._ensure_access_token()\n        \n        # 1. 获取下载链接\n        download_meta_url = \"https://api.weixin.qq.com/tcb/batchdownloadfile\"\n        params = {\"access_token\": self.access_token}\n        payload = {\n            \"env\": self.env,\n            \"file_list\": [{\"fileid\": file_id, \"max_age\": 7200}]\n        }\n        response = requests.post(download_meta_url, params=params, json=payload, verify=False).json()\n        \n        if response.get('errcode', 0) != 0:\n            raise Exception(f\"下载元数据获取失败: {response}\")\n        \n        file_info = response['file_list'][0]\n        if file_info['status'] != 0:\n            raise Exception(f\"下载错误: {file_info['errmsg']}\")\n        \n        # 2. 下载文件\n        download_resp = requests.get(file_info['download_url'], verify=False)\n        if download_resp.status_code != 200:\n            raise Exception(\"文件下载失败\")\n        \n        with open(local_path, 'wb') as f:\n            f.write(download_resp.content)\n            \n        return True\n```\n\n以上就是微信云托管上对象存储的上传和下载的实现了。为了方便，我们可以将功能在一个类中实现。此外，考虑到token获取接口是有限制的，每天的调用次数是2000次，而每个token的有效时间是2小时，因此可以重复利用已有token。\n\n最终，完整的代码实现如下：\n\n``` Python\n# wx-cloud-storage.py\n# description: 微信云托管对象存储管理模块\nimport requests\nimport time\n\nclass WeChatCloudStorage:\n    def __init__(self, appid, secret, env):\n        self.appid = appid\n        self.secret = secret\n        self.env = env\n        self.access_token = None\n        self.token_expires = 0  # Token过期时间戳\n\n    def _refresh_access_token(self):\n        \"\"\"获取或刷新access_token\"\"\"\n        url = \"https://api.weixin.qq.com/cgi-bin/token\"\n        params = {\n            \"grant_type\": \"client_credential\",\n            \"appid\": self.appid,\n            \"secret\": self.secret\n        }\n        response = requests.get(url, params=params, verify=False).json()\n        if 'access_token' in response:\n            self.access_token = response['access_token']\n            self.token_expires = time.time() + response['expires_in'] - 300  # 提前5分钟刷新\n        else:\n            raise Exception(f\"获取access_token失败: {response}\")\n\n    def _ensure_access_token(self):\n        \"\"\"确保access_token有效\"\"\"\n        if time.time() >= self.token_expires or not self.access_token:\n            self._refresh_access_token()\n\n    def upload_file(self, local_path, cloud_path):\n        \"\"\"\n        上传本地文件到微信云存储\n        :param local_path: 本地文件路径\n        :param cloud_path: 云端存储路径（如：'images/example.jpg'）\n        :return: 文件ID（用于后续下载）\n        \"\"\"\n        self._ensure_access_token()\n        \n        # 1. 获取上传元数据\n        upload_meta_url = \"https://api.weixin.qq.com/tcb/uploadfile\"\n        params = {\"access_token\": self.access_token}\n        payload = {\"env\": self.env, \"path\": cloud_path}\n        response = requests.post(upload_meta_url, params=params, json=payload,verify=False).json()\n        print(payload, params)\n        if response.get('errcode', 0) != 0:\n            raise Exception(f\"上传元数据获取失败: {response}\")\n        \n        # 2. 上传文件到COS\n        cos_url = response['url']\n       \n        key = cloud_path.split('/')[-1]\n        print(key)\n        files = {\n            \"Signature\":(None,response['authorization']),\n            \"x-cos-meta-fileid\": (None, response['cos_file_id']),\n            \"x-cos-security-token\": (None,response['token']),\n            \"key\": (None, cloud_path),\n            'file':(key, open(local_path, 'rb')),\n        }\n\n        upload_resp = requests.post(cos_url, files=files, verify=False)\n        if upload_resp.status_code != 204:\n            raise Exception(f\"COS上传失败: {upload_resp.text}\", upload_resp)\n       \n        return response['file_id']\n\n    def download_file(self, file_id, local_path):\n        \"\"\"\n        从微信云存储下载文件\n        :param file_id: 文件ID（上传时返回的file_id）\n        :param local_path: 本地存储路径\n        \"\"\"\n        self._ensure_access_token()\n        \n        # 1. 获取下载链接\n        download_meta_url = \"https://api.weixin.qq.com/tcb/batchdownloadfile\"\n        params = {\"access_token\": self.access_token}\n        payload = {\n            \"env\": self.env,\n            \"file_list\": [{\"fileid\": file_id, \"max_age\": 7200}]\n        }\n        response = requests.post(download_meta_url, params=params, json=payload, verify=False).json()\n        \n        if response.get('errcode', 0) != 0:\n            raise Exception(f\"下载元数据获取失败: {response}\")\n        \n        file_info = response['file_list'][0]\n        if file_info['status'] != 0:\n            raise Exception(f\"下载错误: {file_info['errmsg']}\")\n        \n        # 2. 下载文件\n        download_resp = requests.get(file_info['download_url'], verify=False)\n        if download_resp.status_code != 200:\n            raise Exception(\"文件下载失败\")\n        \n        with open(local_path, 'wb') as f:\n            f.write(download_resp.content)\n            \n        return True\n\n# 使用示例\nif __name__ == \"__main__\":\n    # 配置信息（需要替换为实际值）\n    APPID = \"your-wechat-appid\"\n    SECRET = \"your-wechat-secret\"\n    ENV_ID = \"your-cloud-env-id\"\n   \n    # 上传示例\n    storage = WeChatCloudStorage(APPID, SECRET, ENV_ID)\n    try:\n        file_id = storage.upload_file(\"../test.png\", \"image/test2.png\")\n        print(f\"文件上传成功，File ID: {file_id}\")\n    except Exception as e:\n        print(f\"上传失败: {e}\")\n    # 下载示例\n    try:\n        storage.download_file(file_id, \"downloaded_image.jpg\")\n        print(\"文件下载成功\")\n    except Exception as e:\n        print(f\"下载失败: {e}\")\n\n\n```\n\n以上就是关于对象存储管理相关的内容了，如果你在开发类似的功能过程中有类似的idea或者遇到一些难搞的坑，欢迎一起讨论。","slug":"Manage-wx-could-service","published":1,"updated":"2025-06-21T14:16:44.677Z","_id":"cmb0qjkps000350up5hzhbjyl","comments":1,"layout":"post","photos":[],"content":"<p>最近在鼓捣一个关于图像处理相关的小程序，出于快速开发考虑，在后台开发这块，没有选择走传统的后台部署服务。毕竟，购买云服务器，注册购买域名以及备案等一系列操作下来，也够让人心累。</p>\n<p>这次选择的是微信开发的平台的云托管，至于为什么走的不是云函数开发，其中就涉及到了开发语言的选择–python, 如果改用javascript重写一下，成本有点高，所以最终方案选择云托管。</p>\n<p>在按照云托管的部署流程一通走下来后，everything is fine. But…</p>\n<p>离大谱的，接口请求和响应，居然不能超过1M, 而我这程序就是关于图像处理的，动不动图片大小就会超过1M。如果非要限制用户图片大小限制在1M以下，太过影响用户体验。</p>\n<p>此外我还想过，在用户端使用图像压缩，但图像太大压缩也会存在超过1M的情况，另外清晰度也会受到影响。</p>\n<p>在微信开发社区和各个IT论坛找了一圈下来，其实没有比较好的解决方案，最终都需要经过一个中间对象存储的过程。</p>\n<p>也就是先将图片上传到云上，让后将图片对象的id作为接口入参传入，后台需要使用到图片的时候根据图片id下载即可，然后将处理后的图片，又要上传回云上，返回给客户端新的图片的id，客户端可以根据图片id来获取资源。如下图</p>\n<!-- ![处理流程](./imgs/微信云对象存储..png) -->\n<div align=\"center\">\n    <img src=\"/imgs/微信云对象存储..png\" width=\"80%\" height=\"20%\" alt=\"处理流程\"/>\n</div>\n\n\n\n<p>对象存储云平台其实很多，例如比较有名的比如七牛，阿里，还有腾讯云自己的。我这里采用了微信云对象存储，具体的使用呢可以参考 <a href=\"https://developers.weixin.qq.com/minigame/dev/wxcloudrun/src/guide/storage/manage.html\">微信云托管对象存储</a>，相应的开发手册可以参考<a href=\"https://developers.weixin.qq.com/minigame/dev/wxcloudrun/src/development/storage/service/\">对象存储-服务端和其他客户端</a></p>\n<p>为了在后续的开发中更好处理类似的情况，我将微信云托管对象存储做成了一个模块，具体实现情况如下。</p>\n<p>首先，需要从自己的小程序或者和云托管平台获取到以下三个重要参数：</p>\n<ul>\n<li><p><strong>APPID</strong> ： “your-wechat-appid”</p>\n</li>\n<li><p><strong>SECRET</strong>： “your-wechat-secret”</p>\n</li>\n<li><p><strong>ENV_ID</strong>： “your-cloud-env-id”</p>\n</li>\n<li><h3 id=\"文件上传-获取token-获取元数据-上传COS\"><a href=\"#文件上传-获取token-获取元数据-上传COS\" class=\"headerlink\" title=\"文件上传 (获取token-获取元数据-上传COS)\"></a>文件上传 (获取token-获取元数据-上传COS)</h3></li>\n</ul>\n<p>微信开放平台如果第三方调用对应接口的话，都是需要鉴权了，所以首先我们需要获取到token值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_refresh_access_token</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;获取或刷新access_token&quot;&quot;&quot;</span><br>        url = <span class=\"hljs-string\">&quot;https://api.weixin.qq.com/cgi-bin/token&quot;</span><br>        params = &#123;<br>            <span class=\"hljs-string\">&quot;grant_type&quot;</span>: <span class=\"hljs-string\">&quot;client_credential&quot;</span>,<br>            <span class=\"hljs-string\">&quot;appid&quot;</span>: <span class=\"hljs-variable language_\">self</span>.appid,<br>            <span class=\"hljs-string\">&quot;secret&quot;</span>: <span class=\"hljs-variable language_\">self</span>.secret<br>        &#125;<br>        response = requests.get(url, params=params, verify=<span class=\"hljs-literal\">False</span>).json()<br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-string\">&#x27;access_token&#x27;</span> <span class=\"hljs-keyword\">in</span> response:<br>            <span class=\"hljs-variable language_\">self</span>.access_token = response[<span class=\"hljs-string\">&#x27;access_token&#x27;</span>]<br>            <span class=\"hljs-variable language_\">self</span>.token_expires = time.time() + response[<span class=\"hljs-string\">&#x27;expires_in&#x27;</span>] - <span class=\"hljs-number\">300</span>  <span class=\"hljs-comment\"># 提前5分钟刷新</span><br>        <span class=\"hljs-keyword\">else</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;获取access_token失败: <span class=\"hljs-subst\">&#123;response&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n\n<p>文件上传可以分成2步：<strong>1获取上传元数据，2上传文件到COS</strong>。</p>\n<p>获取元数据可以理解为向平台发送请求，获取一个用来存放一个文件（存储对象）的一个URL地址, 上传文件到COS可以则可以理解成将资源放到上一步生成的URL地址上，经此，文件才算真正的上传成功了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">upload_file</span>(<span class=\"hljs-params\">self, local_path, cloud_path</span>):<br>    <span class=\"hljs-string\">&quot;&quot;&quot;</span><br><span class=\"hljs-string\">    上传本地文件到微信云存储</span><br><span class=\"hljs-string\">    :param local_path: 本地文件路径</span><br><span class=\"hljs-string\">    :param cloud_path: 云端存储路径（如：&#x27;images/example.jpg&#x27;）</span><br><span class=\"hljs-string\">    :return: 文件ID（用于后续下载）</span><br><span class=\"hljs-string\">    &quot;&quot;&quot;</span><br>    <span class=\"hljs-variable language_\">self</span>._ensure_access_token()<br>    <br>    <span class=\"hljs-comment\"># 1. 获取上传元数据</span><br>    upload_meta_url = <span class=\"hljs-string\">&quot;https://api.weixin.qq.com/tcb/uploadfile&quot;</span><br>    params = &#123;<span class=\"hljs-string\">&quot;access_token&quot;</span>: <span class=\"hljs-variable language_\">self</span>.access_token&#125;<br>    payload = &#123;<span class=\"hljs-string\">&quot;env&quot;</span>: <span class=\"hljs-variable language_\">self</span>.env, <span class=\"hljs-string\">&quot;path&quot;</span>: cloud_path&#125;<br>    response = requests.post(upload_meta_url, params=params, json=payload,verify=<span class=\"hljs-literal\">False</span>).json()<br>    <span class=\"hljs-built_in\">print</span>(payload, params)<br>    <span class=\"hljs-keyword\">if</span> response.get(<span class=\"hljs-string\">&#x27;errcode&#x27;</span>, <span class=\"hljs-number\">0</span>) != <span class=\"hljs-number\">0</span>:<br>        <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;上传元数据获取失败: <span class=\"hljs-subst\">&#123;response&#125;</span>&quot;</span>)<br>    <br>    <span class=\"hljs-comment\"># 2. 上传文件到COS</span><br>    cos_url = response[<span class=\"hljs-string\">&#x27;url&#x27;</span>]<br>   <br>    key = cloud_path.split(<span class=\"hljs-string\">&#x27;/&#x27;</span>)[-<span class=\"hljs-number\">1</span>]<br>    <span class=\"hljs-built_in\">print</span>(key)<br>    files = &#123;<br>        <span class=\"hljs-string\">&quot;Signature&quot;</span>:(<span class=\"hljs-literal\">None</span>,response[<span class=\"hljs-string\">&#x27;authorization&#x27;</span>]),<br>        <span class=\"hljs-string\">&quot;x-cos-meta-fileid&quot;</span>: (<span class=\"hljs-literal\">None</span>, response[<span class=\"hljs-string\">&#x27;cos_file_id&#x27;</span>]),<br>        <span class=\"hljs-string\">&quot;x-cos-security-token&quot;</span>: (<span class=\"hljs-literal\">None</span>,response[<span class=\"hljs-string\">&#x27;token&#x27;</span>]),<br>        <span class=\"hljs-string\">&quot;key&quot;</span>: (<span class=\"hljs-literal\">None</span>, cloud_path),<br>        <span class=\"hljs-string\">&#x27;file&#x27;</span>:(key, <span class=\"hljs-built_in\">open</span>(local_path, <span class=\"hljs-string\">&#x27;rb&#x27;</span>)),<br>    &#125;<br><br>    upload_resp = requests.post(cos_url, files=files, verify=<span class=\"hljs-literal\">False</span>)<br>    <span class=\"hljs-keyword\">if</span> upload_resp.status_code != <span class=\"hljs-number\">204</span>:<br>        <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;COS上传失败: <span class=\"hljs-subst\">&#123;upload_resp.text&#125;</span>&quot;</span>, upload_resp)<br>   <br>    <span class=\"hljs-keyword\">return</span> response[<span class=\"hljs-string\">&#x27;file_id&#x27;</span>]<br></code></pre></td></tr></table></figure>\n\n\n<ul>\n<li><h3 id=\"文件下载\"><a href=\"#文件下载\" class=\"headerlink\" title=\"文件下载\"></a>文件下载</h3></li>\n</ul>\n<p>下载文件相对简单一些，直接调用微信开放平台对外提供的批量下载接口，当然对应的token也是需要的，这部分就不做赘述，代码实现可以参考下方。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Python\"><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">download_file</span>(<span class=\"hljs-params\">self, file_id, local_path</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;</span><br><span class=\"hljs-string\">        从微信云存储下载文件</span><br><span class=\"hljs-string\">        :param file_id: 文件ID（上传时返回的file_id）</span><br><span class=\"hljs-string\">        :param local_path: 本地存储路径</span><br><span class=\"hljs-string\">        &quot;&quot;&quot;</span><br>        <span class=\"hljs-variable language_\">self</span>._ensure_access_token()<br>        <br>        <span class=\"hljs-comment\"># 1. 获取下载链接</span><br>        download_meta_url = <span class=\"hljs-string\">&quot;https://api.weixin.qq.com/tcb/batchdownloadfile&quot;</span><br>        params = &#123;<span class=\"hljs-string\">&quot;access_token&quot;</span>: <span class=\"hljs-variable language_\">self</span>.access_token&#125;<br>        payload = &#123;<br>            <span class=\"hljs-string\">&quot;env&quot;</span>: <span class=\"hljs-variable language_\">self</span>.env,<br>            <span class=\"hljs-string\">&quot;file_list&quot;</span>: [&#123;<span class=\"hljs-string\">&quot;fileid&quot;</span>: file_id, <span class=\"hljs-string\">&quot;max_age&quot;</span>: <span class=\"hljs-number\">7200</span>&#125;]<br>        &#125;<br>        response = requests.post(download_meta_url, params=params, json=payload, verify=<span class=\"hljs-literal\">False</span>).json()<br>        <br>        <span class=\"hljs-keyword\">if</span> response.get(<span class=\"hljs-string\">&#x27;errcode&#x27;</span>, <span class=\"hljs-number\">0</span>) != <span class=\"hljs-number\">0</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;下载元数据获取失败: <span class=\"hljs-subst\">&#123;response&#125;</span>&quot;</span>)<br>        <br>        file_info = response[<span class=\"hljs-string\">&#x27;file_list&#x27;</span>][<span class=\"hljs-number\">0</span>]<br>        <span class=\"hljs-keyword\">if</span> file_info[<span class=\"hljs-string\">&#x27;status&#x27;</span>] != <span class=\"hljs-number\">0</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;下载错误: <span class=\"hljs-subst\">&#123;file_info[<span class=\"hljs-string\">&#x27;errmsg&#x27;</span>]&#125;</span>&quot;</span>)<br>        <br>        <span class=\"hljs-comment\"># 2. 下载文件</span><br>        download_resp = requests.get(file_info[<span class=\"hljs-string\">&#x27;download_url&#x27;</span>], verify=<span class=\"hljs-literal\">False</span>)<br>        <span class=\"hljs-keyword\">if</span> download_resp.status_code != <span class=\"hljs-number\">200</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">&quot;文件下载失败&quot;</span>)<br>        <br>        <span class=\"hljs-keyword\">with</span> <span class=\"hljs-built_in\">open</span>(local_path, <span class=\"hljs-string\">&#x27;wb&#x27;</span>) <span class=\"hljs-keyword\">as</span> f:<br>            f.write(download_resp.content)<br>            <br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span><br></code></pre></td></tr></table></figure>\n\n<p>以上就是微信云托管上对象存储的上传和下载的实现了。为了方便，我们可以将功能在一个类中实现。此外，考虑到token获取接口是有限制的，每天的调用次数是2000次，而每个token的有效时间是2小时，因此可以重复利用已有token。</p>\n<p>最终，完整的代码实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Python\"><span class=\"hljs-comment\"># wx-cloud-storage.py</span><br><span class=\"hljs-comment\"># description: 微信云托管对象存储管理模块</span><br><span class=\"hljs-keyword\">import</span> requests<br><span class=\"hljs-keyword\">import</span> time<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">WeChatCloudStorage</span>:<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, appid, secret, env</span>):<br>        <span class=\"hljs-variable language_\">self</span>.appid = appid<br>        <span class=\"hljs-variable language_\">self</span>.secret = secret<br>        <span class=\"hljs-variable language_\">self</span>.env = env<br>        <span class=\"hljs-variable language_\">self</span>.access_token = <span class=\"hljs-literal\">None</span><br>        <span class=\"hljs-variable language_\">self</span>.token_expires = <span class=\"hljs-number\">0</span>  <span class=\"hljs-comment\"># Token过期时间戳</span><br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_refresh_access_token</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;获取或刷新access_token&quot;&quot;&quot;</span><br>        url = <span class=\"hljs-string\">&quot;https://api.weixin.qq.com/cgi-bin/token&quot;</span><br>        params = &#123;<br>            <span class=\"hljs-string\">&quot;grant_type&quot;</span>: <span class=\"hljs-string\">&quot;client_credential&quot;</span>,<br>            <span class=\"hljs-string\">&quot;appid&quot;</span>: <span class=\"hljs-variable language_\">self</span>.appid,<br>            <span class=\"hljs-string\">&quot;secret&quot;</span>: <span class=\"hljs-variable language_\">self</span>.secret<br>        &#125;<br>        response = requests.get(url, params=params, verify=<span class=\"hljs-literal\">False</span>).json()<br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-string\">&#x27;access_token&#x27;</span> <span class=\"hljs-keyword\">in</span> response:<br>            <span class=\"hljs-variable language_\">self</span>.access_token = response[<span class=\"hljs-string\">&#x27;access_token&#x27;</span>]<br>            <span class=\"hljs-variable language_\">self</span>.token_expires = time.time() + response[<span class=\"hljs-string\">&#x27;expires_in&#x27;</span>] - <span class=\"hljs-number\">300</span>  <span class=\"hljs-comment\"># 提前5分钟刷新</span><br>        <span class=\"hljs-keyword\">else</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;获取access_token失败: <span class=\"hljs-subst\">&#123;response&#125;</span>&quot;</span>)<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_ensure_access_token</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;确保access_token有效&quot;&quot;&quot;</span><br>        <span class=\"hljs-keyword\">if</span> time.time() &gt;= <span class=\"hljs-variable language_\">self</span>.token_expires <span class=\"hljs-keyword\">or</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-variable language_\">self</span>.access_token:<br>            <span class=\"hljs-variable language_\">self</span>._refresh_access_token()<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">upload_file</span>(<span class=\"hljs-params\">self, local_path, cloud_path</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;</span><br><span class=\"hljs-string\">        上传本地文件到微信云存储</span><br><span class=\"hljs-string\">        :param local_path: 本地文件路径</span><br><span class=\"hljs-string\">        :param cloud_path: 云端存储路径（如：&#x27;images/example.jpg&#x27;）</span><br><span class=\"hljs-string\">        :return: 文件ID（用于后续下载）</span><br><span class=\"hljs-string\">        &quot;&quot;&quot;</span><br>        <span class=\"hljs-variable language_\">self</span>._ensure_access_token()<br>        <br>        <span class=\"hljs-comment\"># 1. 获取上传元数据</span><br>        upload_meta_url = <span class=\"hljs-string\">&quot;https://api.weixin.qq.com/tcb/uploadfile&quot;</span><br>        params = &#123;<span class=\"hljs-string\">&quot;access_token&quot;</span>: <span class=\"hljs-variable language_\">self</span>.access_token&#125;<br>        payload = &#123;<span class=\"hljs-string\">&quot;env&quot;</span>: <span class=\"hljs-variable language_\">self</span>.env, <span class=\"hljs-string\">&quot;path&quot;</span>: cloud_path&#125;<br>        response = requests.post(upload_meta_url, params=params, json=payload,verify=<span class=\"hljs-literal\">False</span>).json()<br>        <span class=\"hljs-built_in\">print</span>(payload, params)<br>        <span class=\"hljs-keyword\">if</span> response.get(<span class=\"hljs-string\">&#x27;errcode&#x27;</span>, <span class=\"hljs-number\">0</span>) != <span class=\"hljs-number\">0</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;上传元数据获取失败: <span class=\"hljs-subst\">&#123;response&#125;</span>&quot;</span>)<br>        <br>        <span class=\"hljs-comment\"># 2. 上传文件到COS</span><br>        cos_url = response[<span class=\"hljs-string\">&#x27;url&#x27;</span>]<br>       <br>        key = cloud_path.split(<span class=\"hljs-string\">&#x27;/&#x27;</span>)[-<span class=\"hljs-number\">1</span>]<br>        <span class=\"hljs-built_in\">print</span>(key)<br>        files = &#123;<br>            <span class=\"hljs-string\">&quot;Signature&quot;</span>:(<span class=\"hljs-literal\">None</span>,response[<span class=\"hljs-string\">&#x27;authorization&#x27;</span>]),<br>            <span class=\"hljs-string\">&quot;x-cos-meta-fileid&quot;</span>: (<span class=\"hljs-literal\">None</span>, response[<span class=\"hljs-string\">&#x27;cos_file_id&#x27;</span>]),<br>            <span class=\"hljs-string\">&quot;x-cos-security-token&quot;</span>: (<span class=\"hljs-literal\">None</span>,response[<span class=\"hljs-string\">&#x27;token&#x27;</span>]),<br>            <span class=\"hljs-string\">&quot;key&quot;</span>: (<span class=\"hljs-literal\">None</span>, cloud_path),<br>            <span class=\"hljs-string\">&#x27;file&#x27;</span>:(key, <span class=\"hljs-built_in\">open</span>(local_path, <span class=\"hljs-string\">&#x27;rb&#x27;</span>)),<br>        &#125;<br><br>        upload_resp = requests.post(cos_url, files=files, verify=<span class=\"hljs-literal\">False</span>)<br>        <span class=\"hljs-keyword\">if</span> upload_resp.status_code != <span class=\"hljs-number\">204</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;COS上传失败: <span class=\"hljs-subst\">&#123;upload_resp.text&#125;</span>&quot;</span>, upload_resp)<br>       <br>        <span class=\"hljs-keyword\">return</span> response[<span class=\"hljs-string\">&#x27;file_id&#x27;</span>]<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">download_file</span>(<span class=\"hljs-params\">self, file_id, local_path</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;</span><br><span class=\"hljs-string\">        从微信云存储下载文件</span><br><span class=\"hljs-string\">        :param file_id: 文件ID（上传时返回的file_id）</span><br><span class=\"hljs-string\">        :param local_path: 本地存储路径</span><br><span class=\"hljs-string\">        &quot;&quot;&quot;</span><br>        <span class=\"hljs-variable language_\">self</span>._ensure_access_token()<br>        <br>        <span class=\"hljs-comment\"># 1. 获取下载链接</span><br>        download_meta_url = <span class=\"hljs-string\">&quot;https://api.weixin.qq.com/tcb/batchdownloadfile&quot;</span><br>        params = &#123;<span class=\"hljs-string\">&quot;access_token&quot;</span>: <span class=\"hljs-variable language_\">self</span>.access_token&#125;<br>        payload = &#123;<br>            <span class=\"hljs-string\">&quot;env&quot;</span>: <span class=\"hljs-variable language_\">self</span>.env,<br>            <span class=\"hljs-string\">&quot;file_list&quot;</span>: [&#123;<span class=\"hljs-string\">&quot;fileid&quot;</span>: file_id, <span class=\"hljs-string\">&quot;max_age&quot;</span>: <span class=\"hljs-number\">7200</span>&#125;]<br>        &#125;<br>        response = requests.post(download_meta_url, params=params, json=payload, verify=<span class=\"hljs-literal\">False</span>).json()<br>        <br>        <span class=\"hljs-keyword\">if</span> response.get(<span class=\"hljs-string\">&#x27;errcode&#x27;</span>, <span class=\"hljs-number\">0</span>) != <span class=\"hljs-number\">0</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;下载元数据获取失败: <span class=\"hljs-subst\">&#123;response&#125;</span>&quot;</span>)<br>        <br>        file_info = response[<span class=\"hljs-string\">&#x27;file_list&#x27;</span>][<span class=\"hljs-number\">0</span>]<br>        <span class=\"hljs-keyword\">if</span> file_info[<span class=\"hljs-string\">&#x27;status&#x27;</span>] != <span class=\"hljs-number\">0</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;下载错误: <span class=\"hljs-subst\">&#123;file_info[<span class=\"hljs-string\">&#x27;errmsg&#x27;</span>]&#125;</span>&quot;</span>)<br>        <br>        <span class=\"hljs-comment\"># 2. 下载文件</span><br>        download_resp = requests.get(file_info[<span class=\"hljs-string\">&#x27;download_url&#x27;</span>], verify=<span class=\"hljs-literal\">False</span>)<br>        <span class=\"hljs-keyword\">if</span> download_resp.status_code != <span class=\"hljs-number\">200</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">&quot;文件下载失败&quot;</span>)<br>        <br>        <span class=\"hljs-keyword\">with</span> <span class=\"hljs-built_in\">open</span>(local_path, <span class=\"hljs-string\">&#x27;wb&#x27;</span>) <span class=\"hljs-keyword\">as</span> f:<br>            f.write(download_resp.content)<br>            <br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span><br><br><span class=\"hljs-comment\"># 使用示例</span><br><span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:<br>    <span class=\"hljs-comment\"># 配置信息（需要替换为实际值）</span><br>    APPID = <span class=\"hljs-string\">&quot;your-wechat-appid&quot;</span><br>    SECRET = <span class=\"hljs-string\">&quot;your-wechat-secret&quot;</span><br>    ENV_ID = <span class=\"hljs-string\">&quot;your-cloud-env-id&quot;</span><br>   <br>    <span class=\"hljs-comment\"># 上传示例</span><br>    storage = WeChatCloudStorage(APPID, SECRET, ENV_ID)<br>    <span class=\"hljs-keyword\">try</span>:<br>        file_id = storage.upload_file(<span class=\"hljs-string\">&quot;../test.png&quot;</span>, <span class=\"hljs-string\">&quot;image/test2.png&quot;</span>)<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;文件上传成功，File ID: <span class=\"hljs-subst\">&#123;file_id&#125;</span>&quot;</span>)<br>    <span class=\"hljs-keyword\">except</span> Exception <span class=\"hljs-keyword\">as</span> e:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;上传失败: <span class=\"hljs-subst\">&#123;e&#125;</span>&quot;</span>)<br>    <span class=\"hljs-comment\"># 下载示例</span><br>    <span class=\"hljs-keyword\">try</span>:<br>        storage.download_file(file_id, <span class=\"hljs-string\">&quot;downloaded_image.jpg&quot;</span>)<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;文件下载成功&quot;</span>)<br>    <span class=\"hljs-keyword\">except</span> Exception <span class=\"hljs-keyword\">as</span> e:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;下载失败: <span class=\"hljs-subst\">&#123;e&#125;</span>&quot;</span>)<br><br><br></code></pre></td></tr></table></figure>\n\n<p>以上就是关于对象存储管理相关的内容了，如果你在开发类似的功能过程中有类似的idea或者遇到一些难搞的坑，欢迎一起讨论。</p>\n","excerpt":"","more":"<p>最近在鼓捣一个关于图像处理相关的小程序，出于快速开发考虑，在后台开发这块，没有选择走传统的后台部署服务。毕竟，购买云服务器，注册购买域名以及备案等一系列操作下来，也够让人心累。</p>\n<p>这次选择的是微信开发的平台的云托管，至于为什么走的不是云函数开发，其中就涉及到了开发语言的选择–python, 如果改用javascript重写一下，成本有点高，所以最终方案选择云托管。</p>\n<p>在按照云托管的部署流程一通走下来后，everything is fine. But…</p>\n<p>离大谱的，接口请求和响应，居然不能超过1M, 而我这程序就是关于图像处理的，动不动图片大小就会超过1M。如果非要限制用户图片大小限制在1M以下，太过影响用户体验。</p>\n<p>此外我还想过，在用户端使用图像压缩，但图像太大压缩也会存在超过1M的情况，另外清晰度也会受到影响。</p>\n<p>在微信开发社区和各个IT论坛找了一圈下来，其实没有比较好的解决方案，最终都需要经过一个中间对象存储的过程。</p>\n<p>也就是先将图片上传到云上，让后将图片对象的id作为接口入参传入，后台需要使用到图片的时候根据图片id下载即可，然后将处理后的图片，又要上传回云上，返回给客户端新的图片的id，客户端可以根据图片id来获取资源。如下图</p>\n<!-- ![处理流程](./imgs/微信云对象存储..png) -->\n<div align=\"center\">\n    <img src=\"/imgs/微信云对象存储..png\" width=\"80%\" height=\"20%\" alt=\"处理流程\"/>\n</div>\n\n\n\n<p>对象存储云平台其实很多，例如比较有名的比如七牛，阿里，还有腾讯云自己的。我这里采用了微信云对象存储，具体的使用呢可以参考 <a href=\"https://developers.weixin.qq.com/minigame/dev/wxcloudrun/src/guide/storage/manage.html\">微信云托管对象存储</a>，相应的开发手册可以参考<a href=\"https://developers.weixin.qq.com/minigame/dev/wxcloudrun/src/development/storage/service/\">对象存储-服务端和其他客户端</a></p>\n<p>为了在后续的开发中更好处理类似的情况，我将微信云托管对象存储做成了一个模块，具体实现情况如下。</p>\n<p>首先，需要从自己的小程序或者和云托管平台获取到以下三个重要参数：</p>\n<ul>\n<li><p><strong>APPID</strong> ： “your-wechat-appid”</p>\n</li>\n<li><p><strong>SECRET</strong>： “your-wechat-secret”</p>\n</li>\n<li><p><strong>ENV_ID</strong>： “your-cloud-env-id”</p>\n</li>\n<li><h3 id=\"文件上传-获取token-获取元数据-上传COS\"><a href=\"#文件上传-获取token-获取元数据-上传COS\" class=\"headerlink\" title=\"文件上传 (获取token-获取元数据-上传COS)\"></a>文件上传 (获取token-获取元数据-上传COS)</h3></li>\n</ul>\n<p>微信开放平台如果第三方调用对应接口的话，都是需要鉴权了，所以首先我们需要获取到token值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_refresh_access_token</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;获取或刷新access_token&quot;&quot;&quot;</span><br>        url = <span class=\"hljs-string\">&quot;https://api.weixin.qq.com/cgi-bin/token&quot;</span><br>        params = &#123;<br>            <span class=\"hljs-string\">&quot;grant_type&quot;</span>: <span class=\"hljs-string\">&quot;client_credential&quot;</span>,<br>            <span class=\"hljs-string\">&quot;appid&quot;</span>: <span class=\"hljs-variable language_\">self</span>.appid,<br>            <span class=\"hljs-string\">&quot;secret&quot;</span>: <span class=\"hljs-variable language_\">self</span>.secret<br>        &#125;<br>        response = requests.get(url, params=params, verify=<span class=\"hljs-literal\">False</span>).json()<br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-string\">&#x27;access_token&#x27;</span> <span class=\"hljs-keyword\">in</span> response:<br>            <span class=\"hljs-variable language_\">self</span>.access_token = response[<span class=\"hljs-string\">&#x27;access_token&#x27;</span>]<br>            <span class=\"hljs-variable language_\">self</span>.token_expires = time.time() + response[<span class=\"hljs-string\">&#x27;expires_in&#x27;</span>] - <span class=\"hljs-number\">300</span>  <span class=\"hljs-comment\"># 提前5分钟刷新</span><br>        <span class=\"hljs-keyword\">else</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;获取access_token失败: <span class=\"hljs-subst\">&#123;response&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n\n<p>文件上传可以分成2步：<strong>1获取上传元数据，2上传文件到COS</strong>。</p>\n<p>获取元数据可以理解为向平台发送请求，获取一个用来存放一个文件（存储对象）的一个URL地址, 上传文件到COS可以则可以理解成将资源放到上一步生成的URL地址上，经此，文件才算真正的上传成功了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">upload_file</span>(<span class=\"hljs-params\">self, local_path, cloud_path</span>):<br>    <span class=\"hljs-string\">&quot;&quot;&quot;</span><br><span class=\"hljs-string\">    上传本地文件到微信云存储</span><br><span class=\"hljs-string\">    :param local_path: 本地文件路径</span><br><span class=\"hljs-string\">    :param cloud_path: 云端存储路径（如：&#x27;images/example.jpg&#x27;）</span><br><span class=\"hljs-string\">    :return: 文件ID（用于后续下载）</span><br><span class=\"hljs-string\">    &quot;&quot;&quot;</span><br>    <span class=\"hljs-variable language_\">self</span>._ensure_access_token()<br>    <br>    <span class=\"hljs-comment\"># 1. 获取上传元数据</span><br>    upload_meta_url = <span class=\"hljs-string\">&quot;https://api.weixin.qq.com/tcb/uploadfile&quot;</span><br>    params = &#123;<span class=\"hljs-string\">&quot;access_token&quot;</span>: <span class=\"hljs-variable language_\">self</span>.access_token&#125;<br>    payload = &#123;<span class=\"hljs-string\">&quot;env&quot;</span>: <span class=\"hljs-variable language_\">self</span>.env, <span class=\"hljs-string\">&quot;path&quot;</span>: cloud_path&#125;<br>    response = requests.post(upload_meta_url, params=params, json=payload,verify=<span class=\"hljs-literal\">False</span>).json()<br>    <span class=\"hljs-built_in\">print</span>(payload, params)<br>    <span class=\"hljs-keyword\">if</span> response.get(<span class=\"hljs-string\">&#x27;errcode&#x27;</span>, <span class=\"hljs-number\">0</span>) != <span class=\"hljs-number\">0</span>:<br>        <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;上传元数据获取失败: <span class=\"hljs-subst\">&#123;response&#125;</span>&quot;</span>)<br>    <br>    <span class=\"hljs-comment\"># 2. 上传文件到COS</span><br>    cos_url = response[<span class=\"hljs-string\">&#x27;url&#x27;</span>]<br>   <br>    key = cloud_path.split(<span class=\"hljs-string\">&#x27;/&#x27;</span>)[-<span class=\"hljs-number\">1</span>]<br>    <span class=\"hljs-built_in\">print</span>(key)<br>    files = &#123;<br>        <span class=\"hljs-string\">&quot;Signature&quot;</span>:(<span class=\"hljs-literal\">None</span>,response[<span class=\"hljs-string\">&#x27;authorization&#x27;</span>]),<br>        <span class=\"hljs-string\">&quot;x-cos-meta-fileid&quot;</span>: (<span class=\"hljs-literal\">None</span>, response[<span class=\"hljs-string\">&#x27;cos_file_id&#x27;</span>]),<br>        <span class=\"hljs-string\">&quot;x-cos-security-token&quot;</span>: (<span class=\"hljs-literal\">None</span>,response[<span class=\"hljs-string\">&#x27;token&#x27;</span>]),<br>        <span class=\"hljs-string\">&quot;key&quot;</span>: (<span class=\"hljs-literal\">None</span>, cloud_path),<br>        <span class=\"hljs-string\">&#x27;file&#x27;</span>:(key, <span class=\"hljs-built_in\">open</span>(local_path, <span class=\"hljs-string\">&#x27;rb&#x27;</span>)),<br>    &#125;<br><br>    upload_resp = requests.post(cos_url, files=files, verify=<span class=\"hljs-literal\">False</span>)<br>    <span class=\"hljs-keyword\">if</span> upload_resp.status_code != <span class=\"hljs-number\">204</span>:<br>        <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;COS上传失败: <span class=\"hljs-subst\">&#123;upload_resp.text&#125;</span>&quot;</span>, upload_resp)<br>   <br>    <span class=\"hljs-keyword\">return</span> response[<span class=\"hljs-string\">&#x27;file_id&#x27;</span>]<br></code></pre></td></tr></table></figure>\n\n\n<ul>\n<li><h3 id=\"文件下载\"><a href=\"#文件下载\" class=\"headerlink\" title=\"文件下载\"></a>文件下载</h3></li>\n</ul>\n<p>下载文件相对简单一些，直接调用微信开放平台对外提供的批量下载接口，当然对应的token也是需要的，这部分就不做赘述，代码实现可以参考下方。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Python\"><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">download_file</span>(<span class=\"hljs-params\">self, file_id, local_path</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;</span><br><span class=\"hljs-string\">        从微信云存储下载文件</span><br><span class=\"hljs-string\">        :param file_id: 文件ID（上传时返回的file_id）</span><br><span class=\"hljs-string\">        :param local_path: 本地存储路径</span><br><span class=\"hljs-string\">        &quot;&quot;&quot;</span><br>        <span class=\"hljs-variable language_\">self</span>._ensure_access_token()<br>        <br>        <span class=\"hljs-comment\"># 1. 获取下载链接</span><br>        download_meta_url = <span class=\"hljs-string\">&quot;https://api.weixin.qq.com/tcb/batchdownloadfile&quot;</span><br>        params = &#123;<span class=\"hljs-string\">&quot;access_token&quot;</span>: <span class=\"hljs-variable language_\">self</span>.access_token&#125;<br>        payload = &#123;<br>            <span class=\"hljs-string\">&quot;env&quot;</span>: <span class=\"hljs-variable language_\">self</span>.env,<br>            <span class=\"hljs-string\">&quot;file_list&quot;</span>: [&#123;<span class=\"hljs-string\">&quot;fileid&quot;</span>: file_id, <span class=\"hljs-string\">&quot;max_age&quot;</span>: <span class=\"hljs-number\">7200</span>&#125;]<br>        &#125;<br>        response = requests.post(download_meta_url, params=params, json=payload, verify=<span class=\"hljs-literal\">False</span>).json()<br>        <br>        <span class=\"hljs-keyword\">if</span> response.get(<span class=\"hljs-string\">&#x27;errcode&#x27;</span>, <span class=\"hljs-number\">0</span>) != <span class=\"hljs-number\">0</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;下载元数据获取失败: <span class=\"hljs-subst\">&#123;response&#125;</span>&quot;</span>)<br>        <br>        file_info = response[<span class=\"hljs-string\">&#x27;file_list&#x27;</span>][<span class=\"hljs-number\">0</span>]<br>        <span class=\"hljs-keyword\">if</span> file_info[<span class=\"hljs-string\">&#x27;status&#x27;</span>] != <span class=\"hljs-number\">0</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;下载错误: <span class=\"hljs-subst\">&#123;file_info[<span class=\"hljs-string\">&#x27;errmsg&#x27;</span>]&#125;</span>&quot;</span>)<br>        <br>        <span class=\"hljs-comment\"># 2. 下载文件</span><br>        download_resp = requests.get(file_info[<span class=\"hljs-string\">&#x27;download_url&#x27;</span>], verify=<span class=\"hljs-literal\">False</span>)<br>        <span class=\"hljs-keyword\">if</span> download_resp.status_code != <span class=\"hljs-number\">200</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">&quot;文件下载失败&quot;</span>)<br>        <br>        <span class=\"hljs-keyword\">with</span> <span class=\"hljs-built_in\">open</span>(local_path, <span class=\"hljs-string\">&#x27;wb&#x27;</span>) <span class=\"hljs-keyword\">as</span> f:<br>            f.write(download_resp.content)<br>            <br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span><br></code></pre></td></tr></table></figure>\n\n<p>以上就是微信云托管上对象存储的上传和下载的实现了。为了方便，我们可以将功能在一个类中实现。此外，考虑到token获取接口是有限制的，每天的调用次数是2000次，而每个token的有效时间是2小时，因此可以重复利用已有token。</p>\n<p>最终，完整的代码实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Python\"><span class=\"hljs-comment\"># wx-cloud-storage.py</span><br><span class=\"hljs-comment\"># description: 微信云托管对象存储管理模块</span><br><span class=\"hljs-keyword\">import</span> requests<br><span class=\"hljs-keyword\">import</span> time<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">WeChatCloudStorage</span>:<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, appid, secret, env</span>):<br>        <span class=\"hljs-variable language_\">self</span>.appid = appid<br>        <span class=\"hljs-variable language_\">self</span>.secret = secret<br>        <span class=\"hljs-variable language_\">self</span>.env = env<br>        <span class=\"hljs-variable language_\">self</span>.access_token = <span class=\"hljs-literal\">None</span><br>        <span class=\"hljs-variable language_\">self</span>.token_expires = <span class=\"hljs-number\">0</span>  <span class=\"hljs-comment\"># Token过期时间戳</span><br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_refresh_access_token</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;获取或刷新access_token&quot;&quot;&quot;</span><br>        url = <span class=\"hljs-string\">&quot;https://api.weixin.qq.com/cgi-bin/token&quot;</span><br>        params = &#123;<br>            <span class=\"hljs-string\">&quot;grant_type&quot;</span>: <span class=\"hljs-string\">&quot;client_credential&quot;</span>,<br>            <span class=\"hljs-string\">&quot;appid&quot;</span>: <span class=\"hljs-variable language_\">self</span>.appid,<br>            <span class=\"hljs-string\">&quot;secret&quot;</span>: <span class=\"hljs-variable language_\">self</span>.secret<br>        &#125;<br>        response = requests.get(url, params=params, verify=<span class=\"hljs-literal\">False</span>).json()<br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-string\">&#x27;access_token&#x27;</span> <span class=\"hljs-keyword\">in</span> response:<br>            <span class=\"hljs-variable language_\">self</span>.access_token = response[<span class=\"hljs-string\">&#x27;access_token&#x27;</span>]<br>            <span class=\"hljs-variable language_\">self</span>.token_expires = time.time() + response[<span class=\"hljs-string\">&#x27;expires_in&#x27;</span>] - <span class=\"hljs-number\">300</span>  <span class=\"hljs-comment\"># 提前5分钟刷新</span><br>        <span class=\"hljs-keyword\">else</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;获取access_token失败: <span class=\"hljs-subst\">&#123;response&#125;</span>&quot;</span>)<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_ensure_access_token</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;确保access_token有效&quot;&quot;&quot;</span><br>        <span class=\"hljs-keyword\">if</span> time.time() &gt;= <span class=\"hljs-variable language_\">self</span>.token_expires <span class=\"hljs-keyword\">or</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-variable language_\">self</span>.access_token:<br>            <span class=\"hljs-variable language_\">self</span>._refresh_access_token()<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">upload_file</span>(<span class=\"hljs-params\">self, local_path, cloud_path</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;</span><br><span class=\"hljs-string\">        上传本地文件到微信云存储</span><br><span class=\"hljs-string\">        :param local_path: 本地文件路径</span><br><span class=\"hljs-string\">        :param cloud_path: 云端存储路径（如：&#x27;images/example.jpg&#x27;）</span><br><span class=\"hljs-string\">        :return: 文件ID（用于后续下载）</span><br><span class=\"hljs-string\">        &quot;&quot;&quot;</span><br>        <span class=\"hljs-variable language_\">self</span>._ensure_access_token()<br>        <br>        <span class=\"hljs-comment\"># 1. 获取上传元数据</span><br>        upload_meta_url = <span class=\"hljs-string\">&quot;https://api.weixin.qq.com/tcb/uploadfile&quot;</span><br>        params = &#123;<span class=\"hljs-string\">&quot;access_token&quot;</span>: <span class=\"hljs-variable language_\">self</span>.access_token&#125;<br>        payload = &#123;<span class=\"hljs-string\">&quot;env&quot;</span>: <span class=\"hljs-variable language_\">self</span>.env, <span class=\"hljs-string\">&quot;path&quot;</span>: cloud_path&#125;<br>        response = requests.post(upload_meta_url, params=params, json=payload,verify=<span class=\"hljs-literal\">False</span>).json()<br>        <span class=\"hljs-built_in\">print</span>(payload, params)<br>        <span class=\"hljs-keyword\">if</span> response.get(<span class=\"hljs-string\">&#x27;errcode&#x27;</span>, <span class=\"hljs-number\">0</span>) != <span class=\"hljs-number\">0</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;上传元数据获取失败: <span class=\"hljs-subst\">&#123;response&#125;</span>&quot;</span>)<br>        <br>        <span class=\"hljs-comment\"># 2. 上传文件到COS</span><br>        cos_url = response[<span class=\"hljs-string\">&#x27;url&#x27;</span>]<br>       <br>        key = cloud_path.split(<span class=\"hljs-string\">&#x27;/&#x27;</span>)[-<span class=\"hljs-number\">1</span>]<br>        <span class=\"hljs-built_in\">print</span>(key)<br>        files = &#123;<br>            <span class=\"hljs-string\">&quot;Signature&quot;</span>:(<span class=\"hljs-literal\">None</span>,response[<span class=\"hljs-string\">&#x27;authorization&#x27;</span>]),<br>            <span class=\"hljs-string\">&quot;x-cos-meta-fileid&quot;</span>: (<span class=\"hljs-literal\">None</span>, response[<span class=\"hljs-string\">&#x27;cos_file_id&#x27;</span>]),<br>            <span class=\"hljs-string\">&quot;x-cos-security-token&quot;</span>: (<span class=\"hljs-literal\">None</span>,response[<span class=\"hljs-string\">&#x27;token&#x27;</span>]),<br>            <span class=\"hljs-string\">&quot;key&quot;</span>: (<span class=\"hljs-literal\">None</span>, cloud_path),<br>            <span class=\"hljs-string\">&#x27;file&#x27;</span>:(key, <span class=\"hljs-built_in\">open</span>(local_path, <span class=\"hljs-string\">&#x27;rb&#x27;</span>)),<br>        &#125;<br><br>        upload_resp = requests.post(cos_url, files=files, verify=<span class=\"hljs-literal\">False</span>)<br>        <span class=\"hljs-keyword\">if</span> upload_resp.status_code != <span class=\"hljs-number\">204</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;COS上传失败: <span class=\"hljs-subst\">&#123;upload_resp.text&#125;</span>&quot;</span>, upload_resp)<br>       <br>        <span class=\"hljs-keyword\">return</span> response[<span class=\"hljs-string\">&#x27;file_id&#x27;</span>]<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">download_file</span>(<span class=\"hljs-params\">self, file_id, local_path</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;</span><br><span class=\"hljs-string\">        从微信云存储下载文件</span><br><span class=\"hljs-string\">        :param file_id: 文件ID（上传时返回的file_id）</span><br><span class=\"hljs-string\">        :param local_path: 本地存储路径</span><br><span class=\"hljs-string\">        &quot;&quot;&quot;</span><br>        <span class=\"hljs-variable language_\">self</span>._ensure_access_token()<br>        <br>        <span class=\"hljs-comment\"># 1. 获取下载链接</span><br>        download_meta_url = <span class=\"hljs-string\">&quot;https://api.weixin.qq.com/tcb/batchdownloadfile&quot;</span><br>        params = &#123;<span class=\"hljs-string\">&quot;access_token&quot;</span>: <span class=\"hljs-variable language_\">self</span>.access_token&#125;<br>        payload = &#123;<br>            <span class=\"hljs-string\">&quot;env&quot;</span>: <span class=\"hljs-variable language_\">self</span>.env,<br>            <span class=\"hljs-string\">&quot;file_list&quot;</span>: [&#123;<span class=\"hljs-string\">&quot;fileid&quot;</span>: file_id, <span class=\"hljs-string\">&quot;max_age&quot;</span>: <span class=\"hljs-number\">7200</span>&#125;]<br>        &#125;<br>        response = requests.post(download_meta_url, params=params, json=payload, verify=<span class=\"hljs-literal\">False</span>).json()<br>        <br>        <span class=\"hljs-keyword\">if</span> response.get(<span class=\"hljs-string\">&#x27;errcode&#x27;</span>, <span class=\"hljs-number\">0</span>) != <span class=\"hljs-number\">0</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;下载元数据获取失败: <span class=\"hljs-subst\">&#123;response&#125;</span>&quot;</span>)<br>        <br>        file_info = response[<span class=\"hljs-string\">&#x27;file_list&#x27;</span>][<span class=\"hljs-number\">0</span>]<br>        <span class=\"hljs-keyword\">if</span> file_info[<span class=\"hljs-string\">&#x27;status&#x27;</span>] != <span class=\"hljs-number\">0</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;下载错误: <span class=\"hljs-subst\">&#123;file_info[<span class=\"hljs-string\">&#x27;errmsg&#x27;</span>]&#125;</span>&quot;</span>)<br>        <br>        <span class=\"hljs-comment\"># 2. 下载文件</span><br>        download_resp = requests.get(file_info[<span class=\"hljs-string\">&#x27;download_url&#x27;</span>], verify=<span class=\"hljs-literal\">False</span>)<br>        <span class=\"hljs-keyword\">if</span> download_resp.status_code != <span class=\"hljs-number\">200</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">&quot;文件下载失败&quot;</span>)<br>        <br>        <span class=\"hljs-keyword\">with</span> <span class=\"hljs-built_in\">open</span>(local_path, <span class=\"hljs-string\">&#x27;wb&#x27;</span>) <span class=\"hljs-keyword\">as</span> f:<br>            f.write(download_resp.content)<br>            <br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span><br><br><span class=\"hljs-comment\"># 使用示例</span><br><span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:<br>    <span class=\"hljs-comment\"># 配置信息（需要替换为实际值）</span><br>    APPID = <span class=\"hljs-string\">&quot;your-wechat-appid&quot;</span><br>    SECRET = <span class=\"hljs-string\">&quot;your-wechat-secret&quot;</span><br>    ENV_ID = <span class=\"hljs-string\">&quot;your-cloud-env-id&quot;</span><br>   <br>    <span class=\"hljs-comment\"># 上传示例</span><br>    storage = WeChatCloudStorage(APPID, SECRET, ENV_ID)<br>    <span class=\"hljs-keyword\">try</span>:<br>        file_id = storage.upload_file(<span class=\"hljs-string\">&quot;../test.png&quot;</span>, <span class=\"hljs-string\">&quot;image/test2.png&quot;</span>)<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;文件上传成功，File ID: <span class=\"hljs-subst\">&#123;file_id&#125;</span>&quot;</span>)<br>    <span class=\"hljs-keyword\">except</span> Exception <span class=\"hljs-keyword\">as</span> e:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;上传失败: <span class=\"hljs-subst\">&#123;e&#125;</span>&quot;</span>)<br>    <span class=\"hljs-comment\"># 下载示例</span><br>    <span class=\"hljs-keyword\">try</span>:<br>        storage.download_file(file_id, <span class=\"hljs-string\">&quot;downloaded_image.jpg&quot;</span>)<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;文件下载成功&quot;</span>)<br>    <span class=\"hljs-keyword\">except</span> Exception <span class=\"hljs-keyword\">as</span> e:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;下载失败: <span class=\"hljs-subst\">&#123;e&#125;</span>&quot;</span>)<br><br><br></code></pre></td></tr></table></figure>\n\n<p>以上就是关于对象存储管理相关的内容了，如果你在开发类似的功能过程中有类似的idea或者遇到一些难搞的坑，欢迎一起讨论。</p>\n"},{"title":"糟糕，Vite proxy error ECONNREFUSED","date":"2025-05-23T04:40:00.000Z","_content":" \n\n最近正在开发一款应用，前端框架是vite+vue, 后台服务也是使用的node+express组合，当一切工作都在顺利进行的时候，不出意外，意外出现了。\n\n当我尝试使用axios直连本地服务地址的时候，丝滑得如同德芙一样。然而每次请求地址都需要拼写全链接--即host+port+service-path，这是一件很愚蠢的事情。\n\n为了让事情变得简单一些，减少重复工作，我和聪明的各位一样决定使用vite的代理。\n\n因为web的地址9000，本地启动的后台服务地址是8080，所以我最初的配置如下：\n\n``` javascript\nexport default defineConfig({\n  # ...   其它配置\n  server: {\n    host: '0.0.0.0',\n    port: 9000,\n    proxy: {\n      '/api': {\n        target: 'http://localhost:8080/',\n        changeOrigin: true,\n      }\n    }\n  }\n})\n\n```\n\n然后它却对我说 `Vite proxy error ECONNREFUSED`\n\n那么多大风大浪都过去了，居然在这小阴沟里翻了船，忍不了！\n\n## 排查方向\n因为涉及到vite server配置，其本质就是http-server以及http-agent的问题,  于是从从下面几个方向做了一一排查\n\n- **Vite的服务器配置**\n\n- **端口占用或防火墙设置**\n\n- **浏览器或系统代理设置**\n\n- ​**Hosts文件配置问题或DNS解析问题**\n\n\n## 测试验证\n- 首先vite服务配置问题是最先被排除的，因为该项目配置已经经历了时间的考验，在很多项目中都有使用\n\n- 然后通过 `netstat -ano | find 9000` 检查并未发现端口被占用的情况\n\n- 至于代理，确实是开了--科学上网使用。然而在关闭之后，似乎没有起作用，所以问题不在这里。\n\n- 那么还剩最后一条，当我检查我本地的hosts文件时，纳尼，localhost没有配置指向本地的环回地址127.0.0.1，难道是这里出问题了吗。\n\n  为了验证这个想法，我将配置中的target做了以下修改:\n\n  ~~target: 'http://localhost:8080/'~~ </br>\n    target: 'http://127.0.0.1:8080/'\n\n  果然，生效了，看来之前的猜测是对的。\n\n</br>\n\n所以目前至少有两种方法可以解决该问题：\n\n  - **在vite配置中将localhost替换成127.0.0.1**\n  - **在hosts文件中添加localhost的地址**\n\n当然，第二种方式显然是更合理的，几乎是种一劳永逸的方法，在日后不同项目的开发中，总是难免还会存在使用localhost的情况。因此，建议在hosts文件中配置它。\n\n## 总结\n在这个问题中呢，其实也牵扯出更多的关于http server 和 http client相关的知识。不论是server的创建还是client的连接，正确的ip和端口是需要保证的。\n\n当遇到类似的情况时，不妨从底层思考在复杂的封装工具和配置的背后，它的本质是什么，以及正常使用时需要哪些因子的参与。","source":"_posts/Vite-server-error.md","raw":"---\ntitle: 糟糕，Vite proxy error ECONNREFUSED\ndate: 2025-05-23 12:40:00\ncategory: Web开发\ntags:\n  - Vite\n  - Proxy\n  - error\n--- \n\n最近正在开发一款应用，前端框架是vite+vue, 后台服务也是使用的node+express组合，当一切工作都在顺利进行的时候，不出意外，意外出现了。\n\n当我尝试使用axios直连本地服务地址的时候，丝滑得如同德芙一样。然而每次请求地址都需要拼写全链接--即host+port+service-path，这是一件很愚蠢的事情。\n\n为了让事情变得简单一些，减少重复工作，我和聪明的各位一样决定使用vite的代理。\n\n因为web的地址9000，本地启动的后台服务地址是8080，所以我最初的配置如下：\n\n``` javascript\nexport default defineConfig({\n  # ...   其它配置\n  server: {\n    host: '0.0.0.0',\n    port: 9000,\n    proxy: {\n      '/api': {\n        target: 'http://localhost:8080/',\n        changeOrigin: true,\n      }\n    }\n  }\n})\n\n```\n\n然后它却对我说 `Vite proxy error ECONNREFUSED`\n\n那么多大风大浪都过去了，居然在这小阴沟里翻了船，忍不了！\n\n## 排查方向\n因为涉及到vite server配置，其本质就是http-server以及http-agent的问题,  于是从从下面几个方向做了一一排查\n\n- **Vite的服务器配置**\n\n- **端口占用或防火墙设置**\n\n- **浏览器或系统代理设置**\n\n- ​**Hosts文件配置问题或DNS解析问题**\n\n\n## 测试验证\n- 首先vite服务配置问题是最先被排除的，因为该项目配置已经经历了时间的考验，在很多项目中都有使用\n\n- 然后通过 `netstat -ano | find 9000` 检查并未发现端口被占用的情况\n\n- 至于代理，确实是开了--科学上网使用。然而在关闭之后，似乎没有起作用，所以问题不在这里。\n\n- 那么还剩最后一条，当我检查我本地的hosts文件时，纳尼，localhost没有配置指向本地的环回地址127.0.0.1，难道是这里出问题了吗。\n\n  为了验证这个想法，我将配置中的target做了以下修改:\n\n  ~~target: 'http://localhost:8080/'~~ </br>\n    target: 'http://127.0.0.1:8080/'\n\n  果然，生效了，看来之前的猜测是对的。\n\n</br>\n\n所以目前至少有两种方法可以解决该问题：\n\n  - **在vite配置中将localhost替换成127.0.0.1**\n  - **在hosts文件中添加localhost的地址**\n\n当然，第二种方式显然是更合理的，几乎是种一劳永逸的方法，在日后不同项目的开发中，总是难免还会存在使用localhost的情况。因此，建议在hosts文件中配置它。\n\n## 总结\n在这个问题中呢，其实也牵扯出更多的关于http server 和 http client相关的知识。不论是server的创建还是client的连接，正确的ip和端口是需要保证的。\n\n当遇到类似的情况时，不妨从底层思考在复杂的封装工具和配置的背后，它的本质是什么，以及正常使用时需要哪些因子的参与。","slug":"Vite-server-error","published":1,"updated":"2025-06-21T14:16:56.740Z","_id":"cmb0qjkpt000450upatq31y8w","comments":1,"layout":"post","photos":[],"content":"<p>最近正在开发一款应用，前端框架是vite+vue, 后台服务也是使用的node+express组合，当一切工作都在顺利进行的时候，不出意外，意外出现了。</p>\n<p>当我尝试使用axios直连本地服务地址的时候，丝滑得如同德芙一样。然而每次请求地址都需要拼写全链接–即host+port+service-path，这是一件很愚蠢的事情。</p>\n<p>为了让事情变得简单一些，减少重复工作，我和聪明的各位一样决定使用vite的代理。</p>\n<p>因为web的地址9000，本地启动的后台服务地址是8080，所以我最初的配置如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title function_\">defineConfig</span>(&#123;<br>  # ...   其它配置<br>  <span class=\"hljs-attr\">server</span>: &#123;<br>    <span class=\"hljs-attr\">host</span>: <span class=\"hljs-string\">&#x27;0.0.0.0&#x27;</span>,<br>    <span class=\"hljs-attr\">port</span>: <span class=\"hljs-number\">9000</span>,<br>    <span class=\"hljs-attr\">proxy</span>: &#123;<br>      <span class=\"hljs-string\">&#x27;/api&#x27;</span>: &#123;<br>        <span class=\"hljs-attr\">target</span>: <span class=\"hljs-string\">&#x27;http://localhost:8080/&#x27;</span>,<br>        <span class=\"hljs-attr\">changeOrigin</span>: <span class=\"hljs-literal\">true</span>,<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;)<br><br></code></pre></td></tr></table></figure>\n\n<p>然后它却对我说 <code>Vite proxy error ECONNREFUSED</code></p>\n<p>那么多大风大浪都过去了，居然在这小阴沟里翻了船，忍不了！</p>\n<h2 id=\"排查方向\"><a href=\"#排查方向\" class=\"headerlink\" title=\"排查方向\"></a>排查方向</h2><p>因为涉及到vite server配置，其本质就是http-server以及http-agent的问题,  于是从从下面几个方向做了一一排查</p>\n<ul>\n<li><p><strong>Vite的服务器配置</strong></p>\n</li>\n<li><p><strong>端口占用或防火墙设置</strong></p>\n</li>\n<li><p><strong>浏览器或系统代理设置</strong></p>\n</li>\n<li><p>​<strong>Hosts文件配置问题或DNS解析问题</strong></p>\n</li>\n</ul>\n<h2 id=\"测试验证\"><a href=\"#测试验证\" class=\"headerlink\" title=\"测试验证\"></a>测试验证</h2><ul>\n<li><p>首先vite服务配置问题是最先被排除的，因为该项目配置已经经历了时间的考验，在很多项目中都有使用</p>\n</li>\n<li><p>然后通过 <code>netstat -ano | find 9000</code> 检查并未发现端口被占用的情况</p>\n</li>\n<li><p>至于代理，确实是开了–科学上网使用。然而在关闭之后，似乎没有起作用，所以问题不在这里。</p>\n</li>\n<li><p>那么还剩最后一条，当我检查我本地的hosts文件时，纳尼，localhost没有配置指向本地的环回地址127.0.0.1，难道是这里出问题了吗。</p>\n<p>为了验证这个想法，我将配置中的target做了以下修改:</p>\n<p><del>target: ‘<a href=\"http://localhost:8080/\">http://localhost:8080/</a>‘</del> </br><br>  target: ‘<a href=\"http://127.0.0.1:8080/\">http://127.0.0.1:8080/</a>‘</p>\n<p>果然，生效了，看来之前的猜测是对的。</p>\n</li>\n</ul>\n</br>\n\n<p>所以目前至少有两种方法可以解决该问题：</p>\n<ul>\n<li><strong>在vite配置中将localhost替换成127.0.0.1</strong></li>\n<li><strong>在hosts文件中添加localhost的地址</strong></li>\n</ul>\n<p>当然，第二种方式显然是更合理的，几乎是种一劳永逸的方法，在日后不同项目的开发中，总是难免还会存在使用localhost的情况。因此，建议在hosts文件中配置它。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>在这个问题中呢，其实也牵扯出更多的关于http server 和 http client相关的知识。不论是server的创建还是client的连接，正确的ip和端口是需要保证的。</p>\n<p>当遇到类似的情况时，不妨从底层思考在复杂的封装工具和配置的背后，它的本质是什么，以及正常使用时需要哪些因子的参与。</p>\n","excerpt":"","more":"<p>最近正在开发一款应用，前端框架是vite+vue, 后台服务也是使用的node+express组合，当一切工作都在顺利进行的时候，不出意外，意外出现了。</p>\n<p>当我尝试使用axios直连本地服务地址的时候，丝滑得如同德芙一样。然而每次请求地址都需要拼写全链接–即host+port+service-path，这是一件很愚蠢的事情。</p>\n<p>为了让事情变得简单一些，减少重复工作，我和聪明的各位一样决定使用vite的代理。</p>\n<p>因为web的地址9000，本地启动的后台服务地址是8080，所以我最初的配置如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title function_\">defineConfig</span>(&#123;<br>  # ...   其它配置<br>  <span class=\"hljs-attr\">server</span>: &#123;<br>    <span class=\"hljs-attr\">host</span>: <span class=\"hljs-string\">&#x27;0.0.0.0&#x27;</span>,<br>    <span class=\"hljs-attr\">port</span>: <span class=\"hljs-number\">9000</span>,<br>    <span class=\"hljs-attr\">proxy</span>: &#123;<br>      <span class=\"hljs-string\">&#x27;/api&#x27;</span>: &#123;<br>        <span class=\"hljs-attr\">target</span>: <span class=\"hljs-string\">&#x27;http://localhost:8080/&#x27;</span>,<br>        <span class=\"hljs-attr\">changeOrigin</span>: <span class=\"hljs-literal\">true</span>,<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;)<br><br></code></pre></td></tr></table></figure>\n\n<p>然后它却对我说 <code>Vite proxy error ECONNREFUSED</code></p>\n<p>那么多大风大浪都过去了，居然在这小阴沟里翻了船，忍不了！</p>\n<h2 id=\"排查方向\"><a href=\"#排查方向\" class=\"headerlink\" title=\"排查方向\"></a>排查方向</h2><p>因为涉及到vite server配置，其本质就是http-server以及http-agent的问题,  于是从从下面几个方向做了一一排查</p>\n<ul>\n<li><p><strong>Vite的服务器配置</strong></p>\n</li>\n<li><p><strong>端口占用或防火墙设置</strong></p>\n</li>\n<li><p><strong>浏览器或系统代理设置</strong></p>\n</li>\n<li><p>​<strong>Hosts文件配置问题或DNS解析问题</strong></p>\n</li>\n</ul>\n<h2 id=\"测试验证\"><a href=\"#测试验证\" class=\"headerlink\" title=\"测试验证\"></a>测试验证</h2><ul>\n<li><p>首先vite服务配置问题是最先被排除的，因为该项目配置已经经历了时间的考验，在很多项目中都有使用</p>\n</li>\n<li><p>然后通过 <code>netstat -ano | find 9000</code> 检查并未发现端口被占用的情况</p>\n</li>\n<li><p>至于代理，确实是开了–科学上网使用。然而在关闭之后，似乎没有起作用，所以问题不在这里。</p>\n</li>\n<li><p>那么还剩最后一条，当我检查我本地的hosts文件时，纳尼，localhost没有配置指向本地的环回地址127.0.0.1，难道是这里出问题了吗。</p>\n<p>为了验证这个想法，我将配置中的target做了以下修改:</p>\n<p><del>target: ‘<a href=\"http://localhost:8080/\">http://localhost:8080/</a>‘</del> </br><br>  target: ‘<a href=\"http://127.0.0.1:8080/\">http://127.0.0.1:8080/</a>‘</p>\n<p>果然，生效了，看来之前的猜测是对的。</p>\n</li>\n</ul>\n</br>\n\n<p>所以目前至少有两种方法可以解决该问题：</p>\n<ul>\n<li><strong>在vite配置中将localhost替换成127.0.0.1</strong></li>\n<li><strong>在hosts文件中添加localhost的地址</strong></li>\n</ul>\n<p>当然，第二种方式显然是更合理的，几乎是种一劳永逸的方法，在日后不同项目的开发中，总是难免还会存在使用localhost的情况。因此，建议在hosts文件中配置它。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>在这个问题中呢，其实也牵扯出更多的关于http server 和 http client相关的知识。不论是server的创建还是client的连接，正确的ip和端口是需要保证的。</p>\n<p>当遇到类似的情况时，不妨从底层思考在复杂的封装工具和配置的背后，它的本质是什么，以及正常使用时需要哪些因子的参与。</p>\n"},{"title":"搭建个人博客系列--(1) 为什么每个人都该有个数字自留地","date":"2025-05-25T05:40:00.000Z","keywords":["博客搭建","免费博客平台","托管博客","模板建站"],"index_img":"imgs/build-blog1/blog1.jpg","banner_img":"imgs/build-blog1/blog1.jpg","_content":"\n从2017年写第一篇博客，到现在已经过去8个年头了。\n\n期间在不同的平台也写过不少的博客，写了又删，删了有些，留下来的其实也没有多少。\n\n这么多年后，为什么我又和许多人一样，重新开辟自己已经荒芜的自留地？\n\n### 为什么写博客\n\n\n我清晰的记得，我写第一篇博客时的心情，以及那种纯粹的对知识的分享欲。那是一篇在我解决一个困扰我很久的问题之后写下关于[虚拟机安装](https://zhuanlan.zhihu.com/p/26994950)的博客，当时是在知乎上发的。只是让我没想到的是，它至今仍然是我博客中浏览量最高的一篇，有将近30w的浏览量。\n\n纯粹的知识的分享，以及那种来自他人对自己工作的认同感，以及由此产生的成就感，是一促使一个人坚持写博客的主要动力。\n\n![](../imgs/build-blog1/blog2.jpg)\n\n写博客锻炼一个人的表达。在写博客的过程中，尤其是刚开始时，刚经常容易提笔忘字，没有想好如何表达。写得久了，表达上也变得变得清晰，变得通畅。\n\n写博客让人思考，了解自我。写作其实是一件蛮费时间和精力的事情，尤其是当自己需要向别人阐述一件事情，让对方尽可能明白自己在说什么。但写着写着，似乎长时间来，这样的坚持也并没有最初那么难受了。并且，当他人没有理解到自己所表达的意思时，也没有想象中那么郁闷，能够接受自己偶尔不被理解的样。\n\n\n### 程序员写博客的必要性\n\n一个优秀的程序员往往也是一个好的博主。写博客并不需要多门高大上的内容，也不需要华丽的辞藻堆砌。用简洁易懂的语言，把一件事记录好，表达清楚，就OKay了，就像代码一样。\n\n开发过程遇见的问题，搭建环境中遇到的各种坑，都可以作为一篇博客或者系列博客的材料。\n\n![](../imgs/build-blog1/blog6.jpg)\n时间久了，所记录下的一篇篇博客，就不仅仅是简单的博客了，而是自己开发路上成长的最好的见证者。\n\n当你有时候翻看以前博客，嘴中呢喃‘以前怎么这么菜’，觉得眼前博客拿不出手时，那么就说明你真正进步了，也成长了。\n\n### 搭建自己的数字自留地\n\n如今写博客的平台很多，像大家熟知的博客园、CSND、掘金还有思否等。\n\n像博客园这种比较有怀旧情怀的，上面其实还是有蛮多干货的，我个人也特别中意里面的一些怀旧博客主题，不过这几年好像整体流量不及其它平台了。\n\nCSDN的话相对来说对刚刚开始创作博客的人来说比较友好，流量相对来说也大一些，不过毛病也很明显。广告多了些，再就是内容相互抄袭还是比较严重的\n\n至于像掘金和思否，接触相对较少，所以了解不是别多。不过掘金这几年弄得挺不错的，身边蛮多互联网大佬对这个平台评价都挺蛮好的。\n\n![](../imgs/build-blog1/blog4.jpg)\n\n虽然平台选择很多，但依然会有很多博主像作者一样，选择自己搭建自己的独立博客。\n\n不管你是把它打算经营成一个热门博客站点，还是做一个安静记录自己所思所想的树洞，都是你自己说了算。在自己的博客站里，自己就是这里的王。\n\n在搭建博客站点中，你会学习到许多的知识点，接触和使用到许多搭建站点的工具。在自己经过一番折腾，成功搭建起这块独属于自己的数字自留地的时候，心中也会颇有一番成就感。\n\n\n### 写在最后\n\n在这个系列后续的文章中，我将会详细的讲解搭建博客站点的每一个步骤。从技术选型，到本地博客，再到自动化部署，以及如何优雅的实现自己的博客域名，我尽可能的把每一个自己踩过的坑都讲清楚，让所有读者都少走一些弯路。\n\n如果你有什么好的想法或者问题，可以留言或者关注我的公众号“我做开发那些年”，我们一起交流。","source":"_posts/build-personal-blog-1.md","raw":"---\ntitle: 搭建个人博客系列--(1) 为什么每个人都该有个数字自留地\ndate: 2025-05-25 13:40:00\ncategory: 搭建博客\ntags: \n   - 博客搭建\n   - 个人IP\nkeywords: [博客搭建, 免费博客平台, 托管博客, 模板建站]\nindex_img: imgs/build-blog1/blog1.jpg\nbanner_img: imgs/build-blog1/blog1.jpg\n---\n\n从2017年写第一篇博客，到现在已经过去8个年头了。\n\n期间在不同的平台也写过不少的博客，写了又删，删了有些，留下来的其实也没有多少。\n\n这么多年后，为什么我又和许多人一样，重新开辟自己已经荒芜的自留地？\n\n### 为什么写博客\n\n\n我清晰的记得，我写第一篇博客时的心情，以及那种纯粹的对知识的分享欲。那是一篇在我解决一个困扰我很久的问题之后写下关于[虚拟机安装](https://zhuanlan.zhihu.com/p/26994950)的博客，当时是在知乎上发的。只是让我没想到的是，它至今仍然是我博客中浏览量最高的一篇，有将近30w的浏览量。\n\n纯粹的知识的分享，以及那种来自他人对自己工作的认同感，以及由此产生的成就感，是一促使一个人坚持写博客的主要动力。\n\n![](../imgs/build-blog1/blog2.jpg)\n\n写博客锻炼一个人的表达。在写博客的过程中，尤其是刚开始时，刚经常容易提笔忘字，没有想好如何表达。写得久了，表达上也变得变得清晰，变得通畅。\n\n写博客让人思考，了解自我。写作其实是一件蛮费时间和精力的事情，尤其是当自己需要向别人阐述一件事情，让对方尽可能明白自己在说什么。但写着写着，似乎长时间来，这样的坚持也并没有最初那么难受了。并且，当他人没有理解到自己所表达的意思时，也没有想象中那么郁闷，能够接受自己偶尔不被理解的样。\n\n\n### 程序员写博客的必要性\n\n一个优秀的程序员往往也是一个好的博主。写博客并不需要多门高大上的内容，也不需要华丽的辞藻堆砌。用简洁易懂的语言，把一件事记录好，表达清楚，就OKay了，就像代码一样。\n\n开发过程遇见的问题，搭建环境中遇到的各种坑，都可以作为一篇博客或者系列博客的材料。\n\n![](../imgs/build-blog1/blog6.jpg)\n时间久了，所记录下的一篇篇博客，就不仅仅是简单的博客了，而是自己开发路上成长的最好的见证者。\n\n当你有时候翻看以前博客，嘴中呢喃‘以前怎么这么菜’，觉得眼前博客拿不出手时，那么就说明你真正进步了，也成长了。\n\n### 搭建自己的数字自留地\n\n如今写博客的平台很多，像大家熟知的博客园、CSND、掘金还有思否等。\n\n像博客园这种比较有怀旧情怀的，上面其实还是有蛮多干货的，我个人也特别中意里面的一些怀旧博客主题，不过这几年好像整体流量不及其它平台了。\n\nCSDN的话相对来说对刚刚开始创作博客的人来说比较友好，流量相对来说也大一些，不过毛病也很明显。广告多了些，再就是内容相互抄袭还是比较严重的\n\n至于像掘金和思否，接触相对较少，所以了解不是别多。不过掘金这几年弄得挺不错的，身边蛮多互联网大佬对这个平台评价都挺蛮好的。\n\n![](../imgs/build-blog1/blog4.jpg)\n\n虽然平台选择很多，但依然会有很多博主像作者一样，选择自己搭建自己的独立博客。\n\n不管你是把它打算经营成一个热门博客站点，还是做一个安静记录自己所思所想的树洞，都是你自己说了算。在自己的博客站里，自己就是这里的王。\n\n在搭建博客站点中，你会学习到许多的知识点，接触和使用到许多搭建站点的工具。在自己经过一番折腾，成功搭建起这块独属于自己的数字自留地的时候，心中也会颇有一番成就感。\n\n\n### 写在最后\n\n在这个系列后续的文章中，我将会详细的讲解搭建博客站点的每一个步骤。从技术选型，到本地博客，再到自动化部署，以及如何优雅的实现自己的博客域名，我尽可能的把每一个自己踩过的坑都讲清楚，让所有读者都少走一些弯路。\n\n如果你有什么好的想法或者问题，可以留言或者关注我的公众号“我做开发那些年”，我们一起交流。","slug":"build-personal-blog-1","published":1,"updated":"2025-08-26T10:14:36.206Z","_id":"cmb6cfzp200082wup6kkdbh2b","comments":1,"layout":"post","photos":[],"content":"<p>从2017年写第一篇博客，到现在已经过去8个年头了。</p>\n<p>期间在不同的平台也写过不少的博客，写了又删，删了有些，留下来的其实也没有多少。</p>\n<p>这么多年后，为什么我又和许多人一样，重新开辟自己已经荒芜的自留地？</p>\n<h3 id=\"为什么写博客\"><a href=\"#为什么写博客\" class=\"headerlink\" title=\"为什么写博客\"></a>为什么写博客</h3><p>我清晰的记得，我写第一篇博客时的心情，以及那种纯粹的对知识的分享欲。那是一篇在我解决一个困扰我很久的问题之后写下关于<a href=\"https://zhuanlan.zhihu.com/p/26994950\">虚拟机安装</a>的博客，当时是在知乎上发的。只是让我没想到的是，它至今仍然是我博客中浏览量最高的一篇，有将近30w的浏览量。</p>\n<p>纯粹的知识的分享，以及那种来自他人对自己工作的认同感，以及由此产生的成就感，是一促使一个人坚持写博客的主要动力。</p>\n<p><img src=\"/../imgs/build-blog1/blog2.jpg\"></p>\n<p>写博客锻炼一个人的表达。在写博客的过程中，尤其是刚开始时，刚经常容易提笔忘字，没有想好如何表达。写得久了，表达上也变得变得清晰，变得通畅。</p>\n<p>写博客让人思考，了解自我。写作其实是一件蛮费时间和精力的事情，尤其是当自己需要向别人阐述一件事情，让对方尽可能明白自己在说什么。但写着写着，似乎长时间来，这样的坚持也并没有最初那么难受了。并且，当他人没有理解到自己所表达的意思时，也没有想象中那么郁闷，能够接受自己偶尔不被理解的样。</p>\n<h3 id=\"程序员写博客的必要性\"><a href=\"#程序员写博客的必要性\" class=\"headerlink\" title=\"程序员写博客的必要性\"></a>程序员写博客的必要性</h3><p>一个优秀的程序员往往也是一个好的博主。写博客并不需要多门高大上的内容，也不需要华丽的辞藻堆砌。用简洁易懂的语言，把一件事记录好，表达清楚，就OKay了，就像代码一样。</p>\n<p>开发过程遇见的问题，搭建环境中遇到的各种坑，都可以作为一篇博客或者系列博客的材料。</p>\n<p><img src=\"/../imgs/build-blog1/blog6.jpg\"><br>时间久了，所记录下的一篇篇博客，就不仅仅是简单的博客了，而是自己开发路上成长的最好的见证者。</p>\n<p>当你有时候翻看以前博客，嘴中呢喃‘以前怎么这么菜’，觉得眼前博客拿不出手时，那么就说明你真正进步了，也成长了。</p>\n<h3 id=\"搭建自己的数字自留地\"><a href=\"#搭建自己的数字自留地\" class=\"headerlink\" title=\"搭建自己的数字自留地\"></a>搭建自己的数字自留地</h3><p>如今写博客的平台很多，像大家熟知的博客园、CSND、掘金还有思否等。</p>\n<p>像博客园这种比较有怀旧情怀的，上面其实还是有蛮多干货的，我个人也特别中意里面的一些怀旧博客主题，不过这几年好像整体流量不及其它平台了。</p>\n<p>CSDN的话相对来说对刚刚开始创作博客的人来说比较友好，流量相对来说也大一些，不过毛病也很明显。广告多了些，再就是内容相互抄袭还是比较严重的</p>\n<p>至于像掘金和思否，接触相对较少，所以了解不是别多。不过掘金这几年弄得挺不错的，身边蛮多互联网大佬对这个平台评价都挺蛮好的。</p>\n<p><img src=\"/../imgs/build-blog1/blog4.jpg\"></p>\n<p>虽然平台选择很多，但依然会有很多博主像作者一样，选择自己搭建自己的独立博客。</p>\n<p>不管你是把它打算经营成一个热门博客站点，还是做一个安静记录自己所思所想的树洞，都是你自己说了算。在自己的博客站里，自己就是这里的王。</p>\n<p>在搭建博客站点中，你会学习到许多的知识点，接触和使用到许多搭建站点的工具。在自己经过一番折腾，成功搭建起这块独属于自己的数字自留地的时候，心中也会颇有一番成就感。</p>\n<h3 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h3><p>在这个系列后续的文章中，我将会详细的讲解搭建博客站点的每一个步骤。从技术选型，到本地博客，再到自动化部署，以及如何优雅的实现自己的博客域名，我尽可能的把每一个自己踩过的坑都讲清楚，让所有读者都少走一些弯路。</p>\n<p>如果你有什么好的想法或者问题，可以留言或者关注我的公众号“我做开发那些年”，我们一起交流。</p>\n","excerpt":"","more":"<p>从2017年写第一篇博客，到现在已经过去8个年头了。</p>\n<p>期间在不同的平台也写过不少的博客，写了又删，删了有些，留下来的其实也没有多少。</p>\n<p>这么多年后，为什么我又和许多人一样，重新开辟自己已经荒芜的自留地？</p>\n<h3 id=\"为什么写博客\"><a href=\"#为什么写博客\" class=\"headerlink\" title=\"为什么写博客\"></a>为什么写博客</h3><p>我清晰的记得，我写第一篇博客时的心情，以及那种纯粹的对知识的分享欲。那是一篇在我解决一个困扰我很久的问题之后写下关于<a href=\"https://zhuanlan.zhihu.com/p/26994950\">虚拟机安装</a>的博客，当时是在知乎上发的。只是让我没想到的是，它至今仍然是我博客中浏览量最高的一篇，有将近30w的浏览量。</p>\n<p>纯粹的知识的分享，以及那种来自他人对自己工作的认同感，以及由此产生的成就感，是一促使一个人坚持写博客的主要动力。</p>\n<p><img src=\"/../imgs/build-blog1/blog2.jpg\"></p>\n<p>写博客锻炼一个人的表达。在写博客的过程中，尤其是刚开始时，刚经常容易提笔忘字，没有想好如何表达。写得久了，表达上也变得变得清晰，变得通畅。</p>\n<p>写博客让人思考，了解自我。写作其实是一件蛮费时间和精力的事情，尤其是当自己需要向别人阐述一件事情，让对方尽可能明白自己在说什么。但写着写着，似乎长时间来，这样的坚持也并没有最初那么难受了。并且，当他人没有理解到自己所表达的意思时，也没有想象中那么郁闷，能够接受自己偶尔不被理解的样。</p>\n<h3 id=\"程序员写博客的必要性\"><a href=\"#程序员写博客的必要性\" class=\"headerlink\" title=\"程序员写博客的必要性\"></a>程序员写博客的必要性</h3><p>一个优秀的程序员往往也是一个好的博主。写博客并不需要多门高大上的内容，也不需要华丽的辞藻堆砌。用简洁易懂的语言，把一件事记录好，表达清楚，就OKay了，就像代码一样。</p>\n<p>开发过程遇见的问题，搭建环境中遇到的各种坑，都可以作为一篇博客或者系列博客的材料。</p>\n<p><img src=\"/../imgs/build-blog1/blog6.jpg\"><br>时间久了，所记录下的一篇篇博客，就不仅仅是简单的博客了，而是自己开发路上成长的最好的见证者。</p>\n<p>当你有时候翻看以前博客，嘴中呢喃‘以前怎么这么菜’，觉得眼前博客拿不出手时，那么就说明你真正进步了，也成长了。</p>\n<h3 id=\"搭建自己的数字自留地\"><a href=\"#搭建自己的数字自留地\" class=\"headerlink\" title=\"搭建自己的数字自留地\"></a>搭建自己的数字自留地</h3><p>如今写博客的平台很多，像大家熟知的博客园、CSND、掘金还有思否等。</p>\n<p>像博客园这种比较有怀旧情怀的，上面其实还是有蛮多干货的，我个人也特别中意里面的一些怀旧博客主题，不过这几年好像整体流量不及其它平台了。</p>\n<p>CSDN的话相对来说对刚刚开始创作博客的人来说比较友好，流量相对来说也大一些，不过毛病也很明显。广告多了些，再就是内容相互抄袭还是比较严重的</p>\n<p>至于像掘金和思否，接触相对较少，所以了解不是别多。不过掘金这几年弄得挺不错的，身边蛮多互联网大佬对这个平台评价都挺蛮好的。</p>\n<p><img src=\"/../imgs/build-blog1/blog4.jpg\"></p>\n<p>虽然平台选择很多，但依然会有很多博主像作者一样，选择自己搭建自己的独立博客。</p>\n<p>不管你是把它打算经营成一个热门博客站点，还是做一个安静记录自己所思所想的树洞，都是你自己说了算。在自己的博客站里，自己就是这里的王。</p>\n<p>在搭建博客站点中，你会学习到许多的知识点，接触和使用到许多搭建站点的工具。在自己经过一番折腾，成功搭建起这块独属于自己的数字自留地的时候，心中也会颇有一番成就感。</p>\n<h3 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h3><p>在这个系列后续的文章中，我将会详细的讲解搭建博客站点的每一个步骤。从技术选型，到本地博客，再到自动化部署，以及如何优雅的实现自己的博客域名，我尽可能的把每一个自己踩过的坑都讲清楚，让所有读者都少走一些弯路。</p>\n<p>如果你有什么好的想法或者问题，可以留言或者关注我的公众号“我做开发那些年”，我们一起交流。</p>\n"},{"title":"搭建个人博客系列--(2) 动手搭建自己的第一个博客站点","date":"2025-05-27T13:02:53.000Z","keywords":["博客搭建","免费博客平台","托管博客","模板建站"],"index_img":"imgs/build-blog1/blog2.jpg","banner_img":"imgs/build-blog1/blog2.jpg","_content":"\n在上文[什么每个人都该有个数字自留地](./build-personal-blog1.md)中讲解了为什么我们要写博客以及为什么要搭建自己的独立博客，今天我们将要撸起袖子，开始干活了。认真看完本文，按照文中的步骤去做，你将拥有一个属于你自己的博客站点。\n\n## 搭建博客的几种方式\n\n说到博客，不熟悉的人对它的印象可能是微博，QQ空间日志，以及如CSDN，博客园之类的站点的样子，功能丰富，用户上手也快，一部手机就能完成所有的事情。\n\n上面所提到的站点，都是标准的商业型应用了，而作为个人，没有必要浪费过多时间在各种花哨功能构建上。\n\n个人博客，最重要的是内容，是价值输出！\n\n目前呢，搭建个人博客的方式主要有以下几种：\n\n  - **社区平台**：像`博客园`，`CSDN`, `知乎`，`微博`，`公众号`，`QQ空间`等，注册一个账号就Okay了。当然了，既然是社区平台，也就意味着没有独立的网站。\n\n  - **独立博客**: 有自己的网站，博客框架的搭建，内容的发布，都是由自己完成。对未接触过编程的人来说，上手有一定难度。比较适合有一定编程基础，然后又想挑战一下自己那种的同学。\n\n作为一个明日的大佬，自己动手整个独立博客，想必对大家来说也不是什么难事。\n\n## 考虑因素\n\n既然选择建独立博客，那么我们需要考虑以下几个问题了：\n\n  - 是否需要建立数据库，使用前后端配合的方式完成博客的增删改查？\n  - 是否考虑购买服务器，还是进行服务托管?\n  - 打算投入多少时间和金钱去建站?\n \n\n在考虑这些问题的时候，同时问问自己，自己的博客是否需要很多功能，还是作为一个简单记录自己所思所想的自由平台。\n\n个人认为，作为程序员，简洁就是最好的风格！\n\n因此，我更倾向选择的是不使用前后端，使用静态内容托管的方式来搭建自己的博客。正如前面所说的，一个个人博客站重要的是内容输出，戏台子搭得大和漂亮没有多少用，重要的是你的戏是否能够吸引观众。\n\n## 技术选型\n\n既然是使用静态托管平台，那么可供选择的方案有很多：\n  \n  - **[GitHub Pages](https://pages.github.com/)**: 自带域名可 https 访问; 可配置自定义域名\n  - **[Bitbucket Cloud](https://confluence.atlassian.com/bitbucket/publishing-a-website-on-bitbucket-cloud-221449776.html)**: 能且只能通过 https 协议访问; 无法自定义域名\n  - **[GitLab Pages](https://docs.gitlab.com/ee/user/project/pages/index.html)**: 同样跟 GitHub Pages 的功能一样\n  - **[Netlify](https://www.netlify.com/)**: 可以使用 CLI 上传代码; 支持自动构建\n\n在这里，比较推荐 Github Page 和 Netlify, 主要原因有两个：一个是比较能装，另一个是比较能装！\n\n## Github page 建站\n\n下面演示一下Github Page生成一个简单的个人站点名称，Netlify 可以自行探索一下，这里不做讲解。\n\n使用Github Page 建站，首先，你需要有一个Github 账号，如果没有，先去注册一个，注册时记得取个好一点的名字，后面有用。\n\n- **登录github, 新建一个与你名字同名的repository**\n\n登录到Github首页之后，点击右上角 `+` 号，选择 `new repository` 跳转到新建仓库页面。\n\n![step1](https://image.baidu.com/search/down?url=https://tvax4.sinaimg.cn/large/0071fJItgy1i21b6hl5rlj31i70xpe0n.jpg)\n\n其中，`repository name` 一定要是 `你的英文名称.github.io`，比如我的英文名称是`jvxiaome`， 那么我的仓库名称就是 `jvxiaome.github.io`，这个后面也是访问博客站点首页的网址，所以前面说取一个好听的名字，是有道理的。\n\n仓库的可见性选择 `Public`, 另外下面的 `Add a README file` 也可以勾上，会方便一些，至于剩下的内容，看个人需要，不清楚的可以暂时不填，最后确认 `Create repository`。\n\n\n\n![step2](https://image.baidu.com/search/down?url=http://tvax3.sinaimg.cn/large/0071fJItgy1i21ba20naej31aa1ah1ba.jpg)\n\n\n- **编辑一个你的博客主页**\n\n进入到刚刚新建的仓库，点击`add file` 新建一个文件\n\n\n![step3](https://image.baidu.com/search/down?url=http://tvax2.sinaimg.cn/large/0071fJItgy1i21batizraj31gl0ufn95.jpg)\n\n文件名称取名为 `index.html`, 这个文件中包含的就是博客主页的内容了，具体想写什么可以自由发挥\n\n![step4](https://image.baidu.com/search/down?url=http://tvax4.sinaimg.cn/large/0071fJItgy1i21bb808bfj31zr0thgzj.jpg)\n\n写完之后点击 `commit changes` 提交内容到仓库，到这一步，你的博客站就算是基本建立起来了\n![step5](https://image.baidu.com/search/down?url=http://tvax2.sinaimg.cn/large/0071fJItgy1i21bc83oxuj31eu0vyduh.jpg)\n\n\n- **访问验证**\n\n既然博客站点已经建好了，此时是不是特别期待访问自己的博客首页呢。\n\n正如前面所说的，你的仓库名称（你的英文名称.github.io）就是你的博客首页名称，以上面的例子来说，访问 `jvxiaome.github.io` 就能直接看见首页效果了。\n\n虽然整个页面都在诉说着朴素(~~丑~~)，但一点也不影响你拥有一个属于自己博客站点的那份喜悦。都18+了，怎么能没有自己的网站呢。\n\n![step6](https://image.baidu.com/search/down?url=http://tvax3.sinaimg.cn/large/0071fJItgy1i21bcpjfruj310d0k2go1.jpg)\n\n## 写在最后\n\n有了自己的博客网站，还有了域名，而这一切，不是个结束，而是开始。\n\n如何使用工具，使用主题，搭建一个简洁，漂亮的[博客网站](![my-sit](https://image.baidu.com/search/down?url=http://tvax1.sinaimg.cn/large/0071fJItgy1i21bddtgjjj32cu1h8x6q.jpg))，这将是下一篇文中的重点。\n\n\n\n\n\n\n<!-- https://github.com/lmk123/blog/issues/55 -->\n\n","source":"_posts/build-personal-blog2.md","raw":"---\ntitle: 搭建个人博客系列--(2) 动手搭建自己的第一个博客站点\ndate: 2025-05-27 21:02:53\ncategory: 搭建博客\ntags: \n   - 博客搭建\n   - 个人IP\nkeywords: [博客搭建, 免费博客平台, 托管博客, 模板建站]\nindex_img: imgs/build-blog1/blog2.jpg\nbanner_img: imgs/build-blog1/blog2.jpg\n---\n\n在上文[什么每个人都该有个数字自留地](./build-personal-blog1.md)中讲解了为什么我们要写博客以及为什么要搭建自己的独立博客，今天我们将要撸起袖子，开始干活了。认真看完本文，按照文中的步骤去做，你将拥有一个属于你自己的博客站点。\n\n## 搭建博客的几种方式\n\n说到博客，不熟悉的人对它的印象可能是微博，QQ空间日志，以及如CSDN，博客园之类的站点的样子，功能丰富，用户上手也快，一部手机就能完成所有的事情。\n\n上面所提到的站点，都是标准的商业型应用了，而作为个人，没有必要浪费过多时间在各种花哨功能构建上。\n\n个人博客，最重要的是内容，是价值输出！\n\n目前呢，搭建个人博客的方式主要有以下几种：\n\n  - **社区平台**：像`博客园`，`CSDN`, `知乎`，`微博`，`公众号`，`QQ空间`等，注册一个账号就Okay了。当然了，既然是社区平台，也就意味着没有独立的网站。\n\n  - **独立博客**: 有自己的网站，博客框架的搭建，内容的发布，都是由自己完成。对未接触过编程的人来说，上手有一定难度。比较适合有一定编程基础，然后又想挑战一下自己那种的同学。\n\n作为一个明日的大佬，自己动手整个独立博客，想必对大家来说也不是什么难事。\n\n## 考虑因素\n\n既然选择建独立博客，那么我们需要考虑以下几个问题了：\n\n  - 是否需要建立数据库，使用前后端配合的方式完成博客的增删改查？\n  - 是否考虑购买服务器，还是进行服务托管?\n  - 打算投入多少时间和金钱去建站?\n \n\n在考虑这些问题的时候，同时问问自己，自己的博客是否需要很多功能，还是作为一个简单记录自己所思所想的自由平台。\n\n个人认为，作为程序员，简洁就是最好的风格！\n\n因此，我更倾向选择的是不使用前后端，使用静态内容托管的方式来搭建自己的博客。正如前面所说的，一个个人博客站重要的是内容输出，戏台子搭得大和漂亮没有多少用，重要的是你的戏是否能够吸引观众。\n\n## 技术选型\n\n既然是使用静态托管平台，那么可供选择的方案有很多：\n  \n  - **[GitHub Pages](https://pages.github.com/)**: 自带域名可 https 访问; 可配置自定义域名\n  - **[Bitbucket Cloud](https://confluence.atlassian.com/bitbucket/publishing-a-website-on-bitbucket-cloud-221449776.html)**: 能且只能通过 https 协议访问; 无法自定义域名\n  - **[GitLab Pages](https://docs.gitlab.com/ee/user/project/pages/index.html)**: 同样跟 GitHub Pages 的功能一样\n  - **[Netlify](https://www.netlify.com/)**: 可以使用 CLI 上传代码; 支持自动构建\n\n在这里，比较推荐 Github Page 和 Netlify, 主要原因有两个：一个是比较能装，另一个是比较能装！\n\n## Github page 建站\n\n下面演示一下Github Page生成一个简单的个人站点名称，Netlify 可以自行探索一下，这里不做讲解。\n\n使用Github Page 建站，首先，你需要有一个Github 账号，如果没有，先去注册一个，注册时记得取个好一点的名字，后面有用。\n\n- **登录github, 新建一个与你名字同名的repository**\n\n登录到Github首页之后，点击右上角 `+` 号，选择 `new repository` 跳转到新建仓库页面。\n\n![step1](https://image.baidu.com/search/down?url=https://tvax4.sinaimg.cn/large/0071fJItgy1i21b6hl5rlj31i70xpe0n.jpg)\n\n其中，`repository name` 一定要是 `你的英文名称.github.io`，比如我的英文名称是`jvxiaome`， 那么我的仓库名称就是 `jvxiaome.github.io`，这个后面也是访问博客站点首页的网址，所以前面说取一个好听的名字，是有道理的。\n\n仓库的可见性选择 `Public`, 另外下面的 `Add a README file` 也可以勾上，会方便一些，至于剩下的内容，看个人需要，不清楚的可以暂时不填，最后确认 `Create repository`。\n\n\n\n![step2](https://image.baidu.com/search/down?url=http://tvax3.sinaimg.cn/large/0071fJItgy1i21ba20naej31aa1ah1ba.jpg)\n\n\n- **编辑一个你的博客主页**\n\n进入到刚刚新建的仓库，点击`add file` 新建一个文件\n\n\n![step3](https://image.baidu.com/search/down?url=http://tvax2.sinaimg.cn/large/0071fJItgy1i21batizraj31gl0ufn95.jpg)\n\n文件名称取名为 `index.html`, 这个文件中包含的就是博客主页的内容了，具体想写什么可以自由发挥\n\n![step4](https://image.baidu.com/search/down?url=http://tvax4.sinaimg.cn/large/0071fJItgy1i21bb808bfj31zr0thgzj.jpg)\n\n写完之后点击 `commit changes` 提交内容到仓库，到这一步，你的博客站就算是基本建立起来了\n![step5](https://image.baidu.com/search/down?url=http://tvax2.sinaimg.cn/large/0071fJItgy1i21bc83oxuj31eu0vyduh.jpg)\n\n\n- **访问验证**\n\n既然博客站点已经建好了，此时是不是特别期待访问自己的博客首页呢。\n\n正如前面所说的，你的仓库名称（你的英文名称.github.io）就是你的博客首页名称，以上面的例子来说，访问 `jvxiaome.github.io` 就能直接看见首页效果了。\n\n虽然整个页面都在诉说着朴素(~~丑~~)，但一点也不影响你拥有一个属于自己博客站点的那份喜悦。都18+了，怎么能没有自己的网站呢。\n\n![step6](https://image.baidu.com/search/down?url=http://tvax3.sinaimg.cn/large/0071fJItgy1i21bcpjfruj310d0k2go1.jpg)\n\n## 写在最后\n\n有了自己的博客网站，还有了域名，而这一切，不是个结束，而是开始。\n\n如何使用工具，使用主题，搭建一个简洁，漂亮的[博客网站](![my-sit](https://image.baidu.com/search/down?url=http://tvax1.sinaimg.cn/large/0071fJItgy1i21bddtgjjj32cu1h8x6q.jpg))，这将是下一篇文中的重点。\n\n\n\n\n\n\n<!-- https://github.com/lmk123/blog/issues/55 -->\n\n","slug":"build-personal-blog2","published":1,"updated":"2025-08-26T10:15:22.050Z","_id":"cmbf62vvl000duoup8jpg6zb0","comments":1,"layout":"post","photos":[],"content":"<p>在上文<a href=\"./build-personal-blog1.md\">什么每个人都该有个数字自留地</a>中讲解了为什么我们要写博客以及为什么要搭建自己的独立博客，今天我们将要撸起袖子，开始干活了。认真看完本文，按照文中的步骤去做，你将拥有一个属于你自己的博客站点。</p>\n<h2 id=\"搭建博客的几种方式\"><a href=\"#搭建博客的几种方式\" class=\"headerlink\" title=\"搭建博客的几种方式\"></a>搭建博客的几种方式</h2><p>说到博客，不熟悉的人对它的印象可能是微博，QQ空间日志，以及如CSDN，博客园之类的站点的样子，功能丰富，用户上手也快，一部手机就能完成所有的事情。</p>\n<p>上面所提到的站点，都是标准的商业型应用了，而作为个人，没有必要浪费过多时间在各种花哨功能构建上。</p>\n<p>个人博客，最重要的是内容，是价值输出！</p>\n<p>目前呢，搭建个人博客的方式主要有以下几种：</p>\n<ul>\n<li><p><strong>社区平台</strong>：像<code>博客园</code>，<code>CSDN</code>, <code>知乎</code>，<code>微博</code>，<code>公众号</code>，<code>QQ空间</code>等，注册一个账号就Okay了。当然了，既然是社区平台，也就意味着没有独立的网站。</p>\n</li>\n<li><p><strong>独立博客</strong>: 有自己的网站，博客框架的搭建，内容的发布，都是由自己完成。对未接触过编程的人来说，上手有一定难度。比较适合有一定编程基础，然后又想挑战一下自己那种的同学。</p>\n</li>\n</ul>\n<p>作为一个明日的大佬，自己动手整个独立博客，想必对大家来说也不是什么难事。</p>\n<h2 id=\"考虑因素\"><a href=\"#考虑因素\" class=\"headerlink\" title=\"考虑因素\"></a>考虑因素</h2><p>既然选择建独立博客，那么我们需要考虑以下几个问题了：</p>\n<ul>\n<li>是否需要建立数据库，使用前后端配合的方式完成博客的增删改查？</li>\n<li>是否考虑购买服务器，还是进行服务托管?</li>\n<li>打算投入多少时间和金钱去建站?</li>\n</ul>\n<p>在考虑这些问题的时候，同时问问自己，自己的博客是否需要很多功能，还是作为一个简单记录自己所思所想的自由平台。</p>\n<p>个人认为，作为程序员，简洁就是最好的风格！</p>\n<p>因此，我更倾向选择的是不使用前后端，使用静态内容托管的方式来搭建自己的博客。正如前面所说的，一个个人博客站重要的是内容输出，戏台子搭得大和漂亮没有多少用，重要的是你的戏是否能够吸引观众。</p>\n<h2 id=\"技术选型\"><a href=\"#技术选型\" class=\"headerlink\" title=\"技术选型\"></a>技术选型</h2><p>既然是使用静态托管平台，那么可供选择的方案有很多：</p>\n<ul>\n<li><strong><a href=\"https://pages.github.com/\">GitHub Pages</a></strong>: 自带域名可 https 访问; 可配置自定义域名</li>\n<li><strong><a href=\"https://confluence.atlassian.com/bitbucket/publishing-a-website-on-bitbucket-cloud-221449776.html\">Bitbucket Cloud</a></strong>: 能且只能通过 https 协议访问; 无法自定义域名</li>\n<li><strong><a href=\"https://docs.gitlab.com/ee/user/project/pages/index.html\">GitLab Pages</a></strong>: 同样跟 GitHub Pages 的功能一样</li>\n<li><strong><a href=\"https://www.netlify.com/\">Netlify</a></strong>: 可以使用 CLI 上传代码; 支持自动构建</li>\n</ul>\n<p>在这里，比较推荐 Github Page 和 Netlify, 主要原因有两个：一个是比较能装，另一个是比较能装！</p>\n<h2 id=\"Github-page-建站\"><a href=\"#Github-page-建站\" class=\"headerlink\" title=\"Github page 建站\"></a>Github page 建站</h2><p>下面演示一下Github Page生成一个简单的个人站点名称，Netlify 可以自行探索一下，这里不做讲解。</p>\n<p>使用Github Page 建站，首先，你需要有一个Github 账号，如果没有，先去注册一个，注册时记得取个好一点的名字，后面有用。</p>\n<ul>\n<li><strong>登录github, 新建一个与你名字同名的repository</strong></li>\n</ul>\n<p>登录到Github首页之后，点击右上角 <code>+</code> 号，选择 <code>new repository</code> 跳转到新建仓库页面。</p>\n<p><img src=\"https://image.baidu.com/search/down?url=https://tvax4.sinaimg.cn/large/0071fJItgy1i21b6hl5rlj31i70xpe0n.jpg\" alt=\"step1\"></p>\n<p>其中，<code>repository name</code> 一定要是 <code>你的英文名称.github.io</code>，比如我的英文名称是<code>jvxiaome</code>， 那么我的仓库名称就是 <code>jvxiaome.github.io</code>，这个后面也是访问博客站点首页的网址，所以前面说取一个好听的名字，是有道理的。</p>\n<p>仓库的可见性选择 <code>Public</code>, 另外下面的 <code>Add a README file</code> 也可以勾上，会方便一些，至于剩下的内容，看个人需要，不清楚的可以暂时不填，最后确认 <code>Create repository</code>。</p>\n<p><img src=\"https://image.baidu.com/search/down?url=http://tvax3.sinaimg.cn/large/0071fJItgy1i21ba20naej31aa1ah1ba.jpg\" alt=\"step2\"></p>\n<ul>\n<li><strong>编辑一个你的博客主页</strong></li>\n</ul>\n<p>进入到刚刚新建的仓库，点击<code>add file</code> 新建一个文件</p>\n<p><img src=\"https://image.baidu.com/search/down?url=http://tvax2.sinaimg.cn/large/0071fJItgy1i21batizraj31gl0ufn95.jpg\" alt=\"step3\"></p>\n<p>文件名称取名为 <code>index.html</code>, 这个文件中包含的就是博客主页的内容了，具体想写什么可以自由发挥</p>\n<p><img src=\"https://image.baidu.com/search/down?url=http://tvax4.sinaimg.cn/large/0071fJItgy1i21bb808bfj31zr0thgzj.jpg\" alt=\"step4\"></p>\n<p>写完之后点击 <code>commit changes</code> 提交内容到仓库，到这一步，你的博客站就算是基本建立起来了<br><img src=\"https://image.baidu.com/search/down?url=http://tvax2.sinaimg.cn/large/0071fJItgy1i21bc83oxuj31eu0vyduh.jpg\" alt=\"step5\"></p>\n<ul>\n<li><strong>访问验证</strong></li>\n</ul>\n<p>既然博客站点已经建好了，此时是不是特别期待访问自己的博客首页呢。</p>\n<p>正如前面所说的，你的仓库名称（你的英文名称.github.io）就是你的博客首页名称，以上面的例子来说，访问 <code>jvxiaome.github.io</code> 就能直接看见首页效果了。</p>\n<p>虽然整个页面都在诉说着朴素(<del>丑</del>)，但一点也不影响你拥有一个属于自己博客站点的那份喜悦。都18+了，怎么能没有自己的网站呢。</p>\n<p><img src=\"https://image.baidu.com/search/down?url=http://tvax3.sinaimg.cn/large/0071fJItgy1i21bcpjfruj310d0k2go1.jpg\" alt=\"step6\"></p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>有了自己的博客网站，还有了域名，而这一切，不是个结束，而是开始。</p>\n<p>如何使用工具，使用主题，搭建一个简洁，漂亮的<a href=\"!%5Bmy-sit%5D(https://image.baidu.com/search/down?url=http://tvax1.sinaimg.cn/large/0071fJItgy1i21bddtgjjj32cu1h8x6q.jpg)\">博客网站</a>，这将是下一篇文中的重点。</p>\n<!-- https://github.com/lmk123/blog/issues/55 -->\n\n","excerpt":"","more":"<p>在上文<a href=\"./build-personal-blog1.md\">什么每个人都该有个数字自留地</a>中讲解了为什么我们要写博客以及为什么要搭建自己的独立博客，今天我们将要撸起袖子，开始干活了。认真看完本文，按照文中的步骤去做，你将拥有一个属于你自己的博客站点。</p>\n<h2 id=\"搭建博客的几种方式\"><a href=\"#搭建博客的几种方式\" class=\"headerlink\" title=\"搭建博客的几种方式\"></a>搭建博客的几种方式</h2><p>说到博客，不熟悉的人对它的印象可能是微博，QQ空间日志，以及如CSDN，博客园之类的站点的样子，功能丰富，用户上手也快，一部手机就能完成所有的事情。</p>\n<p>上面所提到的站点，都是标准的商业型应用了，而作为个人，没有必要浪费过多时间在各种花哨功能构建上。</p>\n<p>个人博客，最重要的是内容，是价值输出！</p>\n<p>目前呢，搭建个人博客的方式主要有以下几种：</p>\n<ul>\n<li><p><strong>社区平台</strong>：像<code>博客园</code>，<code>CSDN</code>, <code>知乎</code>，<code>微博</code>，<code>公众号</code>，<code>QQ空间</code>等，注册一个账号就Okay了。当然了，既然是社区平台，也就意味着没有独立的网站。</p>\n</li>\n<li><p><strong>独立博客</strong>: 有自己的网站，博客框架的搭建，内容的发布，都是由自己完成。对未接触过编程的人来说，上手有一定难度。比较适合有一定编程基础，然后又想挑战一下自己那种的同学。</p>\n</li>\n</ul>\n<p>作为一个明日的大佬，自己动手整个独立博客，想必对大家来说也不是什么难事。</p>\n<h2 id=\"考虑因素\"><a href=\"#考虑因素\" class=\"headerlink\" title=\"考虑因素\"></a>考虑因素</h2><p>既然选择建独立博客，那么我们需要考虑以下几个问题了：</p>\n<ul>\n<li>是否需要建立数据库，使用前后端配合的方式完成博客的增删改查？</li>\n<li>是否考虑购买服务器，还是进行服务托管?</li>\n<li>打算投入多少时间和金钱去建站?</li>\n</ul>\n<p>在考虑这些问题的时候，同时问问自己，自己的博客是否需要很多功能，还是作为一个简单记录自己所思所想的自由平台。</p>\n<p>个人认为，作为程序员，简洁就是最好的风格！</p>\n<p>因此，我更倾向选择的是不使用前后端，使用静态内容托管的方式来搭建自己的博客。正如前面所说的，一个个人博客站重要的是内容输出，戏台子搭得大和漂亮没有多少用，重要的是你的戏是否能够吸引观众。</p>\n<h2 id=\"技术选型\"><a href=\"#技术选型\" class=\"headerlink\" title=\"技术选型\"></a>技术选型</h2><p>既然是使用静态托管平台，那么可供选择的方案有很多：</p>\n<ul>\n<li><strong><a href=\"https://pages.github.com/\">GitHub Pages</a></strong>: 自带域名可 https 访问; 可配置自定义域名</li>\n<li><strong><a href=\"https://confluence.atlassian.com/bitbucket/publishing-a-website-on-bitbucket-cloud-221449776.html\">Bitbucket Cloud</a></strong>: 能且只能通过 https 协议访问; 无法自定义域名</li>\n<li><strong><a href=\"https://docs.gitlab.com/ee/user/project/pages/index.html\">GitLab Pages</a></strong>: 同样跟 GitHub Pages 的功能一样</li>\n<li><strong><a href=\"https://www.netlify.com/\">Netlify</a></strong>: 可以使用 CLI 上传代码; 支持自动构建</li>\n</ul>\n<p>在这里，比较推荐 Github Page 和 Netlify, 主要原因有两个：一个是比较能装，另一个是比较能装！</p>\n<h2 id=\"Github-page-建站\"><a href=\"#Github-page-建站\" class=\"headerlink\" title=\"Github page 建站\"></a>Github page 建站</h2><p>下面演示一下Github Page生成一个简单的个人站点名称，Netlify 可以自行探索一下，这里不做讲解。</p>\n<p>使用Github Page 建站，首先，你需要有一个Github 账号，如果没有，先去注册一个，注册时记得取个好一点的名字，后面有用。</p>\n<ul>\n<li><strong>登录github, 新建一个与你名字同名的repository</strong></li>\n</ul>\n<p>登录到Github首页之后，点击右上角 <code>+</code> 号，选择 <code>new repository</code> 跳转到新建仓库页面。</p>\n<p><img src=\"https://image.baidu.com/search/down?url=https://tvax4.sinaimg.cn/large/0071fJItgy1i21b6hl5rlj31i70xpe0n.jpg\" alt=\"step1\"></p>\n<p>其中，<code>repository name</code> 一定要是 <code>你的英文名称.github.io</code>，比如我的英文名称是<code>jvxiaome</code>， 那么我的仓库名称就是 <code>jvxiaome.github.io</code>，这个后面也是访问博客站点首页的网址，所以前面说取一个好听的名字，是有道理的。</p>\n<p>仓库的可见性选择 <code>Public</code>, 另外下面的 <code>Add a README file</code> 也可以勾上，会方便一些，至于剩下的内容，看个人需要，不清楚的可以暂时不填，最后确认 <code>Create repository</code>。</p>\n<p><img src=\"https://image.baidu.com/search/down?url=http://tvax3.sinaimg.cn/large/0071fJItgy1i21ba20naej31aa1ah1ba.jpg\" alt=\"step2\"></p>\n<ul>\n<li><strong>编辑一个你的博客主页</strong></li>\n</ul>\n<p>进入到刚刚新建的仓库，点击<code>add file</code> 新建一个文件</p>\n<p><img src=\"https://image.baidu.com/search/down?url=http://tvax2.sinaimg.cn/large/0071fJItgy1i21batizraj31gl0ufn95.jpg\" alt=\"step3\"></p>\n<p>文件名称取名为 <code>index.html</code>, 这个文件中包含的就是博客主页的内容了，具体想写什么可以自由发挥</p>\n<p><img src=\"https://image.baidu.com/search/down?url=http://tvax4.sinaimg.cn/large/0071fJItgy1i21bb808bfj31zr0thgzj.jpg\" alt=\"step4\"></p>\n<p>写完之后点击 <code>commit changes</code> 提交内容到仓库，到这一步，你的博客站就算是基本建立起来了<br><img src=\"https://image.baidu.com/search/down?url=http://tvax2.sinaimg.cn/large/0071fJItgy1i21bc83oxuj31eu0vyduh.jpg\" alt=\"step5\"></p>\n<ul>\n<li><strong>访问验证</strong></li>\n</ul>\n<p>既然博客站点已经建好了，此时是不是特别期待访问自己的博客首页呢。</p>\n<p>正如前面所说的，你的仓库名称（你的英文名称.github.io）就是你的博客首页名称，以上面的例子来说，访问 <code>jvxiaome.github.io</code> 就能直接看见首页效果了。</p>\n<p>虽然整个页面都在诉说着朴素(<del>丑</del>)，但一点也不影响你拥有一个属于自己博客站点的那份喜悦。都18+了，怎么能没有自己的网站呢。</p>\n<p><img src=\"https://image.baidu.com/search/down?url=http://tvax3.sinaimg.cn/large/0071fJItgy1i21bcpjfruj310d0k2go1.jpg\" alt=\"step6\"></p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>有了自己的博客网站，还有了域名，而这一切，不是个结束，而是开始。</p>\n<p>如何使用工具，使用主题，搭建一个简洁，漂亮的<a href=\"!%5Bmy-sit%5D(https://image.baidu.com/search/down?url=http://tvax1.sinaimg.cn/large/0071fJItgy1i21bddtgjjj32cu1h8x6q.jpg)\">博客网站</a>，这将是下一篇文中的重点。</p>\n<!-- https://github.com/lmk123/blog/issues/55 -->\n\n"},{"title":"一篇文章搞懂Array,Set和Map异同","date":"2025-05-23T04:40:00.000Z","_content":"\nArray,Set和Map三个作为Javascript中可迭代的集合数据类型，在编程过程中使用的频率也比较高。针对三种数据类型各自的一些特性，本文的内容将从以下几个方面来上述数据类型做一个总结。\n\n-  [**实例的创建**](##实例的创建)\n-  [**数据添加**](##数据添加)\n-  [**数据访问（查找）**](##数据访问（查找）)\n-  [**数据的遍历**](##数据的遍历)\n-  [**类似的功能和一些专有方法**](##类似的功能和一些专有方法)\n-  [**三者之间的转换**](##三者之间的转换)\n-  [**应用场景**](##应用场景)\n\n## 实例的创建\n  Map和Set创建实例的方式是唯一的，只允许通过new调用构造方法来创建一个实例。值得注意的是，Set和Map在调用构造函数的时候，传参都是数组或者可迭代对象，其中Map的传参数组需要时一个键值对数组。当然，传参也是可选的，非必须。\n\n Array相较于前两者，其创建实例的方式要多写，可通过字面方式创建，也可像Map和Set一样通过构造函数来创建。此外使用Array的静态函数Array.from来创建也是非常常见的。例如，通过docuemnt.getElementsByTagName这类方法获取到一个HTMLCollect这样一个类数组，通常会通过Array.from将其装换成一个真正的数组来进行后续的操作。\n\n  ```Javascript\n\n   // 创建map实例\n   let map1 = new Map();\n   let map2 = new Map([['a', 1], ['b', 2]]); //  a=>1, b=>2\n   // 创建set实例\n   let set1 = new Set();\n   let set2 = new Set([1,2])\n\n  // 通过字面量创建数组\n  let arr1 = [1,2,3];\n  // 使用Array静态方法从一个可迭代对象或者类数组中创建数组实例\n  let arr2 = Array.from([4,5]) \n  // 使用Array构造函数\n  let arr3 = new Array([6,7]);\n```\n\n## 数据添加与变更\n\n\n```Javascript\n  // Set的数据操作：添加与删除\n  let set = new Set();\n  set.add(11) // [11]\n  set.add(23) // [11, 23]\n  set.add(11) // [11, 23]\n  set.delete(23) // [11] \n  \n  // Map的数据操作：添加与删除\n  let  map = new Map();\n  map.set('a', 1);   // [a=>1]\n  map.set('b', 2);   // [a=>1, b=>2]\n  map.delete('b');   // [a=>1]\n\n  // Array\n  let arr = [1,2,3]\n  // 在数组末尾添加一个值\n  arr.push(4)       // [1,2,3,4]\n  // 弹出数组末尾的值\n  arr.pop(4)        // [1,2,3]\n  // 在数组头部添加一个值\n  arr.unshift(0)    // [0,1,2,3]\n  // 移除头部的第一个值\n  arr.shift()       // [1,2,3]\n  // 在第二个数（下标1）之后插入一个值‘a’\n  arr.splice(1,0,'a')   // [1,2,'a', 3];\n  // 删除第二个数（下标1）后面1个值，然后插入一个新的值‘b’\n  arr.splice(1,1,'b')   // [1,2,'b',3]\n```\n\n## 数据访问\n  Array和Map都能够访问实例中的特定数据，Array是通过下标，而Map是通过实例方法get, 唯独Set没有方式可以直接访问其中特定数据。其实也不难理解，Set本身不是为了单纯存储数据和访问特殊而生的，因为这些功能Array就可以支持，何必再单出构造一个Set数据结构了。我对此的理解是，Set跟多的是紧紧围绕着数据唯一不重复这一准则来的，它的侧重点是某一数据的有无，而不是数据存在哪里。\n\n  另外，从结构上来说。Set不像Array那样是有序的，所以也无法使用下标来访问，也不像Map那般，每个键对应一个值，所以也无法通过键来访问。故而，Set没有单独访问某一数据的方式。\n\n```Javascript\n  const arr = [1,2,3];\n  const set = new Set(['a', 'b']);\n  const map = new Map([['a', 1], ['b', '2']]);\n  \n  //Array通过下标访问数据\n  console.log(arr[0], arr[2]) // 1, 3\n  //Map使用实例方法get访问数据，参数是键\n  console.log(mpa.get('a))    // 1\n```\n## 数据的遍历\n\n**Set数据的遍历方式**：\n-  keys()   &emsp;&emsp;返回键名迭代器\n-  values() &emsp;返回值迭代器  \n-  entries() &emsp;返回键值迭代器\n-  forEach()\n```Javascript\nconst set = new Set(['a', 'b', 'c']);\n// set每个值对应的key其实也是数据值本身\nconst keyIter = set.keys();\nconsole.log(keyIter.next().value);  // 'a'\nconsole.log(keyIter.next().value);  // 'b'\nconsole.log(keyIter.next().value);  // 'c'\nconsole.log(keyIter.next().value);  // undefined\n\nconst valueIter = set.values();\nfor(let val of valueIter) {\n  console.log(val);                // 'a', 'b', 'c'\n}\n\nconst entriesIter = set.entries();\nfor(let [key, value] of entriesIter) {\n  console(`${key}:${value}`)     // 'a':'a', 'b':'b', 'c':'c'\n}\n\nset.forEach(val => {\n  console.log(val)             // 'a', 'b', 'c'\n})\n```\n</br>\n\n**Map数据的遍历方式**\n-  keys()   &emsp;&emsp;返回键名迭代器\n-  values() &emsp;返回值迭代器  \n-  entries() &emsp;返回键值迭代器\n-  forEach()\n\n```Javascript\nconst map = new Map([['a', 1], ['b', '2']]);\n/**\n* 代码就自己脑补吧，\n* 不能说和Set的方式很像，\n* 只能说真的就是一模一样\n**/\n```\n</br>\n\n**Array数据的遍历方式**\n\nArray遍历数据的方法是最多的，除了下面列举的几个之外，还有some, every,甚至filter, find和findIndex这些方法可以用来遍历数据。使用这些方法需要注意的是其使用的场景，例如map和forEach都可以用来对数组内数据做一些操作，但如果不需要返回值的情况，还是使用forEach方法，而不建议是map，其它方法也是如此。\n\n-  keys()   &emsp;&emsp;返回键名迭代器\n-  values() &emsp;返回值迭代器  \n-  entries() &emsp;返回键值迭代器\n-  map()    &emsp;回调函数，要有返回值\n-  reduce() \n-  forEach()\n-  for...of\n```Javascript\n/**\n* 代码就不写了，偷个懒，不过还是贴心的附上链接\n* https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array\n**/\n```\n\n\n## 类似的功能和一些专有方法\n- **是否包含某个元素**: 数组的includes方法，map和set的has方法，三者的返回值都是布尔值，区别只在于传入的参数。数组和set传入的是值，map传入的是键。\n- **合并两个相同类型的数据**： 数组使用concat方法，合并两个数组值，set使用union方法合并两个集合。map没有专有方法可以用来合并两个map数据，不过可以通过使用new Map([...map1, ...map2])来返回一个合并之后的新map\n- **数据大小**：数组有length属性，map和set有size属性\n- **清空数据**：map和size都可通过clear()方法来清空数据，数组无专有方法，可自己通过修改length值为0或者使用splice方法清空数据。\n\n>关于数组中的includes方法在数组值为一个个对象的时候，这个时候传入的值就只能是对象的引用了。如果作用域内不存在引用的话，判断数组中是否存在某个对象，就只能通过filter, find或者findIndex之类的方法加上数据特征去判断数组中是否存在该对象了。\n\n  \n## 三者之间的转换\n\n\n```Javascript\nconst arr = [1, 3, 4, 4];\nconst arr1 = [['a', 'Kebei']];\nconst map = new Map(['a', 1], ['b', 2]);\nconst set = new Set([1, 5]);\n\n// Array 转 Set\nconst arr2Set = new Set(arr);   // [1, 3, 4];\n// Array 转Map\nconst arr2Map = new Map(arr1);  // {'a' => 'Kebei'}\n\n//Set转Array\nconst set2Arr = Array.from(set);        // [1, 5]\nconst set2Arr2 = [...set];              // [1, 5]\nconst set2Arr3 = set.values()           // [1, 5]\n//Set转Map\nconst set2Map = new Map(set.entries())  // { 1=> 1, 5=>5}\n\n// Map转Array\nconst map2Arr = Array.from(map);     // ['a', 1], ['b', 2]\nconst map2Arr2 = [...map];           // ['a', 1], ['b', 2]\nconst map2Arr3 = map.values()        // ['a', 1], ['b', 2]\n// Map转Set\nconst map2Set = new Set(map.values()) // [1, 2]\n```\n## 应用场景\n</br>\n最常见的一种场景莫过于使用数组与Set之间格式变化进行数据去重\n\n```Javascript\n  const dedup = (arr) => {\n    return [...new Set(arr)]\n  }\n```\n上述方法和之前includes方法也是一样存在无法处理复杂数据类型，对于复杂对象数据，需要根据各自业务场景对重复的数据进行去重策略选择，即在一堆的重复对象中（以id重复为例）保留业务需要的唯一一个数据。\n\n## 总结\n三种数据结构有着各自不同的特性。数组是一个天然的栈，也是一个天然的队列，在三种数据结构中，其实例方法也应用也是最多的，是线性存储中话事人般的存在，也是我们在普通业务场景下的首选。Set数据的唯一性，可以帮助我们在业务场景中快速的进行去重。Map键值对结构的特殊性，以及对键的包容性，能够通过键快速获取到值，也是复杂业务冲常常用的。\n</br>\n\n【资料参考】\n  1. https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array\n  2. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\n  3. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map","source":"_posts/Array-set-map-summary.md","raw":"\n---\ntitle: 一篇文章搞懂Array,Set和Map异同\ndate: 2025-05-23 12:40:00\ntags:\n  - Javascript\n  - Array\n  - Set\n  - Map\n---\n\nArray,Set和Map三个作为Javascript中可迭代的集合数据类型，在编程过程中使用的频率也比较高。针对三种数据类型各自的一些特性，本文的内容将从以下几个方面来上述数据类型做一个总结。\n\n-  [**实例的创建**](##实例的创建)\n-  [**数据添加**](##数据添加)\n-  [**数据访问（查找）**](##数据访问（查找）)\n-  [**数据的遍历**](##数据的遍历)\n-  [**类似的功能和一些专有方法**](##类似的功能和一些专有方法)\n-  [**三者之间的转换**](##三者之间的转换)\n-  [**应用场景**](##应用场景)\n\n## 实例的创建\n  Map和Set创建实例的方式是唯一的，只允许通过new调用构造方法来创建一个实例。值得注意的是，Set和Map在调用构造函数的时候，传参都是数组或者可迭代对象，其中Map的传参数组需要时一个键值对数组。当然，传参也是可选的，非必须。\n\n Array相较于前两者，其创建实例的方式要多写，可通过字面方式创建，也可像Map和Set一样通过构造函数来创建。此外使用Array的静态函数Array.from来创建也是非常常见的。例如，通过docuemnt.getElementsByTagName这类方法获取到一个HTMLCollect这样一个类数组，通常会通过Array.from将其装换成一个真正的数组来进行后续的操作。\n\n  ```Javascript\n\n   // 创建map实例\n   let map1 = new Map();\n   let map2 = new Map([['a', 1], ['b', 2]]); //  a=>1, b=>2\n   // 创建set实例\n   let set1 = new Set();\n   let set2 = new Set([1,2])\n\n  // 通过字面量创建数组\n  let arr1 = [1,2,3];\n  // 使用Array静态方法从一个可迭代对象或者类数组中创建数组实例\n  let arr2 = Array.from([4,5]) \n  // 使用Array构造函数\n  let arr3 = new Array([6,7]);\n```\n\n## 数据添加与变更\n\n\n```Javascript\n  // Set的数据操作：添加与删除\n  let set = new Set();\n  set.add(11) // [11]\n  set.add(23) // [11, 23]\n  set.add(11) // [11, 23]\n  set.delete(23) // [11] \n  \n  // Map的数据操作：添加与删除\n  let  map = new Map();\n  map.set('a', 1);   // [a=>1]\n  map.set('b', 2);   // [a=>1, b=>2]\n  map.delete('b');   // [a=>1]\n\n  // Array\n  let arr = [1,2,3]\n  // 在数组末尾添加一个值\n  arr.push(4)       // [1,2,3,4]\n  // 弹出数组末尾的值\n  arr.pop(4)        // [1,2,3]\n  // 在数组头部添加一个值\n  arr.unshift(0)    // [0,1,2,3]\n  // 移除头部的第一个值\n  arr.shift()       // [1,2,3]\n  // 在第二个数（下标1）之后插入一个值‘a’\n  arr.splice(1,0,'a')   // [1,2,'a', 3];\n  // 删除第二个数（下标1）后面1个值，然后插入一个新的值‘b’\n  arr.splice(1,1,'b')   // [1,2,'b',3]\n```\n\n## 数据访问\n  Array和Map都能够访问实例中的特定数据，Array是通过下标，而Map是通过实例方法get, 唯独Set没有方式可以直接访问其中特定数据。其实也不难理解，Set本身不是为了单纯存储数据和访问特殊而生的，因为这些功能Array就可以支持，何必再单出构造一个Set数据结构了。我对此的理解是，Set跟多的是紧紧围绕着数据唯一不重复这一准则来的，它的侧重点是某一数据的有无，而不是数据存在哪里。\n\n  另外，从结构上来说。Set不像Array那样是有序的，所以也无法使用下标来访问，也不像Map那般，每个键对应一个值，所以也无法通过键来访问。故而，Set没有单独访问某一数据的方式。\n\n```Javascript\n  const arr = [1,2,3];\n  const set = new Set(['a', 'b']);\n  const map = new Map([['a', 1], ['b', '2']]);\n  \n  //Array通过下标访问数据\n  console.log(arr[0], arr[2]) // 1, 3\n  //Map使用实例方法get访问数据，参数是键\n  console.log(mpa.get('a))    // 1\n```\n## 数据的遍历\n\n**Set数据的遍历方式**：\n-  keys()   &emsp;&emsp;返回键名迭代器\n-  values() &emsp;返回值迭代器  \n-  entries() &emsp;返回键值迭代器\n-  forEach()\n```Javascript\nconst set = new Set(['a', 'b', 'c']);\n// set每个值对应的key其实也是数据值本身\nconst keyIter = set.keys();\nconsole.log(keyIter.next().value);  // 'a'\nconsole.log(keyIter.next().value);  // 'b'\nconsole.log(keyIter.next().value);  // 'c'\nconsole.log(keyIter.next().value);  // undefined\n\nconst valueIter = set.values();\nfor(let val of valueIter) {\n  console.log(val);                // 'a', 'b', 'c'\n}\n\nconst entriesIter = set.entries();\nfor(let [key, value] of entriesIter) {\n  console(`${key}:${value}`)     // 'a':'a', 'b':'b', 'c':'c'\n}\n\nset.forEach(val => {\n  console.log(val)             // 'a', 'b', 'c'\n})\n```\n</br>\n\n**Map数据的遍历方式**\n-  keys()   &emsp;&emsp;返回键名迭代器\n-  values() &emsp;返回值迭代器  \n-  entries() &emsp;返回键值迭代器\n-  forEach()\n\n```Javascript\nconst map = new Map([['a', 1], ['b', '2']]);\n/**\n* 代码就自己脑补吧，\n* 不能说和Set的方式很像，\n* 只能说真的就是一模一样\n**/\n```\n</br>\n\n**Array数据的遍历方式**\n\nArray遍历数据的方法是最多的，除了下面列举的几个之外，还有some, every,甚至filter, find和findIndex这些方法可以用来遍历数据。使用这些方法需要注意的是其使用的场景，例如map和forEach都可以用来对数组内数据做一些操作，但如果不需要返回值的情况，还是使用forEach方法，而不建议是map，其它方法也是如此。\n\n-  keys()   &emsp;&emsp;返回键名迭代器\n-  values() &emsp;返回值迭代器  \n-  entries() &emsp;返回键值迭代器\n-  map()    &emsp;回调函数，要有返回值\n-  reduce() \n-  forEach()\n-  for...of\n```Javascript\n/**\n* 代码就不写了，偷个懒，不过还是贴心的附上链接\n* https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array\n**/\n```\n\n\n## 类似的功能和一些专有方法\n- **是否包含某个元素**: 数组的includes方法，map和set的has方法，三者的返回值都是布尔值，区别只在于传入的参数。数组和set传入的是值，map传入的是键。\n- **合并两个相同类型的数据**： 数组使用concat方法，合并两个数组值，set使用union方法合并两个集合。map没有专有方法可以用来合并两个map数据，不过可以通过使用new Map([...map1, ...map2])来返回一个合并之后的新map\n- **数据大小**：数组有length属性，map和set有size属性\n- **清空数据**：map和size都可通过clear()方法来清空数据，数组无专有方法，可自己通过修改length值为0或者使用splice方法清空数据。\n\n>关于数组中的includes方法在数组值为一个个对象的时候，这个时候传入的值就只能是对象的引用了。如果作用域内不存在引用的话，判断数组中是否存在某个对象，就只能通过filter, find或者findIndex之类的方法加上数据特征去判断数组中是否存在该对象了。\n\n  \n## 三者之间的转换\n\n\n```Javascript\nconst arr = [1, 3, 4, 4];\nconst arr1 = [['a', 'Kebei']];\nconst map = new Map(['a', 1], ['b', 2]);\nconst set = new Set([1, 5]);\n\n// Array 转 Set\nconst arr2Set = new Set(arr);   // [1, 3, 4];\n// Array 转Map\nconst arr2Map = new Map(arr1);  // {'a' => 'Kebei'}\n\n//Set转Array\nconst set2Arr = Array.from(set);        // [1, 5]\nconst set2Arr2 = [...set];              // [1, 5]\nconst set2Arr3 = set.values()           // [1, 5]\n//Set转Map\nconst set2Map = new Map(set.entries())  // { 1=> 1, 5=>5}\n\n// Map转Array\nconst map2Arr = Array.from(map);     // ['a', 1], ['b', 2]\nconst map2Arr2 = [...map];           // ['a', 1], ['b', 2]\nconst map2Arr3 = map.values()        // ['a', 1], ['b', 2]\n// Map转Set\nconst map2Set = new Set(map.values()) // [1, 2]\n```\n## 应用场景\n</br>\n最常见的一种场景莫过于使用数组与Set之间格式变化进行数据去重\n\n```Javascript\n  const dedup = (arr) => {\n    return [...new Set(arr)]\n  }\n```\n上述方法和之前includes方法也是一样存在无法处理复杂数据类型，对于复杂对象数据，需要根据各自业务场景对重复的数据进行去重策略选择，即在一堆的重复对象中（以id重复为例）保留业务需要的唯一一个数据。\n\n## 总结\n三种数据结构有着各自不同的特性。数组是一个天然的栈，也是一个天然的队列，在三种数据结构中，其实例方法也应用也是最多的，是线性存储中话事人般的存在，也是我们在普通业务场景下的首选。Set数据的唯一性，可以帮助我们在业务场景中快速的进行去重。Map键值对结构的特殊性，以及对键的包容性，能够通过键快速获取到值，也是复杂业务冲常常用的。\n</br>\n\n【资料参考】\n  1. https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array\n  2. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\n  3. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map","slug":"Array-set-map-summary","published":1,"updated":"2025-05-27T10:17:21.034Z","comments":1,"layout":"post","photos":[],"_id":"cmbkxc9ov0000koup1mpldhh3","content":"<p>Array,Set和Map三个作为Javascript中可迭代的集合数据类型，在编程过程中使用的频率也比较高。针对三种数据类型各自的一些特性，本文的内容将从以下几个方面来上述数据类型做一个总结。</p>\n<ul>\n<li><a href=\"##%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%88%9B%E5%BB%BA\"><strong>实例的创建</strong></a></li>\n<li><a href=\"##%E6%95%B0%E6%8D%AE%E6%B7%BB%E5%8A%A0\"><strong>数据添加</strong></a></li>\n<li><a href=\"##%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%EF%BC%88%E6%9F%A5%E6%89%BE%EF%BC%89\"><strong>数据访问（查找）</strong></a></li>\n<li><a href=\"##%E6%95%B0%E6%8D%AE%E7%9A%84%E9%81%8D%E5%8E%86\"><strong>数据的遍历</strong></a></li>\n<li><a href=\"##%E7%B1%BB%E4%BC%BC%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E4%B8%80%E4%BA%9B%E4%B8%93%E6%9C%89%E6%96%B9%E6%B3%95\"><strong>类似的功能和一些专有方法</strong></a></li>\n<li><a href=\"##%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2\"><strong>三者之间的转换</strong></a></li>\n<li><a href=\"##%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\"><strong>应用场景</strong></a></li>\n</ul>\n<h2 id=\"实例的创建\"><a href=\"#实例的创建\" class=\"headerlink\" title=\"实例的创建\"></a>实例的创建</h2><p>  Map和Set创建实例的方式是唯一的，只允许通过new调用构造方法来创建一个实例。值得注意的是，Set和Map在调用构造函数的时候，传参都是数组或者可迭代对象，其中Map的传参数组需要时一个键值对数组。当然，传参也是可选的，非必须。</p>\n<p> Array相较于前两者，其创建实例的方式要多写，可通过字面方式创建，也可像Map和Set一样通过构造函数来创建。此外使用Array的静态函数Array.from来创建也是非常常见的。例如，通过docuemnt.getElementsByTagName这类方法获取到一个HTMLCollect这样一个类数组，通常会通过Array.from将其装换成一个真正的数组来进行后续的操作。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><br> <span class=\"hljs-comment\">// 创建map实例</span><br> <span class=\"hljs-keyword\">let</span> map1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();<br> <span class=\"hljs-keyword\">let</span> map2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">1</span>], [<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-number\">2</span>]]); <span class=\"hljs-comment\">//  a=&gt;1, b=&gt;2</span><br> <span class=\"hljs-comment\">// 创建set实例</span><br> <span class=\"hljs-keyword\">let</span> set1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>();<br> <span class=\"hljs-keyword\">let</span> set2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>])<br><br><span class=\"hljs-comment\">// 通过字面量创建数组</span><br><span class=\"hljs-keyword\">let</span> arr1 = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>];<br><span class=\"hljs-comment\">// 使用Array静态方法从一个可迭代对象或者类数组中创建数组实例</span><br><span class=\"hljs-keyword\">let</span> arr2 = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>([<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>]) <br><span class=\"hljs-comment\">// 使用Array构造函数</span><br><span class=\"hljs-keyword\">let</span> arr3 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Array</span>([<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">7</span>]);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"数据添加与变更\"><a href=\"#数据添加与变更\" class=\"headerlink\" title=\"数据添加与变更\"></a>数据添加与变更</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">// Set的数据操作：添加与删除</span><br><span class=\"hljs-keyword\">let</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>();<br>set.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">11</span>) <span class=\"hljs-comment\">// [11]</span><br>set.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">23</span>) <span class=\"hljs-comment\">// [11, 23]</span><br>set.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">11</span>) <span class=\"hljs-comment\">// [11, 23]</span><br>set.<span class=\"hljs-title function_\">delete</span>(<span class=\"hljs-number\">23</span>) <span class=\"hljs-comment\">// [11] </span><br><br><span class=\"hljs-comment\">// Map的数据操作：添加与删除</span><br><span class=\"hljs-keyword\">let</span>  map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();<br>map.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">1</span>);   <span class=\"hljs-comment\">// [a=&gt;1]</span><br>map.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-number\">2</span>);   <span class=\"hljs-comment\">// [a=&gt;1, b=&gt;2]</span><br>map.<span class=\"hljs-title function_\">delete</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>);   <span class=\"hljs-comment\">// [a=&gt;1]</span><br><br><span class=\"hljs-comment\">// Array</span><br><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>]<br><span class=\"hljs-comment\">// 在数组末尾添加一个值</span><br>arr.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-number\">4</span>)       <span class=\"hljs-comment\">// [1,2,3,4]</span><br><span class=\"hljs-comment\">// 弹出数组末尾的值</span><br>arr.<span class=\"hljs-title function_\">pop</span>(<span class=\"hljs-number\">4</span>)        <span class=\"hljs-comment\">// [1,2,3]</span><br><span class=\"hljs-comment\">// 在数组头部添加一个值</span><br>arr.<span class=\"hljs-title function_\">unshift</span>(<span class=\"hljs-number\">0</span>)    <span class=\"hljs-comment\">// [0,1,2,3]</span><br><span class=\"hljs-comment\">// 移除头部的第一个值</span><br>arr.<span class=\"hljs-title function_\">shift</span>()       <span class=\"hljs-comment\">// [1,2,3]</span><br><span class=\"hljs-comment\">// 在第二个数（下标1）之后插入一个值‘a’</span><br>arr.<span class=\"hljs-title function_\">splice</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-string\">&#x27;a&#x27;</span>)   <span class=\"hljs-comment\">// [1,2,&#x27;a&#x27;, 3];</span><br><span class=\"hljs-comment\">// 删除第二个数（下标1）后面1个值，然后插入一个新的值‘b’</span><br>arr.<span class=\"hljs-title function_\">splice</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">&#x27;b&#x27;</span>)   <span class=\"hljs-comment\">// [1,2,&#x27;b&#x27;,3]</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"数据访问\"><a href=\"#数据访问\" class=\"headerlink\" title=\"数据访问\"></a>数据访问</h2><p>  Array和Map都能够访问实例中的特定数据，Array是通过下标，而Map是通过实例方法get, 唯独Set没有方式可以直接访问其中特定数据。其实也不难理解，Set本身不是为了单纯存储数据和访问特殊而生的，因为这些功能Array就可以支持，何必再单出构造一个Set数据结构了。我对此的理解是，Set跟多的是紧紧围绕着数据唯一不重复这一准则来的，它的侧重点是某一数据的有无，而不是数据存在哪里。</p>\n<p>  另外，从结构上来说。Set不像Array那样是有序的，所以也无法使用下标来访问，也不像Map那般，每个键对应一个值，所以也无法通过键来访问。故而，Set没有单独访问某一数据的方式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>];<br><span class=\"hljs-keyword\">const</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>]);<br><span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">1</span>], [<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;2&#x27;</span>]]);<br><br><span class=\"hljs-comment\">//Array通过下标访问数据</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(arr[<span class=\"hljs-number\">0</span>], arr[<span class=\"hljs-number\">2</span>]) <span class=\"hljs-comment\">// 1, 3</span><br><span class=\"hljs-comment\">//Map使用实例方法get访问数据，参数是键</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(mpa.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;a))    // 1</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"数据的遍历\"><a href=\"#数据的遍历\" class=\"headerlink\" title=\"数据的遍历\"></a>数据的遍历</h2><p><strong>Set数据的遍历方式</strong>：</p>\n<ul>\n<li>keys()   &emsp;&emsp;返回键名迭代器</li>\n<li>values() &emsp;返回值迭代器  </li>\n<li>entries() &emsp;返回键值迭代器</li>\n<li>forEach()<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">const</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>]);<br><span class=\"hljs-comment\">// set每个值对应的key其实也是数据值本身</span><br><span class=\"hljs-keyword\">const</span> keyIter = set.<span class=\"hljs-title function_\">keys</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(keyIter.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>);  <span class=\"hljs-comment\">// &#x27;a&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(keyIter.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>);  <span class=\"hljs-comment\">// &#x27;b&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(keyIter.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>);  <span class=\"hljs-comment\">// &#x27;c&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(keyIter.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>);  <span class=\"hljs-comment\">// undefined</span><br><br><span class=\"hljs-keyword\">const</span> valueIter = set.<span class=\"hljs-title function_\">values</span>();<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> val <span class=\"hljs-keyword\">of</span> valueIter) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(val);                <span class=\"hljs-comment\">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span><br>&#125;<br><br><span class=\"hljs-keyword\">const</span> entriesIter = set.<span class=\"hljs-title function_\">entries</span>();<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> [key, value] <span class=\"hljs-keyword\">of</span> entriesIter) &#123;<br>  <span class=\"hljs-title function_\">console</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;key&#125;</span>:<span class=\"hljs-subst\">$&#123;value&#125;</span>`</span>)     <span class=\"hljs-comment\">// &#x27;a&#x27;:&#x27;a&#x27;, &#x27;b&#x27;:&#x27;b&#x27;, &#x27;c&#x27;:&#x27;c&#x27;</span><br>&#125;<br><br>set.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">val</span> =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(val)             <span class=\"hljs-comment\">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n</br></li>\n</ul>\n<p><strong>Map数据的遍历方式</strong></p>\n<ul>\n<li>keys()   &emsp;&emsp;返回键名迭代器</li>\n<li>values() &emsp;返回值迭代器  </li>\n<li>entries() &emsp;返回键值迭代器</li>\n<li>forEach()</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">1</span>], [<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;2&#x27;</span>]]);<br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">* 代码就自己脑补吧，</span><br><span class=\"hljs-comment\">* 不能说和Set的方式很像，</span><br><span class=\"hljs-comment\">* 只能说真的就是一模一样</span><br><span class=\"hljs-comment\">**/</span><br></code></pre></td></tr></table></figure>\n</br>\n\n<p><strong>Array数据的遍历方式</strong></p>\n<p>Array遍历数据的方法是最多的，除了下面列举的几个之外，还有some, every,甚至filter, find和findIndex这些方法可以用来遍历数据。使用这些方法需要注意的是其使用的场景，例如map和forEach都可以用来对数组内数据做一些操作，但如果不需要返回值的情况，还是使用forEach方法，而不建议是map，其它方法也是如此。</p>\n<ul>\n<li>keys()   &emsp;&emsp;返回键名迭代器</li>\n<li>values() &emsp;返回值迭代器  </li>\n<li>entries() &emsp;返回键值迭代器</li>\n<li>map()    &emsp;回调函数，要有返回值</li>\n<li>reduce() </li>\n<li>forEach()</li>\n<li>for…of<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">* 代码就不写了，偷个懒，不过还是贴心的附上链接</span><br><span class=\"hljs-comment\">* https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array</span><br><span class=\"hljs-comment\">**/</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"类似的功能和一些专有方法\"><a href=\"#类似的功能和一些专有方法\" class=\"headerlink\" title=\"类似的功能和一些专有方法\"></a>类似的功能和一些专有方法</h2><ul>\n<li><strong>是否包含某个元素</strong>: 数组的includes方法，map和set的has方法，三者的返回值都是布尔值，区别只在于传入的参数。数组和set传入的是值，map传入的是键。</li>\n<li><strong>合并两个相同类型的数据</strong>： 数组使用concat方法，合并两个数组值，set使用union方法合并两个集合。map没有专有方法可以用来合并两个map数据，不过可以通过使用new Map([…map1, …map2])来返回一个合并之后的新map</li>\n<li><strong>数据大小</strong>：数组有length属性，map和set有size属性</li>\n<li><strong>清空数据</strong>：map和size都可通过clear()方法来清空数据，数组无专有方法，可自己通过修改length值为0或者使用splice方法清空数据。</li>\n</ul>\n<blockquote>\n<p>关于数组中的includes方法在数组值为一个个对象的时候，这个时候传入的值就只能是对象的引用了。如果作用域内不存在引用的话，判断数组中是否存在某个对象，就只能通过filter, find或者findIndex之类的方法加上数据特征去判断数组中是否存在该对象了。</p>\n</blockquote>\n<h2 id=\"三者之间的转换\"><a href=\"#三者之间的转换\" class=\"headerlink\" title=\"三者之间的转换\"></a>三者之间的转换</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">4</span>];<br><span class=\"hljs-keyword\">const</span> arr1 = [[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;Kebei&#x27;</span>]];<br><span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">1</span>], [<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-number\">2</span>]);<br><span class=\"hljs-keyword\">const</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>]);<br><br><span class=\"hljs-comment\">// Array 转 Set</span><br><span class=\"hljs-keyword\">const</span> arr2Set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>(arr);   <span class=\"hljs-comment\">// [1, 3, 4];</span><br><span class=\"hljs-comment\">// Array 转Map</span><br><span class=\"hljs-keyword\">const</span> arr2Map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(arr1);  <span class=\"hljs-comment\">// &#123;&#x27;a&#x27; =&gt; &#x27;Kebei&#x27;&#125;</span><br><br><span class=\"hljs-comment\">//Set转Array</span><br><span class=\"hljs-keyword\">const</span> set2Arr = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(set);        <span class=\"hljs-comment\">// [1, 5]</span><br><span class=\"hljs-keyword\">const</span> set2Arr2 = [...set];              <span class=\"hljs-comment\">// [1, 5]</span><br><span class=\"hljs-keyword\">const</span> set2Arr3 = set.<span class=\"hljs-title function_\">values</span>()           <span class=\"hljs-comment\">// [1, 5]</span><br><span class=\"hljs-comment\">//Set转Map</span><br><span class=\"hljs-keyword\">const</span> set2Map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(set.<span class=\"hljs-title function_\">entries</span>())  <span class=\"hljs-comment\">// &#123; 1=&gt; 1, 5=&gt;5&#125;</span><br><br><span class=\"hljs-comment\">// Map转Array</span><br><span class=\"hljs-keyword\">const</span> map2Arr = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(map);     <span class=\"hljs-comment\">// [&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2]</span><br><span class=\"hljs-keyword\">const</span> map2Arr2 = [...map];           <span class=\"hljs-comment\">// [&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2]</span><br><span class=\"hljs-keyword\">const</span> map2Arr3 = map.<span class=\"hljs-title function_\">values</span>()        <span class=\"hljs-comment\">// [&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2]</span><br><span class=\"hljs-comment\">// Map转Set</span><br><span class=\"hljs-keyword\">const</span> map2Set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>(map.<span class=\"hljs-title function_\">values</span>()) <span class=\"hljs-comment\">// [1, 2]</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2></br>\n最常见的一种场景莫过于使用数组与Set之间格式变化进行数据去重\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">dedup</span> = (<span class=\"hljs-params\">arr</span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">return</span> [...<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>(arr)]<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>上述方法和之前includes方法也是一样存在无法处理复杂数据类型，对于复杂对象数据，需要根据各自业务场景对重复的数据进行去重策略选择，即在一堆的重复对象中（以id重复为例）保留业务需要的唯一一个数据。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>三种数据结构有着各自不同的特性。数组是一个天然的栈，也是一个天然的队列，在三种数据结构中，其实例方法也应用也是最多的，是线性存储中话事人般的存在，也是我们在普通业务场景下的首选。Set数据的唯一性，可以帮助我们在业务场景中快速的进行去重。Map键值对结构的特殊性，以及对键的包容性，能够通过键快速获取到值，也是复杂业务冲常常用的。<br></br></p>\n<p>【资料参考】</p>\n<ol>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map</a></li>\n</ol>\n","excerpt":"","more":"<p>Array,Set和Map三个作为Javascript中可迭代的集合数据类型，在编程过程中使用的频率也比较高。针对三种数据类型各自的一些特性，本文的内容将从以下几个方面来上述数据类型做一个总结。</p>\n<ul>\n<li><a href=\"##%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%88%9B%E5%BB%BA\"><strong>实例的创建</strong></a></li>\n<li><a href=\"##%E6%95%B0%E6%8D%AE%E6%B7%BB%E5%8A%A0\"><strong>数据添加</strong></a></li>\n<li><a href=\"##%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%EF%BC%88%E6%9F%A5%E6%89%BE%EF%BC%89\"><strong>数据访问（查找）</strong></a></li>\n<li><a href=\"##%E6%95%B0%E6%8D%AE%E7%9A%84%E9%81%8D%E5%8E%86\"><strong>数据的遍历</strong></a></li>\n<li><a href=\"##%E7%B1%BB%E4%BC%BC%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E4%B8%80%E4%BA%9B%E4%B8%93%E6%9C%89%E6%96%B9%E6%B3%95\"><strong>类似的功能和一些专有方法</strong></a></li>\n<li><a href=\"##%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2\"><strong>三者之间的转换</strong></a></li>\n<li><a href=\"##%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\"><strong>应用场景</strong></a></li>\n</ul>\n<h2 id=\"实例的创建\"><a href=\"#实例的创建\" class=\"headerlink\" title=\"实例的创建\"></a>实例的创建</h2><p>  Map和Set创建实例的方式是唯一的，只允许通过new调用构造方法来创建一个实例。值得注意的是，Set和Map在调用构造函数的时候，传参都是数组或者可迭代对象，其中Map的传参数组需要时一个键值对数组。当然，传参也是可选的，非必须。</p>\n<p> Array相较于前两者，其创建实例的方式要多写，可通过字面方式创建，也可像Map和Set一样通过构造函数来创建。此外使用Array的静态函数Array.from来创建也是非常常见的。例如，通过docuemnt.getElementsByTagName这类方法获取到一个HTMLCollect这样一个类数组，通常会通过Array.from将其装换成一个真正的数组来进行后续的操作。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><br> <span class=\"hljs-comment\">// 创建map实例</span><br> <span class=\"hljs-keyword\">let</span> map1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();<br> <span class=\"hljs-keyword\">let</span> map2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">1</span>], [<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-number\">2</span>]]); <span class=\"hljs-comment\">//  a=&gt;1, b=&gt;2</span><br> <span class=\"hljs-comment\">// 创建set实例</span><br> <span class=\"hljs-keyword\">let</span> set1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>();<br> <span class=\"hljs-keyword\">let</span> set2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>])<br><br><span class=\"hljs-comment\">// 通过字面量创建数组</span><br><span class=\"hljs-keyword\">let</span> arr1 = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>];<br><span class=\"hljs-comment\">// 使用Array静态方法从一个可迭代对象或者类数组中创建数组实例</span><br><span class=\"hljs-keyword\">let</span> arr2 = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>([<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>]) <br><span class=\"hljs-comment\">// 使用Array构造函数</span><br><span class=\"hljs-keyword\">let</span> arr3 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Array</span>([<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">7</span>]);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"数据添加与变更\"><a href=\"#数据添加与变更\" class=\"headerlink\" title=\"数据添加与变更\"></a>数据添加与变更</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">// Set的数据操作：添加与删除</span><br><span class=\"hljs-keyword\">let</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>();<br>set.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">11</span>) <span class=\"hljs-comment\">// [11]</span><br>set.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">23</span>) <span class=\"hljs-comment\">// [11, 23]</span><br>set.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">11</span>) <span class=\"hljs-comment\">// [11, 23]</span><br>set.<span class=\"hljs-title function_\">delete</span>(<span class=\"hljs-number\">23</span>) <span class=\"hljs-comment\">// [11] </span><br><br><span class=\"hljs-comment\">// Map的数据操作：添加与删除</span><br><span class=\"hljs-keyword\">let</span>  map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();<br>map.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">1</span>);   <span class=\"hljs-comment\">// [a=&gt;1]</span><br>map.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-number\">2</span>);   <span class=\"hljs-comment\">// [a=&gt;1, b=&gt;2]</span><br>map.<span class=\"hljs-title function_\">delete</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>);   <span class=\"hljs-comment\">// [a=&gt;1]</span><br><br><span class=\"hljs-comment\">// Array</span><br><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>]<br><span class=\"hljs-comment\">// 在数组末尾添加一个值</span><br>arr.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-number\">4</span>)       <span class=\"hljs-comment\">// [1,2,3,4]</span><br><span class=\"hljs-comment\">// 弹出数组末尾的值</span><br>arr.<span class=\"hljs-title function_\">pop</span>(<span class=\"hljs-number\">4</span>)        <span class=\"hljs-comment\">// [1,2,3]</span><br><span class=\"hljs-comment\">// 在数组头部添加一个值</span><br>arr.<span class=\"hljs-title function_\">unshift</span>(<span class=\"hljs-number\">0</span>)    <span class=\"hljs-comment\">// [0,1,2,3]</span><br><span class=\"hljs-comment\">// 移除头部的第一个值</span><br>arr.<span class=\"hljs-title function_\">shift</span>()       <span class=\"hljs-comment\">// [1,2,3]</span><br><span class=\"hljs-comment\">// 在第二个数（下标1）之后插入一个值‘a’</span><br>arr.<span class=\"hljs-title function_\">splice</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-string\">&#x27;a&#x27;</span>)   <span class=\"hljs-comment\">// [1,2,&#x27;a&#x27;, 3];</span><br><span class=\"hljs-comment\">// 删除第二个数（下标1）后面1个值，然后插入一个新的值‘b’</span><br>arr.<span class=\"hljs-title function_\">splice</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">&#x27;b&#x27;</span>)   <span class=\"hljs-comment\">// [1,2,&#x27;b&#x27;,3]</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"数据访问\"><a href=\"#数据访问\" class=\"headerlink\" title=\"数据访问\"></a>数据访问</h2><p>  Array和Map都能够访问实例中的特定数据，Array是通过下标，而Map是通过实例方法get, 唯独Set没有方式可以直接访问其中特定数据。其实也不难理解，Set本身不是为了单纯存储数据和访问特殊而生的，因为这些功能Array就可以支持，何必再单出构造一个Set数据结构了。我对此的理解是，Set跟多的是紧紧围绕着数据唯一不重复这一准则来的，它的侧重点是某一数据的有无，而不是数据存在哪里。</p>\n<p>  另外，从结构上来说。Set不像Array那样是有序的，所以也无法使用下标来访问，也不像Map那般，每个键对应一个值，所以也无法通过键来访问。故而，Set没有单独访问某一数据的方式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>];<br><span class=\"hljs-keyword\">const</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>]);<br><span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">1</span>], [<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;2&#x27;</span>]]);<br><br><span class=\"hljs-comment\">//Array通过下标访问数据</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(arr[<span class=\"hljs-number\">0</span>], arr[<span class=\"hljs-number\">2</span>]) <span class=\"hljs-comment\">// 1, 3</span><br><span class=\"hljs-comment\">//Map使用实例方法get访问数据，参数是键</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(mpa.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;a))    // 1</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"数据的遍历\"><a href=\"#数据的遍历\" class=\"headerlink\" title=\"数据的遍历\"></a>数据的遍历</h2><p><strong>Set数据的遍历方式</strong>：</p>\n<ul>\n<li>keys()   &emsp;&emsp;返回键名迭代器</li>\n<li>values() &emsp;返回值迭代器  </li>\n<li>entries() &emsp;返回键值迭代器</li>\n<li>forEach()<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">const</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>]);<br><span class=\"hljs-comment\">// set每个值对应的key其实也是数据值本身</span><br><span class=\"hljs-keyword\">const</span> keyIter = set.<span class=\"hljs-title function_\">keys</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(keyIter.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>);  <span class=\"hljs-comment\">// &#x27;a&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(keyIter.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>);  <span class=\"hljs-comment\">// &#x27;b&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(keyIter.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>);  <span class=\"hljs-comment\">// &#x27;c&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(keyIter.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>);  <span class=\"hljs-comment\">// undefined</span><br><br><span class=\"hljs-keyword\">const</span> valueIter = set.<span class=\"hljs-title function_\">values</span>();<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> val <span class=\"hljs-keyword\">of</span> valueIter) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(val);                <span class=\"hljs-comment\">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span><br>&#125;<br><br><span class=\"hljs-keyword\">const</span> entriesIter = set.<span class=\"hljs-title function_\">entries</span>();<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> [key, value] <span class=\"hljs-keyword\">of</span> entriesIter) &#123;<br>  <span class=\"hljs-title function_\">console</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;key&#125;</span>:<span class=\"hljs-subst\">$&#123;value&#125;</span>`</span>)     <span class=\"hljs-comment\">// &#x27;a&#x27;:&#x27;a&#x27;, &#x27;b&#x27;:&#x27;b&#x27;, &#x27;c&#x27;:&#x27;c&#x27;</span><br>&#125;<br><br>set.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">val</span> =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(val)             <span class=\"hljs-comment\">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n</br></li>\n</ul>\n<p><strong>Map数据的遍历方式</strong></p>\n<ul>\n<li>keys()   &emsp;&emsp;返回键名迭代器</li>\n<li>values() &emsp;返回值迭代器  </li>\n<li>entries() &emsp;返回键值迭代器</li>\n<li>forEach()</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">1</span>], [<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;2&#x27;</span>]]);<br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">* 代码就自己脑补吧，</span><br><span class=\"hljs-comment\">* 不能说和Set的方式很像，</span><br><span class=\"hljs-comment\">* 只能说真的就是一模一样</span><br><span class=\"hljs-comment\">**/</span><br></code></pre></td></tr></table></figure>\n</br>\n\n<p><strong>Array数据的遍历方式</strong></p>\n<p>Array遍历数据的方法是最多的，除了下面列举的几个之外，还有some, every,甚至filter, find和findIndex这些方法可以用来遍历数据。使用这些方法需要注意的是其使用的场景，例如map和forEach都可以用来对数组内数据做一些操作，但如果不需要返回值的情况，还是使用forEach方法，而不建议是map，其它方法也是如此。</p>\n<ul>\n<li>keys()   &emsp;&emsp;返回键名迭代器</li>\n<li>values() &emsp;返回值迭代器  </li>\n<li>entries() &emsp;返回键值迭代器</li>\n<li>map()    &emsp;回调函数，要有返回值</li>\n<li>reduce() </li>\n<li>forEach()</li>\n<li>for…of<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">* 代码就不写了，偷个懒，不过还是贴心的附上链接</span><br><span class=\"hljs-comment\">* https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array</span><br><span class=\"hljs-comment\">**/</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"类似的功能和一些专有方法\"><a href=\"#类似的功能和一些专有方法\" class=\"headerlink\" title=\"类似的功能和一些专有方法\"></a>类似的功能和一些专有方法</h2><ul>\n<li><strong>是否包含某个元素</strong>: 数组的includes方法，map和set的has方法，三者的返回值都是布尔值，区别只在于传入的参数。数组和set传入的是值，map传入的是键。</li>\n<li><strong>合并两个相同类型的数据</strong>： 数组使用concat方法，合并两个数组值，set使用union方法合并两个集合。map没有专有方法可以用来合并两个map数据，不过可以通过使用new Map([…map1, …map2])来返回一个合并之后的新map</li>\n<li><strong>数据大小</strong>：数组有length属性，map和set有size属性</li>\n<li><strong>清空数据</strong>：map和size都可通过clear()方法来清空数据，数组无专有方法，可自己通过修改length值为0或者使用splice方法清空数据。</li>\n</ul>\n<blockquote>\n<p>关于数组中的includes方法在数组值为一个个对象的时候，这个时候传入的值就只能是对象的引用了。如果作用域内不存在引用的话，判断数组中是否存在某个对象，就只能通过filter, find或者findIndex之类的方法加上数据特征去判断数组中是否存在该对象了。</p>\n</blockquote>\n<h2 id=\"三者之间的转换\"><a href=\"#三者之间的转换\" class=\"headerlink\" title=\"三者之间的转换\"></a>三者之间的转换</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">4</span>];<br><span class=\"hljs-keyword\">const</span> arr1 = [[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;Kebei&#x27;</span>]];<br><span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">1</span>], [<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-number\">2</span>]);<br><span class=\"hljs-keyword\">const</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>]);<br><br><span class=\"hljs-comment\">// Array 转 Set</span><br><span class=\"hljs-keyword\">const</span> arr2Set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>(arr);   <span class=\"hljs-comment\">// [1, 3, 4];</span><br><span class=\"hljs-comment\">// Array 转Map</span><br><span class=\"hljs-keyword\">const</span> arr2Map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(arr1);  <span class=\"hljs-comment\">// &#123;&#x27;a&#x27; =&gt; &#x27;Kebei&#x27;&#125;</span><br><br><span class=\"hljs-comment\">//Set转Array</span><br><span class=\"hljs-keyword\">const</span> set2Arr = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(set);        <span class=\"hljs-comment\">// [1, 5]</span><br><span class=\"hljs-keyword\">const</span> set2Arr2 = [...set];              <span class=\"hljs-comment\">// [1, 5]</span><br><span class=\"hljs-keyword\">const</span> set2Arr3 = set.<span class=\"hljs-title function_\">values</span>()           <span class=\"hljs-comment\">// [1, 5]</span><br><span class=\"hljs-comment\">//Set转Map</span><br><span class=\"hljs-keyword\">const</span> set2Map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(set.<span class=\"hljs-title function_\">entries</span>())  <span class=\"hljs-comment\">// &#123; 1=&gt; 1, 5=&gt;5&#125;</span><br><br><span class=\"hljs-comment\">// Map转Array</span><br><span class=\"hljs-keyword\">const</span> map2Arr = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(map);     <span class=\"hljs-comment\">// [&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2]</span><br><span class=\"hljs-keyword\">const</span> map2Arr2 = [...map];           <span class=\"hljs-comment\">// [&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2]</span><br><span class=\"hljs-keyword\">const</span> map2Arr3 = map.<span class=\"hljs-title function_\">values</span>()        <span class=\"hljs-comment\">// [&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2]</span><br><span class=\"hljs-comment\">// Map转Set</span><br><span class=\"hljs-keyword\">const</span> map2Set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>(map.<span class=\"hljs-title function_\">values</span>()) <span class=\"hljs-comment\">// [1, 2]</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2></br>\n最常见的一种场景莫过于使用数组与Set之间格式变化进行数据去重\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">dedup</span> = (<span class=\"hljs-params\">arr</span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">return</span> [...<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>(arr)]<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>上述方法和之前includes方法也是一样存在无法处理复杂数据类型，对于复杂对象数据，需要根据各自业务场景对重复的数据进行去重策略选择，即在一堆的重复对象中（以id重复为例）保留业务需要的唯一一个数据。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>三种数据结构有着各自不同的特性。数组是一个天然的栈，也是一个天然的队列，在三种数据结构中，其实例方法也应用也是最多的，是线性存储中话事人般的存在，也是我们在普通业务场景下的首选。Set数据的唯一性，可以帮助我们在业务场景中快速的进行去重。Map键值对结构的特殊性，以及对键的包容性，能够通过键快速获取到值，也是复杂业务冲常常用的。<br></br></p>\n<p>【资料参考】</p>\n<ol>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map</a></li>\n</ol>\n"},{"title":"Vue依赖收集和触发，看这些关键源码","date":"2025-05-23T04:40:00.000Z","_content":"\n从Vue开始较大范围在前端应用开始，关于Vue一些基础知识的讨论和面试问题就在开发圈子里基本上就跟前几年的股票和基金一样，楼下摆摊卖酱香饼的阿姨都能说上几句那种。找过前端开发工作或者正在找开发工作的前端都知道，面试官基本上都有那么几个常问的问题，而网上呢也有那么一套可以用来背诵的“八股文”，自己懂多少没有关系，应付面试官还是够的，可以算是屡试不爽吧。\n\n背诵面试八股文无可厚非的，可以说是每一个找工作的人都干过和必须干的事情，因为我们都要工作，都要恰饭。只有恰上饭，才能去谈些伟大的理想。背“八股文”本是一种捷径，尤其是本身对一门技术不是特别了解的开发者，就是那种刚刚能使用它那种。\n\n在众多关于Vue的面试“八股文”中，今天讲的是其中最常问的一个--Vue中的依赖收集。本文也将从代码层面，讲清楚关于依赖收集的几个问题。\n-  收集的依赖是什么？（what）\n-  怎么收集的依赖？  （how）\n-  什么时候收集？     (when)\n\n至于为什么要收集依赖(why)，现在就可以先告诉答案。**收集依赖，其核心作用是在数据发生变化的时候可以做出相应的动作，比如刷新视图**，为了执行这一动作，我们就得知道是谁在什么时候发生了变化，所以我们要收集依赖。\n\n\n下面我们结合代码，尽可能通俗的讲解关于上述的三个问题：\n\n\n\n在搞清楚依赖收集之前，先把源码中几个概念性的东西说明一下，建议下载[Vue3源码](https://github.com/vuejs/core)进行对照着看：\n-  **Dep**: 本质上是一个Map实例，同时在map实例上绑定一个celanup函数和一个computed属性。\n- **ReactiveEffect**: 相当于2.x版本中的Watcher类, 里头有一个deps数组，用来存dep, 每个实例里面都有一个track_id用来标识唯一性。\n\n- **effect函数**： 里头实例化一个ReactiveEffect对象，同时绑定一些options, 返回值是一个runner,实际上是对ReactiveEffect对象行为的一种业务封装。\n\n下面以一行简单的代码开始关于依赖收集的探索。\n```Javascript\nconst num = ref(1);\n```\n```Javascript\n// packages/reactivity/src/ref.ts\nexport function ref<T>(value: T): Ref<UnwrapRef<T>>\nexport function ref<T = any>(): Ref<T | undefined>\nexport function ref(value?: unknown) {\n  return createRef(value, false)\n}\n```\nref函数主要是对createRef做了一个函数包装，主要内容看到createRef函数。\n\n```Javascript\n// packages/reactivity/src/ref.ts\nfunction createRef(rawValue: unknown, shallow: boolean) {\n  if (isRef(rawValue)) {\n    return rawValue\n  }\n  return new RefImpl(rawValue, shallow)\n}\n```\ncreateRef函数在这里对原始数据rawValue做了一个判断，如果数据本身就是响应式数据了，就直接返回它本身，如果不是，就返回一个实例化的RefImpl对象。\n\n\n```Javascript\n// packages/reactivity/src/ref.ts\nclass RefImpl<T> {\n  private _value: T\n  private _rawValue: T\n\n  public dep?: Dep = undefined\n  public readonly __v_isRef = true\n\n  constructor(\n    value: T,\n    public readonly __v_isShallow: boolean,\n  ) {\n    this._rawValue = __v_isShallow ? value : toRaw(value)\n    this._value = __v_isShallow ? value : toReactive(value)\n  }\n\n  get value() {\n    trackRefValue(this)\n    return this._value\n  }\n\n  set value(newVal) {\n    const useDirectValue =\n      this.__v_isShallow || isShallow(newVal) || isReadonly(newVal)\n    newVal = useDirectValue ? newVal : toRaw(newVal)\n    if (hasChanged(newVal, this._rawValue)) {\n      this._rawValue = newVal\n      this._value = useDirectValue ? newVal : toReactive(newVal)\n      triggerRefValue(this, DirtyLevels.Dirty, newVal)\n    }\n  }\n}\n```\n重点来了，RefImple类里头，才是真正包含了从原始数据变成响应式数据，以及收集依赖的逻辑。在一个refImpl实例中，里面有一个dep对象，初始值是undefined， 这个dep会这trackRefValue函数执行的过程中被赋值。\n\n下面代码从17-21(get value())行，就是依赖收集的过程：当一个ref型响应式数据通过.value访问时，会触发RefImpl实例中的getter。它会首先执行一个trackValue函数，然后再返回_value值，所以接下来重点看关注trackValue函数，所以**依赖是在数据被访问的时候触发的**。\n\n```Javascript\n// packages/reactivity/src/ref.ts\nexport function trackRefValue(ref: RefBase<any>) {\n  if (shouldTrack && activeEffect) {\n    ref = toRaw(ref)\n    trackEffect(\n      activeEffect,\n      (ref.dep ??= createDep(\n        () => (ref.dep = undefined),\n        ref instanceof ComputedRefImpl ? ref : undefined,\n      )),\n      __DEV__\n        ? {\n            target: ref,\n            type: TrackOpTypes.GET,\n            key: 'value',\n          }\n        : void 0,\n    )\n  }\n}u\n```\n\ntrackRefValue函数中有两个变量，shouldTrack和activeEffect，暂时我们不去理会它们，只要知道shouldTrack是一个布尔值，activeEffect是一个RectiveEffect实例。\n\n在shouldTrack值为true且activeEffect有值的情况下，首先会将ref转成原始值，然后再执行trackEffect函数。\n\n在执行trackEffect函数的中，第一个是activeEffect, 在任意时刻它在全局是具有唯一性的；第二个是ref.dep, 其中给ref.dep的赋值函数createDep返回一个Dep实例，前面说过的，本质是个map; 第三个函数是个对象，是关于开发环境下debug的一些配置。\n\n在这里，我们可以看到，之前说个的ref实例中原来是undefined的ref.dep赋值，就在此处。\n\n```Javascript\n// packages/reactivity/src/effect.ts\nexport function trackEffect(\n  effect: ReactiveEffect,\n  dep: Dep,\n  debuggerEventExtraInfo?: DebuggerEventExtraInfo,\n) {\n  if (dep.get(effect) !== effect._trackId) {\n    dep.set(effect, effect._trackId)\n    const oldDep = effect.deps[effect._depsLength]\n    if (oldDep !== dep) {\n      if (oldDep) {\n        cleanupDepEffect(oldDep, effect)\n      }\n      effect.deps[effect._depsLength++] = dep\n    } else {\n      effect._depsLength++\n    }\n    if (__DEV__) {\n      effect.onTrack?.(extend({ effect }, debuggerEventExtraInfo!))\n    }\n  }\n}\n```\ntrackEffect函数绝对是依赖收集重头戏中的重头戏。\n\n首先上来就是一个判断，dep, 也就是ref中的dep，本质是个map，判断里面是否存在对应的effect, 如果没有，就执行接下来的操作。\n\ndep将effect也就是activeEffect作为键，其_trackId作为值添加到dep，**所以我们说的收集的依赖指的就是effect对象**。同时我们得到了一个关于**dep和effect之间的第一关系，即一个dep可以对应多个effect**。\n\n接着，将effects实例中deps数组中最后一个值取出来与当前的dep值进行比对，看是否是同一个值如果不是同一个值，而且oldDep是有值的，那么就执行cleanupDepEffect操作。如果oldDep为空值，就跳过这一步，直接往effect.deps中添加dep。因此，我们在这里得到了关于dep和effect第二个结论，**一个effect可以对应多个dep**。\n\n代码还有一部分，接着往下看，在oldDep不等于当前dep的时候，直接对effec_depsLength进行加操作，也就是说，effect.deps值没有变，但是_depsLength值却超出了deps数组边界的情况，这也就是为什么上面要判断oldDep是否存在的原因。\n\n\n由上面上面两个结论我们可以得出，一个dep中可以对应多个effect, 一个effect也可以对应多个dep, 因此dep和effect的关系是多对多的关系。\n\n### 总结\n\n-  收集的依赖是什么？（what）\n  > 我们常说的收集的依赖是effect对象\n\n-  怎么收集的依赖？  （how）\n > 判断当前数据dep中有没有activeEffct, 没有就加进去。把大象关进冰箱里要几步！！！\n-  什么时候收集？     (when)\n> 在数据被访问时，触发getter，进行依赖收集\n","source":"_posts/Dependencies-collecting-of-vue3.md","raw":"---\ntitle: Vue依赖收集和触发，看这些关键源码\ndate: 2025-05-23 12:40:00\ncategory: Vue源码阅读\ntags:\n  - Vue\n  - 源码阅读\n  - 依赖收集\n---\n\n从Vue开始较大范围在前端应用开始，关于Vue一些基础知识的讨论和面试问题就在开发圈子里基本上就跟前几年的股票和基金一样，楼下摆摊卖酱香饼的阿姨都能说上几句那种。找过前端开发工作或者正在找开发工作的前端都知道，面试官基本上都有那么几个常问的问题，而网上呢也有那么一套可以用来背诵的“八股文”，自己懂多少没有关系，应付面试官还是够的，可以算是屡试不爽吧。\n\n背诵面试八股文无可厚非的，可以说是每一个找工作的人都干过和必须干的事情，因为我们都要工作，都要恰饭。只有恰上饭，才能去谈些伟大的理想。背“八股文”本是一种捷径，尤其是本身对一门技术不是特别了解的开发者，就是那种刚刚能使用它那种。\n\n在众多关于Vue的面试“八股文”中，今天讲的是其中最常问的一个--Vue中的依赖收集。本文也将从代码层面，讲清楚关于依赖收集的几个问题。\n-  收集的依赖是什么？（what）\n-  怎么收集的依赖？  （how）\n-  什么时候收集？     (when)\n\n至于为什么要收集依赖(why)，现在就可以先告诉答案。**收集依赖，其核心作用是在数据发生变化的时候可以做出相应的动作，比如刷新视图**，为了执行这一动作，我们就得知道是谁在什么时候发生了变化，所以我们要收集依赖。\n\n\n下面我们结合代码，尽可能通俗的讲解关于上述的三个问题：\n\n\n\n在搞清楚依赖收集之前，先把源码中几个概念性的东西说明一下，建议下载[Vue3源码](https://github.com/vuejs/core)进行对照着看：\n-  **Dep**: 本质上是一个Map实例，同时在map实例上绑定一个celanup函数和一个computed属性。\n- **ReactiveEffect**: 相当于2.x版本中的Watcher类, 里头有一个deps数组，用来存dep, 每个实例里面都有一个track_id用来标识唯一性。\n\n- **effect函数**： 里头实例化一个ReactiveEffect对象，同时绑定一些options, 返回值是一个runner,实际上是对ReactiveEffect对象行为的一种业务封装。\n\n下面以一行简单的代码开始关于依赖收集的探索。\n```Javascript\nconst num = ref(1);\n```\n```Javascript\n// packages/reactivity/src/ref.ts\nexport function ref<T>(value: T): Ref<UnwrapRef<T>>\nexport function ref<T = any>(): Ref<T | undefined>\nexport function ref(value?: unknown) {\n  return createRef(value, false)\n}\n```\nref函数主要是对createRef做了一个函数包装，主要内容看到createRef函数。\n\n```Javascript\n// packages/reactivity/src/ref.ts\nfunction createRef(rawValue: unknown, shallow: boolean) {\n  if (isRef(rawValue)) {\n    return rawValue\n  }\n  return new RefImpl(rawValue, shallow)\n}\n```\ncreateRef函数在这里对原始数据rawValue做了一个判断，如果数据本身就是响应式数据了，就直接返回它本身，如果不是，就返回一个实例化的RefImpl对象。\n\n\n```Javascript\n// packages/reactivity/src/ref.ts\nclass RefImpl<T> {\n  private _value: T\n  private _rawValue: T\n\n  public dep?: Dep = undefined\n  public readonly __v_isRef = true\n\n  constructor(\n    value: T,\n    public readonly __v_isShallow: boolean,\n  ) {\n    this._rawValue = __v_isShallow ? value : toRaw(value)\n    this._value = __v_isShallow ? value : toReactive(value)\n  }\n\n  get value() {\n    trackRefValue(this)\n    return this._value\n  }\n\n  set value(newVal) {\n    const useDirectValue =\n      this.__v_isShallow || isShallow(newVal) || isReadonly(newVal)\n    newVal = useDirectValue ? newVal : toRaw(newVal)\n    if (hasChanged(newVal, this._rawValue)) {\n      this._rawValue = newVal\n      this._value = useDirectValue ? newVal : toReactive(newVal)\n      triggerRefValue(this, DirtyLevels.Dirty, newVal)\n    }\n  }\n}\n```\n重点来了，RefImple类里头，才是真正包含了从原始数据变成响应式数据，以及收集依赖的逻辑。在一个refImpl实例中，里面有一个dep对象，初始值是undefined， 这个dep会这trackRefValue函数执行的过程中被赋值。\n\n下面代码从17-21(get value())行，就是依赖收集的过程：当一个ref型响应式数据通过.value访问时，会触发RefImpl实例中的getter。它会首先执行一个trackValue函数，然后再返回_value值，所以接下来重点看关注trackValue函数，所以**依赖是在数据被访问的时候触发的**。\n\n```Javascript\n// packages/reactivity/src/ref.ts\nexport function trackRefValue(ref: RefBase<any>) {\n  if (shouldTrack && activeEffect) {\n    ref = toRaw(ref)\n    trackEffect(\n      activeEffect,\n      (ref.dep ??= createDep(\n        () => (ref.dep = undefined),\n        ref instanceof ComputedRefImpl ? ref : undefined,\n      )),\n      __DEV__\n        ? {\n            target: ref,\n            type: TrackOpTypes.GET,\n            key: 'value',\n          }\n        : void 0,\n    )\n  }\n}u\n```\n\ntrackRefValue函数中有两个变量，shouldTrack和activeEffect，暂时我们不去理会它们，只要知道shouldTrack是一个布尔值，activeEffect是一个RectiveEffect实例。\n\n在shouldTrack值为true且activeEffect有值的情况下，首先会将ref转成原始值，然后再执行trackEffect函数。\n\n在执行trackEffect函数的中，第一个是activeEffect, 在任意时刻它在全局是具有唯一性的；第二个是ref.dep, 其中给ref.dep的赋值函数createDep返回一个Dep实例，前面说过的，本质是个map; 第三个函数是个对象，是关于开发环境下debug的一些配置。\n\n在这里，我们可以看到，之前说个的ref实例中原来是undefined的ref.dep赋值，就在此处。\n\n```Javascript\n// packages/reactivity/src/effect.ts\nexport function trackEffect(\n  effect: ReactiveEffect,\n  dep: Dep,\n  debuggerEventExtraInfo?: DebuggerEventExtraInfo,\n) {\n  if (dep.get(effect) !== effect._trackId) {\n    dep.set(effect, effect._trackId)\n    const oldDep = effect.deps[effect._depsLength]\n    if (oldDep !== dep) {\n      if (oldDep) {\n        cleanupDepEffect(oldDep, effect)\n      }\n      effect.deps[effect._depsLength++] = dep\n    } else {\n      effect._depsLength++\n    }\n    if (__DEV__) {\n      effect.onTrack?.(extend({ effect }, debuggerEventExtraInfo!))\n    }\n  }\n}\n```\ntrackEffect函数绝对是依赖收集重头戏中的重头戏。\n\n首先上来就是一个判断，dep, 也就是ref中的dep，本质是个map，判断里面是否存在对应的effect, 如果没有，就执行接下来的操作。\n\ndep将effect也就是activeEffect作为键，其_trackId作为值添加到dep，**所以我们说的收集的依赖指的就是effect对象**。同时我们得到了一个关于**dep和effect之间的第一关系，即一个dep可以对应多个effect**。\n\n接着，将effects实例中deps数组中最后一个值取出来与当前的dep值进行比对，看是否是同一个值如果不是同一个值，而且oldDep是有值的，那么就执行cleanupDepEffect操作。如果oldDep为空值，就跳过这一步，直接往effect.deps中添加dep。因此，我们在这里得到了关于dep和effect第二个结论，**一个effect可以对应多个dep**。\n\n代码还有一部分，接着往下看，在oldDep不等于当前dep的时候，直接对effec_depsLength进行加操作，也就是说，effect.deps值没有变，但是_depsLength值却超出了deps数组边界的情况，这也就是为什么上面要判断oldDep是否存在的原因。\n\n\n由上面上面两个结论我们可以得出，一个dep中可以对应多个effect, 一个effect也可以对应多个dep, 因此dep和effect的关系是多对多的关系。\n\n### 总结\n\n-  收集的依赖是什么？（what）\n  > 我们常说的收集的依赖是effect对象\n\n-  怎么收集的依赖？  （how）\n > 判断当前数据dep中有没有activeEffct, 没有就加进去。把大象关进冰箱里要几步！！！\n-  什么时候收集？     (when)\n> 在数据被访问时，触发getter，进行依赖收集\n","slug":"Dependencies-collecting-of-vue3","published":1,"updated":"2025-06-21T14:15:44.943Z","_id":"cmbkxc9p00001koupe3jv27tn","comments":1,"layout":"post","photos":[],"content":"<p>从Vue开始较大范围在前端应用开始，关于Vue一些基础知识的讨论和面试问题就在开发圈子里基本上就跟前几年的股票和基金一样，楼下摆摊卖酱香饼的阿姨都能说上几句那种。找过前端开发工作或者正在找开发工作的前端都知道，面试官基本上都有那么几个常问的问题，而网上呢也有那么一套可以用来背诵的“八股文”，自己懂多少没有关系，应付面试官还是够的，可以算是屡试不爽吧。</p>\n<p>背诵面试八股文无可厚非的，可以说是每一个找工作的人都干过和必须干的事情，因为我们都要工作，都要恰饭。只有恰上饭，才能去谈些伟大的理想。背“八股文”本是一种捷径，尤其是本身对一门技术不是特别了解的开发者，就是那种刚刚能使用它那种。</p>\n<p>在众多关于Vue的面试“八股文”中，今天讲的是其中最常问的一个–Vue中的依赖收集。本文也将从代码层面，讲清楚关于依赖收集的几个问题。</p>\n<ul>\n<li>收集的依赖是什么？（what）</li>\n<li>怎么收集的依赖？  （how）</li>\n<li>什么时候收集？     (when)</li>\n</ul>\n<p>至于为什么要收集依赖(why)，现在就可以先告诉答案。<strong>收集依赖，其核心作用是在数据发生变化的时候可以做出相应的动作，比如刷新视图</strong>，为了执行这一动作，我们就得知道是谁在什么时候发生了变化，所以我们要收集依赖。</p>\n<p>下面我们结合代码，尽可能通俗的讲解关于上述的三个问题：</p>\n<p>在搞清楚依赖收集之前，先把源码中几个概念性的东西说明一下，建议下载<a href=\"https://github.com/vuejs/core\">Vue3源码</a>进行对照着看：</p>\n<ul>\n<li><p><strong>Dep</strong>: 本质上是一个Map实例，同时在map实例上绑定一个celanup函数和一个computed属性。</p>\n</li>\n<li><p><strong>ReactiveEffect</strong>: 相当于2.x版本中的Watcher类, 里头有一个deps数组，用来存dep, 每个实例里面都有一个track_id用来标识唯一性。</p>\n</li>\n<li><p><strong>effect函数</strong>： 里头实例化一个ReactiveEffect对象，同时绑定一些options, 返回值是一个runner,实际上是对ReactiveEffect对象行为的一种业务封装。</p>\n</li>\n</ul>\n<p>下面以一行简单的代码开始关于依赖收集的探索。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">const</span> num = <span class=\"hljs-title function_\">ref</span>(<span class=\"hljs-number\">1</span>);<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">// packages/reactivity/src/ref.ts</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> ref&lt;T&gt;(<span class=\"hljs-attr\">value</span>: T): <span class=\"hljs-title class_\">Ref</span>&lt;<span class=\"hljs-title class_\">UnwrapRef</span>&lt;T&gt;&gt;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> ref&lt;T = any&gt;(): <span class=\"hljs-title class_\">Ref</span>&lt;T | <span class=\"hljs-literal\">undefined</span>&gt;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">ref</span>(<span class=\"hljs-params\">value?: unknown</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">createRef</span>(value, <span class=\"hljs-literal\">false</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>ref函数主要是对createRef做了一个函数包装，主要内容看到createRef函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">// packages/reactivity/src/ref.ts</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createRef</span>(<span class=\"hljs-params\">rawValue: unknown, shallow: boolean</span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_\">isRef</span>(rawValue)) &#123;<br>    <span class=\"hljs-keyword\">return</span> rawValue<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RefImpl</span>(rawValue, shallow)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>createRef函数在这里对原始数据rawValue做了一个判断，如果数据本身就是响应式数据了，就直接返回它本身，如果不是，就返回一个实例化的RefImpl对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">// packages/reactivity/src/ref.ts</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RefImpl</span>&lt;T&gt; &#123;<br>  private <span class=\"hljs-attr\">_value</span>: T<br>  private <span class=\"hljs-attr\">_rawValue</span>: T<br><br>  public dep?: <span class=\"hljs-title class_\">Dep</span> = <span class=\"hljs-literal\">undefined</span><br>  public readonly __v_isRef = <span class=\"hljs-literal\">true</span><br><br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span><br><span class=\"hljs-params\">    value: T,</span><br><span class=\"hljs-params\">    public readonly __v_isShallow: boolean,</span><br><span class=\"hljs-params\">  </span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_rawValue</span> = __v_isShallow ? value : <span class=\"hljs-title function_\">toRaw</span>(value)<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_value</span> = __v_isShallow ? value : <span class=\"hljs-title function_\">toReactive</span>(value)<br>  &#125;<br><br>  <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title function_\">value</span>() &#123;<br>    <span class=\"hljs-title function_\">trackRefValue</span>(<span class=\"hljs-variable language_\">this</span>)<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_value</span><br>  &#125;<br><br>  <span class=\"hljs-keyword\">set</span> <span class=\"hljs-title function_\">value</span>(<span class=\"hljs-params\">newVal</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> useDirectValue =<br>      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">__v_isShallow</span> || <span class=\"hljs-title function_\">isShallow</span>(newVal) || <span class=\"hljs-title function_\">isReadonly</span>(newVal)<br>    newVal = useDirectValue ? newVal : <span class=\"hljs-title function_\">toRaw</span>(newVal)<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_\">hasChanged</span>(newVal, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_rawValue</span>)) &#123;<br>      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_rawValue</span> = newVal<br>      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_value</span> = useDirectValue ? newVal : <span class=\"hljs-title function_\">toReactive</span>(newVal)<br>      <span class=\"hljs-title function_\">triggerRefValue</span>(<span class=\"hljs-variable language_\">this</span>, <span class=\"hljs-title class_\">DirtyLevels</span>.<span class=\"hljs-property\">Dirty</span>, newVal)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>重点来了，RefImple类里头，才是真正包含了从原始数据变成响应式数据，以及收集依赖的逻辑。在一个refImpl实例中，里面有一个dep对象，初始值是undefined， 这个dep会这trackRefValue函数执行的过程中被赋值。</p>\n<p>下面代码从17-21(get value())行，就是依赖收集的过程：当一个ref型响应式数据通过.value访问时，会触发RefImpl实例中的getter。它会首先执行一个trackValue函数，然后再返回_value值，所以接下来重点看关注trackValue函数，所以<strong>依赖是在数据被访问的时候触发的</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">// packages/reactivity/src/ref.ts</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">trackRefValue</span>(<span class=\"hljs-params\">ref: RefBase&lt;any&gt;</span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (shouldTrack &amp;&amp; activeEffect) &#123;<br>    ref = <span class=\"hljs-title function_\">toRaw</span>(ref)<br>    <span class=\"hljs-title function_\">trackEffect</span>(<br>      activeEffect,<br>      (ref.<span class=\"hljs-property\">dep</span> ??= <span class=\"hljs-title function_\">createDep</span>(<br>        <span class=\"hljs-function\">() =&gt;</span> (ref.<span class=\"hljs-property\">dep</span> = <span class=\"hljs-literal\">undefined</span>),<br>        ref <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">ComputedRefImpl</span> ? ref : <span class=\"hljs-literal\">undefined</span>,<br>      )),<br>      __DEV__<br>        ? &#123;<br>            <span class=\"hljs-attr\">target</span>: ref,<br>            <span class=\"hljs-attr\">type</span>: <span class=\"hljs-title class_\">TrackOpTypes</span>.<span class=\"hljs-property\">GET</span>,<br>            <span class=\"hljs-attr\">key</span>: <span class=\"hljs-string\">&#x27;value&#x27;</span>,<br>          &#125;<br>        : <span class=\"hljs-keyword\">void</span> <span class=\"hljs-number\">0</span>,<br>    )<br>  &#125;<br>&#125;u<br></code></pre></td></tr></table></figure>\n\n<p>trackRefValue函数中有两个变量，shouldTrack和activeEffect，暂时我们不去理会它们，只要知道shouldTrack是一个布尔值，activeEffect是一个RectiveEffect实例。</p>\n<p>在shouldTrack值为true且activeEffect有值的情况下，首先会将ref转成原始值，然后再执行trackEffect函数。</p>\n<p>在执行trackEffect函数的中，第一个是activeEffect, 在任意时刻它在全局是具有唯一性的；第二个是ref.dep, 其中给ref.dep的赋值函数createDep返回一个Dep实例，前面说过的，本质是个map; 第三个函数是个对象，是关于开发环境下debug的一些配置。</p>\n<p>在这里，我们可以看到，之前说个的ref实例中原来是undefined的ref.dep赋值，就在此处。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">// packages/reactivity/src/effect.ts</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">trackEffect</span>(<span class=\"hljs-params\"></span><br><span class=\"hljs-params\">  effect: ReactiveEffect,</span><br><span class=\"hljs-params\">  dep: Dep,</span><br><span class=\"hljs-params\">  debuggerEventExtraInfo?: DebuggerEventExtraInfo,</span><br><span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (dep.<span class=\"hljs-title function_\">get</span>(effect) !== effect.<span class=\"hljs-property\">_trackId</span>) &#123;<br>    dep.<span class=\"hljs-title function_\">set</span>(effect, effect.<span class=\"hljs-property\">_trackId</span>)<br>    <span class=\"hljs-keyword\">const</span> oldDep = effect.<span class=\"hljs-property\">deps</span>[effect.<span class=\"hljs-property\">_depsLength</span>]<br>    <span class=\"hljs-keyword\">if</span> (oldDep !== dep) &#123;<br>      <span class=\"hljs-keyword\">if</span> (oldDep) &#123;<br>        <span class=\"hljs-title function_\">cleanupDepEffect</span>(oldDep, effect)<br>      &#125;<br>      effect.<span class=\"hljs-property\">deps</span>[effect.<span class=\"hljs-property\">_depsLength</span>++] = dep<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      effect.<span class=\"hljs-property\">_depsLength</span>++<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (__DEV__) &#123;<br>      effect.<span class=\"hljs-property\">onTrack</span>?.(<span class=\"hljs-title function_\">extend</span>(&#123; effect &#125;, debuggerEventExtraInfo!))<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>trackEffect函数绝对是依赖收集重头戏中的重头戏。</p>\n<p>首先上来就是一个判断，dep, 也就是ref中的dep，本质是个map，判断里面是否存在对应的effect, 如果没有，就执行接下来的操作。</p>\n<p>dep将effect也就是activeEffect作为键，其_trackId作为值添加到dep，<strong>所以我们说的收集的依赖指的就是effect对象</strong>。同时我们得到了一个关于<strong>dep和effect之间的第一关系，即一个dep可以对应多个effect</strong>。</p>\n<p>接着，将effects实例中deps数组中最后一个值取出来与当前的dep值进行比对，看是否是同一个值如果不是同一个值，而且oldDep是有值的，那么就执行cleanupDepEffect操作。如果oldDep为空值，就跳过这一步，直接往effect.deps中添加dep。因此，我们在这里得到了关于dep和effect第二个结论，<strong>一个effect可以对应多个dep</strong>。</p>\n<p>代码还有一部分，接着往下看，在oldDep不等于当前dep的时候，直接对effec_depsLength进行加操作，也就是说，effect.deps值没有变，但是_depsLength值却超出了deps数组边界的情况，这也就是为什么上面要判断oldDep是否存在的原因。</p>\n<p>由上面上面两个结论我们可以得出，一个dep中可以对应多个effect, 一个effect也可以对应多个dep, 因此dep和effect的关系是多对多的关系。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><p>收集的依赖是什么？（what）</p>\n<blockquote>\n<p>我们常说的收集的依赖是effect对象</p>\n</blockquote>\n</li>\n<li><p>怎么收集的依赖？  （how）</p>\n<blockquote>\n<p>判断当前数据dep中有没有activeEffct, 没有就加进去。把大象关进冰箱里要几步！！！</p>\n</blockquote>\n</li>\n<li><p>什么时候收集？     (when)</p>\n<blockquote>\n<p>在数据被访问时，触发getter，进行依赖收集</p>\n</blockquote>\n</li>\n</ul>\n","excerpt":"","more":"<p>从Vue开始较大范围在前端应用开始，关于Vue一些基础知识的讨论和面试问题就在开发圈子里基本上就跟前几年的股票和基金一样，楼下摆摊卖酱香饼的阿姨都能说上几句那种。找过前端开发工作或者正在找开发工作的前端都知道，面试官基本上都有那么几个常问的问题，而网上呢也有那么一套可以用来背诵的“八股文”，自己懂多少没有关系，应付面试官还是够的，可以算是屡试不爽吧。</p>\n<p>背诵面试八股文无可厚非的，可以说是每一个找工作的人都干过和必须干的事情，因为我们都要工作，都要恰饭。只有恰上饭，才能去谈些伟大的理想。背“八股文”本是一种捷径，尤其是本身对一门技术不是特别了解的开发者，就是那种刚刚能使用它那种。</p>\n<p>在众多关于Vue的面试“八股文”中，今天讲的是其中最常问的一个–Vue中的依赖收集。本文也将从代码层面，讲清楚关于依赖收集的几个问题。</p>\n<ul>\n<li>收集的依赖是什么？（what）</li>\n<li>怎么收集的依赖？  （how）</li>\n<li>什么时候收集？     (when)</li>\n</ul>\n<p>至于为什么要收集依赖(why)，现在就可以先告诉答案。<strong>收集依赖，其核心作用是在数据发生变化的时候可以做出相应的动作，比如刷新视图</strong>，为了执行这一动作，我们就得知道是谁在什么时候发生了变化，所以我们要收集依赖。</p>\n<p>下面我们结合代码，尽可能通俗的讲解关于上述的三个问题：</p>\n<p>在搞清楚依赖收集之前，先把源码中几个概念性的东西说明一下，建议下载<a href=\"https://github.com/vuejs/core\">Vue3源码</a>进行对照着看：</p>\n<ul>\n<li><p><strong>Dep</strong>: 本质上是一个Map实例，同时在map实例上绑定一个celanup函数和一个computed属性。</p>\n</li>\n<li><p><strong>ReactiveEffect</strong>: 相当于2.x版本中的Watcher类, 里头有一个deps数组，用来存dep, 每个实例里面都有一个track_id用来标识唯一性。</p>\n</li>\n<li><p><strong>effect函数</strong>： 里头实例化一个ReactiveEffect对象，同时绑定一些options, 返回值是一个runner,实际上是对ReactiveEffect对象行为的一种业务封装。</p>\n</li>\n</ul>\n<p>下面以一行简单的代码开始关于依赖收集的探索。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">const</span> num = <span class=\"hljs-title function_\">ref</span>(<span class=\"hljs-number\">1</span>);<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">// packages/reactivity/src/ref.ts</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> ref&lt;T&gt;(<span class=\"hljs-attr\">value</span>: T): <span class=\"hljs-title class_\">Ref</span>&lt;<span class=\"hljs-title class_\">UnwrapRef</span>&lt;T&gt;&gt;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> ref&lt;T = any&gt;(): <span class=\"hljs-title class_\">Ref</span>&lt;T | <span class=\"hljs-literal\">undefined</span>&gt;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">ref</span>(<span class=\"hljs-params\">value?: unknown</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">createRef</span>(value, <span class=\"hljs-literal\">false</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>ref函数主要是对createRef做了一个函数包装，主要内容看到createRef函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">// packages/reactivity/src/ref.ts</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createRef</span>(<span class=\"hljs-params\">rawValue: unknown, shallow: boolean</span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_\">isRef</span>(rawValue)) &#123;<br>    <span class=\"hljs-keyword\">return</span> rawValue<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RefImpl</span>(rawValue, shallow)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>createRef函数在这里对原始数据rawValue做了一个判断，如果数据本身就是响应式数据了，就直接返回它本身，如果不是，就返回一个实例化的RefImpl对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">// packages/reactivity/src/ref.ts</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RefImpl</span>&lt;T&gt; &#123;<br>  private <span class=\"hljs-attr\">_value</span>: T<br>  private <span class=\"hljs-attr\">_rawValue</span>: T<br><br>  public dep?: <span class=\"hljs-title class_\">Dep</span> = <span class=\"hljs-literal\">undefined</span><br>  public readonly __v_isRef = <span class=\"hljs-literal\">true</span><br><br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span><br><span class=\"hljs-params\">    value: T,</span><br><span class=\"hljs-params\">    public readonly __v_isShallow: boolean,</span><br><span class=\"hljs-params\">  </span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_rawValue</span> = __v_isShallow ? value : <span class=\"hljs-title function_\">toRaw</span>(value)<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_value</span> = __v_isShallow ? value : <span class=\"hljs-title function_\">toReactive</span>(value)<br>  &#125;<br><br>  <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title function_\">value</span>() &#123;<br>    <span class=\"hljs-title function_\">trackRefValue</span>(<span class=\"hljs-variable language_\">this</span>)<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_value</span><br>  &#125;<br><br>  <span class=\"hljs-keyword\">set</span> <span class=\"hljs-title function_\">value</span>(<span class=\"hljs-params\">newVal</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> useDirectValue =<br>      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">__v_isShallow</span> || <span class=\"hljs-title function_\">isShallow</span>(newVal) || <span class=\"hljs-title function_\">isReadonly</span>(newVal)<br>    newVal = useDirectValue ? newVal : <span class=\"hljs-title function_\">toRaw</span>(newVal)<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_\">hasChanged</span>(newVal, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_rawValue</span>)) &#123;<br>      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_rawValue</span> = newVal<br>      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_value</span> = useDirectValue ? newVal : <span class=\"hljs-title function_\">toReactive</span>(newVal)<br>      <span class=\"hljs-title function_\">triggerRefValue</span>(<span class=\"hljs-variable language_\">this</span>, <span class=\"hljs-title class_\">DirtyLevels</span>.<span class=\"hljs-property\">Dirty</span>, newVal)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>重点来了，RefImple类里头，才是真正包含了从原始数据变成响应式数据，以及收集依赖的逻辑。在一个refImpl实例中，里面有一个dep对象，初始值是undefined， 这个dep会这trackRefValue函数执行的过程中被赋值。</p>\n<p>下面代码从17-21(get value())行，就是依赖收集的过程：当一个ref型响应式数据通过.value访问时，会触发RefImpl实例中的getter。它会首先执行一个trackValue函数，然后再返回_value值，所以接下来重点看关注trackValue函数，所以<strong>依赖是在数据被访问的时候触发的</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">// packages/reactivity/src/ref.ts</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">trackRefValue</span>(<span class=\"hljs-params\">ref: RefBase&lt;any&gt;</span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (shouldTrack &amp;&amp; activeEffect) &#123;<br>    ref = <span class=\"hljs-title function_\">toRaw</span>(ref)<br>    <span class=\"hljs-title function_\">trackEffect</span>(<br>      activeEffect,<br>      (ref.<span class=\"hljs-property\">dep</span> ??= <span class=\"hljs-title function_\">createDep</span>(<br>        <span class=\"hljs-function\">() =&gt;</span> (ref.<span class=\"hljs-property\">dep</span> = <span class=\"hljs-literal\">undefined</span>),<br>        ref <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">ComputedRefImpl</span> ? ref : <span class=\"hljs-literal\">undefined</span>,<br>      )),<br>      __DEV__<br>        ? &#123;<br>            <span class=\"hljs-attr\">target</span>: ref,<br>            <span class=\"hljs-attr\">type</span>: <span class=\"hljs-title class_\">TrackOpTypes</span>.<span class=\"hljs-property\">GET</span>,<br>            <span class=\"hljs-attr\">key</span>: <span class=\"hljs-string\">&#x27;value&#x27;</span>,<br>          &#125;<br>        : <span class=\"hljs-keyword\">void</span> <span class=\"hljs-number\">0</span>,<br>    )<br>  &#125;<br>&#125;u<br></code></pre></td></tr></table></figure>\n\n<p>trackRefValue函数中有两个变量，shouldTrack和activeEffect，暂时我们不去理会它们，只要知道shouldTrack是一个布尔值，activeEffect是一个RectiveEffect实例。</p>\n<p>在shouldTrack值为true且activeEffect有值的情况下，首先会将ref转成原始值，然后再执行trackEffect函数。</p>\n<p>在执行trackEffect函数的中，第一个是activeEffect, 在任意时刻它在全局是具有唯一性的；第二个是ref.dep, 其中给ref.dep的赋值函数createDep返回一个Dep实例，前面说过的，本质是个map; 第三个函数是个对象，是关于开发环境下debug的一些配置。</p>\n<p>在这里，我们可以看到，之前说个的ref实例中原来是undefined的ref.dep赋值，就在此处。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">// packages/reactivity/src/effect.ts</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">trackEffect</span>(<span class=\"hljs-params\"></span><br><span class=\"hljs-params\">  effect: ReactiveEffect,</span><br><span class=\"hljs-params\">  dep: Dep,</span><br><span class=\"hljs-params\">  debuggerEventExtraInfo?: DebuggerEventExtraInfo,</span><br><span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (dep.<span class=\"hljs-title function_\">get</span>(effect) !== effect.<span class=\"hljs-property\">_trackId</span>) &#123;<br>    dep.<span class=\"hljs-title function_\">set</span>(effect, effect.<span class=\"hljs-property\">_trackId</span>)<br>    <span class=\"hljs-keyword\">const</span> oldDep = effect.<span class=\"hljs-property\">deps</span>[effect.<span class=\"hljs-property\">_depsLength</span>]<br>    <span class=\"hljs-keyword\">if</span> (oldDep !== dep) &#123;<br>      <span class=\"hljs-keyword\">if</span> (oldDep) &#123;<br>        <span class=\"hljs-title function_\">cleanupDepEffect</span>(oldDep, effect)<br>      &#125;<br>      effect.<span class=\"hljs-property\">deps</span>[effect.<span class=\"hljs-property\">_depsLength</span>++] = dep<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      effect.<span class=\"hljs-property\">_depsLength</span>++<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (__DEV__) &#123;<br>      effect.<span class=\"hljs-property\">onTrack</span>?.(<span class=\"hljs-title function_\">extend</span>(&#123; effect &#125;, debuggerEventExtraInfo!))<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>trackEffect函数绝对是依赖收集重头戏中的重头戏。</p>\n<p>首先上来就是一个判断，dep, 也就是ref中的dep，本质是个map，判断里面是否存在对应的effect, 如果没有，就执行接下来的操作。</p>\n<p>dep将effect也就是activeEffect作为键，其_trackId作为值添加到dep，<strong>所以我们说的收集的依赖指的就是effect对象</strong>。同时我们得到了一个关于<strong>dep和effect之间的第一关系，即一个dep可以对应多个effect</strong>。</p>\n<p>接着，将effects实例中deps数组中最后一个值取出来与当前的dep值进行比对，看是否是同一个值如果不是同一个值，而且oldDep是有值的，那么就执行cleanupDepEffect操作。如果oldDep为空值，就跳过这一步，直接往effect.deps中添加dep。因此，我们在这里得到了关于dep和effect第二个结论，<strong>一个effect可以对应多个dep</strong>。</p>\n<p>代码还有一部分，接着往下看，在oldDep不等于当前dep的时候，直接对effec_depsLength进行加操作，也就是说，effect.deps值没有变，但是_depsLength值却超出了deps数组边界的情况，这也就是为什么上面要判断oldDep是否存在的原因。</p>\n<p>由上面上面两个结论我们可以得出，一个dep中可以对应多个effect, 一个effect也可以对应多个dep, 因此dep和effect的关系是多对多的关系。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><p>收集的依赖是什么？（what）</p>\n<blockquote>\n<p>我们常说的收集的依赖是effect对象</p>\n</blockquote>\n</li>\n<li><p>怎么收集的依赖？  （how）</p>\n<blockquote>\n<p>判断当前数据dep中有没有activeEffct, 没有就加进去。把大象关进冰箱里要几步！！！</p>\n</blockquote>\n</li>\n<li><p>什么时候收集？     (when)</p>\n<blockquote>\n<p>在数据被访问时，触发getter，进行依赖收集</p>\n</blockquote>\n</li>\n</ul>\n"},{"title":"搭建个人博客系列--(3) Hexo 静态博客搭建实战","date":"2025-06-07T16:21:58.000Z","keywords":["博客搭建","免费博客平台","托管博客","模板建站"],"index_img":"imgs/build-blog3/hexo.png","banner_img":"imgs/build-blog3/hexo.png","_content":"\n通过上一篇文章--[动手搭建自己的第一个博客站点](./build-personal-blog2.md)的介绍，相信你已经成功搭建起了自己的第一个博客网站。如果你的动手能力比较强的话，或许还给博客页面做了页面美工，添加了导航等功能。\n\n如果你的博客还停留在手写html的阶段，也没有关系，通过这篇文章，让你在10分钟内学会如何使用工具生成漂亮好看的博客页面。\n\n\n## 什么是 SSG\n\n人类与其他动物的一个显著区别在于，人类擅长制造并使用工具，撰写博客亦是如此。如今，搭建站点撰写博客早已告别了需要手动逐行编写 HTML 代码的 “刀耕火种” 时代，众多优秀工具可供选择，助力我们快速实现更出色的博客呈现效果。\n\n我们知道，一篇博客内容通常都是以HTML的形式存储的，但对于写博客的人来说，其更想要关注的是其内容本身，而不是各种HTML标签的排列组合和样式调整。\n\n![markdown-to-html](../imgs/build-blog3/md2html.png)\n\n那么是否有一种工具，可以让撰写博客的人从书写HTML和各种样式调整中解脱出来，可以直接将纯文本内容转换成带漂亮样式的HTML文件呢？\n\n有的，那就是静态站点生成器（Static Site Generator)。它是一种自动化工具，它通过模板和数据源（如 Markdown 文件、CMS 内容或 API 数据）生成完整的 HTML、CSS 和 JavaScript 文件。与传统动态网站不同，SSG 生成的页面在构建时就已完全渲染，无需在用户访问时依赖数据库或服务器端处理。\n\n\n## 一些常见的SSG工具\n\n下面是一些常见的SSG工具，其中包含一些大家都比较熟悉的，比如Next, Hugo, Jekyll还有Hexo之类的。\n\n![site-generator](../imgs//build-blog3/site-generator.png)\n![site-generator](../imgs//build-blog3/site-generator2.png)\n\n`Next.js`有完整的React生态支持，内置CSS模块化、图像优化和自动代码风格功能, 适合构建复杂交互应用。\n\n`Hugo` 是一块由Go语言开发的超高速静态站点生成器，最大的特点就是，快！\n\n`Jekyll` 算是一款老牌的静态站点生成器了，Github Pages原生就支持，非常适合搞小型项目展示页和个人博客。\n\n`Hexo` 是一款Node.js生态的轻量博客框架，Markdown只有友好，非常适合中文写作。\n\n工具那么多，我独爱Hexo! \n\n## Why Hexo?\n\n在众多的SSG工具中，为什么为独独选择Hexo呢？ 除了是个人接触比较早之外，还有一些其它的深层次的原因。\n\n![hexo](../imgs/build-blog3/hexo.png)\n\n**极低的入门门槛**，只需安装 Node 环境后，通过几条命令即可初始化站点，无需复杂配置。而且中文教程十分丰富，即使是新手，也能在10分钟之内搭建出一个基础博客。\n\n**中文生态友好**，配置文件、错误提示等均为中文，对国内开发者更友好; 社区活跃，中文主题和插件资源丰富。\n\n**灵活扩展，功能丰富**，插件系统完善，通过 npm 安装插件即可扩展功能；主题基于 EJS/Pug/Markdown 模板，支持自定义布局、样式和脚本。\n\n如果你恰好也是一名前端开发工程师，日常开发中必然常常与Node打交道，那么对于自己写Hexo插件和主题是很有优势的，Hexo对于你来说是个很不错的选择。\n\n## 实战操作\n\n前面就说了，即使是新手，也能够在10分钟之内搭建出一个基础博客。如果你正在尝试着跟着步骤做，不妨计时验证一下。\n\n多的话不说了，撸起袖子，开干！\n\n- ### step1: 准备Node环境\n\n  如果之前接触过Node或者已经安装过Node, 可以直接跳过该步骤，直接进入到step2。如果是Node新手，可以按照下面步骤来安装Node。\n  - **方法1：安装包安装**\n\n    a）前往[Node官网](https://nodejs.org/zh-cn/download)下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node安装包”获取。<br>\n    b) 双击安装包，开始安装, 傻瓜式的点击Next.\n\n\n  - **方法2：可移动二进制文件安装**\n\n      a）前往[Node官网](https://nodejs.org/zh-cn/download)下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node独立文件包”获取。<br>\n      b) 将包解压任意目录, 然后将其中的`bin`目录路径配置到环境变量 `path`中\n\n  如安装过程过程中有疑问，可参考详细教程: [Node安装保姆级教程](./install-node.md)\n\n  安装之后，打开命令行窗口，输入 `node -v` 验证，如果出现对应版本号，则说明安装成功了。\n\n- ### step2: 安装Hexo脚手架\n\n全局安装 **Hexo CLI**, 一行命令行就够了。\n\n```\nnpm install hexo-cli -g \n```\n![step2](../imgs//build-blog3/step2.png)\n\n- ### step3: 搭建博客\n\n使用hexo脚手架，完成博客搭建操作\n```\nhexo init my-blog           # 初始化博客目录\ncd my-blog && npm install   # 安装依赖\nnpm run server              # 启动本地预览（http://localhost:4000）\n```\n执行完上述操作之后，在浏览器中输入地址`http://localhost:4000`, 你将看到整个博客的样子，其中包含一篇默认的 `Hello world`博文。\n\n![landscape](../imgs/build-blog3/landscape.png)\n\n如果你想要添加新的博客，执行 `hexo new post 文章标题`即可在 `source/_post`目录下生成一个新的 `.md`文件。如果不熟悉Markdown语法，可以查阅相关资料学习，上手其实挺快的。\n\n\n### step4: 部署到Github Page\n\n执行命令下方命令\n\n``` bash\nhexo generate\n```\n\nhexo将会把所有相关资源文件进行转换，最后所有的资源都都存放在 `public`目录下。将所有文件上传到上一篇文中提到的个人仓库或者使用git命令提交，等待一两分钟，访问自己的博客站点地址，你将看内容已经更新。\n\n\n## 写在最后\n\nHexo 博客的默认主题是 `landscape`, 你也可以尝试着使用其它博客主题，如 `Next`, `Fluid`等。\n\n如果你想对博客站点做些修改，可以通过编辑其根目录下配置文件 `_config.yml` 来进行调整。如果在主题样式上需要做修改，也可以编辑其对应的配置文件，对应的配置文件在 `/themes/主题名称/`中。\n\n关于Hexo更多的配置可查阅其官方文档，里面都有十分详细的介绍。如果个人动手能力比较强，也可以尝试着写一些主题或者插件，那将是一件让你感到成就感满满的事情。\n\n","source":"_posts/build-personal-blog3.md","raw":"---\ntitle: 搭建个人博客系列--(3) Hexo 静态博客搭建实战\ndate: 2025-06-08 00:21:58\ncategory: 搭建博客\ntags: \n   - 博客搭建\n   - 个人IP\nkeywords: [博客搭建, 免费博客平台, 托管博客, 模板建站]\nindex_img: imgs/build-blog3/hexo.png\nbanner_img: imgs/build-blog3/hexo.png\n---\n\n通过上一篇文章--[动手搭建自己的第一个博客站点](./build-personal-blog2.md)的介绍，相信你已经成功搭建起了自己的第一个博客网站。如果你的动手能力比较强的话，或许还给博客页面做了页面美工，添加了导航等功能。\n\n如果你的博客还停留在手写html的阶段，也没有关系，通过这篇文章，让你在10分钟内学会如何使用工具生成漂亮好看的博客页面。\n\n\n## 什么是 SSG\n\n人类与其他动物的一个显著区别在于，人类擅长制造并使用工具，撰写博客亦是如此。如今，搭建站点撰写博客早已告别了需要手动逐行编写 HTML 代码的 “刀耕火种” 时代，众多优秀工具可供选择，助力我们快速实现更出色的博客呈现效果。\n\n我们知道，一篇博客内容通常都是以HTML的形式存储的，但对于写博客的人来说，其更想要关注的是其内容本身，而不是各种HTML标签的排列组合和样式调整。\n\n![markdown-to-html](../imgs/build-blog3/md2html.png)\n\n那么是否有一种工具，可以让撰写博客的人从书写HTML和各种样式调整中解脱出来，可以直接将纯文本内容转换成带漂亮样式的HTML文件呢？\n\n有的，那就是静态站点生成器（Static Site Generator)。它是一种自动化工具，它通过模板和数据源（如 Markdown 文件、CMS 内容或 API 数据）生成完整的 HTML、CSS 和 JavaScript 文件。与传统动态网站不同，SSG 生成的页面在构建时就已完全渲染，无需在用户访问时依赖数据库或服务器端处理。\n\n\n## 一些常见的SSG工具\n\n下面是一些常见的SSG工具，其中包含一些大家都比较熟悉的，比如Next, Hugo, Jekyll还有Hexo之类的。\n\n![site-generator](../imgs//build-blog3/site-generator.png)\n![site-generator](../imgs//build-blog3/site-generator2.png)\n\n`Next.js`有完整的React生态支持，内置CSS模块化、图像优化和自动代码风格功能, 适合构建复杂交互应用。\n\n`Hugo` 是一块由Go语言开发的超高速静态站点生成器，最大的特点就是，快！\n\n`Jekyll` 算是一款老牌的静态站点生成器了，Github Pages原生就支持，非常适合搞小型项目展示页和个人博客。\n\n`Hexo` 是一款Node.js生态的轻量博客框架，Markdown只有友好，非常适合中文写作。\n\n工具那么多，我独爱Hexo! \n\n## Why Hexo?\n\n在众多的SSG工具中，为什么为独独选择Hexo呢？ 除了是个人接触比较早之外，还有一些其它的深层次的原因。\n\n![hexo](../imgs/build-blog3/hexo.png)\n\n**极低的入门门槛**，只需安装 Node 环境后，通过几条命令即可初始化站点，无需复杂配置。而且中文教程十分丰富，即使是新手，也能在10分钟之内搭建出一个基础博客。\n\n**中文生态友好**，配置文件、错误提示等均为中文，对国内开发者更友好; 社区活跃，中文主题和插件资源丰富。\n\n**灵活扩展，功能丰富**，插件系统完善，通过 npm 安装插件即可扩展功能；主题基于 EJS/Pug/Markdown 模板，支持自定义布局、样式和脚本。\n\n如果你恰好也是一名前端开发工程师，日常开发中必然常常与Node打交道，那么对于自己写Hexo插件和主题是很有优势的，Hexo对于你来说是个很不错的选择。\n\n## 实战操作\n\n前面就说了，即使是新手，也能够在10分钟之内搭建出一个基础博客。如果你正在尝试着跟着步骤做，不妨计时验证一下。\n\n多的话不说了，撸起袖子，开干！\n\n- ### step1: 准备Node环境\n\n  如果之前接触过Node或者已经安装过Node, 可以直接跳过该步骤，直接进入到step2。如果是Node新手，可以按照下面步骤来安装Node。\n  - **方法1：安装包安装**\n\n    a）前往[Node官网](https://nodejs.org/zh-cn/download)下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node安装包”获取。<br>\n    b) 双击安装包，开始安装, 傻瓜式的点击Next.\n\n\n  - **方法2：可移动二进制文件安装**\n\n      a）前往[Node官网](https://nodejs.org/zh-cn/download)下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node独立文件包”获取。<br>\n      b) 将包解压任意目录, 然后将其中的`bin`目录路径配置到环境变量 `path`中\n\n  如安装过程过程中有疑问，可参考详细教程: [Node安装保姆级教程](./install-node.md)\n\n  安装之后，打开命令行窗口，输入 `node -v` 验证，如果出现对应版本号，则说明安装成功了。\n\n- ### step2: 安装Hexo脚手架\n\n全局安装 **Hexo CLI**, 一行命令行就够了。\n\n```\nnpm install hexo-cli -g \n```\n![step2](../imgs//build-blog3/step2.png)\n\n- ### step3: 搭建博客\n\n使用hexo脚手架，完成博客搭建操作\n```\nhexo init my-blog           # 初始化博客目录\ncd my-blog && npm install   # 安装依赖\nnpm run server              # 启动本地预览（http://localhost:4000）\n```\n执行完上述操作之后，在浏览器中输入地址`http://localhost:4000`, 你将看到整个博客的样子，其中包含一篇默认的 `Hello world`博文。\n\n![landscape](../imgs/build-blog3/landscape.png)\n\n如果你想要添加新的博客，执行 `hexo new post 文章标题`即可在 `source/_post`目录下生成一个新的 `.md`文件。如果不熟悉Markdown语法，可以查阅相关资料学习，上手其实挺快的。\n\n\n### step4: 部署到Github Page\n\n执行命令下方命令\n\n``` bash\nhexo generate\n```\n\nhexo将会把所有相关资源文件进行转换，最后所有的资源都都存放在 `public`目录下。将所有文件上传到上一篇文中提到的个人仓库或者使用git命令提交，等待一两分钟，访问自己的博客站点地址，你将看内容已经更新。\n\n\n## 写在最后\n\nHexo 博客的默认主题是 `landscape`, 你也可以尝试着使用其它博客主题，如 `Next`, `Fluid`等。\n\n如果你想对博客站点做些修改，可以通过编辑其根目录下配置文件 `_config.yml` 来进行调整。如果在主题样式上需要做修改，也可以编辑其对应的配置文件，对应的配置文件在 `/themes/主题名称/`中。\n\n关于Hexo更多的配置可查阅其官方文档，里面都有十分详细的介绍。如果个人动手能力比较强，也可以尝试着写一些主题或者插件，那将是一件让你感到成就感满满的事情。\n\n","slug":"build-personal-blog3","published":1,"updated":"2025-08-26T10:16:37.605Z","_id":"cmbmg2vsx0000loup2bgwc9c7","comments":1,"layout":"post","photos":[],"content":"<p>通过上一篇文章–<a href=\"./build-personal-blog2.md\">动手搭建自己的第一个博客站点</a>的介绍，相信你已经成功搭建起了自己的第一个博客网站。如果你的动手能力比较强的话，或许还给博客页面做了页面美工，添加了导航等功能。</p>\n<p>如果你的博客还停留在手写html的阶段，也没有关系，通过这篇文章，让你在10分钟内学会如何使用工具生成漂亮好看的博客页面。</p>\n<h2 id=\"什么是-SSG\"><a href=\"#什么是-SSG\" class=\"headerlink\" title=\"什么是 SSG\"></a>什么是 SSG</h2><p>人类与其他动物的一个显著区别在于，人类擅长制造并使用工具，撰写博客亦是如此。如今，搭建站点撰写博客早已告别了需要手动逐行编写 HTML 代码的 “刀耕火种” 时代，众多优秀工具可供选择，助力我们快速实现更出色的博客呈现效果。</p>\n<p>我们知道，一篇博客内容通常都是以HTML的形式存储的，但对于写博客的人来说，其更想要关注的是其内容本身，而不是各种HTML标签的排列组合和样式调整。</p>\n<p><img src=\"/../imgs/build-blog3/md2html.png\" alt=\"markdown-to-html\"></p>\n<p>那么是否有一种工具，可以让撰写博客的人从书写HTML和各种样式调整中解脱出来，可以直接将纯文本内容转换成带漂亮样式的HTML文件呢？</p>\n<p>有的，那就是静态站点生成器（Static Site Generator)。它是一种自动化工具，它通过模板和数据源（如 Markdown 文件、CMS 内容或 API 数据）生成完整的 HTML、CSS 和 JavaScript 文件。与传统动态网站不同，SSG 生成的页面在构建时就已完全渲染，无需在用户访问时依赖数据库或服务器端处理。</p>\n<h2 id=\"一些常见的SSG工具\"><a href=\"#一些常见的SSG工具\" class=\"headerlink\" title=\"一些常见的SSG工具\"></a>一些常见的SSG工具</h2><p>下面是一些常见的SSG工具，其中包含一些大家都比较熟悉的，比如Next, Hugo, Jekyll还有Hexo之类的。</p>\n<p><img src=\"/../imgs/build-blog3/site-generator.png\" alt=\"site-generator\"><br><img src=\"/../imgs/build-blog3/site-generator2.png\" alt=\"site-generator\"></p>\n<p><code>Next.js</code>有完整的React生态支持，内置CSS模块化、图像优化和自动代码风格功能, 适合构建复杂交互应用。</p>\n<p><code>Hugo</code> 是一块由Go语言开发的超高速静态站点生成器，最大的特点就是，快！</p>\n<p><code>Jekyll</code> 算是一款老牌的静态站点生成器了，Github Pages原生就支持，非常适合搞小型项目展示页和个人博客。</p>\n<p><code>Hexo</code> 是一款Node.js生态的轻量博客框架，Markdown只有友好，非常适合中文写作。</p>\n<p>工具那么多，我独爱Hexo! </p>\n<h2 id=\"Why-Hexo\"><a href=\"#Why-Hexo\" class=\"headerlink\" title=\"Why Hexo?\"></a>Why Hexo?</h2><p>在众多的SSG工具中，为什么为独独选择Hexo呢？ 除了是个人接触比较早之外，还有一些其它的深层次的原因。</p>\n<p><img src=\"/../imgs/build-blog3/hexo.png\" alt=\"hexo\"></p>\n<p><strong>极低的入门门槛</strong>，只需安装 Node 环境后，通过几条命令即可初始化站点，无需复杂配置。而且中文教程十分丰富，即使是新手，也能在10分钟之内搭建出一个基础博客。</p>\n<p><strong>中文生态友好</strong>，配置文件、错误提示等均为中文，对国内开发者更友好; 社区活跃，中文主题和插件资源丰富。</p>\n<p><strong>灵活扩展，功能丰富</strong>，插件系统完善，通过 npm 安装插件即可扩展功能；主题基于 EJS&#x2F;Pug&#x2F;Markdown 模板，支持自定义布局、样式和脚本。</p>\n<p>如果你恰好也是一名前端开发工程师，日常开发中必然常常与Node打交道，那么对于自己写Hexo插件和主题是很有优势的，Hexo对于你来说是个很不错的选择。</p>\n<h2 id=\"实战操作\"><a href=\"#实战操作\" class=\"headerlink\" title=\"实战操作\"></a>实战操作</h2><p>前面就说了，即使是新手，也能够在10分钟之内搭建出一个基础博客。如果你正在尝试着跟着步骤做，不妨计时验证一下。</p>\n<p>多的话不说了，撸起袖子，开干！</p>\n<ul>\n<li><h3 id=\"step1-准备Node环境\"><a href=\"#step1-准备Node环境\" class=\"headerlink\" title=\"step1: 准备Node环境\"></a>step1: 准备Node环境</h3><p>如果之前接触过Node或者已经安装过Node, 可以直接跳过该步骤，直接进入到step2。如果是Node新手，可以按照下面步骤来安装Node。</p>\n<ul>\n<li><p><strong>方法1：安装包安装</strong></p>\n<p>a）前往<a href=\"https://nodejs.org/zh-cn/download\">Node官网</a>下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node安装包”获取。<br><br>b) 双击安装包，开始安装, 傻瓜式的点击Next.</p>\n</li>\n<li><p><strong>方法2：可移动二进制文件安装</strong></p>\n<p>  a）前往<a href=\"https://nodejs.org/zh-cn/download\">Node官网</a>下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node独立文件包”获取。<br><br>  b) 将包解压任意目录, 然后将其中的<code>bin</code>目录路径配置到环境变量 <code>path</code>中</p>\n</li>\n</ul>\n<p>如安装过程过程中有疑问，可参考详细教程: <a href=\"./install-node.md\">Node安装保姆级教程</a></p>\n<p>安装之后，打开命令行窗口，输入 <code>node -v</code> 验证，如果出现对应版本号，则说明安装成功了。</p>\n</li>\n<li><h3 id=\"step2-安装Hexo脚手架\"><a href=\"#step2-安装Hexo脚手架\" class=\"headerlink\" title=\"step2: 安装Hexo脚手架\"></a>step2: 安装Hexo脚手架</h3></li>\n</ul>\n<p>全局安装 <strong>Hexo CLI</strong>, 一行命令行就够了。</p>\n<figure class=\"highlight avrasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs avrasm\">npm install hexo-<span class=\"hljs-keyword\">cli</span> -g <br></code></pre></td></tr></table></figure>\n<p><img src=\"/../imgs/build-blog3/step2.png\" alt=\"step2\"></p>\n<ul>\n<li><h3 id=\"step3-搭建博客\"><a href=\"#step3-搭建博客\" class=\"headerlink\" title=\"step3: 搭建博客\"></a>step3: 搭建博客</h3></li>\n</ul>\n<p>使用hexo脚手架，完成博客搭建操作</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">hexo init <span class=\"hljs-keyword\">my</span>-blog           <span class=\"hljs-comment\"># 初始化博客目录</span><br>cd <span class=\"hljs-keyword\">my</span>-blog &amp;&amp; npm install   <span class=\"hljs-comment\"># 安装依赖</span><br>npm <span class=\"hljs-built_in\">run</span> server              <span class=\"hljs-comment\"># 启动本地预览（http://localhost:4000）</span><br></code></pre></td></tr></table></figure>\n<p>执行完上述操作之后，在浏览器中输入地址<code>http://localhost:4000</code>, 你将看到整个博客的样子，其中包含一篇默认的 <code>Hello world</code>博文。</p>\n<p><img src=\"/../imgs/build-blog3/landscape.png\" alt=\"landscape\"></p>\n<p>如果你想要添加新的博客，执行 <code>hexo new post 文章标题</code>即可在 <code>source/_post</code>目录下生成一个新的 <code>.md</code>文件。如果不熟悉Markdown语法，可以查阅相关资料学习，上手其实挺快的。</p>\n<h3 id=\"step4-部署到Github-Page\"><a href=\"#step4-部署到Github-Page\" class=\"headerlink\" title=\"step4: 部署到Github Page\"></a>step4: 部署到Github Page</h3><p>执行命令下方命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">hexo generate<br></code></pre></td></tr></table></figure>\n\n<p>hexo将会把所有相关资源文件进行转换，最后所有的资源都都存放在 <code>public</code>目录下。将所有文件上传到上一篇文中提到的个人仓库或者使用git命令提交，等待一两分钟，访问自己的博客站点地址，你将看内容已经更新。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>Hexo 博客的默认主题是 <code>landscape</code>, 你也可以尝试着使用其它博客主题，如 <code>Next</code>, <code>Fluid</code>等。</p>\n<p>如果你想对博客站点做些修改，可以通过编辑其根目录下配置文件 <code>_config.yml</code> 来进行调整。如果在主题样式上需要做修改，也可以编辑其对应的配置文件，对应的配置文件在 <code>/themes/主题名称/</code>中。</p>\n<p>关于Hexo更多的配置可查阅其官方文档，里面都有十分详细的介绍。如果个人动手能力比较强，也可以尝试着写一些主题或者插件，那将是一件让你感到成就感满满的事情。</p>\n","excerpt":"","more":"<p>通过上一篇文章–<a href=\"./build-personal-blog2.md\">动手搭建自己的第一个博客站点</a>的介绍，相信你已经成功搭建起了自己的第一个博客网站。如果你的动手能力比较强的话，或许还给博客页面做了页面美工，添加了导航等功能。</p>\n<p>如果你的博客还停留在手写html的阶段，也没有关系，通过这篇文章，让你在10分钟内学会如何使用工具生成漂亮好看的博客页面。</p>\n<h2 id=\"什么是-SSG\"><a href=\"#什么是-SSG\" class=\"headerlink\" title=\"什么是 SSG\"></a>什么是 SSG</h2><p>人类与其他动物的一个显著区别在于，人类擅长制造并使用工具，撰写博客亦是如此。如今，搭建站点撰写博客早已告别了需要手动逐行编写 HTML 代码的 “刀耕火种” 时代，众多优秀工具可供选择，助力我们快速实现更出色的博客呈现效果。</p>\n<p>我们知道，一篇博客内容通常都是以HTML的形式存储的，但对于写博客的人来说，其更想要关注的是其内容本身，而不是各种HTML标签的排列组合和样式调整。</p>\n<p><img src=\"/../imgs/build-blog3/md2html.png\" alt=\"markdown-to-html\"></p>\n<p>那么是否有一种工具，可以让撰写博客的人从书写HTML和各种样式调整中解脱出来，可以直接将纯文本内容转换成带漂亮样式的HTML文件呢？</p>\n<p>有的，那就是静态站点生成器（Static Site Generator)。它是一种自动化工具，它通过模板和数据源（如 Markdown 文件、CMS 内容或 API 数据）生成完整的 HTML、CSS 和 JavaScript 文件。与传统动态网站不同，SSG 生成的页面在构建时就已完全渲染，无需在用户访问时依赖数据库或服务器端处理。</p>\n<h2 id=\"一些常见的SSG工具\"><a href=\"#一些常见的SSG工具\" class=\"headerlink\" title=\"一些常见的SSG工具\"></a>一些常见的SSG工具</h2><p>下面是一些常见的SSG工具，其中包含一些大家都比较熟悉的，比如Next, Hugo, Jekyll还有Hexo之类的。</p>\n<p><img src=\"/../imgs/build-blog3/site-generator.png\" alt=\"site-generator\"><br><img src=\"/../imgs/build-blog3/site-generator2.png\" alt=\"site-generator\"></p>\n<p><code>Next.js</code>有完整的React生态支持，内置CSS模块化、图像优化和自动代码风格功能, 适合构建复杂交互应用。</p>\n<p><code>Hugo</code> 是一块由Go语言开发的超高速静态站点生成器，最大的特点就是，快！</p>\n<p><code>Jekyll</code> 算是一款老牌的静态站点生成器了，Github Pages原生就支持，非常适合搞小型项目展示页和个人博客。</p>\n<p><code>Hexo</code> 是一款Node.js生态的轻量博客框架，Markdown只有友好，非常适合中文写作。</p>\n<p>工具那么多，我独爱Hexo! </p>\n<h2 id=\"Why-Hexo\"><a href=\"#Why-Hexo\" class=\"headerlink\" title=\"Why Hexo?\"></a>Why Hexo?</h2><p>在众多的SSG工具中，为什么为独独选择Hexo呢？ 除了是个人接触比较早之外，还有一些其它的深层次的原因。</p>\n<p><img src=\"/../imgs/build-blog3/hexo.png\" alt=\"hexo\"></p>\n<p><strong>极低的入门门槛</strong>，只需安装 Node 环境后，通过几条命令即可初始化站点，无需复杂配置。而且中文教程十分丰富，即使是新手，也能在10分钟之内搭建出一个基础博客。</p>\n<p><strong>中文生态友好</strong>，配置文件、错误提示等均为中文，对国内开发者更友好; 社区活跃，中文主题和插件资源丰富。</p>\n<p><strong>灵活扩展，功能丰富</strong>，插件系统完善，通过 npm 安装插件即可扩展功能；主题基于 EJS&#x2F;Pug&#x2F;Markdown 模板，支持自定义布局、样式和脚本。</p>\n<p>如果你恰好也是一名前端开发工程师，日常开发中必然常常与Node打交道，那么对于自己写Hexo插件和主题是很有优势的，Hexo对于你来说是个很不错的选择。</p>\n<h2 id=\"实战操作\"><a href=\"#实战操作\" class=\"headerlink\" title=\"实战操作\"></a>实战操作</h2><p>前面就说了，即使是新手，也能够在10分钟之内搭建出一个基础博客。如果你正在尝试着跟着步骤做，不妨计时验证一下。</p>\n<p>多的话不说了，撸起袖子，开干！</p>\n<ul>\n<li><h3 id=\"step1-准备Node环境\"><a href=\"#step1-准备Node环境\" class=\"headerlink\" title=\"step1: 准备Node环境\"></a>step1: 准备Node环境</h3><p>如果之前接触过Node或者已经安装过Node, 可以直接跳过该步骤，直接进入到step2。如果是Node新手，可以按照下面步骤来安装Node。</p>\n<ul>\n<li><p><strong>方法1：安装包安装</strong></p>\n<p>a）前往<a href=\"https://nodejs.org/zh-cn/download\">Node官网</a>下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node安装包”获取。<br><br>b) 双击安装包，开始安装, 傻瓜式的点击Next.</p>\n</li>\n<li><p><strong>方法2：可移动二进制文件安装</strong></p>\n<p>  a）前往<a href=\"https://nodejs.org/zh-cn/download\">Node官网</a>下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node独立文件包”获取。<br><br>  b) 将包解压任意目录, 然后将其中的<code>bin</code>目录路径配置到环境变量 <code>path</code>中</p>\n</li>\n</ul>\n<p>如安装过程过程中有疑问，可参考详细教程: <a href=\"./install-node.md\">Node安装保姆级教程</a></p>\n<p>安装之后，打开命令行窗口，输入 <code>node -v</code> 验证，如果出现对应版本号，则说明安装成功了。</p>\n</li>\n<li><h3 id=\"step2-安装Hexo脚手架\"><a href=\"#step2-安装Hexo脚手架\" class=\"headerlink\" title=\"step2: 安装Hexo脚手架\"></a>step2: 安装Hexo脚手架</h3></li>\n</ul>\n<p>全局安装 <strong>Hexo CLI</strong>, 一行命令行就够了。</p>\n<figure class=\"highlight avrasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs avrasm\">npm install hexo-<span class=\"hljs-keyword\">cli</span> -g <br></code></pre></td></tr></table></figure>\n<p><img src=\"/../imgs/build-blog3/step2.png\" alt=\"step2\"></p>\n<ul>\n<li><h3 id=\"step3-搭建博客\"><a href=\"#step3-搭建博客\" class=\"headerlink\" title=\"step3: 搭建博客\"></a>step3: 搭建博客</h3></li>\n</ul>\n<p>使用hexo脚手架，完成博客搭建操作</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">hexo init <span class=\"hljs-keyword\">my</span>-blog           <span class=\"hljs-comment\"># 初始化博客目录</span><br>cd <span class=\"hljs-keyword\">my</span>-blog &amp;&amp; npm install   <span class=\"hljs-comment\"># 安装依赖</span><br>npm <span class=\"hljs-built_in\">run</span> server              <span class=\"hljs-comment\"># 启动本地预览（http://localhost:4000）</span><br></code></pre></td></tr></table></figure>\n<p>执行完上述操作之后，在浏览器中输入地址<code>http://localhost:4000</code>, 你将看到整个博客的样子，其中包含一篇默认的 <code>Hello world</code>博文。</p>\n<p><img src=\"/../imgs/build-blog3/landscape.png\" alt=\"landscape\"></p>\n<p>如果你想要添加新的博客，执行 <code>hexo new post 文章标题</code>即可在 <code>source/_post</code>目录下生成一个新的 <code>.md</code>文件。如果不熟悉Markdown语法，可以查阅相关资料学习，上手其实挺快的。</p>\n<h3 id=\"step4-部署到Github-Page\"><a href=\"#step4-部署到Github-Page\" class=\"headerlink\" title=\"step4: 部署到Github Page\"></a>step4: 部署到Github Page</h3><p>执行命令下方命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">hexo generate<br></code></pre></td></tr></table></figure>\n\n<p>hexo将会把所有相关资源文件进行转换，最后所有的资源都都存放在 <code>public</code>目录下。将所有文件上传到上一篇文中提到的个人仓库或者使用git命令提交，等待一两分钟，访问自己的博客站点地址，你将看内容已经更新。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>Hexo 博客的默认主题是 <code>landscape</code>, 你也可以尝试着使用其它博客主题，如 <code>Next</code>, <code>Fluid</code>等。</p>\n<p>如果你想对博客站点做些修改，可以通过编辑其根目录下配置文件 <code>_config.yml</code> 来进行调整。如果在主题样式上需要做修改，也可以编辑其对应的配置文件，对应的配置文件在 <code>/themes/主题名称/</code>中。</p>\n<p>关于Hexo更多的配置可查阅其官方文档，里面都有十分详细的介绍。如果个人动手能力比较强，也可以尝试着写一些主题或者插件，那将是一件让你感到成就感满满的事情。</p>\n"},{"title":"Node安装保姆级教程","date":"2025-06-08T10:08:43.000Z","keywords":["Node安装，如何安装Node","Windows上安装Node"],"banner_img":"/imgs/baners/node.png","index_img":"/imgs/baners/node.png","_content":"\n## 方法1：安装包安装\n\n- **step1**: 前往[Node官网](https://nodejs.org/zh-cn/download)下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node安装包”获取。\n![Node安装](../imgs/build-blog3/NodeSite.png)\n\n- **step2** 双击安装包，开始安装, 傻瓜式的点击 `Next`.\n![Node安装](../imgs/build-blog3/Node1.png)\n\n  点击 `next`\n  ![Node安装](../imgs/build-blog3/Node2.png)\n\n  如果你不想Node默认安装在C盘目录下，可以在这一步修改安装盘\n![Node安装](../imgs/build-blog3/Node3.png)\n\n  点击 `next`\n![Node安装](../imgs/build-blog3/Node4.png)\n\n  点击 `Install`\n![Node安装](../imgs/build-blog3/Node5.png)\n\n## 方法2：可移动二进制文件安装\n\n- **step1**: 前往[Node官网](https://nodejs.org/zh-cn/download)下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node独立文件包”获取。<br>\n- **step2**: 将包解压任意目录，如我的是 在`D:\\software_install\\develop`下\n![Node安装](../imgs/build-blog3/Node-folder.png)\n- **step3**: 将Node目录下的 `bin`下的配置到window环境变量中\n  a) win+s，搜索 `环境变量`, 点击`编辑系统环境变量`\n\n  ![环境变量](../imgs/build-blog3/environment1.png)\n\n  b) 点击`环境变量`\n  ![环境变量](../imgs/build-blog3/environment2.png)\n  \n  c) 找到 `path`, 点击 `编辑`\n  ![环境变量](../imgs/build-blog3/environment3.png)\n\n  d) 点击 `浏览`\n  ![环境变量](../imgs/build-blog3/environment4.png)\n\n  e) 选择 step2 中解压的目录路径\n  ![环境变量](../imgs/build-blog3/environment5.png)\n\n  最后点击 `确定`关闭所有窗口，将环境变量保存应用。\n\n## 安装验证\n\n打开DOS窗口，输入 `node -v`, 查看是否输出对应的 Node 版本号，如果有，则说明安装成功。如果报错，则重新检查安装步骤是否出错，如果需要，重新安装。\n\n![环境变量](../imgs/build-blog3/success.png)\n","source":"_posts/install-node.md","raw":"---\ntitle: Node安装保姆级教程\ndate: 2025-06-08 18:08:43\ncategory: Web开发\ntags: [Node安装, npm]\nkeywords: [Node安装，如何安装Node, Windows上安装Node]\nbanner_img: /imgs/baners/node.png\nindex_img: /imgs/baners/node.png\n---\n\n## 方法1：安装包安装\n\n- **step1**: 前往[Node官网](https://nodejs.org/zh-cn/download)下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node安装包”获取。\n![Node安装](../imgs/build-blog3/NodeSite.png)\n\n- **step2** 双击安装包，开始安装, 傻瓜式的点击 `Next`.\n![Node安装](../imgs/build-blog3/Node1.png)\n\n  点击 `next`\n  ![Node安装](../imgs/build-blog3/Node2.png)\n\n  如果你不想Node默认安装在C盘目录下，可以在这一步修改安装盘\n![Node安装](../imgs/build-blog3/Node3.png)\n\n  点击 `next`\n![Node安装](../imgs/build-blog3/Node4.png)\n\n  点击 `Install`\n![Node安装](../imgs/build-blog3/Node5.png)\n\n## 方法2：可移动二进制文件安装\n\n- **step1**: 前往[Node官网](https://nodejs.org/zh-cn/download)下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node独立文件包”获取。<br>\n- **step2**: 将包解压任意目录，如我的是 在`D:\\software_install\\develop`下\n![Node安装](../imgs/build-blog3/Node-folder.png)\n- **step3**: 将Node目录下的 `bin`下的配置到window环境变量中\n  a) win+s，搜索 `环境变量`, 点击`编辑系统环境变量`\n\n  ![环境变量](../imgs/build-blog3/environment1.png)\n\n  b) 点击`环境变量`\n  ![环境变量](../imgs/build-blog3/environment2.png)\n  \n  c) 找到 `path`, 点击 `编辑`\n  ![环境变量](../imgs/build-blog3/environment3.png)\n\n  d) 点击 `浏览`\n  ![环境变量](../imgs/build-blog3/environment4.png)\n\n  e) 选择 step2 中解压的目录路径\n  ![环境变量](../imgs/build-blog3/environment5.png)\n\n  最后点击 `确定`关闭所有窗口，将环境变量保存应用。\n\n## 安装验证\n\n打开DOS窗口，输入 `node -v`, 查看是否输出对应的 Node 版本号，如果有，则说明安装成功。如果报错，则重新检查安装步骤是否出错，如果需要，重新安装。\n\n![环境变量](../imgs/build-blog3/success.png)\n","slug":"install-node","published":1,"updated":"2025-08-26T10:52:07.157Z","_id":"cmbni3a1f0003loup86tygfqi","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"方法1：安装包安装\"><a href=\"#方法1：安装包安装\" class=\"headerlink\" title=\"方法1：安装包安装\"></a>方法1：安装包安装</h2><ul>\n<li><p><strong>step1</strong>: 前往<a href=\"https://nodejs.org/zh-cn/download\">Node官网</a>下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node安装包”获取。<br><img src=\"/../imgs/build-blog3/NodeSite.png\" alt=\"Node安装\"></p>\n</li>\n<li><p><strong>step2</strong> 双击安装包，开始安装, 傻瓜式的点击 <code>Next</code>.<br><img src=\"/../imgs/build-blog3/Node1.png\" alt=\"Node安装\"></p>\n<p>点击 <code>next</code><br><img src=\"/../imgs/build-blog3/Node2.png\" alt=\"Node安装\"></p>\n<p>如果你不想Node默认安装在C盘目录下，可以在这一步修改安装盘</p>\n</li>\n</ul>\n<p><img src=\"/../imgs/build-blog3/Node3.png\" alt=\"Node安装\"></p>\n<p>  点击 <code>next</code><br><img src=\"/../imgs/build-blog3/Node4.png\" alt=\"Node安装\"></p>\n<p>  点击 <code>Install</code><br><img src=\"/../imgs/build-blog3/Node5.png\" alt=\"Node安装\"></p>\n<h2 id=\"方法2：可移动二进制文件安装\"><a href=\"#方法2：可移动二进制文件安装\" class=\"headerlink\" title=\"方法2：可移动二进制文件安装\"></a>方法2：可移动二进制文件安装</h2><ul>\n<li><p><strong>step1</strong>: 前往<a href=\"https://nodejs.org/zh-cn/download\">Node官网</a>下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node独立文件包”获取。<br></p>\n</li>\n<li><p><strong>step2</strong>: 将包解压任意目录，如我的是 在<code>D:\\software_install\\develop</code>下<br><img src=\"/../imgs/build-blog3/Node-folder.png\" alt=\"Node安装\"></p>\n</li>\n<li><p><strong>step3</strong>: 将Node目录下的 <code>bin</code>下的配置到window环境变量中<br>a) win+s，搜索 <code>环境变量</code>, 点击<code>编辑系统环境变量</code></p>\n<p><img src=\"/../imgs/build-blog3/environment1.png\" alt=\"环境变量\"></p>\n<p>b) 点击<code>环境变量</code><br><img src=\"/../imgs/build-blog3/environment2.png\" alt=\"环境变量\"></p>\n<p>c) 找到 <code>path</code>, 点击 <code>编辑</code><br><img src=\"/../imgs/build-blog3/environment3.png\" alt=\"环境变量\"></p>\n<p>d) 点击 <code>浏览</code><br><img src=\"/../imgs/build-blog3/environment4.png\" alt=\"环境变量\"></p>\n<p>e) 选择 step2 中解压的目录路径<br><img src=\"/../imgs/build-blog3/environment5.png\" alt=\"环境变量\"></p>\n<p>最后点击 <code>确定</code>关闭所有窗口，将环境变量保存应用。</p>\n</li>\n</ul>\n<h2 id=\"安装验证\"><a href=\"#安装验证\" class=\"headerlink\" title=\"安装验证\"></a>安装验证</h2><p>打开DOS窗口，输入 <code>node -v</code>, 查看是否输出对应的 Node 版本号，如果有，则说明安装成功。如果报错，则重新检查安装步骤是否出错，如果需要，重新安装。</p>\n<p><img src=\"/../imgs/build-blog3/success.png\" alt=\"环境变量\"></p>\n","excerpt":"","more":"<h2 id=\"方法1：安装包安装\"><a href=\"#方法1：安装包安装\" class=\"headerlink\" title=\"方法1：安装包安装\"></a>方法1：安装包安装</h2><ul>\n<li><p><strong>step1</strong>: 前往<a href=\"https://nodejs.org/zh-cn/download\">Node官网</a>下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node安装包”获取。<br><img src=\"/../imgs/build-blog3/NodeSite.png\" alt=\"Node安装\"></p>\n</li>\n<li><p><strong>step2</strong> 双击安装包，开始安装, 傻瓜式的点击 <code>Next</code>.<br><img src=\"/../imgs/build-blog3/Node1.png\" alt=\"Node安装\"></p>\n<p>点击 <code>next</code><br><img src=\"/../imgs/build-blog3/Node2.png\" alt=\"Node安装\"></p>\n<p>如果你不想Node默认安装在C盘目录下，可以在这一步修改安装盘</p>\n</li>\n</ul>\n<p><img src=\"/../imgs/build-blog3/Node3.png\" alt=\"Node安装\"></p>\n<p>  点击 <code>next</code><br><img src=\"/../imgs/build-blog3/Node4.png\" alt=\"Node安装\"></p>\n<p>  点击 <code>Install</code><br><img src=\"/../imgs/build-blog3/Node5.png\" alt=\"Node安装\"></p>\n<h2 id=\"方法2：可移动二进制文件安装\"><a href=\"#方法2：可移动二进制文件安装\" class=\"headerlink\" title=\"方法2：可移动二进制文件安装\"></a>方法2：可移动二进制文件安装</h2><ul>\n<li><p><strong>step1</strong>: 前往<a href=\"https://nodejs.org/zh-cn/download\">Node官网</a>下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node独立文件包”获取。<br></p>\n</li>\n<li><p><strong>step2</strong>: 将包解压任意目录，如我的是 在<code>D:\\software_install\\develop</code>下<br><img src=\"/../imgs/build-blog3/Node-folder.png\" alt=\"Node安装\"></p>\n</li>\n<li><p><strong>step3</strong>: 将Node目录下的 <code>bin</code>下的配置到window环境变量中<br>a) win+s，搜索 <code>环境变量</code>, 点击<code>编辑系统环境变量</code></p>\n<p><img src=\"/../imgs/build-blog3/environment1.png\" alt=\"环境变量\"></p>\n<p>b) 点击<code>环境变量</code><br><img src=\"/../imgs/build-blog3/environment2.png\" alt=\"环境变量\"></p>\n<p>c) 找到 <code>path</code>, 点击 <code>编辑</code><br><img src=\"/../imgs/build-blog3/environment3.png\" alt=\"环境变量\"></p>\n<p>d) 点击 <code>浏览</code><br><img src=\"/../imgs/build-blog3/environment4.png\" alt=\"环境变量\"></p>\n<p>e) 选择 step2 中解压的目录路径<br><img src=\"/../imgs/build-blog3/environment5.png\" alt=\"环境变量\"></p>\n<p>最后点击 <code>确定</code>关闭所有窗口，将环境变量保存应用。</p>\n</li>\n</ul>\n<h2 id=\"安装验证\"><a href=\"#安装验证\" class=\"headerlink\" title=\"安装验证\"></a>安装验证</h2><p>打开DOS窗口，输入 <code>node -v</code>, 查看是否输出对应的 Node 版本号，如果有，则说明安装成功。如果报错，则重新检查安装步骤是否出错，如果需要，重新安装。</p>\n<p><img src=\"/../imgs/build-blog3/success.png\" alt=\"环境变量\"></p>\n"},{"title":"搭建个人博客系列--(4) 利用Github Actions自动构建博客","date":"2025-06-14T07:37:45.000Z","keywords":["Github Actions","博客搭建","免费博客平台","托管博客","模板建站"],"index_img":"imgs/build-blog1/blog4.jpg","banner_img":"imgs/build-blog1/blog4.jpg","_content":"\n经过前面的系列文章的学习和实践，相信你已经成功的利用Hexo构建自己的博客并且部署到了Github上。\n\n目前整个发布博客的流程是，用markdown文件写好博客，然后使用Hexo编译成html, 最后将public下的内容部署到github上。整个过程虽然不复杂，但每次都要重新在本地编译然后上传，多少有些繁琐。\n\n这个时候我们可以寻求一种方法，实现博客自动编译和内容的部署，它就是 **Github Actions**。\n\n## 什么是Github Actions?\n\nGitHub Actions 是 GitHub 提供的 持续集成与持续部署（CI/CD）平台，允许开发者直接在 GitHub 仓库中自动化构建、测试、打包、发布代码，实现软件开发流程的自动化。通过定义 YAML 格式的配置文件（称为 Workflow），开发者可以定制化代码仓库的自动化工作流程，例如代码提交时自动运行测试、合并分支时自动部署到服务器等。\n\n## 核心概念\n\n### Workflow（工作流）\n- 一个 Workflow 是一个自动化流程，由一个或多个 Job 组成，通过 YAML 文件（.github/workflows/ 目录下）定义。\n\n- 可以配置 Workflow 在特定事件（如代码推送、Pull Request 创建、Issue 评论等）触发，或按计划定期运行。\n\n### Job（任务）\n\n- 一个 Job 是 Workflow 中的独立任务，包含一系列 Step，默认在一个虚拟机（Runner）上运行。\n- Jobs 可以并行或按顺序执行，支持定义依赖关系（如 Job B 等待 Job A 完成）。\n\n### Step（步骤）\n\n- Step 是 Job 中的最小执行单元，可以是运行 Shell 命令（如 npm install）或调用 Action（预定义的功能模块）。\n\n- 例如：拉取代码、安装依赖、运行测试、部署到服务器等。\n\n### Action（动作）\n\n- 可复用的代码模块，用于完成特定功能（如检出代码、设置环境、发送通知等）。\n\n- GitHub Marketplace 提供大量公开 Actions（如 actions/checkout、actions/setup-node），开发者也可自定义 Actions。\n\n## 举个例子\n\n以下是一个简单的 Workflow 配置（.github/workflows/node.js.yml），用于在 Node.js 项目中执行测试：\n\n```\nname: Node.js CI\non: [push] # 当代码推送时触发\n\njobs:\n  build:\n    runs-on: ubuntu-latest # 使用 Ubuntu 最新版虚拟机\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4 # 拉取代码到 Runner\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: 20 # 指定 Node.js 版本\n\n      - name: Install dependencies\n        run: npm install # 运行 Shell 命令安装依赖\n\n      - name: Run tests\n        run: npm test # 运行测试脚本\n```\n\n## 编写自动编译并部署博客脚本\n\n如果需要实现博客的自动化部署，那么有两个步骤要走，一是在push新内容的时候编译，二是编译之后部署到Github pages上。\n\n### 编译博客\n\n在之前的内容中，我们知道编译markdown文件成html文件使用的命令是 `hexo build`, 后来我们又将其写入到 `package.json`里的`scripts`中并取名为 `build`, 那么在执行编译的时候可以使用 `npm run build`来替代之前的命令。\n\n下面我们开始来写自动化脚本，首先在根目录下新建一个`./github/workflows/update-blogs.yml`文件，整体框架可以参考上面例子，因为使用的都是 Node 环境。\n\n完成一个build操作，要执行的操作分4步骤\n - 拉取代码\n - 配置Node环境\n - 安装依赖\n - 执行编译操作\n - 上传编译内容\n```\nname: automaticly update blogs\non: \n branches:\n  - master # master分支\njobs:\n  build:\n    runs-on: ubuntu-latest # 使用 Ubuntu 最新版虚拟机\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4 # 拉取代码到 Runner\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: 20 # 指定 Node.js 版本\n\n      - name: Install dependencies\n        run: |\n          npm install\n          npm install -g hexo-cli\n\n      - name: Run build\n        run: npm run build # 运行编译操作\n      \n      - name: Upload Pages artifact\n        uses: actions/upload-pages-artifact@v3 # 上传public目录内容\n        with:\n          path: ./public\n\n```\n\n修改点：\n\n- 不想任意分支提交都执行该操作，所以选择  `master` 分支有提交的时候执行。\n\n- 安装依赖依赖，需要在全局安装 `hexo-cli`\n\n- 上传内容使用的是Github Actions 官方的一个专用 Action: actions/upload-pages-aartifact, 主要用于 将静态网站文件打包并上传为 GitHub Pages 部署所需的 “工件”。\n\n\n### 部署博客\n\n在成功编译博客之后，也是通过一个官方的Action来实现博客内容的部署\n\n```\nname: automaticly update blogs\non: \n branches:\n  - master # master分支\njobs:\n  build:\n    ...\n\n  # 部署博客  \n  deploy:\n    needs: build   # 依赖上一个build操作\n    permissions:   # # 需授予 Pages 写入权限和生成部署令牌的权限\n      pages: write\n      id-token: write\n    environment:\n      name: github-pages\n      url: ${{ steps.deployment.outputs.page_url }}\n    runs-on: ubuntu-latest\n    steps:         # 使用actions 部署\n      - name: Deploy to GitHub Pages\n        id: deployment\n        uses: actions/deploy-pages@v4\n\n```\n\n## 测试验证\n\n编写完脚本之后，提交代码至 `master` 分支，在Github对应的仓库分支上可以看见已经有对应的workflow，如作者的脚本配置。\n\n![actions](https://www.jvxiao.cn/imgs/build-blog4/actions.png)\n\n如果左侧出现刚才脚本的名称 `automaticly update blogs`, 则说明已经配置成功了，可以通过提交内容到 master分支来检验脚本的执行情况。\n\n\n## 写在最后\n\n到目前为止，整个搭建个人博客系列文章已经实现了个人博客站点的搭建和自动化部署，相信此时的你也搭建好了自己的博客站点。\n\n正如之前所说，博客站点最重要的就是价值输出，也就是要勤写内容。但是有时候，酒香也怕巷子深，如何让更多的人看到自己写的文章，增加个人影响力，这将是后面将要讨论的问题，请持续关注！","source":"_posts/build-personal-blog4.md","raw":"---\ntitle: 搭建个人博客系列--(4) 利用Github Actions自动构建博客\ndate: 2025-06-14 15:37:45\ncategory: 搭建博客\ntags: \n   - 博客搭建\n   - 个人IP\nkeywords: [Github Actions, 博客搭建, 免费博客平台, 托管博客, 模板建站]\nindex_img: imgs/build-blog1/blog4.jpg\nbanner_img: imgs/build-blog1/blog4.jpg\n---\n\n经过前面的系列文章的学习和实践，相信你已经成功的利用Hexo构建自己的博客并且部署到了Github上。\n\n目前整个发布博客的流程是，用markdown文件写好博客，然后使用Hexo编译成html, 最后将public下的内容部署到github上。整个过程虽然不复杂，但每次都要重新在本地编译然后上传，多少有些繁琐。\n\n这个时候我们可以寻求一种方法，实现博客自动编译和内容的部署，它就是 **Github Actions**。\n\n## 什么是Github Actions?\n\nGitHub Actions 是 GitHub 提供的 持续集成与持续部署（CI/CD）平台，允许开发者直接在 GitHub 仓库中自动化构建、测试、打包、发布代码，实现软件开发流程的自动化。通过定义 YAML 格式的配置文件（称为 Workflow），开发者可以定制化代码仓库的自动化工作流程，例如代码提交时自动运行测试、合并分支时自动部署到服务器等。\n\n## 核心概念\n\n### Workflow（工作流）\n- 一个 Workflow 是一个自动化流程，由一个或多个 Job 组成，通过 YAML 文件（.github/workflows/ 目录下）定义。\n\n- 可以配置 Workflow 在特定事件（如代码推送、Pull Request 创建、Issue 评论等）触发，或按计划定期运行。\n\n### Job（任务）\n\n- 一个 Job 是 Workflow 中的独立任务，包含一系列 Step，默认在一个虚拟机（Runner）上运行。\n- Jobs 可以并行或按顺序执行，支持定义依赖关系（如 Job B 等待 Job A 完成）。\n\n### Step（步骤）\n\n- Step 是 Job 中的最小执行单元，可以是运行 Shell 命令（如 npm install）或调用 Action（预定义的功能模块）。\n\n- 例如：拉取代码、安装依赖、运行测试、部署到服务器等。\n\n### Action（动作）\n\n- 可复用的代码模块，用于完成特定功能（如检出代码、设置环境、发送通知等）。\n\n- GitHub Marketplace 提供大量公开 Actions（如 actions/checkout、actions/setup-node），开发者也可自定义 Actions。\n\n## 举个例子\n\n以下是一个简单的 Workflow 配置（.github/workflows/node.js.yml），用于在 Node.js 项目中执行测试：\n\n```\nname: Node.js CI\non: [push] # 当代码推送时触发\n\njobs:\n  build:\n    runs-on: ubuntu-latest # 使用 Ubuntu 最新版虚拟机\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4 # 拉取代码到 Runner\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: 20 # 指定 Node.js 版本\n\n      - name: Install dependencies\n        run: npm install # 运行 Shell 命令安装依赖\n\n      - name: Run tests\n        run: npm test # 运行测试脚本\n```\n\n## 编写自动编译并部署博客脚本\n\n如果需要实现博客的自动化部署，那么有两个步骤要走，一是在push新内容的时候编译，二是编译之后部署到Github pages上。\n\n### 编译博客\n\n在之前的内容中，我们知道编译markdown文件成html文件使用的命令是 `hexo build`, 后来我们又将其写入到 `package.json`里的`scripts`中并取名为 `build`, 那么在执行编译的时候可以使用 `npm run build`来替代之前的命令。\n\n下面我们开始来写自动化脚本，首先在根目录下新建一个`./github/workflows/update-blogs.yml`文件，整体框架可以参考上面例子，因为使用的都是 Node 环境。\n\n完成一个build操作，要执行的操作分4步骤\n - 拉取代码\n - 配置Node环境\n - 安装依赖\n - 执行编译操作\n - 上传编译内容\n```\nname: automaticly update blogs\non: \n branches:\n  - master # master分支\njobs:\n  build:\n    runs-on: ubuntu-latest # 使用 Ubuntu 最新版虚拟机\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4 # 拉取代码到 Runner\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: 20 # 指定 Node.js 版本\n\n      - name: Install dependencies\n        run: |\n          npm install\n          npm install -g hexo-cli\n\n      - name: Run build\n        run: npm run build # 运行编译操作\n      \n      - name: Upload Pages artifact\n        uses: actions/upload-pages-artifact@v3 # 上传public目录内容\n        with:\n          path: ./public\n\n```\n\n修改点：\n\n- 不想任意分支提交都执行该操作，所以选择  `master` 分支有提交的时候执行。\n\n- 安装依赖依赖，需要在全局安装 `hexo-cli`\n\n- 上传内容使用的是Github Actions 官方的一个专用 Action: actions/upload-pages-aartifact, 主要用于 将静态网站文件打包并上传为 GitHub Pages 部署所需的 “工件”。\n\n\n### 部署博客\n\n在成功编译博客之后，也是通过一个官方的Action来实现博客内容的部署\n\n```\nname: automaticly update blogs\non: \n branches:\n  - master # master分支\njobs:\n  build:\n    ...\n\n  # 部署博客  \n  deploy:\n    needs: build   # 依赖上一个build操作\n    permissions:   # # 需授予 Pages 写入权限和生成部署令牌的权限\n      pages: write\n      id-token: write\n    environment:\n      name: github-pages\n      url: ${{ steps.deployment.outputs.page_url }}\n    runs-on: ubuntu-latest\n    steps:         # 使用actions 部署\n      - name: Deploy to GitHub Pages\n        id: deployment\n        uses: actions/deploy-pages@v4\n\n```\n\n## 测试验证\n\n编写完脚本之后，提交代码至 `master` 分支，在Github对应的仓库分支上可以看见已经有对应的workflow，如作者的脚本配置。\n\n![actions](https://www.jvxiao.cn/imgs/build-blog4/actions.png)\n\n如果左侧出现刚才脚本的名称 `automaticly update blogs`, 则说明已经配置成功了，可以通过提交内容到 master分支来检验脚本的执行情况。\n\n\n## 写在最后\n\n到目前为止，整个搭建个人博客系列文章已经实现了个人博客站点的搭建和自动化部署，相信此时的你也搭建好了自己的博客站点。\n\n正如之前所说，博客站点最重要的就是价值输出，也就是要勤写内容。但是有时候，酒香也怕巷子深，如何让更多的人看到自己写的文章，增加个人影响力，这将是后面将要讨论的问题，请持续关注！","slug":"build-personal-blog4","published":1,"updated":"2025-08-26T10:17:52.503Z","_id":"cmc0k7zum0000iwupcmfjci7e","comments":1,"layout":"post","photos":[],"content":"<p>经过前面的系列文章的学习和实践，相信你已经成功的利用Hexo构建自己的博客并且部署到了Github上。</p>\n<p>目前整个发布博客的流程是，用markdown文件写好博客，然后使用Hexo编译成html, 最后将public下的内容部署到github上。整个过程虽然不复杂，但每次都要重新在本地编译然后上传，多少有些繁琐。</p>\n<p>这个时候我们可以寻求一种方法，实现博客自动编译和内容的部署，它就是 <strong>Github Actions</strong>。</p>\n<h2 id=\"什么是Github-Actions\"><a href=\"#什么是Github-Actions\" class=\"headerlink\" title=\"什么是Github Actions?\"></a>什么是Github Actions?</h2><p>GitHub Actions 是 GitHub 提供的 持续集成与持续部署（CI&#x2F;CD）平台，允许开发者直接在 GitHub 仓库中自动化构建、测试、打包、发布代码，实现软件开发流程的自动化。通过定义 YAML 格式的配置文件（称为 Workflow），开发者可以定制化代码仓库的自动化工作流程，例如代码提交时自动运行测试、合并分支时自动部署到服务器等。</p>\n<h2 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h2><h3 id=\"Workflow（工作流）\"><a href=\"#Workflow（工作流）\" class=\"headerlink\" title=\"Workflow（工作流）\"></a>Workflow（工作流）</h3><ul>\n<li><p>一个 Workflow 是一个自动化流程，由一个或多个 Job 组成，通过 YAML 文件（.github&#x2F;workflows&#x2F; 目录下）定义。</p>\n</li>\n<li><p>可以配置 Workflow 在特定事件（如代码推送、Pull Request 创建、Issue 评论等）触发，或按计划定期运行。</p>\n</li>\n</ul>\n<h3 id=\"Job（任务）\"><a href=\"#Job（任务）\" class=\"headerlink\" title=\"Job（任务）\"></a>Job（任务）</h3><ul>\n<li>一个 Job 是 Workflow 中的独立任务，包含一系列 Step，默认在一个虚拟机（Runner）上运行。</li>\n<li>Jobs 可以并行或按顺序执行，支持定义依赖关系（如 Job B 等待 Job A 完成）。</li>\n</ul>\n<h3 id=\"Step（步骤）\"><a href=\"#Step（步骤）\" class=\"headerlink\" title=\"Step（步骤）\"></a>Step（步骤）</h3><ul>\n<li><p>Step 是 Job 中的最小执行单元，可以是运行 Shell 命令（如 npm install）或调用 Action（预定义的功能模块）。</p>\n</li>\n<li><p>例如：拉取代码、安装依赖、运行测试、部署到服务器等。</p>\n</li>\n</ul>\n<h3 id=\"Action（动作）\"><a href=\"#Action（动作）\" class=\"headerlink\" title=\"Action（动作）\"></a>Action（动作）</h3><ul>\n<li><p>可复用的代码模块，用于完成特定功能（如检出代码、设置环境、发送通知等）。</p>\n</li>\n<li><p>GitHub Marketplace 提供大量公开 Actions（如 actions&#x2F;checkout、actions&#x2F;setup-node），开发者也可自定义 Actions。</p>\n</li>\n</ul>\n<h2 id=\"举个例子\"><a href=\"#举个例子\" class=\"headerlink\" title=\"举个例子\"></a>举个例子</h2><p>以下是一个简单的 Workflow 配置（.github&#x2F;workflows&#x2F;node.js.yml），用于在 Node.js 项目中执行测试：</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nix\"><span class=\"hljs-params\">name:</span> Node.js CI<br><span class=\"hljs-params\">on:</span> [push] <span class=\"hljs-comment\"># 当代码推送时触发</span><br><br><span class=\"hljs-params\">jobs:</span><br>  <span class=\"hljs-params\">build:</span><br>    <span class=\"hljs-params\">runs-on:</span> ubuntu-latest <span class=\"hljs-comment\"># 使用 Ubuntu 最新版虚拟机</span><br>    <span class=\"hljs-params\">steps:</span><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Checkout code<br>        <span class=\"hljs-params\">uses:</span> actions<span class=\"hljs-operator\">/</span>checkout@v4 <span class=\"hljs-comment\"># 拉取代码到 Runner</span><br><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Set up Node.js<br>        <span class=\"hljs-params\">uses:</span> actions<span class=\"hljs-operator\">/</span>setup-node@v4<br>        <span class=\"hljs-params\">with:</span><br>          <span class=\"hljs-params\">node-version:</span> <span class=\"hljs-number\">20</span> <span class=\"hljs-comment\"># 指定 Node.js 版本</span><br><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Install dependencies<br>        <span class=\"hljs-params\">run:</span> npm install <span class=\"hljs-comment\"># 运行 Shell 命令安装依赖</span><br><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Run tests<br>        <span class=\"hljs-params\">run:</span> npm test <span class=\"hljs-comment\"># 运行测试脚本</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"编写自动编译并部署博客脚本\"><a href=\"#编写自动编译并部署博客脚本\" class=\"headerlink\" title=\"编写自动编译并部署博客脚本\"></a>编写自动编译并部署博客脚本</h2><p>如果需要实现博客的自动化部署，那么有两个步骤要走，一是在push新内容的时候编译，二是编译之后部署到Github pages上。</p>\n<h3 id=\"编译博客\"><a href=\"#编译博客\" class=\"headerlink\" title=\"编译博客\"></a>编译博客</h3><p>在之前的内容中，我们知道编译markdown文件成html文件使用的命令是 <code>hexo build</code>, 后来我们又将其写入到 <code>package.json</code>里的<code>scripts</code>中并取名为 <code>build</code>, 那么在执行编译的时候可以使用 <code>npm run build</code>来替代之前的命令。</p>\n<p>下面我们开始来写自动化脚本，首先在根目录下新建一个<code>./github/workflows/update-blogs.yml</code>文件，整体框架可以参考上面例子，因为使用的都是 Node 环境。</p>\n<p>完成一个build操作，要执行的操作分4步骤</p>\n<ul>\n<li>拉取代码</li>\n<li>配置Node环境</li>\n<li>安装依赖</li>\n<li>执行编译操作</li>\n<li>上传编译内容<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nix\"><span class=\"hljs-params\">name:</span> automaticly update blogs<br><span class=\"hljs-params\">on:</span> <br> <span class=\"hljs-params\">branches:</span><br>  <span class=\"hljs-operator\">-</span> master <span class=\"hljs-comment\"># master分支</span><br><span class=\"hljs-params\">jobs:</span><br>  <span class=\"hljs-params\">build:</span><br>    <span class=\"hljs-params\">runs-on:</span> ubuntu-latest <span class=\"hljs-comment\"># 使用 Ubuntu 最新版虚拟机</span><br>    <span class=\"hljs-params\">steps:</span><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Checkout code<br>        <span class=\"hljs-params\">uses:</span> actions<span class=\"hljs-operator\">/</span>checkout@v4 <span class=\"hljs-comment\"># 拉取代码到 Runner</span><br><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Set up Node.js<br>        <span class=\"hljs-params\">uses:</span> actions<span class=\"hljs-operator\">/</span>setup-node@v4<br>        <span class=\"hljs-params\">with:</span><br>          <span class=\"hljs-params\">node-version:</span> <span class=\"hljs-number\">20</span> <span class=\"hljs-comment\"># 指定 Node.js 版本</span><br><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Install dependencies<br>        <span class=\"hljs-params\">run:</span> |<br>          npm install<br>          npm install <span class=\"hljs-operator\">-</span>g hexo-cli<br><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Run build<br>        <span class=\"hljs-params\">run:</span> npm run build <span class=\"hljs-comment\"># 运行编译操作</span><br>      <br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Upload Pages artifact<br>        <span class=\"hljs-params\">uses:</span> actions<span class=\"hljs-operator\">/</span>upload-pages-artifact@v3 <span class=\"hljs-comment\"># 上传public目录内容</span><br>        <span class=\"hljs-params\">with:</span><br>          <span class=\"hljs-params\">path:</span> <span class=\"hljs-symbol\">./public</span><br><br></code></pre></td></tr></table></figure></li>\n</ul>\n<p>修改点：</p>\n<ul>\n<li><p>不想任意分支提交都执行该操作，所以选择  <code>master</code> 分支有提交的时候执行。</p>\n</li>\n<li><p>安装依赖依赖，需要在全局安装 <code>hexo-cli</code></p>\n</li>\n<li><p>上传内容使用的是Github Actions 官方的一个专用 Action: actions&#x2F;upload-pages-aartifact, 主要用于 将静态网站文件打包并上传为 GitHub Pages 部署所需的 “工件”。</p>\n</li>\n</ul>\n<h3 id=\"部署博客\"><a href=\"#部署博客\" class=\"headerlink\" title=\"部署博客\"></a>部署博客</h3><p>在成功编译博客之后，也是通过一个官方的Action来实现博客内容的部署</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nix\"><span class=\"hljs-params\">name:</span> automaticly update blogs<br><span class=\"hljs-params\">on:</span> <br> <span class=\"hljs-params\">branches:</span><br>  <span class=\"hljs-operator\">-</span> master <span class=\"hljs-comment\"># master分支</span><br><span class=\"hljs-params\">jobs:</span><br>  <span class=\"hljs-params\">build:</span><br>    ...<br><br>  <span class=\"hljs-comment\"># 部署博客  </span><br>  <span class=\"hljs-params\">deploy:</span><br>    <span class=\"hljs-params\">needs:</span> build   <span class=\"hljs-comment\"># 依赖上一个build操作</span><br>    <span class=\"hljs-params\">permissions:</span>   <span class=\"hljs-comment\"># # 需授予 Pages 写入权限和生成部署令牌的权限</span><br>      <span class=\"hljs-params\">pages:</span> write<br>      <span class=\"hljs-params\">id-token:</span> write<br>    <span class=\"hljs-params\">environment:</span><br>      <span class=\"hljs-params\">name:</span> github-pages<br>      <span class=\"hljs-params\">url:</span> $&#123;&#123; steps.deployment.outputs.page_url &#125;&#125;<br>    <span class=\"hljs-params\">runs-on:</span> ubuntu-latest<br>    <span class=\"hljs-params\">steps:</span>         <span class=\"hljs-comment\"># 使用actions 部署</span><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Deploy to GitHub Pages<br>        <span class=\"hljs-params\">id:</span> deployment<br>        <span class=\"hljs-params\">uses:</span> actions<span class=\"hljs-operator\">/</span>deploy-pages@v4<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"测试验证\"><a href=\"#测试验证\" class=\"headerlink\" title=\"测试验证\"></a>测试验证</h2><p>编写完脚本之后，提交代码至 <code>master</code> 分支，在Github对应的仓库分支上可以看见已经有对应的workflow，如作者的脚本配置。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/build-blog4/actions.png\" alt=\"actions\"></p>\n<p>如果左侧出现刚才脚本的名称 <code>automaticly update blogs</code>, 则说明已经配置成功了，可以通过提交内容到 master分支来检验脚本的执行情况。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>到目前为止，整个搭建个人博客系列文章已经实现了个人博客站点的搭建和自动化部署，相信此时的你也搭建好了自己的博客站点。</p>\n<p>正如之前所说，博客站点最重要的就是价值输出，也就是要勤写内容。但是有时候，酒香也怕巷子深，如何让更多的人看到自己写的文章，增加个人影响力，这将是后面将要讨论的问题，请持续关注！</p>\n","excerpt":"","more":"<p>经过前面的系列文章的学习和实践，相信你已经成功的利用Hexo构建自己的博客并且部署到了Github上。</p>\n<p>目前整个发布博客的流程是，用markdown文件写好博客，然后使用Hexo编译成html, 最后将public下的内容部署到github上。整个过程虽然不复杂，但每次都要重新在本地编译然后上传，多少有些繁琐。</p>\n<p>这个时候我们可以寻求一种方法，实现博客自动编译和内容的部署，它就是 <strong>Github Actions</strong>。</p>\n<h2 id=\"什么是Github-Actions\"><a href=\"#什么是Github-Actions\" class=\"headerlink\" title=\"什么是Github Actions?\"></a>什么是Github Actions?</h2><p>GitHub Actions 是 GitHub 提供的 持续集成与持续部署（CI&#x2F;CD）平台，允许开发者直接在 GitHub 仓库中自动化构建、测试、打包、发布代码，实现软件开发流程的自动化。通过定义 YAML 格式的配置文件（称为 Workflow），开发者可以定制化代码仓库的自动化工作流程，例如代码提交时自动运行测试、合并分支时自动部署到服务器等。</p>\n<h2 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h2><h3 id=\"Workflow（工作流）\"><a href=\"#Workflow（工作流）\" class=\"headerlink\" title=\"Workflow（工作流）\"></a>Workflow（工作流）</h3><ul>\n<li><p>一个 Workflow 是一个自动化流程，由一个或多个 Job 组成，通过 YAML 文件（.github&#x2F;workflows&#x2F; 目录下）定义。</p>\n</li>\n<li><p>可以配置 Workflow 在特定事件（如代码推送、Pull Request 创建、Issue 评论等）触发，或按计划定期运行。</p>\n</li>\n</ul>\n<h3 id=\"Job（任务）\"><a href=\"#Job（任务）\" class=\"headerlink\" title=\"Job（任务）\"></a>Job（任务）</h3><ul>\n<li>一个 Job 是 Workflow 中的独立任务，包含一系列 Step，默认在一个虚拟机（Runner）上运行。</li>\n<li>Jobs 可以并行或按顺序执行，支持定义依赖关系（如 Job B 等待 Job A 完成）。</li>\n</ul>\n<h3 id=\"Step（步骤）\"><a href=\"#Step（步骤）\" class=\"headerlink\" title=\"Step（步骤）\"></a>Step（步骤）</h3><ul>\n<li><p>Step 是 Job 中的最小执行单元，可以是运行 Shell 命令（如 npm install）或调用 Action（预定义的功能模块）。</p>\n</li>\n<li><p>例如：拉取代码、安装依赖、运行测试、部署到服务器等。</p>\n</li>\n</ul>\n<h3 id=\"Action（动作）\"><a href=\"#Action（动作）\" class=\"headerlink\" title=\"Action（动作）\"></a>Action（动作）</h3><ul>\n<li><p>可复用的代码模块，用于完成特定功能（如检出代码、设置环境、发送通知等）。</p>\n</li>\n<li><p>GitHub Marketplace 提供大量公开 Actions（如 actions&#x2F;checkout、actions&#x2F;setup-node），开发者也可自定义 Actions。</p>\n</li>\n</ul>\n<h2 id=\"举个例子\"><a href=\"#举个例子\" class=\"headerlink\" title=\"举个例子\"></a>举个例子</h2><p>以下是一个简单的 Workflow 配置（.github&#x2F;workflows&#x2F;node.js.yml），用于在 Node.js 项目中执行测试：</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nix\"><span class=\"hljs-params\">name:</span> Node.js CI<br><span class=\"hljs-params\">on:</span> [push] <span class=\"hljs-comment\"># 当代码推送时触发</span><br><br><span class=\"hljs-params\">jobs:</span><br>  <span class=\"hljs-params\">build:</span><br>    <span class=\"hljs-params\">runs-on:</span> ubuntu-latest <span class=\"hljs-comment\"># 使用 Ubuntu 最新版虚拟机</span><br>    <span class=\"hljs-params\">steps:</span><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Checkout code<br>        <span class=\"hljs-params\">uses:</span> actions<span class=\"hljs-operator\">/</span>checkout@v4 <span class=\"hljs-comment\"># 拉取代码到 Runner</span><br><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Set up Node.js<br>        <span class=\"hljs-params\">uses:</span> actions<span class=\"hljs-operator\">/</span>setup-node@v4<br>        <span class=\"hljs-params\">with:</span><br>          <span class=\"hljs-params\">node-version:</span> <span class=\"hljs-number\">20</span> <span class=\"hljs-comment\"># 指定 Node.js 版本</span><br><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Install dependencies<br>        <span class=\"hljs-params\">run:</span> npm install <span class=\"hljs-comment\"># 运行 Shell 命令安装依赖</span><br><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Run tests<br>        <span class=\"hljs-params\">run:</span> npm test <span class=\"hljs-comment\"># 运行测试脚本</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"编写自动编译并部署博客脚本\"><a href=\"#编写自动编译并部署博客脚本\" class=\"headerlink\" title=\"编写自动编译并部署博客脚本\"></a>编写自动编译并部署博客脚本</h2><p>如果需要实现博客的自动化部署，那么有两个步骤要走，一是在push新内容的时候编译，二是编译之后部署到Github pages上。</p>\n<h3 id=\"编译博客\"><a href=\"#编译博客\" class=\"headerlink\" title=\"编译博客\"></a>编译博客</h3><p>在之前的内容中，我们知道编译markdown文件成html文件使用的命令是 <code>hexo build</code>, 后来我们又将其写入到 <code>package.json</code>里的<code>scripts</code>中并取名为 <code>build</code>, 那么在执行编译的时候可以使用 <code>npm run build</code>来替代之前的命令。</p>\n<p>下面我们开始来写自动化脚本，首先在根目录下新建一个<code>./github/workflows/update-blogs.yml</code>文件，整体框架可以参考上面例子，因为使用的都是 Node 环境。</p>\n<p>完成一个build操作，要执行的操作分4步骤</p>\n<ul>\n<li>拉取代码</li>\n<li>配置Node环境</li>\n<li>安装依赖</li>\n<li>执行编译操作</li>\n<li>上传编译内容<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nix\"><span class=\"hljs-params\">name:</span> automaticly update blogs<br><span class=\"hljs-params\">on:</span> <br> <span class=\"hljs-params\">branches:</span><br>  <span class=\"hljs-operator\">-</span> master <span class=\"hljs-comment\"># master分支</span><br><span class=\"hljs-params\">jobs:</span><br>  <span class=\"hljs-params\">build:</span><br>    <span class=\"hljs-params\">runs-on:</span> ubuntu-latest <span class=\"hljs-comment\"># 使用 Ubuntu 最新版虚拟机</span><br>    <span class=\"hljs-params\">steps:</span><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Checkout code<br>        <span class=\"hljs-params\">uses:</span> actions<span class=\"hljs-operator\">/</span>checkout@v4 <span class=\"hljs-comment\"># 拉取代码到 Runner</span><br><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Set up Node.js<br>        <span class=\"hljs-params\">uses:</span> actions<span class=\"hljs-operator\">/</span>setup-node@v4<br>        <span class=\"hljs-params\">with:</span><br>          <span class=\"hljs-params\">node-version:</span> <span class=\"hljs-number\">20</span> <span class=\"hljs-comment\"># 指定 Node.js 版本</span><br><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Install dependencies<br>        <span class=\"hljs-params\">run:</span> |<br>          npm install<br>          npm install <span class=\"hljs-operator\">-</span>g hexo-cli<br><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Run build<br>        <span class=\"hljs-params\">run:</span> npm run build <span class=\"hljs-comment\"># 运行编译操作</span><br>      <br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Upload Pages artifact<br>        <span class=\"hljs-params\">uses:</span> actions<span class=\"hljs-operator\">/</span>upload-pages-artifact@v3 <span class=\"hljs-comment\"># 上传public目录内容</span><br>        <span class=\"hljs-params\">with:</span><br>          <span class=\"hljs-params\">path:</span> <span class=\"hljs-symbol\">./public</span><br><br></code></pre></td></tr></table></figure></li>\n</ul>\n<p>修改点：</p>\n<ul>\n<li><p>不想任意分支提交都执行该操作，所以选择  <code>master</code> 分支有提交的时候执行。</p>\n</li>\n<li><p>安装依赖依赖，需要在全局安装 <code>hexo-cli</code></p>\n</li>\n<li><p>上传内容使用的是Github Actions 官方的一个专用 Action: actions&#x2F;upload-pages-aartifact, 主要用于 将静态网站文件打包并上传为 GitHub Pages 部署所需的 “工件”。</p>\n</li>\n</ul>\n<h3 id=\"部署博客\"><a href=\"#部署博客\" class=\"headerlink\" title=\"部署博客\"></a>部署博客</h3><p>在成功编译博客之后，也是通过一个官方的Action来实现博客内容的部署</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nix\"><span class=\"hljs-params\">name:</span> automaticly update blogs<br><span class=\"hljs-params\">on:</span> <br> <span class=\"hljs-params\">branches:</span><br>  <span class=\"hljs-operator\">-</span> master <span class=\"hljs-comment\"># master分支</span><br><span class=\"hljs-params\">jobs:</span><br>  <span class=\"hljs-params\">build:</span><br>    ...<br><br>  <span class=\"hljs-comment\"># 部署博客  </span><br>  <span class=\"hljs-params\">deploy:</span><br>    <span class=\"hljs-params\">needs:</span> build   <span class=\"hljs-comment\"># 依赖上一个build操作</span><br>    <span class=\"hljs-params\">permissions:</span>   <span class=\"hljs-comment\"># # 需授予 Pages 写入权限和生成部署令牌的权限</span><br>      <span class=\"hljs-params\">pages:</span> write<br>      <span class=\"hljs-params\">id-token:</span> write<br>    <span class=\"hljs-params\">environment:</span><br>      <span class=\"hljs-params\">name:</span> github-pages<br>      <span class=\"hljs-params\">url:</span> $&#123;&#123; steps.deployment.outputs.page_url &#125;&#125;<br>    <span class=\"hljs-params\">runs-on:</span> ubuntu-latest<br>    <span class=\"hljs-params\">steps:</span>         <span class=\"hljs-comment\"># 使用actions 部署</span><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Deploy to GitHub Pages<br>        <span class=\"hljs-params\">id:</span> deployment<br>        <span class=\"hljs-params\">uses:</span> actions<span class=\"hljs-operator\">/</span>deploy-pages@v4<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"测试验证\"><a href=\"#测试验证\" class=\"headerlink\" title=\"测试验证\"></a>测试验证</h2><p>编写完脚本之后，提交代码至 <code>master</code> 分支，在Github对应的仓库分支上可以看见已经有对应的workflow，如作者的脚本配置。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/build-blog4/actions.png\" alt=\"actions\"></p>\n<p>如果左侧出现刚才脚本的名称 <code>automaticly update blogs</code>, 则说明已经配置成功了，可以通过提交内容到 master分支来检验脚本的执行情况。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>到目前为止，整个搭建个人博客系列文章已经实现了个人博客站点的搭建和自动化部署，相信此时的你也搭建好了自己的博客站点。</p>\n<p>正如之前所说，博客站点最重要的就是价值输出，也就是要勤写内容。但是有时候，酒香也怕巷子深，如何让更多的人看到自己写的文章，增加个人影响力，这将是后面将要讨论的问题，请持续关注！</p>\n"},{"title":"为什么团队总在写烂代码？因为 “背锅侠” 根本不存在","date":"2025-06-25T10:20:41.000Z","keywords":["Vue","组件"],"banner_img":"/imgs/baners/team.jfif","index_img":"/imgs/baners/team.jfif","_content":"\n > CV: Copy & Paste, 复制的意思\n\n### 草台班子的代码现状：烂却能跑的魔幻现实\n\n做开发越久，你就越能感受到“这个世界，就是个巨大的草台班子”这句话的含金量。很多看似不错的项目，其代码质量和整理设计往往都经不起推敲。\n\n项目中的冗余代码堆砌，不做修改的暴力复制，混乱的逻辑判断，以及令人作呕的文件命名，有时候自己都会不禁发出灵魂拷问：\n\n“这东西能跑起来吗？ 这东西为什么能跑起来？”\n\n可是，没有人一开始就是奔着要把整个项目写烂为目的的吧？ 没有吧！ 但事实就是这样啊，它虽然很烂，但它能用。虽然它能用，但也是真的烂。\n\nWhy? Tell me why?\n\n![](../imgs/bad-code/en.jfif)\n\n###  熵增的起点：一次复制、一个else if的蝴蝶效应\n\n它肯定不是一开始就是这么烂的，但随着时间的推移，版本的迭代，似乎有种 力量在不断地将他慢慢往变烂的的方向推。而且随着时间的变长，作为项目的开发者，能够明显的感觉到这种力量越来越强，整个项目的维护成本也越来越高。\n\n而这一些，最初可能只是一次简单的代码复制，文件拷贝，也可能只是在原来的判断逻辑上加了一条 `else if` 判断语句...\n\n而做这些的原因，可能是一次的需求变更，也可能是新特性的加入，又或是一次错误的代码优化，但最终的结果是一样的--整个项目的复杂度提高了，代码混乱程度也变高了，换句话来说就是，整个项目的**熵**增加了。\n\n### 协作困境：通用性在功能优先主义下的妥协\n\n对于一个生命周期还没有走到成熟那步的项目来说，需求点的增加和改动是必然的。而需求点的增加和改动，对原有代码的通用性造成的影响有时候是破坏性的。\n\n而在保证项目功能优先的情况下，开发者往往会选择通过牺牲一定通用性来实现对应的功能。虽然可以通过提升组件抽象层次来保证组件的通用性，但这种设计上下多个层次的改动，工作量会比前者多出很多。\n\n而且对于一个多人协作开发的项目而言，每个人并非对指定组件或者模块负责，而是对某些功能点负责，因此在维护组件通用的积极性并没有那么强。\n\n于是今天少一点通用性，明天少一点通用性，直到有一天，协同开发的同事小明需要使用该组件，但是又涉及到内部改动，不好评估改动对整个项目带来的影响。索性生死看淡，不符就干，直接来个CV操作。\n\n至此，回归到了CV的路上。\n\n\n###  伪组件化陷阱：看似复用，实则埋雷\n\n通常，我们对弈是否要将一部分代码抽取成一个模块或者组件的判断还是比较朴素的。\n\n比如，有一段判断逻辑，如果有在3个或3个以上地方出现，这个时候我们就可以考虑将其抽取成一个函数。对于组件也是一样，频繁出现内容相近的表单，也可以封装成一个公共组件。\n\n为什么说这种判断依据比较朴素呢？ 通过一定参数或者内部逻辑适配，使得一个组件能够在多个地方应用，在开发是确实方便了很多。但是，这一操作本身可能就破坏了组件的单一性职责，而且其内部代码将比原来三者中任意一个都负责。\n\n而且，**通过简单适配出来的组件，其本身的通用性在复杂多变的需求面前是十分脆弱的**。\n\n### 烂代码的本质：团队责任感的集体缺位\n\n不可否认，一个项目在功能变复杂的过程中，其代码的复杂程度是会对应增加的，代码烂的程度也会增加。但比较可悲的是，我们往往总是把这种结果归咎于事情本身，而不是管理机制和人。\n\n每一位开发者都在关注着自己手头上的功能，“人和代码，有一个能跑就行”，把手头上的功能做完即可。 整个团队中，没有人需要为项目的烂代码兜底，因为它不是烂在自己手上的。\n\n**责任感的缺位，导致烂代码就像癌细胞一样逐渐扩散到整个项目**。“能用就行，能跑就行，现就这样吧，之前又不是我写的”，这样的思想侵蚀着开发者的责任感。\n\n按理说，每个项目的代码都是有代码审查环节，但在实际操作中，代码审查者往往都是起一个橡皮图章的作用，要么根本没有参与到开发中，要么就是随便瞅两眼后便何如代码。代码审查，本该是把好代码质量的一道重要的门，但却形同虚设，这样又怎能保证代码的质量呢？\n\n组件的通用性差，代码乱复制，冗余代码堆砌...这些烂代码的现象，其实也都是表象。说到底，**项目代码的烂，本质是研发团队管理机制和责任感的烂**。\n\n先说到这吧，散了散了...","source":"_posts/component-versatility.md","raw":"---\ntitle: 为什么团队总在写烂代码？因为 “背锅侠” 根本不存在\ndate: 2025-06-25 18:20:41\ntags: [Vue, 组件]\nkeywords: [Vue, 组件]\ncategory: Web开发\nbanner_img: /imgs/baners/team.jfif\nindex_img: /imgs/baners/team.jfif\n---\n\n > CV: Copy & Paste, 复制的意思\n\n### 草台班子的代码现状：烂却能跑的魔幻现实\n\n做开发越久，你就越能感受到“这个世界，就是个巨大的草台班子”这句话的含金量。很多看似不错的项目，其代码质量和整理设计往往都经不起推敲。\n\n项目中的冗余代码堆砌，不做修改的暴力复制，混乱的逻辑判断，以及令人作呕的文件命名，有时候自己都会不禁发出灵魂拷问：\n\n“这东西能跑起来吗？ 这东西为什么能跑起来？”\n\n可是，没有人一开始就是奔着要把整个项目写烂为目的的吧？ 没有吧！ 但事实就是这样啊，它虽然很烂，但它能用。虽然它能用，但也是真的烂。\n\nWhy? Tell me why?\n\n![](../imgs/bad-code/en.jfif)\n\n###  熵增的起点：一次复制、一个else if的蝴蝶效应\n\n它肯定不是一开始就是这么烂的，但随着时间的推移，版本的迭代，似乎有种 力量在不断地将他慢慢往变烂的的方向推。而且随着时间的变长，作为项目的开发者，能够明显的感觉到这种力量越来越强，整个项目的维护成本也越来越高。\n\n而这一些，最初可能只是一次简单的代码复制，文件拷贝，也可能只是在原来的判断逻辑上加了一条 `else if` 判断语句...\n\n而做这些的原因，可能是一次的需求变更，也可能是新特性的加入，又或是一次错误的代码优化，但最终的结果是一样的--整个项目的复杂度提高了，代码混乱程度也变高了，换句话来说就是，整个项目的**熵**增加了。\n\n### 协作困境：通用性在功能优先主义下的妥协\n\n对于一个生命周期还没有走到成熟那步的项目来说，需求点的增加和改动是必然的。而需求点的增加和改动，对原有代码的通用性造成的影响有时候是破坏性的。\n\n而在保证项目功能优先的情况下，开发者往往会选择通过牺牲一定通用性来实现对应的功能。虽然可以通过提升组件抽象层次来保证组件的通用性，但这种设计上下多个层次的改动，工作量会比前者多出很多。\n\n而且对于一个多人协作开发的项目而言，每个人并非对指定组件或者模块负责，而是对某些功能点负责，因此在维护组件通用的积极性并没有那么强。\n\n于是今天少一点通用性，明天少一点通用性，直到有一天，协同开发的同事小明需要使用该组件，但是又涉及到内部改动，不好评估改动对整个项目带来的影响。索性生死看淡，不符就干，直接来个CV操作。\n\n至此，回归到了CV的路上。\n\n\n###  伪组件化陷阱：看似复用，实则埋雷\n\n通常，我们对弈是否要将一部分代码抽取成一个模块或者组件的判断还是比较朴素的。\n\n比如，有一段判断逻辑，如果有在3个或3个以上地方出现，这个时候我们就可以考虑将其抽取成一个函数。对于组件也是一样，频繁出现内容相近的表单，也可以封装成一个公共组件。\n\n为什么说这种判断依据比较朴素呢？ 通过一定参数或者内部逻辑适配，使得一个组件能够在多个地方应用，在开发是确实方便了很多。但是，这一操作本身可能就破坏了组件的单一性职责，而且其内部代码将比原来三者中任意一个都负责。\n\n而且，**通过简单适配出来的组件，其本身的通用性在复杂多变的需求面前是十分脆弱的**。\n\n### 烂代码的本质：团队责任感的集体缺位\n\n不可否认，一个项目在功能变复杂的过程中，其代码的复杂程度是会对应增加的，代码烂的程度也会增加。但比较可悲的是，我们往往总是把这种结果归咎于事情本身，而不是管理机制和人。\n\n每一位开发者都在关注着自己手头上的功能，“人和代码，有一个能跑就行”，把手头上的功能做完即可。 整个团队中，没有人需要为项目的烂代码兜底，因为它不是烂在自己手上的。\n\n**责任感的缺位，导致烂代码就像癌细胞一样逐渐扩散到整个项目**。“能用就行，能跑就行，现就这样吧，之前又不是我写的”，这样的思想侵蚀着开发者的责任感。\n\n按理说，每个项目的代码都是有代码审查环节，但在实际操作中，代码审查者往往都是起一个橡皮图章的作用，要么根本没有参与到开发中，要么就是随便瞅两眼后便何如代码。代码审查，本该是把好代码质量的一道重要的门，但却形同虚设，这样又怎能保证代码的质量呢？\n\n组件的通用性差，代码乱复制，冗余代码堆砌...这些烂代码的现象，其实也都是表象。说到底，**项目代码的烂，本质是研发团队管理机制和责任感的烂**。\n\n先说到这吧，散了散了...","slug":"component-versatility","published":1,"updated":"2025-08-26T10:51:25.343Z","_id":"cmcbtzcuy00042gup8b7mgn4o","comments":1,"layout":"post","photos":[],"content":"<blockquote>\n<p>CV: Copy &amp; Paste, 复制的意思</p>\n</blockquote>\n<h3 id=\"草台班子的代码现状：烂却能跑的魔幻现实\"><a href=\"#草台班子的代码现状：烂却能跑的魔幻现实\" class=\"headerlink\" title=\"草台班子的代码现状：烂却能跑的魔幻现实\"></a>草台班子的代码现状：烂却能跑的魔幻现实</h3><p>做开发越久，你就越能感受到“这个世界，就是个巨大的草台班子”这句话的含金量。很多看似不错的项目，其代码质量和整理设计往往都经不起推敲。</p>\n<p>项目中的冗余代码堆砌，不做修改的暴力复制，混乱的逻辑判断，以及令人作呕的文件命名，有时候自己都会不禁发出灵魂拷问：</p>\n<p>“这东西能跑起来吗？ 这东西为什么能跑起来？”</p>\n<p>可是，没有人一开始就是奔着要把整个项目写烂为目的的吧？ 没有吧！ 但事实就是这样啊，它虽然很烂，但它能用。虽然它能用，但也是真的烂。</p>\n<p>Why? Tell me why?</p>\n<p><img src=\"/../imgs/bad-code/en.jfif\"></p>\n<h3 id=\"熵增的起点：一次复制、一个else-if的蝴蝶效应\"><a href=\"#熵增的起点：一次复制、一个else-if的蝴蝶效应\" class=\"headerlink\" title=\"熵增的起点：一次复制、一个else if的蝴蝶效应\"></a>熵增的起点：一次复制、一个else if的蝴蝶效应</h3><p>它肯定不是一开始就是这么烂的，但随着时间的推移，版本的迭代，似乎有种 力量在不断地将他慢慢往变烂的的方向推。而且随着时间的变长，作为项目的开发者，能够明显的感觉到这种力量越来越强，整个项目的维护成本也越来越高。</p>\n<p>而这一些，最初可能只是一次简单的代码复制，文件拷贝，也可能只是在原来的判断逻辑上加了一条 <code>else if</code> 判断语句…</p>\n<p>而做这些的原因，可能是一次的需求变更，也可能是新特性的加入，又或是一次错误的代码优化，但最终的结果是一样的–整个项目的复杂度提高了，代码混乱程度也变高了，换句话来说就是，整个项目的<strong>熵</strong>增加了。</p>\n<h3 id=\"协作困境：通用性在功能优先主义下的妥协\"><a href=\"#协作困境：通用性在功能优先主义下的妥协\" class=\"headerlink\" title=\"协作困境：通用性在功能优先主义下的妥协\"></a>协作困境：通用性在功能优先主义下的妥协</h3><p>对于一个生命周期还没有走到成熟那步的项目来说，需求点的增加和改动是必然的。而需求点的增加和改动，对原有代码的通用性造成的影响有时候是破坏性的。</p>\n<p>而在保证项目功能优先的情况下，开发者往往会选择通过牺牲一定通用性来实现对应的功能。虽然可以通过提升组件抽象层次来保证组件的通用性，但这种设计上下多个层次的改动，工作量会比前者多出很多。</p>\n<p>而且对于一个多人协作开发的项目而言，每个人并非对指定组件或者模块负责，而是对某些功能点负责，因此在维护组件通用的积极性并没有那么强。</p>\n<p>于是今天少一点通用性，明天少一点通用性，直到有一天，协同开发的同事小明需要使用该组件，但是又涉及到内部改动，不好评估改动对整个项目带来的影响。索性生死看淡，不符就干，直接来个CV操作。</p>\n<p>至此，回归到了CV的路上。</p>\n<h3 id=\"伪组件化陷阱：看似复用，实则埋雷\"><a href=\"#伪组件化陷阱：看似复用，实则埋雷\" class=\"headerlink\" title=\"伪组件化陷阱：看似复用，实则埋雷\"></a>伪组件化陷阱：看似复用，实则埋雷</h3><p>通常，我们对弈是否要将一部分代码抽取成一个模块或者组件的判断还是比较朴素的。</p>\n<p>比如，有一段判断逻辑，如果有在3个或3个以上地方出现，这个时候我们就可以考虑将其抽取成一个函数。对于组件也是一样，频繁出现内容相近的表单，也可以封装成一个公共组件。</p>\n<p>为什么说这种判断依据比较朴素呢？ 通过一定参数或者内部逻辑适配，使得一个组件能够在多个地方应用，在开发是确实方便了很多。但是，这一操作本身可能就破坏了组件的单一性职责，而且其内部代码将比原来三者中任意一个都负责。</p>\n<p>而且，<strong>通过简单适配出来的组件，其本身的通用性在复杂多变的需求面前是十分脆弱的</strong>。</p>\n<h3 id=\"烂代码的本质：团队责任感的集体缺位\"><a href=\"#烂代码的本质：团队责任感的集体缺位\" class=\"headerlink\" title=\"烂代码的本质：团队责任感的集体缺位\"></a>烂代码的本质：团队责任感的集体缺位</h3><p>不可否认，一个项目在功能变复杂的过程中，其代码的复杂程度是会对应增加的，代码烂的程度也会增加。但比较可悲的是，我们往往总是把这种结果归咎于事情本身，而不是管理机制和人。</p>\n<p>每一位开发者都在关注着自己手头上的功能，“人和代码，有一个能跑就行”，把手头上的功能做完即可。 整个团队中，没有人需要为项目的烂代码兜底，因为它不是烂在自己手上的。</p>\n<p><strong>责任感的缺位，导致烂代码就像癌细胞一样逐渐扩散到整个项目</strong>。“能用就行，能跑就行，现就这样吧，之前又不是我写的”，这样的思想侵蚀着开发者的责任感。</p>\n<p>按理说，每个项目的代码都是有代码审查环节，但在实际操作中，代码审查者往往都是起一个橡皮图章的作用，要么根本没有参与到开发中，要么就是随便瞅两眼后便何如代码。代码审查，本该是把好代码质量的一道重要的门，但却形同虚设，这样又怎能保证代码的质量呢？</p>\n<p>组件的通用性差，代码乱复制，冗余代码堆砌…这些烂代码的现象，其实也都是表象。说到底，<strong>项目代码的烂，本质是研发团队管理机制和责任感的烂</strong>。</p>\n<p>先说到这吧，散了散了…</p>\n","excerpt":"","more":"<blockquote>\n<p>CV: Copy &amp; Paste, 复制的意思</p>\n</blockquote>\n<h3 id=\"草台班子的代码现状：烂却能跑的魔幻现实\"><a href=\"#草台班子的代码现状：烂却能跑的魔幻现实\" class=\"headerlink\" title=\"草台班子的代码现状：烂却能跑的魔幻现实\"></a>草台班子的代码现状：烂却能跑的魔幻现实</h3><p>做开发越久，你就越能感受到“这个世界，就是个巨大的草台班子”这句话的含金量。很多看似不错的项目，其代码质量和整理设计往往都经不起推敲。</p>\n<p>项目中的冗余代码堆砌，不做修改的暴力复制，混乱的逻辑判断，以及令人作呕的文件命名，有时候自己都会不禁发出灵魂拷问：</p>\n<p>“这东西能跑起来吗？ 这东西为什么能跑起来？”</p>\n<p>可是，没有人一开始就是奔着要把整个项目写烂为目的的吧？ 没有吧！ 但事实就是这样啊，它虽然很烂，但它能用。虽然它能用，但也是真的烂。</p>\n<p>Why? Tell me why?</p>\n<p><img src=\"/../imgs/bad-code/en.jfif\"></p>\n<h3 id=\"熵增的起点：一次复制、一个else-if的蝴蝶效应\"><a href=\"#熵增的起点：一次复制、一个else-if的蝴蝶效应\" class=\"headerlink\" title=\"熵增的起点：一次复制、一个else if的蝴蝶效应\"></a>熵增的起点：一次复制、一个else if的蝴蝶效应</h3><p>它肯定不是一开始就是这么烂的，但随着时间的推移，版本的迭代，似乎有种 力量在不断地将他慢慢往变烂的的方向推。而且随着时间的变长，作为项目的开发者，能够明显的感觉到这种力量越来越强，整个项目的维护成本也越来越高。</p>\n<p>而这一些，最初可能只是一次简单的代码复制，文件拷贝，也可能只是在原来的判断逻辑上加了一条 <code>else if</code> 判断语句…</p>\n<p>而做这些的原因，可能是一次的需求变更，也可能是新特性的加入，又或是一次错误的代码优化，但最终的结果是一样的–整个项目的复杂度提高了，代码混乱程度也变高了，换句话来说就是，整个项目的<strong>熵</strong>增加了。</p>\n<h3 id=\"协作困境：通用性在功能优先主义下的妥协\"><a href=\"#协作困境：通用性在功能优先主义下的妥协\" class=\"headerlink\" title=\"协作困境：通用性在功能优先主义下的妥协\"></a>协作困境：通用性在功能优先主义下的妥协</h3><p>对于一个生命周期还没有走到成熟那步的项目来说，需求点的增加和改动是必然的。而需求点的增加和改动，对原有代码的通用性造成的影响有时候是破坏性的。</p>\n<p>而在保证项目功能优先的情况下，开发者往往会选择通过牺牲一定通用性来实现对应的功能。虽然可以通过提升组件抽象层次来保证组件的通用性，但这种设计上下多个层次的改动，工作量会比前者多出很多。</p>\n<p>而且对于一个多人协作开发的项目而言，每个人并非对指定组件或者模块负责，而是对某些功能点负责，因此在维护组件通用的积极性并没有那么强。</p>\n<p>于是今天少一点通用性，明天少一点通用性，直到有一天，协同开发的同事小明需要使用该组件，但是又涉及到内部改动，不好评估改动对整个项目带来的影响。索性生死看淡，不符就干，直接来个CV操作。</p>\n<p>至此，回归到了CV的路上。</p>\n<h3 id=\"伪组件化陷阱：看似复用，实则埋雷\"><a href=\"#伪组件化陷阱：看似复用，实则埋雷\" class=\"headerlink\" title=\"伪组件化陷阱：看似复用，实则埋雷\"></a>伪组件化陷阱：看似复用，实则埋雷</h3><p>通常，我们对弈是否要将一部分代码抽取成一个模块或者组件的判断还是比较朴素的。</p>\n<p>比如，有一段判断逻辑，如果有在3个或3个以上地方出现，这个时候我们就可以考虑将其抽取成一个函数。对于组件也是一样，频繁出现内容相近的表单，也可以封装成一个公共组件。</p>\n<p>为什么说这种判断依据比较朴素呢？ 通过一定参数或者内部逻辑适配，使得一个组件能够在多个地方应用，在开发是确实方便了很多。但是，这一操作本身可能就破坏了组件的单一性职责，而且其内部代码将比原来三者中任意一个都负责。</p>\n<p>而且，<strong>通过简单适配出来的组件，其本身的通用性在复杂多变的需求面前是十分脆弱的</strong>。</p>\n<h3 id=\"烂代码的本质：团队责任感的集体缺位\"><a href=\"#烂代码的本质：团队责任感的集体缺位\" class=\"headerlink\" title=\"烂代码的本质：团队责任感的集体缺位\"></a>烂代码的本质：团队责任感的集体缺位</h3><p>不可否认，一个项目在功能变复杂的过程中，其代码的复杂程度是会对应增加的，代码烂的程度也会增加。但比较可悲的是，我们往往总是把这种结果归咎于事情本身，而不是管理机制和人。</p>\n<p>每一位开发者都在关注着自己手头上的功能，“人和代码，有一个能跑就行”，把手头上的功能做完即可。 整个团队中，没有人需要为项目的烂代码兜底，因为它不是烂在自己手上的。</p>\n<p><strong>责任感的缺位，导致烂代码就像癌细胞一样逐渐扩散到整个项目</strong>。“能用就行，能跑就行，现就这样吧，之前又不是我写的”，这样的思想侵蚀着开发者的责任感。</p>\n<p>按理说，每个项目的代码都是有代码审查环节，但在实际操作中，代码审查者往往都是起一个橡皮图章的作用，要么根本没有参与到开发中，要么就是随便瞅两眼后便何如代码。代码审查，本该是把好代码质量的一道重要的门，但却形同虚设，这样又怎能保证代码的质量呢？</p>\n<p>组件的通用性差，代码乱复制，冗余代码堆砌…这些烂代码的现象，其实也都是表象。说到底，<strong>项目代码的烂，本质是研发团队管理机制和责任感的烂</strong>。</p>\n<p>先说到这吧，散了散了…</p>\n"},{"title":"JavaScript的\"数值计算困局\"：生态缺位下的破局之路","date":"2025-06-27T14:36:13.000Z","keywords":["Web开发","Node"],"banner_img":"/imgs/baners/numpy-in-node.jfif","index_img":"/imgs/baners/numpy-in-node.jfif","_content":"\n\n**背景**：最近在尝试使用Node折腾一下图像处理相关的操作，以往使用Python处理时常常都会搭配使用numpy库，它在数值和矩阵等计算方面的性能是不用多说的，但在Node生态下却很难找到类似的替代方案，又是有了此文。\n\n\n在Node.js的世界里，写一个矩阵乘法函数或许只需百行代码，但要构建一个能与NumPy媲美的科学计算库，却堪比在沙漠中种树——技术的种子早已埋下，缺乏的是滋养生态的绿洲。这不是语言能力的边界，而是一场关于开发者选择的博弈。\n\n## 一、被误解的\"技术原罪\"\n当开发者争论\"JS能否做科学计算\"时，往往忽略了一个事实：V8引擎的浮点运算性能早已超越多数脚本语言。**类型化数组**配合SIMD.js（通过WebAssembly实现），能让矩阵乘法达到C语言90%的效率；Node.js的N-API允许无缝绑定Fortran数值库，就像**stdlib项目**所展示的那样。ES6引入的类与模块系统，虽未直接赋能数值计算，却为构建复杂数据结构提供了基础设施。\n\n真正的技术瓶颈藏在细节里。比如，JS至今缺乏原生的64位整数数组，这让金融计算场景颇为棘手；复数类型的缺失，也让信号处理库的开发绕道而行。但这些都不是不可逾越的高墙——TypeScript可以通过类型声明模拟，原生插件能够补充底层能力。正如用JS实现FFT算法的开发者所言：\"不是不能写，而是写完后发现，愿意用的人太少。\"\n\n## 二、生态循环的\"死亡螺旋\"\n在Python社区，一个NumPy的bug可能引发百人协作修复；而在JS世界，即便写出性能媲美的ndarray库，也可能面临\"无人问津\"的尴尬。这种差距源于两个恶性循环：\n\n### 人才的\"用脚投票\"\n数据科学家更熟悉Python的SciPy生态，前端开发者擅长的DOM操作与数值计算需求错位。就像PHP开发者转向全栈时更易选择Node.js，数值计算领域的专家天然倾向于已有成熟工具的语言。某开源JS数学库维护者坦言：\"我花3个月优化的矩阵求逆算法，不如Python同行一个星期的Stack Overflow答疑获得的关注多。\"\n\n### 库作者的\"收益悖论\"\n优秀的数值计算库需要持续打磨——这既包括算法优化，也需要完善的文档和教程。但JS生态的\"快餐文化\"让深度投入变得稀缺：一个实现K-means聚类的NPM包可能有2000+下载，但愿意提交文档翻译的贡献者不到5人。这种\"用得多、养得少\"的现状，让库作者难以获得持续创作的动力。\n\n## 三、破局的\"星星之火\"\n转机正在边缘地带悄然发生。在边缘计算场景，Node.js的低延迟特性催生了实时数据处理需求：某物联网公司用JS编写的信号滤波算法，在边缘设备上实现了比Python快30%的处理速度；WebAssembly的普及，让TensorFlow.js能在浏览器中直接运行轻量化模型，这种\"计算可视化一体\"的体验，正是Python生态难以复制的优势。\n\n更值得关注的是工具链的进化。TypeScript的类型系统正在重塑JS的工程能力——某数值计算库通过严格的类型定义，让线性代数操作的错误率下降70%；Vite等构建工具的普及，让JS库的打包体积缩小60%，降低了科学计算库的集成成本。这些变化正在吸引跨界开发者：一位从Julia转投JS的计算生物学家表示：\"现在用JS写的分子动力学模拟，调试效率比编译型语言高5倍。\"\n\n## 四、未来的\"第三条路\"\nJS的数值计算生态不会重复Python的路径，而是走出自己的特色：在浏览器端，WebGPU与WebAssembly的结合，正在孕育\"可视化即计算\"的新范式——用户在Canvas上绘制的图表，背后可能运行着百万级的矩阵运算；在服务端，Node.js的分布式特性让大规模数值计算可以无缝融入微服务架构，某金融公司已用此方案实现了实时风控模型的动态部署。\n\n这场生态突围的关键，在于找到JS的\"不可替代性\"。当Python开发者还在为环境配置发愁时，JS开发者已经通过CDN让数值计算库秒级加载；当R语言的图表需要导出才能分享时，JS的D3.js正在浏览器中实现交互式数据分析。这些差异化体验，正在吸引越来越多\"非典型\"开发者——他们未必精通算法，但擅长将计算能力转化为用户可见的价值。\n\n在JS的世界里，数值计算的未来不是复刻NumPy，而是创造属于自己的\"计算原语\"。当某天，前端开发者能用熟悉的语法操作多维数组，后端工程师可以轻松将数值计算嵌入API，这场迟到的生态革命才算真正完成。而此刻，那些在荒芜中播种的开发者，正在书写着这段历史的序章。","source":"_posts/node-numpy.md","raw":"---\ntitle: JavaScript的\"数值计算困局\"：生态缺位下的破局之路\ndate: 2025-06-27 22:36:13\ntags: [Web开发, Node, packages]\nkeywords: [Web开发, Node]\nbanner_img: /imgs/baners/numpy-in-node.jfif\nindex_img: /imgs/baners/numpy-in-node.jfif\n---\n\n\n**背景**：最近在尝试使用Node折腾一下图像处理相关的操作，以往使用Python处理时常常都会搭配使用numpy库，它在数值和矩阵等计算方面的性能是不用多说的，但在Node生态下却很难找到类似的替代方案，又是有了此文。\n\n\n在Node.js的世界里，写一个矩阵乘法函数或许只需百行代码，但要构建一个能与NumPy媲美的科学计算库，却堪比在沙漠中种树——技术的种子早已埋下，缺乏的是滋养生态的绿洲。这不是语言能力的边界，而是一场关于开发者选择的博弈。\n\n## 一、被误解的\"技术原罪\"\n当开发者争论\"JS能否做科学计算\"时，往往忽略了一个事实：V8引擎的浮点运算性能早已超越多数脚本语言。**类型化数组**配合SIMD.js（通过WebAssembly实现），能让矩阵乘法达到C语言90%的效率；Node.js的N-API允许无缝绑定Fortran数值库，就像**stdlib项目**所展示的那样。ES6引入的类与模块系统，虽未直接赋能数值计算，却为构建复杂数据结构提供了基础设施。\n\n真正的技术瓶颈藏在细节里。比如，JS至今缺乏原生的64位整数数组，这让金融计算场景颇为棘手；复数类型的缺失，也让信号处理库的开发绕道而行。但这些都不是不可逾越的高墙——TypeScript可以通过类型声明模拟，原生插件能够补充底层能力。正如用JS实现FFT算法的开发者所言：\"不是不能写，而是写完后发现，愿意用的人太少。\"\n\n## 二、生态循环的\"死亡螺旋\"\n在Python社区，一个NumPy的bug可能引发百人协作修复；而在JS世界，即便写出性能媲美的ndarray库，也可能面临\"无人问津\"的尴尬。这种差距源于两个恶性循环：\n\n### 人才的\"用脚投票\"\n数据科学家更熟悉Python的SciPy生态，前端开发者擅长的DOM操作与数值计算需求错位。就像PHP开发者转向全栈时更易选择Node.js，数值计算领域的专家天然倾向于已有成熟工具的语言。某开源JS数学库维护者坦言：\"我花3个月优化的矩阵求逆算法，不如Python同行一个星期的Stack Overflow答疑获得的关注多。\"\n\n### 库作者的\"收益悖论\"\n优秀的数值计算库需要持续打磨——这既包括算法优化，也需要完善的文档和教程。但JS生态的\"快餐文化\"让深度投入变得稀缺：一个实现K-means聚类的NPM包可能有2000+下载，但愿意提交文档翻译的贡献者不到5人。这种\"用得多、养得少\"的现状，让库作者难以获得持续创作的动力。\n\n## 三、破局的\"星星之火\"\n转机正在边缘地带悄然发生。在边缘计算场景，Node.js的低延迟特性催生了实时数据处理需求：某物联网公司用JS编写的信号滤波算法，在边缘设备上实现了比Python快30%的处理速度；WebAssembly的普及，让TensorFlow.js能在浏览器中直接运行轻量化模型，这种\"计算可视化一体\"的体验，正是Python生态难以复制的优势。\n\n更值得关注的是工具链的进化。TypeScript的类型系统正在重塑JS的工程能力——某数值计算库通过严格的类型定义，让线性代数操作的错误率下降70%；Vite等构建工具的普及，让JS库的打包体积缩小60%，降低了科学计算库的集成成本。这些变化正在吸引跨界开发者：一位从Julia转投JS的计算生物学家表示：\"现在用JS写的分子动力学模拟，调试效率比编译型语言高5倍。\"\n\n## 四、未来的\"第三条路\"\nJS的数值计算生态不会重复Python的路径，而是走出自己的特色：在浏览器端，WebGPU与WebAssembly的结合，正在孕育\"可视化即计算\"的新范式——用户在Canvas上绘制的图表，背后可能运行着百万级的矩阵运算；在服务端，Node.js的分布式特性让大规模数值计算可以无缝融入微服务架构，某金融公司已用此方案实现了实时风控模型的动态部署。\n\n这场生态突围的关键，在于找到JS的\"不可替代性\"。当Python开发者还在为环境配置发愁时，JS开发者已经通过CDN让数值计算库秒级加载；当R语言的图表需要导出才能分享时，JS的D3.js正在浏览器中实现交互式数据分析。这些差异化体验，正在吸引越来越多\"非典型\"开发者——他们未必精通算法，但擅长将计算能力转化为用户可见的价值。\n\n在JS的世界里，数值计算的未来不是复刻NumPy，而是创造属于自己的\"计算原语\"。当某天，前端开发者能用熟悉的语法操作多维数组，后端工程师可以轻松将数值计算嵌入API，这场迟到的生态革命才算真正完成。而此刻，那些在荒芜中播种的开发者，正在书写着这段历史的序章。","slug":"node-numpy","published":1,"updated":"2025-08-26T10:48:43.926Z","_id":"cmcexlrxm0000bcupenyp0yis","comments":1,"layout":"post","photos":[],"content":"<p><strong>背景</strong>：最近在尝试使用Node折腾一下图像处理相关的操作，以往使用Python处理时常常都会搭配使用numpy库，它在数值和矩阵等计算方面的性能是不用多说的，但在Node生态下却很难找到类似的替代方案，又是有了此文。</p>\n<p>在Node.js的世界里，写一个矩阵乘法函数或许只需百行代码，但要构建一个能与NumPy媲美的科学计算库，却堪比在沙漠中种树——技术的种子早已埋下，缺乏的是滋养生态的绿洲。这不是语言能力的边界，而是一场关于开发者选择的博弈。</p>\n<h2 id=\"一、被误解的”技术原罪”\"><a href=\"#一、被误解的”技术原罪”\" class=\"headerlink\" title=\"一、被误解的”技术原罪”\"></a>一、被误解的”技术原罪”</h2><p>当开发者争论”JS能否做科学计算”时，往往忽略了一个事实：V8引擎的浮点运算性能早已超越多数脚本语言。<strong>类型化数组</strong>配合SIMD.js（通过WebAssembly实现），能让矩阵乘法达到C语言90%的效率；Node.js的N-API允许无缝绑定Fortran数值库，就像<strong>stdlib项目</strong>所展示的那样。ES6引入的类与模块系统，虽未直接赋能数值计算，却为构建复杂数据结构提供了基础设施。</p>\n<p>真正的技术瓶颈藏在细节里。比如，JS至今缺乏原生的64位整数数组，这让金融计算场景颇为棘手；复数类型的缺失，也让信号处理库的开发绕道而行。但这些都不是不可逾越的高墙——TypeScript可以通过类型声明模拟，原生插件能够补充底层能力。正如用JS实现FFT算法的开发者所言：”不是不能写，而是写完后发现，愿意用的人太少。”</p>\n<h2 id=\"二、生态循环的”死亡螺旋”\"><a href=\"#二、生态循环的”死亡螺旋”\" class=\"headerlink\" title=\"二、生态循环的”死亡螺旋”\"></a>二、生态循环的”死亡螺旋”</h2><p>在Python社区，一个NumPy的bug可能引发百人协作修复；而在JS世界，即便写出性能媲美的ndarray库，也可能面临”无人问津”的尴尬。这种差距源于两个恶性循环：</p>\n<h3 id=\"人才的”用脚投票”\"><a href=\"#人才的”用脚投票”\" class=\"headerlink\" title=\"人才的”用脚投票”\"></a>人才的”用脚投票”</h3><p>数据科学家更熟悉Python的SciPy生态，前端开发者擅长的DOM操作与数值计算需求错位。就像PHP开发者转向全栈时更易选择Node.js，数值计算领域的专家天然倾向于已有成熟工具的语言。某开源JS数学库维护者坦言：”我花3个月优化的矩阵求逆算法，不如Python同行一个星期的Stack Overflow答疑获得的关注多。”</p>\n<h3 id=\"库作者的”收益悖论”\"><a href=\"#库作者的”收益悖论”\" class=\"headerlink\" title=\"库作者的”收益悖论”\"></a>库作者的”收益悖论”</h3><p>优秀的数值计算库需要持续打磨——这既包括算法优化，也需要完善的文档和教程。但JS生态的”快餐文化”让深度投入变得稀缺：一个实现K-means聚类的NPM包可能有2000+下载，但愿意提交文档翻译的贡献者不到5人。这种”用得多、养得少”的现状，让库作者难以获得持续创作的动力。</p>\n<h2 id=\"三、破局的”星星之火”\"><a href=\"#三、破局的”星星之火”\" class=\"headerlink\" title=\"三、破局的”星星之火”\"></a>三、破局的”星星之火”</h2><p>转机正在边缘地带悄然发生。在边缘计算场景，Node.js的低延迟特性催生了实时数据处理需求：某物联网公司用JS编写的信号滤波算法，在边缘设备上实现了比Python快30%的处理速度；WebAssembly的普及，让TensorFlow.js能在浏览器中直接运行轻量化模型，这种”计算可视化一体”的体验，正是Python生态难以复制的优势。</p>\n<p>更值得关注的是工具链的进化。TypeScript的类型系统正在重塑JS的工程能力——某数值计算库通过严格的类型定义，让线性代数操作的错误率下降70%；Vite等构建工具的普及，让JS库的打包体积缩小60%，降低了科学计算库的集成成本。这些变化正在吸引跨界开发者：一位从Julia转投JS的计算生物学家表示：”现在用JS写的分子动力学模拟，调试效率比编译型语言高5倍。”</p>\n<h2 id=\"四、未来的”第三条路”\"><a href=\"#四、未来的”第三条路”\" class=\"headerlink\" title=\"四、未来的”第三条路”\"></a>四、未来的”第三条路”</h2><p>JS的数值计算生态不会重复Python的路径，而是走出自己的特色：在浏览器端，WebGPU与WebAssembly的结合，正在孕育”可视化即计算”的新范式——用户在Canvas上绘制的图表，背后可能运行着百万级的矩阵运算；在服务端，Node.js的分布式特性让大规模数值计算可以无缝融入微服务架构，某金融公司已用此方案实现了实时风控模型的动态部署。</p>\n<p>这场生态突围的关键，在于找到JS的”不可替代性”。当Python开发者还在为环境配置发愁时，JS开发者已经通过CDN让数值计算库秒级加载；当R语言的图表需要导出才能分享时，JS的D3.js正在浏览器中实现交互式数据分析。这些差异化体验，正在吸引越来越多”非典型”开发者——他们未必精通算法，但擅长将计算能力转化为用户可见的价值。</p>\n<p>在JS的世界里，数值计算的未来不是复刻NumPy，而是创造属于自己的”计算原语”。当某天，前端开发者能用熟悉的语法操作多维数组，后端工程师可以轻松将数值计算嵌入API，这场迟到的生态革命才算真正完成。而此刻，那些在荒芜中播种的开发者，正在书写着这段历史的序章。</p>\n","excerpt":"","more":"<p><strong>背景</strong>：最近在尝试使用Node折腾一下图像处理相关的操作，以往使用Python处理时常常都会搭配使用numpy库，它在数值和矩阵等计算方面的性能是不用多说的，但在Node生态下却很难找到类似的替代方案，又是有了此文。</p>\n<p>在Node.js的世界里，写一个矩阵乘法函数或许只需百行代码，但要构建一个能与NumPy媲美的科学计算库，却堪比在沙漠中种树——技术的种子早已埋下，缺乏的是滋养生态的绿洲。这不是语言能力的边界，而是一场关于开发者选择的博弈。</p>\n<h2 id=\"一、被误解的”技术原罪”\"><a href=\"#一、被误解的”技术原罪”\" class=\"headerlink\" title=\"一、被误解的”技术原罪”\"></a>一、被误解的”技术原罪”</h2><p>当开发者争论”JS能否做科学计算”时，往往忽略了一个事实：V8引擎的浮点运算性能早已超越多数脚本语言。<strong>类型化数组</strong>配合SIMD.js（通过WebAssembly实现），能让矩阵乘法达到C语言90%的效率；Node.js的N-API允许无缝绑定Fortran数值库，就像<strong>stdlib项目</strong>所展示的那样。ES6引入的类与模块系统，虽未直接赋能数值计算，却为构建复杂数据结构提供了基础设施。</p>\n<p>真正的技术瓶颈藏在细节里。比如，JS至今缺乏原生的64位整数数组，这让金融计算场景颇为棘手；复数类型的缺失，也让信号处理库的开发绕道而行。但这些都不是不可逾越的高墙——TypeScript可以通过类型声明模拟，原生插件能够补充底层能力。正如用JS实现FFT算法的开发者所言：”不是不能写，而是写完后发现，愿意用的人太少。”</p>\n<h2 id=\"二、生态循环的”死亡螺旋”\"><a href=\"#二、生态循环的”死亡螺旋”\" class=\"headerlink\" title=\"二、生态循环的”死亡螺旋”\"></a>二、生态循环的”死亡螺旋”</h2><p>在Python社区，一个NumPy的bug可能引发百人协作修复；而在JS世界，即便写出性能媲美的ndarray库，也可能面临”无人问津”的尴尬。这种差距源于两个恶性循环：</p>\n<h3 id=\"人才的”用脚投票”\"><a href=\"#人才的”用脚投票”\" class=\"headerlink\" title=\"人才的”用脚投票”\"></a>人才的”用脚投票”</h3><p>数据科学家更熟悉Python的SciPy生态，前端开发者擅长的DOM操作与数值计算需求错位。就像PHP开发者转向全栈时更易选择Node.js，数值计算领域的专家天然倾向于已有成熟工具的语言。某开源JS数学库维护者坦言：”我花3个月优化的矩阵求逆算法，不如Python同行一个星期的Stack Overflow答疑获得的关注多。”</p>\n<h3 id=\"库作者的”收益悖论”\"><a href=\"#库作者的”收益悖论”\" class=\"headerlink\" title=\"库作者的”收益悖论”\"></a>库作者的”收益悖论”</h3><p>优秀的数值计算库需要持续打磨——这既包括算法优化，也需要完善的文档和教程。但JS生态的”快餐文化”让深度投入变得稀缺：一个实现K-means聚类的NPM包可能有2000+下载，但愿意提交文档翻译的贡献者不到5人。这种”用得多、养得少”的现状，让库作者难以获得持续创作的动力。</p>\n<h2 id=\"三、破局的”星星之火”\"><a href=\"#三、破局的”星星之火”\" class=\"headerlink\" title=\"三、破局的”星星之火”\"></a>三、破局的”星星之火”</h2><p>转机正在边缘地带悄然发生。在边缘计算场景，Node.js的低延迟特性催生了实时数据处理需求：某物联网公司用JS编写的信号滤波算法，在边缘设备上实现了比Python快30%的处理速度；WebAssembly的普及，让TensorFlow.js能在浏览器中直接运行轻量化模型，这种”计算可视化一体”的体验，正是Python生态难以复制的优势。</p>\n<p>更值得关注的是工具链的进化。TypeScript的类型系统正在重塑JS的工程能力——某数值计算库通过严格的类型定义，让线性代数操作的错误率下降70%；Vite等构建工具的普及，让JS库的打包体积缩小60%，降低了科学计算库的集成成本。这些变化正在吸引跨界开发者：一位从Julia转投JS的计算生物学家表示：”现在用JS写的分子动力学模拟，调试效率比编译型语言高5倍。”</p>\n<h2 id=\"四、未来的”第三条路”\"><a href=\"#四、未来的”第三条路”\" class=\"headerlink\" title=\"四、未来的”第三条路”\"></a>四、未来的”第三条路”</h2><p>JS的数值计算生态不会重复Python的路径，而是走出自己的特色：在浏览器端，WebGPU与WebAssembly的结合，正在孕育”可视化即计算”的新范式——用户在Canvas上绘制的图表，背后可能运行着百万级的矩阵运算；在服务端，Node.js的分布式特性让大规模数值计算可以无缝融入微服务架构，某金融公司已用此方案实现了实时风控模型的动态部署。</p>\n<p>这场生态突围的关键，在于找到JS的”不可替代性”。当Python开发者还在为环境配置发愁时，JS开发者已经通过CDN让数值计算库秒级加载；当R语言的图表需要导出才能分享时，JS的D3.js正在浏览器中实现交互式数据分析。这些差异化体验，正在吸引越来越多”非典型”开发者——他们未必精通算法，但擅长将计算能力转化为用户可见的价值。</p>\n<p>在JS的世界里，数值计算的未来不是复刻NumPy，而是创造属于自己的”计算原语”。当某天，前端开发者能用熟悉的语法操作多维数组，后端工程师可以轻松将数值计算嵌入API，这场迟到的生态革命才算真正完成。而此刻，那些在荒芜中播种的开发者，正在书写着这段历史的序章。</p>\n"},{"title":"一文读懂 Cookie、Session 和 Token：原理、区别与应用场景","date":"2025-07-01T13:15:32.000Z","keywords":["Cookie","Session","Token"],"banner_img":"/imgs/baners/security.jfif","index_img":"/imgs/baners/security.jfif","_content":"\n# 一文读懂Cookie、Session和Token：原理、区别与应用场景\n咱上网冲浪的时候，天天和各种网站、APP打交道。但HTTP协议有个“毛病”——它记性不好，每次请求都像第一次见面，根本不记得之前和你聊过啥。为了解决这个问题，程序员们整出了**Cookie**、**Session**和**Token**这三个“神器”，它们就像我们在网络世界的身份证、通行证，帮服务器记住你是谁，都干了啥。今天咱就唠唠这仨到底是干啥的，有啥不一样！\n\n## 一、Cookie、Session和Token都干啥用？\n### 1.1 Cookie：浏览器帮你记事儿的小本本\nCookie就是服务器给浏览器塞的小纸条，存的都是些用户信息，像登录状态、浏览偏好啥的。举个例子，你第一次进某个网站，选了中文界面、深色模式，下次再访问，网站秒变你喜欢的样子，这背后就是Cookie在偷偷“记笔记”。不过这小纸条存你电脑里，容易被人偷看，所以得小心点用！\n\n### 1.2 Session：服务器的专属“私人档案库”\nSession相当于是服务器自己的“小账本”，专门用来存用户的会话数据。当你登录网站，服务器就给你开个“档案袋”，把你购物车有啥、订单到哪一步了这些信息全塞进去。但它咋知道这份档案归谁呢？靠的就是Cookie里的Session ID，相当于档案编号，浏览器每次带着编号来，服务器一看就知道：“哦！原来是你！”\n\n### 1.3 Token：万能通行令牌\nToken就是服务器发的一串乱码“令牌”，你拿着它去访问网站的各种服务，就像拿着身份证证明“我是我”。Token最大的好处是不用服务器记太多东西，你每次来，它只需要验证令牌是真是假就行。现在流行的前后端分离、第三方登录，基本都靠Token“打天下”，移动端APP更是离了它不行。\n\n## 二、Cookie、Session和Token，到底咋区分？\n### 2.1 都藏在哪？能存多少东西？\nCookie就住你电脑里，浏览器帮你保管。不过它个头很小气，一般不能超过4KB，而且一个网站最多也就存50个左右。\nSession住在服务器那边，理论上想存多少存多少，但服务器空间有限，存太多也顶不住。\nToken呢，既可以放在客户端（比如APP里），也能在每次请求的时候跟着一起“跑”，大小没严格限制，通常几百字节。\n\n### 2.2 安不安全？容易被偷吗？\nCookie因为在客户端，就像放在桌子上的纸条，很容易被人篡改。不过可以给它加把锁：\n- `HttpOnly`让JavaScript读不到它\n- `Secure`保证它只在安全的HTTPS通道里传送\n- `SameSite`防止被别人“冒名顶替”发请求\n\nSession数据在服务器，相对安全些，但要是Session ID被坏人搞到手，也能冒充你。\nToken用签名加密，一般改不了，但一旦被偷，坏人也能用，所以得设个有效期，到期就作废。\n\n### 2.3 怎么在网络里“传送”？\n- Cookie最“自觉”，浏览器每次发请求，都会自动把相关的Cookie带上，除非你特意限制它。\n- Session得靠Cookie帮忙传递Session ID，虽然也能藏在URL里，但容易暴露，不太安全。\n- Token就比较“自由”，常见的是放在请求头的`Authorization`字段里，也能塞到请求体或URL里，全看开发者咋安排。\n\n### 2.4 能用多久？啥时候过期？\n- Cookie想“活”多久，由服务器说了算。设置了`expires`或`max-age`，它就是“长寿型”，到期才失效；不设置的话，浏览器一关，它就“凉凉”。\n- Session和Cookie里的Session ID绑在一起，服务器还会设个“闲置超时”，比如30分钟没操作，直接清空档案。\n- Token出生的时候就被定好了“保质期”（像JWT的`exp`字段），过期就得重新申请新令牌。\n\n### 2.5 能不能适应复杂的网络环境？\n要是网站用的是分布式系统（多个服务器协同工作），Cookie + Session组合就有点“吃力”。因为Session存在服务器里，多个服务器之间得同步数据，不然容易“认不出”用户。\nToken就没这烦恼，它不需要服务器存啥，验证一下令牌是真是假就行，特别适合微服务、跨域这种复杂场景。\n\n## 三、生活里都在哪见过它们？\n### 3.1 Cookie的“日常工作”\n- 刷新闻的时候，为啥总给你推爱看的内容？Cookie在“搞事情”！它记住了你的兴趣标签。\n- 还有电商网站没登录时加进购物车的商品，也是Cookie临时存着。不过拿Cookie做广告追踪得小心，一不小心就违反隐私规定了。\n\n### 3.2 Session的“用武之地”\n电商平台的购物车、订单状态，后台管理系统的用户权限，在线聊天的实时状态……这些对安全性、实时性要求高的场景，都是Session的主场。服务器随时能查看、修改你的会话数据，还能强制你下线，安全感拉满！\n\n### 3.3 Token的“高光时刻”\n- 现在很多网站支持微信、GitHub一键登录，靠的就是Token在不同平台间“传话”。\n- 前后端分离项目里，前端和后端不在一个域名下，Token能轻松实现跨域认证。\n- 还有手机APP，没Cookie可用，Token就是它唯一的“身份认证官”。\n\n## 四、到底该选谁？\n简单来说：\n- Cookie适合存点小偏好、临时数据\n- Session适合对安全要求高、需要集中管理的场景\n- Token则是跨域、移动端、微服务的“心头好”\n\n实际开发中，大家经常把它们搭配着用，比如用Cookie传Session ID，或者把Token藏在Cookie里，增强安全性。具体咋选，还得根据业务需求，综合考虑安全、性能这些因素，找到最适合的方案！\n\n要是你对哪个部分还有疑问，或者想知道更多实战技巧，欢迎随时来唠嗑！ ","source":"_posts/cookie-session-token.md","raw":"---\ntitle: 一文读懂 Cookie、Session 和 Token：原理、区别与应用场景\ndate: 2025-07-01 21:15:32\ntags: [Cookie, Session, Token]\nkeywords: [Cookie, Session, Token]\ncategory: [Web开发, 网络安全]\nbanner_img: /imgs/baners/security.jfif\nindex_img: /imgs/baners/security.jfif\n---\n\n# 一文读懂Cookie、Session和Token：原理、区别与应用场景\n咱上网冲浪的时候，天天和各种网站、APP打交道。但HTTP协议有个“毛病”——它记性不好，每次请求都像第一次见面，根本不记得之前和你聊过啥。为了解决这个问题，程序员们整出了**Cookie**、**Session**和**Token**这三个“神器”，它们就像我们在网络世界的身份证、通行证，帮服务器记住你是谁，都干了啥。今天咱就唠唠这仨到底是干啥的，有啥不一样！\n\n## 一、Cookie、Session和Token都干啥用？\n### 1.1 Cookie：浏览器帮你记事儿的小本本\nCookie就是服务器给浏览器塞的小纸条，存的都是些用户信息，像登录状态、浏览偏好啥的。举个例子，你第一次进某个网站，选了中文界面、深色模式，下次再访问，网站秒变你喜欢的样子，这背后就是Cookie在偷偷“记笔记”。不过这小纸条存你电脑里，容易被人偷看，所以得小心点用！\n\n### 1.2 Session：服务器的专属“私人档案库”\nSession相当于是服务器自己的“小账本”，专门用来存用户的会话数据。当你登录网站，服务器就给你开个“档案袋”，把你购物车有啥、订单到哪一步了这些信息全塞进去。但它咋知道这份档案归谁呢？靠的就是Cookie里的Session ID，相当于档案编号，浏览器每次带着编号来，服务器一看就知道：“哦！原来是你！”\n\n### 1.3 Token：万能通行令牌\nToken就是服务器发的一串乱码“令牌”，你拿着它去访问网站的各种服务，就像拿着身份证证明“我是我”。Token最大的好处是不用服务器记太多东西，你每次来，它只需要验证令牌是真是假就行。现在流行的前后端分离、第三方登录，基本都靠Token“打天下”，移动端APP更是离了它不行。\n\n## 二、Cookie、Session和Token，到底咋区分？\n### 2.1 都藏在哪？能存多少东西？\nCookie就住你电脑里，浏览器帮你保管。不过它个头很小气，一般不能超过4KB，而且一个网站最多也就存50个左右。\nSession住在服务器那边，理论上想存多少存多少，但服务器空间有限，存太多也顶不住。\nToken呢，既可以放在客户端（比如APP里），也能在每次请求的时候跟着一起“跑”，大小没严格限制，通常几百字节。\n\n### 2.2 安不安全？容易被偷吗？\nCookie因为在客户端，就像放在桌子上的纸条，很容易被人篡改。不过可以给它加把锁：\n- `HttpOnly`让JavaScript读不到它\n- `Secure`保证它只在安全的HTTPS通道里传送\n- `SameSite`防止被别人“冒名顶替”发请求\n\nSession数据在服务器，相对安全些，但要是Session ID被坏人搞到手，也能冒充你。\nToken用签名加密，一般改不了，但一旦被偷，坏人也能用，所以得设个有效期，到期就作废。\n\n### 2.3 怎么在网络里“传送”？\n- Cookie最“自觉”，浏览器每次发请求，都会自动把相关的Cookie带上，除非你特意限制它。\n- Session得靠Cookie帮忙传递Session ID，虽然也能藏在URL里，但容易暴露，不太安全。\n- Token就比较“自由”，常见的是放在请求头的`Authorization`字段里，也能塞到请求体或URL里，全看开发者咋安排。\n\n### 2.4 能用多久？啥时候过期？\n- Cookie想“活”多久，由服务器说了算。设置了`expires`或`max-age`，它就是“长寿型”，到期才失效；不设置的话，浏览器一关，它就“凉凉”。\n- Session和Cookie里的Session ID绑在一起，服务器还会设个“闲置超时”，比如30分钟没操作，直接清空档案。\n- Token出生的时候就被定好了“保质期”（像JWT的`exp`字段），过期就得重新申请新令牌。\n\n### 2.5 能不能适应复杂的网络环境？\n要是网站用的是分布式系统（多个服务器协同工作），Cookie + Session组合就有点“吃力”。因为Session存在服务器里，多个服务器之间得同步数据，不然容易“认不出”用户。\nToken就没这烦恼，它不需要服务器存啥，验证一下令牌是真是假就行，特别适合微服务、跨域这种复杂场景。\n\n## 三、生活里都在哪见过它们？\n### 3.1 Cookie的“日常工作”\n- 刷新闻的时候，为啥总给你推爱看的内容？Cookie在“搞事情”！它记住了你的兴趣标签。\n- 还有电商网站没登录时加进购物车的商品，也是Cookie临时存着。不过拿Cookie做广告追踪得小心，一不小心就违反隐私规定了。\n\n### 3.2 Session的“用武之地”\n电商平台的购物车、订单状态，后台管理系统的用户权限，在线聊天的实时状态……这些对安全性、实时性要求高的场景，都是Session的主场。服务器随时能查看、修改你的会话数据，还能强制你下线，安全感拉满！\n\n### 3.3 Token的“高光时刻”\n- 现在很多网站支持微信、GitHub一键登录，靠的就是Token在不同平台间“传话”。\n- 前后端分离项目里，前端和后端不在一个域名下，Token能轻松实现跨域认证。\n- 还有手机APP，没Cookie可用，Token就是它唯一的“身份认证官”。\n\n## 四、到底该选谁？\n简单来说：\n- Cookie适合存点小偏好、临时数据\n- Session适合对安全要求高、需要集中管理的场景\n- Token则是跨域、移动端、微服务的“心头好”\n\n实际开发中，大家经常把它们搭配着用，比如用Cookie传Session ID，或者把Token藏在Cookie里，增强安全性。具体咋选，还得根据业务需求，综合考虑安全、性能这些因素，找到最适合的方案！\n\n要是你对哪个部分还有疑问，或者想知道更多实战技巧，欢迎随时来唠嗑！ ","slug":"cookie-session-token","published":1,"updated":"2025-08-26T10:47:25.358Z","_id":"cmckk1h8m0000ioup68xi86ww","comments":1,"layout":"post","photos":[],"content":"<h1 id=\"一文读懂Cookie、Session和Token：原理、区别与应用场景\"><a href=\"#一文读懂Cookie、Session和Token：原理、区别与应用场景\" class=\"headerlink\" title=\"一文读懂Cookie、Session和Token：原理、区别与应用场景\"></a>一文读懂Cookie、Session和Token：原理、区别与应用场景</h1><p>咱上网冲浪的时候，天天和各种网站、APP打交道。但HTTP协议有个“毛病”——它记性不好，每次请求都像第一次见面，根本不记得之前和你聊过啥。为了解决这个问题，程序员们整出了<strong>Cookie</strong>、<strong>Session</strong>和<strong>Token</strong>这三个“神器”，它们就像我们在网络世界的身份证、通行证，帮服务器记住你是谁，都干了啥。今天咱就唠唠这仨到底是干啥的，有啥不一样！</p>\n<h2 id=\"一、Cookie、Session和Token都干啥用？\"><a href=\"#一、Cookie、Session和Token都干啥用？\" class=\"headerlink\" title=\"一、Cookie、Session和Token都干啥用？\"></a>一、Cookie、Session和Token都干啥用？</h2><h3 id=\"1-1-Cookie：浏览器帮你记事儿的小本本\"><a href=\"#1-1-Cookie：浏览器帮你记事儿的小本本\" class=\"headerlink\" title=\"1.1 Cookie：浏览器帮你记事儿的小本本\"></a>1.1 Cookie：浏览器帮你记事儿的小本本</h3><p>Cookie就是服务器给浏览器塞的小纸条，存的都是些用户信息，像登录状态、浏览偏好啥的。举个例子，你第一次进某个网站，选了中文界面、深色模式，下次再访问，网站秒变你喜欢的样子，这背后就是Cookie在偷偷“记笔记”。不过这小纸条存你电脑里，容易被人偷看，所以得小心点用！</p>\n<h3 id=\"1-2-Session：服务器的专属“私人档案库”\"><a href=\"#1-2-Session：服务器的专属“私人档案库”\" class=\"headerlink\" title=\"1.2 Session：服务器的专属“私人档案库”\"></a>1.2 Session：服务器的专属“私人档案库”</h3><p>Session相当于是服务器自己的“小账本”，专门用来存用户的会话数据。当你登录网站，服务器就给你开个“档案袋”，把你购物车有啥、订单到哪一步了这些信息全塞进去。但它咋知道这份档案归谁呢？靠的就是Cookie里的Session ID，相当于档案编号，浏览器每次带着编号来，服务器一看就知道：“哦！原来是你！”</p>\n<h3 id=\"1-3-Token：万能通行令牌\"><a href=\"#1-3-Token：万能通行令牌\" class=\"headerlink\" title=\"1.3 Token：万能通行令牌\"></a>1.3 Token：万能通行令牌</h3><p>Token就是服务器发的一串乱码“令牌”，你拿着它去访问网站的各种服务，就像拿着身份证证明“我是我”。Token最大的好处是不用服务器记太多东西，你每次来，它只需要验证令牌是真是假就行。现在流行的前后端分离、第三方登录，基本都靠Token“打天下”，移动端APP更是离了它不行。</p>\n<h2 id=\"二、Cookie、Session和Token，到底咋区分？\"><a href=\"#二、Cookie、Session和Token，到底咋区分？\" class=\"headerlink\" title=\"二、Cookie、Session和Token，到底咋区分？\"></a>二、Cookie、Session和Token，到底咋区分？</h2><h3 id=\"2-1-都藏在哪？能存多少东西？\"><a href=\"#2-1-都藏在哪？能存多少东西？\" class=\"headerlink\" title=\"2.1 都藏在哪？能存多少东西？\"></a>2.1 都藏在哪？能存多少东西？</h3><p>Cookie就住你电脑里，浏览器帮你保管。不过它个头很小气，一般不能超过4KB，而且一个网站最多也就存50个左右。<br>Session住在服务器那边，理论上想存多少存多少，但服务器空间有限，存太多也顶不住。<br>Token呢，既可以放在客户端（比如APP里），也能在每次请求的时候跟着一起“跑”，大小没严格限制，通常几百字节。</p>\n<h3 id=\"2-2-安不安全？容易被偷吗？\"><a href=\"#2-2-安不安全？容易被偷吗？\" class=\"headerlink\" title=\"2.2 安不安全？容易被偷吗？\"></a>2.2 安不安全？容易被偷吗？</h3><p>Cookie因为在客户端，就像放在桌子上的纸条，很容易被人篡改。不过可以给它加把锁：</p>\n<ul>\n<li><code>HttpOnly</code>让JavaScript读不到它</li>\n<li><code>Secure</code>保证它只在安全的HTTPS通道里传送</li>\n<li><code>SameSite</code>防止被别人“冒名顶替”发请求</li>\n</ul>\n<p>Session数据在服务器，相对安全些，但要是Session ID被坏人搞到手，也能冒充你。<br>Token用签名加密，一般改不了，但一旦被偷，坏人也能用，所以得设个有效期，到期就作废。</p>\n<h3 id=\"2-3-怎么在网络里“传送”？\"><a href=\"#2-3-怎么在网络里“传送”？\" class=\"headerlink\" title=\"2.3 怎么在网络里“传送”？\"></a>2.3 怎么在网络里“传送”？</h3><ul>\n<li>Cookie最“自觉”，浏览器每次发请求，都会自动把相关的Cookie带上，除非你特意限制它。</li>\n<li>Session得靠Cookie帮忙传递Session ID，虽然也能藏在URL里，但容易暴露，不太安全。</li>\n<li>Token就比较“自由”，常见的是放在请求头的<code>Authorization</code>字段里，也能塞到请求体或URL里，全看开发者咋安排。</li>\n</ul>\n<h3 id=\"2-4-能用多久？啥时候过期？\"><a href=\"#2-4-能用多久？啥时候过期？\" class=\"headerlink\" title=\"2.4 能用多久？啥时候过期？\"></a>2.4 能用多久？啥时候过期？</h3><ul>\n<li>Cookie想“活”多久，由服务器说了算。设置了<code>expires</code>或<code>max-age</code>，它就是“长寿型”，到期才失效；不设置的话，浏览器一关，它就“凉凉”。</li>\n<li>Session和Cookie里的Session ID绑在一起，服务器还会设个“闲置超时”，比如30分钟没操作，直接清空档案。</li>\n<li>Token出生的时候就被定好了“保质期”（像JWT的<code>exp</code>字段），过期就得重新申请新令牌。</li>\n</ul>\n<h3 id=\"2-5-能不能适应复杂的网络环境？\"><a href=\"#2-5-能不能适应复杂的网络环境？\" class=\"headerlink\" title=\"2.5 能不能适应复杂的网络环境？\"></a>2.5 能不能适应复杂的网络环境？</h3><p>要是网站用的是分布式系统（多个服务器协同工作），Cookie + Session组合就有点“吃力”。因为Session存在服务器里，多个服务器之间得同步数据，不然容易“认不出”用户。<br>Token就没这烦恼，它不需要服务器存啥，验证一下令牌是真是假就行，特别适合微服务、跨域这种复杂场景。</p>\n<h2 id=\"三、生活里都在哪见过它们？\"><a href=\"#三、生活里都在哪见过它们？\" class=\"headerlink\" title=\"三、生活里都在哪见过它们？\"></a>三、生活里都在哪见过它们？</h2><h3 id=\"3-1-Cookie的“日常工作”\"><a href=\"#3-1-Cookie的“日常工作”\" class=\"headerlink\" title=\"3.1 Cookie的“日常工作”\"></a>3.1 Cookie的“日常工作”</h3><ul>\n<li>刷新闻的时候，为啥总给你推爱看的内容？Cookie在“搞事情”！它记住了你的兴趣标签。</li>\n<li>还有电商网站没登录时加进购物车的商品，也是Cookie临时存着。不过拿Cookie做广告追踪得小心，一不小心就违反隐私规定了。</li>\n</ul>\n<h3 id=\"3-2-Session的“用武之地”\"><a href=\"#3-2-Session的“用武之地”\" class=\"headerlink\" title=\"3.2 Session的“用武之地”\"></a>3.2 Session的“用武之地”</h3><p>电商平台的购物车、订单状态，后台管理系统的用户权限，在线聊天的实时状态……这些对安全性、实时性要求高的场景，都是Session的主场。服务器随时能查看、修改你的会话数据，还能强制你下线，安全感拉满！</p>\n<h3 id=\"3-3-Token的“高光时刻”\"><a href=\"#3-3-Token的“高光时刻”\" class=\"headerlink\" title=\"3.3 Token的“高光时刻”\"></a>3.3 Token的“高光时刻”</h3><ul>\n<li>现在很多网站支持微信、GitHub一键登录，靠的就是Token在不同平台间“传话”。</li>\n<li>前后端分离项目里，前端和后端不在一个域名下，Token能轻松实现跨域认证。</li>\n<li>还有手机APP，没Cookie可用，Token就是它唯一的“身份认证官”。</li>\n</ul>\n<h2 id=\"四、到底该选谁？\"><a href=\"#四、到底该选谁？\" class=\"headerlink\" title=\"四、到底该选谁？\"></a>四、到底该选谁？</h2><p>简单来说：</p>\n<ul>\n<li>Cookie适合存点小偏好、临时数据</li>\n<li>Session适合对安全要求高、需要集中管理的场景</li>\n<li>Token则是跨域、移动端、微服务的“心头好”</li>\n</ul>\n<p>实际开发中，大家经常把它们搭配着用，比如用Cookie传Session ID，或者把Token藏在Cookie里，增强安全性。具体咋选，还得根据业务需求，综合考虑安全、性能这些因素，找到最适合的方案！</p>\n<p>要是你对哪个部分还有疑问，或者想知道更多实战技巧，欢迎随时来唠嗑！ </p>\n","excerpt":"","more":"<h1 id=\"一文读懂Cookie、Session和Token：原理、区别与应用场景\"><a href=\"#一文读懂Cookie、Session和Token：原理、区别与应用场景\" class=\"headerlink\" title=\"一文读懂Cookie、Session和Token：原理、区别与应用场景\"></a>一文读懂Cookie、Session和Token：原理、区别与应用场景</h1><p>咱上网冲浪的时候，天天和各种网站、APP打交道。但HTTP协议有个“毛病”——它记性不好，每次请求都像第一次见面，根本不记得之前和你聊过啥。为了解决这个问题，程序员们整出了<strong>Cookie</strong>、<strong>Session</strong>和<strong>Token</strong>这三个“神器”，它们就像我们在网络世界的身份证、通行证，帮服务器记住你是谁，都干了啥。今天咱就唠唠这仨到底是干啥的，有啥不一样！</p>\n<h2 id=\"一、Cookie、Session和Token都干啥用？\"><a href=\"#一、Cookie、Session和Token都干啥用？\" class=\"headerlink\" title=\"一、Cookie、Session和Token都干啥用？\"></a>一、Cookie、Session和Token都干啥用？</h2><h3 id=\"1-1-Cookie：浏览器帮你记事儿的小本本\"><a href=\"#1-1-Cookie：浏览器帮你记事儿的小本本\" class=\"headerlink\" title=\"1.1 Cookie：浏览器帮你记事儿的小本本\"></a>1.1 Cookie：浏览器帮你记事儿的小本本</h3><p>Cookie就是服务器给浏览器塞的小纸条，存的都是些用户信息，像登录状态、浏览偏好啥的。举个例子，你第一次进某个网站，选了中文界面、深色模式，下次再访问，网站秒变你喜欢的样子，这背后就是Cookie在偷偷“记笔记”。不过这小纸条存你电脑里，容易被人偷看，所以得小心点用！</p>\n<h3 id=\"1-2-Session：服务器的专属“私人档案库”\"><a href=\"#1-2-Session：服务器的专属“私人档案库”\" class=\"headerlink\" title=\"1.2 Session：服务器的专属“私人档案库”\"></a>1.2 Session：服务器的专属“私人档案库”</h3><p>Session相当于是服务器自己的“小账本”，专门用来存用户的会话数据。当你登录网站，服务器就给你开个“档案袋”，把你购物车有啥、订单到哪一步了这些信息全塞进去。但它咋知道这份档案归谁呢？靠的就是Cookie里的Session ID，相当于档案编号，浏览器每次带着编号来，服务器一看就知道：“哦！原来是你！”</p>\n<h3 id=\"1-3-Token：万能通行令牌\"><a href=\"#1-3-Token：万能通行令牌\" class=\"headerlink\" title=\"1.3 Token：万能通行令牌\"></a>1.3 Token：万能通行令牌</h3><p>Token就是服务器发的一串乱码“令牌”，你拿着它去访问网站的各种服务，就像拿着身份证证明“我是我”。Token最大的好处是不用服务器记太多东西，你每次来，它只需要验证令牌是真是假就行。现在流行的前后端分离、第三方登录，基本都靠Token“打天下”，移动端APP更是离了它不行。</p>\n<h2 id=\"二、Cookie、Session和Token，到底咋区分？\"><a href=\"#二、Cookie、Session和Token，到底咋区分？\" class=\"headerlink\" title=\"二、Cookie、Session和Token，到底咋区分？\"></a>二、Cookie、Session和Token，到底咋区分？</h2><h3 id=\"2-1-都藏在哪？能存多少东西？\"><a href=\"#2-1-都藏在哪？能存多少东西？\" class=\"headerlink\" title=\"2.1 都藏在哪？能存多少东西？\"></a>2.1 都藏在哪？能存多少东西？</h3><p>Cookie就住你电脑里，浏览器帮你保管。不过它个头很小气，一般不能超过4KB，而且一个网站最多也就存50个左右。<br>Session住在服务器那边，理论上想存多少存多少，但服务器空间有限，存太多也顶不住。<br>Token呢，既可以放在客户端（比如APP里），也能在每次请求的时候跟着一起“跑”，大小没严格限制，通常几百字节。</p>\n<h3 id=\"2-2-安不安全？容易被偷吗？\"><a href=\"#2-2-安不安全？容易被偷吗？\" class=\"headerlink\" title=\"2.2 安不安全？容易被偷吗？\"></a>2.2 安不安全？容易被偷吗？</h3><p>Cookie因为在客户端，就像放在桌子上的纸条，很容易被人篡改。不过可以给它加把锁：</p>\n<ul>\n<li><code>HttpOnly</code>让JavaScript读不到它</li>\n<li><code>Secure</code>保证它只在安全的HTTPS通道里传送</li>\n<li><code>SameSite</code>防止被别人“冒名顶替”发请求</li>\n</ul>\n<p>Session数据在服务器，相对安全些，但要是Session ID被坏人搞到手，也能冒充你。<br>Token用签名加密，一般改不了，但一旦被偷，坏人也能用，所以得设个有效期，到期就作废。</p>\n<h3 id=\"2-3-怎么在网络里“传送”？\"><a href=\"#2-3-怎么在网络里“传送”？\" class=\"headerlink\" title=\"2.3 怎么在网络里“传送”？\"></a>2.3 怎么在网络里“传送”？</h3><ul>\n<li>Cookie最“自觉”，浏览器每次发请求，都会自动把相关的Cookie带上，除非你特意限制它。</li>\n<li>Session得靠Cookie帮忙传递Session ID，虽然也能藏在URL里，但容易暴露，不太安全。</li>\n<li>Token就比较“自由”，常见的是放在请求头的<code>Authorization</code>字段里，也能塞到请求体或URL里，全看开发者咋安排。</li>\n</ul>\n<h3 id=\"2-4-能用多久？啥时候过期？\"><a href=\"#2-4-能用多久？啥时候过期？\" class=\"headerlink\" title=\"2.4 能用多久？啥时候过期？\"></a>2.4 能用多久？啥时候过期？</h3><ul>\n<li>Cookie想“活”多久，由服务器说了算。设置了<code>expires</code>或<code>max-age</code>，它就是“长寿型”，到期才失效；不设置的话，浏览器一关，它就“凉凉”。</li>\n<li>Session和Cookie里的Session ID绑在一起，服务器还会设个“闲置超时”，比如30分钟没操作，直接清空档案。</li>\n<li>Token出生的时候就被定好了“保质期”（像JWT的<code>exp</code>字段），过期就得重新申请新令牌。</li>\n</ul>\n<h3 id=\"2-5-能不能适应复杂的网络环境？\"><a href=\"#2-5-能不能适应复杂的网络环境？\" class=\"headerlink\" title=\"2.5 能不能适应复杂的网络环境？\"></a>2.5 能不能适应复杂的网络环境？</h3><p>要是网站用的是分布式系统（多个服务器协同工作），Cookie + Session组合就有点“吃力”。因为Session存在服务器里，多个服务器之间得同步数据，不然容易“认不出”用户。<br>Token就没这烦恼，它不需要服务器存啥，验证一下令牌是真是假就行，特别适合微服务、跨域这种复杂场景。</p>\n<h2 id=\"三、生活里都在哪见过它们？\"><a href=\"#三、生活里都在哪见过它们？\" class=\"headerlink\" title=\"三、生活里都在哪见过它们？\"></a>三、生活里都在哪见过它们？</h2><h3 id=\"3-1-Cookie的“日常工作”\"><a href=\"#3-1-Cookie的“日常工作”\" class=\"headerlink\" title=\"3.1 Cookie的“日常工作”\"></a>3.1 Cookie的“日常工作”</h3><ul>\n<li>刷新闻的时候，为啥总给你推爱看的内容？Cookie在“搞事情”！它记住了你的兴趣标签。</li>\n<li>还有电商网站没登录时加进购物车的商品，也是Cookie临时存着。不过拿Cookie做广告追踪得小心，一不小心就违反隐私规定了。</li>\n</ul>\n<h3 id=\"3-2-Session的“用武之地”\"><a href=\"#3-2-Session的“用武之地”\" class=\"headerlink\" title=\"3.2 Session的“用武之地”\"></a>3.2 Session的“用武之地”</h3><p>电商平台的购物车、订单状态，后台管理系统的用户权限，在线聊天的实时状态……这些对安全性、实时性要求高的场景，都是Session的主场。服务器随时能查看、修改你的会话数据，还能强制你下线，安全感拉满！</p>\n<h3 id=\"3-3-Token的“高光时刻”\"><a href=\"#3-3-Token的“高光时刻”\" class=\"headerlink\" title=\"3.3 Token的“高光时刻”\"></a>3.3 Token的“高光时刻”</h3><ul>\n<li>现在很多网站支持微信、GitHub一键登录，靠的就是Token在不同平台间“传话”。</li>\n<li>前后端分离项目里，前端和后端不在一个域名下，Token能轻松实现跨域认证。</li>\n<li>还有手机APP，没Cookie可用，Token就是它唯一的“身份认证官”。</li>\n</ul>\n<h2 id=\"四、到底该选谁？\"><a href=\"#四、到底该选谁？\" class=\"headerlink\" title=\"四、到底该选谁？\"></a>四、到底该选谁？</h2><p>简单来说：</p>\n<ul>\n<li>Cookie适合存点小偏好、临时数据</li>\n<li>Session适合对安全要求高、需要集中管理的场景</li>\n<li>Token则是跨域、移动端、微服务的“心头好”</li>\n</ul>\n<p>实际开发中，大家经常把它们搭配着用，比如用Cookie传Session ID，或者把Token藏在Cookie里，增强安全性。具体咋选，还得根据业务需求，综合考虑安全、性能这些因素，找到最适合的方案！</p>\n<p>要是你对哪个部分还有疑问，或者想知道更多实战技巧，欢迎随时来唠嗑！ </p>\n"},{"title":"从 Vuex 到 Pinia：Vue 3 状态管理的全面升级","date":"2025-07-01T13:51:10.000Z","keywords":["Vuex","Pinia","Vue"],"banner_img":"/imgs/baners/pinia.png","index_img":"/imgs/baners/pinia.png","_content":"\n\n在Vue 3的“江湖”里，状态管理这块可是发生了大变化！当咱们从Vue 2“升级打怪”到Vue 3，以前常用的Vuex逐渐被更“香”的Pinia替代了。今天就来唠唠Vuex和Pinia到底有啥不一样，帮大家轻松拿捏新的状态管理姿势！\n\n\n## 1. API风格与设计：告别繁琐，拥抱简洁\nVuex就像个“老学究”，用的是类似Redux的那一套，非得让开发者把逻辑按`mutations`、`actions`、`getters`这些规矩分好类。虽然确实规范，但写起代码来可太啰嗦了，一堆模板代码看着就头大！  \n\nPinia就不一样，它紧跟Vue 3的“潮流”，用组合式API设计，直接把`mutations`“踢出局”（只保留`state`、`getters`、`actions`）。代码一下子变得超扁平、超直观，再也不用为那些复杂的条条框框费脑筋，开发起来轻松多啦！\n\n\n## 2. TypeScript支持：天生适配，用着超爽\n要是你用Vuex搭配TypeScript，那可得费点劲！得额外捣鼓不少配置和类型定义，不然根本用不顺手，就像给自行车硬装上火箭发动机，麻烦得很。  \n\nPinia可就贴心多了，它对TypeScript是“真爱”，天生适配！在定义store的时候，类型直接就能自动推导出来，完全不用手动写那些复杂的类型声明。这就好比有个贴心小助手，帮你把繁琐的活儿都干了，开发效率直接起飞，代码的安全性也拉满！\n\n\n## 3. 代码结构：新旧语法大PK\n先看看Vuex的store代码长啥样：  \n```javascript\n// Vuex store示例\nexport default new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment(state) {\n      state.count++;\n    }\n  },\n  actions: {\n    incrementAsync({ commit }) {\n      setTimeout(() => commit('increment'), 1000);\n    }\n  },\n  getters: {\n    doubleCount: state => state.count * 2\n  }\n});\n```  \n\n再瞅瞅Pinia的：  \n```javascript\n// Pinia store示例\nimport { defineStore } from 'pinia';\n\nexport const useCounterStore = defineStore('counter', {\n  state: () => ({\n    count: 0\n  }),\n  actions: {\n    increment() {\n      this.count++;\n    },\n    incrementAsync() {\n      setTimeout(() => this.increment(), 1000);\n    }\n  },\n  getters: {\n    doubleCount: state => state.count * 2\n  }\n});\n```  \n\n这么一对比，是不是瞬间觉得Pinia的代码清爽多了？没有那么多复杂的层级和重复的结构，就像把乱糟糟的房间收拾得整整齐齐，看着就舒服，写代码也更顺手！\n\n\n## 4. 响应式原理：Proxy带来的“黑科技”\nVuex用的是Vue 2的`Object.defineProperty`实现响应式，这就像给数据安了个“老旧监控”，在处理深层嵌套数据更新的时候，经常会“掉链子”，数据变了，视图却没反应，让人干着急。  \n\nPinia可就“高大上”了，它基于Vue 3的Proxy，相当于给数据配了个“智能管家”！不仅支持直接修改`state`，不用再走`mutations`那些弯弯绕绕，而且响应式超高效、超准确，数据一有风吹草动，它立马就能感知到，视图更新那叫一个快！\n\n\n## 5. 模块化方式：轻松管理，互不干扰\nVuex拆分store靠`modules`选项，但是模块之间的关系就像一团乱麻，命名空间管理起来也特别麻烦，稍不注意就容易“翻车”，把代码搞得一团糟。  \n\nPinia就聪明多了，每个store都是独立的“小个体”，用`defineStore`定义就行。模块之间井水不犯河水，完全解耦，命名空间也自动安排得明明白白。开发者管理起状态逻辑来，就像整理自己的小抽屉，想找啥一目了然，别提多轻松了！\n\n\n## 6. 插件系统：简单扩展，功能拉满\nVuex的插件机制复杂得很，开发者要是想实现点特定功能，就得自己写中间件或者插件，跟“造轮子”似的，费时又费力。  \n\nPinia的插件系统就“傻瓜式”多了，特别简洁明了。不管是扩展store功能，还是实现状态持久化，都超容易。比如用`pinia-plugin-persistedstate`插件，分分钟就能把状态存起来，就像用手机APP，点点按钮就能搞定，轻松实现功能自由！\n\n\n## 7. 与组合式API的集成：无缝配合，丝滑流畅\n在Vuex里想用组合式API？那得通过`useStore`获取store实例，写法又长又麻烦，就像绕了个大弯才能到达目的地。  \n\nPinia和组合式API简直是“最佳拍档”！直接在`setup`函数里调用`useStore()`就能拿到store，代码写起来行云流水，一点都不卡顿，用起来丝滑得不行！\n\n\n## 8. 开发工具支持：调试神器，效率翻倍\nVuex调试得靠Vue DevTools，但用起来总觉得差点意思，就像用一把不太顺手的钥匙开锁，费半天劲。  \n\nPinia和Vue DevTools那可是“深度绑定”！支持时间旅行调试，还能轻松追踪store变化。调试的时候就像拥有了“时光回溯”的超能力，哪里出问题一目了然，开发效率直接翻倍！\n\n\n## 9. 状态持久化：一键配置，轻松搞定\nVuex想实现状态持久化？得额外安装`vuex-persistedstate`插件，一顿操作猛如虎，才能把数据存起来。  \n\nPinia就简单多了，用`pinia-plugin-persistedstate`插件，简单配置一下，数据保存妥妥的，就像给数据加了个“保险箱”，一键操作，省心又省力！\n\n\n## 升级建议\n1. **慢慢过渡**：在Vue 3项目里，别着急把Vuex全换掉，可以Vuex和Pinia一起用，慢慢把旧的store迁移到Pinia，稳扎稳打，降低升级风险。  \n2. **整理代码**：把Vuex里的`mutations`合并到`actions`里，让代码结构更贴合Pinia的风格，就像给旧衣服改个新款式，焕然一新！  \n3. **用好组合式API**：充分发挥Pinia和组合式API的“CP”优势，用`setup`函数写代码，灵活安排逻辑，怎么方便怎么来！  \n4. **享受类型安全**：Pinia的类型推导超厉害，一定要好好利用，减少手动写类型声明的麻烦，让代码又快又安全！  \n\n\n从Vuex换成Pinia，可不只是换个工具那么简单，更是开发体验的大升级！Pinia凭借简洁的设计、强大的功能，还有对Vue 3的“完美适配”，妥妥成了Vue开发者状态管理的“新宠”。希望这篇文章能帮你快速上手Pinia，在Vue 3的开发路上一路“狂飙”！\n# 从Vuex到Pinia：Vue 3状态管理的全面升级\n\n家人们！在Vue 3的“江湖”里，状态管理这块可是发生了大变化！当咱们从Vue 2“升级打怪”到Vue 3，以前常用的Vuex逐渐被更“香”的Pinia替代了。今天就来唠唠Vuex和Pinia到底有啥不一样，帮大家轻松拿捏新的状态管理姿势！\n\n\n## 1. API风格与设计：告别繁琐，拥抱简洁\nVuex就像个“老学究”，用的是类似Redux的那一套，非得让开发者把逻辑按`mutations`、`actions`、`getters`这些规矩分好类。虽然确实规范，但写起代码来可太啰嗦了，一堆模板代码看着就头大！  \n\nPinia就不一样，它紧跟Vue 3的“潮流”，用组合式API设计，直接把`mutations`“踢出局”（只保留`state`、`getters`、`actions`）。代码一下子变得超扁平、超直观，再也不用为那些复杂的条条框框费脑筋，开发起来轻松多啦！\n\n\n## 2. TypeScript支持：天生适配，用着超爽\n要是你用Vuex搭配TypeScript，那可得费点劲！得额外捣鼓不少配置和类型定义，不然根本用不顺手，就像给自行车硬装上火箭发动机，麻烦得很。  \n\nPinia可就贴心多了，它对TypeScript是“真爱”，天生适配！在定义store的时候，类型直接就能自动推导出来，完全不用手动写那些复杂的类型声明。这就好比有个贴心小助手，帮你把繁琐的活儿都干了，开发效率直接起飞，代码的安全性也拉满！\n\n\n## 3. 代码结构：新旧语法大PK\n先看看Vuex的store代码长啥样：  \n```javascript\n// Vuex store示例\nexport default new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment(state) {\n      state.count++;\n    }\n  },\n  actions: {\n    incrementAsync({ commit }) {\n      setTimeout(() => commit('increment'), 1000);\n    }\n  },\n  getters: {\n    doubleCount: state => state.count * 2\n  }\n});\n```  \n\n再瞅瞅Pinia的：  \n```javascript\n// Pinia store示例\nimport { defineStore } from 'pinia';\n\nexport const useCounterStore = defineStore('counter', {\n  state: () => ({\n    count: 0\n  }),\n  actions: {\n    increment() {\n      this.count++;\n    },\n    incrementAsync() {\n      setTimeout(() => this.increment(), 1000);\n    }\n  },\n  getters: {\n    doubleCount: state => state.count * 2\n  }\n});\n```  \n\n这么一对比，是不是瞬间觉得Pinia的代码清爽多了？没有那么多复杂的层级和重复的结构，就像把乱糟糟的房间收拾得整整齐齐，看着就舒服，写代码也更顺手！\n\n\n## 4. 响应式原理：Proxy带来的“黑科技”\nVuex用的是Vue 2的`Object.defineProperty`实现响应式，这就像给数据安了个“老旧监控”，在处理深层嵌套数据更新的时候，经常会“掉链子”，数据变了，视图却没反应，让人干着急。  \n\nPinia可就“高大上”了，它基于Vue 3的Proxy，相当于给数据配了个“智能管家”！不仅支持直接修改`state`，不用再走`mutations`那些弯弯绕绕，而且响应式超高效、超准确，数据一有风吹草动，它立马就能感知到，视图更新那叫一个快！\n\n\n## 5. 模块化方式：轻松管理，互不干扰\nVuex拆分store靠`modules`选项，但是模块之间的关系就像一团乱麻，命名空间管理起来也特别麻烦，稍不注意就容易“翻车”，把代码搞得一团糟。  \n\nPinia就聪明多了，每个store都是独立的“小个体”，用`defineStore`定义就行。模块之间井水不犯河水，完全解耦，命名空间也自动安排得明明白白。开发者管理起状态逻辑来，就像整理自己的小抽屉，想找啥一目了然，别提多轻松了！\n\n\n## 6. 插件系统：简单扩展，功能拉满\nVuex的插件机制复杂得很，开发者要是想实现点特定功能，就得自己写中间件或者插件，跟“造轮子”似的，费时又费力。  \n\nPinia的插件系统就“傻瓜式”多了，特别简洁明了。不管是扩展store功能，还是实现状态持久化，都超容易。比如用`pinia-plugin-persistedstate`插件，分分钟就能把状态存起来，就像用手机APP，点点按钮就能搞定，轻松实现功能自由！\n\n\n## 7. 与组合式API的集成：无缝配合，丝滑流畅\n在Vuex里想用组合式API？那得通过`useStore`获取store实例，写法又长又麻烦，就像绕了个大弯才能到达目的地。  \n\nPinia和组合式API简直是“最佳拍档”！直接在`setup`函数里调用`useStore()`就能拿到store，代码写起来行云流水，一点都不卡顿，用起来丝滑得不行！\n\n\n## 8. 开发工具支持：调试神器，效率翻倍\nVuex调试得靠Vue DevTools，但用起来总觉得差点意思，就像用一把不太顺手的钥匙开锁，费半天劲。  \n\nPinia和Vue DevTools那可是“深度绑定”！支持时间旅行调试，还能轻松追踪store变化。调试的时候就像拥有了“时光回溯”的超能力，哪里出问题一目了然，开发效率直接翻倍！\n\n\n## 9. 状态持久化：一键配置，轻松搞定\nVuex想实现状态持久化？得额外安装`vuex-persistedstate`插件，一顿操作猛如虎，才能把数据存起来。  \n\nPinia就简单多了，用`pinia-plugin-persistedstate`插件，简单配置一下，数据保存妥妥的，就像给数据加了个“保险箱”，一键操作，省心又省力！\n\n\n## 升级建议\n1. **慢慢过渡**：在Vue 3项目里，别着急把Vuex全换掉，可以Vuex和Pinia一起用，慢慢把旧的store迁移到Pinia，稳扎稳打，降低升级风险。  \n2. **整理代码**：把Vuex里的`mutations`合并到`actions`里，让代码结构更贴合Pinia的风格，就像给旧衣服改个新款式，焕然一新！  \n3. **用好组合式API**：充分发挥Pinia和组合式API的“CP”优势，用`setup`函数写代码，灵活安排逻辑，怎么方便怎么来！  \n4. **享受类型安全**：Pinia的类型推导超厉害，一定要好好利用，减少手动写类型声明的麻烦，让代码又快又安全！  \n\n\n从Vuex换成Pinia，可不只是换个工具那么简单，更是开发体验的大升级！Pinia凭借简洁的设计、强大的功能，还有对Vue 3的“完美适配”，妥妥成了Vue开发者状态管理的“新宠”。希望这篇文章能帮你快速上手Pinia，在Vue 3的开发路上一路“狂飙”！","source":"_posts/from-vuex-to-pinia.md","raw":"---\ntitle: 从 Vuex 到 Pinia：Vue 3 状态管理的全面升级\ndate: 2025-07-01 21:51:10\ntags: [Vuex, Pinia, Vue]\nkeywords: [Vuex, Pinia, Vue]\ncategory: Web开发\nbanner_img: /imgs/baners/pinia.png\nindex_img: /imgs/baners/pinia.png\n---\n\n\n在Vue 3的“江湖”里，状态管理这块可是发生了大变化！当咱们从Vue 2“升级打怪”到Vue 3，以前常用的Vuex逐渐被更“香”的Pinia替代了。今天就来唠唠Vuex和Pinia到底有啥不一样，帮大家轻松拿捏新的状态管理姿势！\n\n\n## 1. API风格与设计：告别繁琐，拥抱简洁\nVuex就像个“老学究”，用的是类似Redux的那一套，非得让开发者把逻辑按`mutations`、`actions`、`getters`这些规矩分好类。虽然确实规范，但写起代码来可太啰嗦了，一堆模板代码看着就头大！  \n\nPinia就不一样，它紧跟Vue 3的“潮流”，用组合式API设计，直接把`mutations`“踢出局”（只保留`state`、`getters`、`actions`）。代码一下子变得超扁平、超直观，再也不用为那些复杂的条条框框费脑筋，开发起来轻松多啦！\n\n\n## 2. TypeScript支持：天生适配，用着超爽\n要是你用Vuex搭配TypeScript，那可得费点劲！得额外捣鼓不少配置和类型定义，不然根本用不顺手，就像给自行车硬装上火箭发动机，麻烦得很。  \n\nPinia可就贴心多了，它对TypeScript是“真爱”，天生适配！在定义store的时候，类型直接就能自动推导出来，完全不用手动写那些复杂的类型声明。这就好比有个贴心小助手，帮你把繁琐的活儿都干了，开发效率直接起飞，代码的安全性也拉满！\n\n\n## 3. 代码结构：新旧语法大PK\n先看看Vuex的store代码长啥样：  \n```javascript\n// Vuex store示例\nexport default new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment(state) {\n      state.count++;\n    }\n  },\n  actions: {\n    incrementAsync({ commit }) {\n      setTimeout(() => commit('increment'), 1000);\n    }\n  },\n  getters: {\n    doubleCount: state => state.count * 2\n  }\n});\n```  \n\n再瞅瞅Pinia的：  \n```javascript\n// Pinia store示例\nimport { defineStore } from 'pinia';\n\nexport const useCounterStore = defineStore('counter', {\n  state: () => ({\n    count: 0\n  }),\n  actions: {\n    increment() {\n      this.count++;\n    },\n    incrementAsync() {\n      setTimeout(() => this.increment(), 1000);\n    }\n  },\n  getters: {\n    doubleCount: state => state.count * 2\n  }\n});\n```  \n\n这么一对比，是不是瞬间觉得Pinia的代码清爽多了？没有那么多复杂的层级和重复的结构，就像把乱糟糟的房间收拾得整整齐齐，看着就舒服，写代码也更顺手！\n\n\n## 4. 响应式原理：Proxy带来的“黑科技”\nVuex用的是Vue 2的`Object.defineProperty`实现响应式，这就像给数据安了个“老旧监控”，在处理深层嵌套数据更新的时候，经常会“掉链子”，数据变了，视图却没反应，让人干着急。  \n\nPinia可就“高大上”了，它基于Vue 3的Proxy，相当于给数据配了个“智能管家”！不仅支持直接修改`state`，不用再走`mutations`那些弯弯绕绕，而且响应式超高效、超准确，数据一有风吹草动，它立马就能感知到，视图更新那叫一个快！\n\n\n## 5. 模块化方式：轻松管理，互不干扰\nVuex拆分store靠`modules`选项，但是模块之间的关系就像一团乱麻，命名空间管理起来也特别麻烦，稍不注意就容易“翻车”，把代码搞得一团糟。  \n\nPinia就聪明多了，每个store都是独立的“小个体”，用`defineStore`定义就行。模块之间井水不犯河水，完全解耦，命名空间也自动安排得明明白白。开发者管理起状态逻辑来，就像整理自己的小抽屉，想找啥一目了然，别提多轻松了！\n\n\n## 6. 插件系统：简单扩展，功能拉满\nVuex的插件机制复杂得很，开发者要是想实现点特定功能，就得自己写中间件或者插件，跟“造轮子”似的，费时又费力。  \n\nPinia的插件系统就“傻瓜式”多了，特别简洁明了。不管是扩展store功能，还是实现状态持久化，都超容易。比如用`pinia-plugin-persistedstate`插件，分分钟就能把状态存起来，就像用手机APP，点点按钮就能搞定，轻松实现功能自由！\n\n\n## 7. 与组合式API的集成：无缝配合，丝滑流畅\n在Vuex里想用组合式API？那得通过`useStore`获取store实例，写法又长又麻烦，就像绕了个大弯才能到达目的地。  \n\nPinia和组合式API简直是“最佳拍档”！直接在`setup`函数里调用`useStore()`就能拿到store，代码写起来行云流水，一点都不卡顿，用起来丝滑得不行！\n\n\n## 8. 开发工具支持：调试神器，效率翻倍\nVuex调试得靠Vue DevTools，但用起来总觉得差点意思，就像用一把不太顺手的钥匙开锁，费半天劲。  \n\nPinia和Vue DevTools那可是“深度绑定”！支持时间旅行调试，还能轻松追踪store变化。调试的时候就像拥有了“时光回溯”的超能力，哪里出问题一目了然，开发效率直接翻倍！\n\n\n## 9. 状态持久化：一键配置，轻松搞定\nVuex想实现状态持久化？得额外安装`vuex-persistedstate`插件，一顿操作猛如虎，才能把数据存起来。  \n\nPinia就简单多了，用`pinia-plugin-persistedstate`插件，简单配置一下，数据保存妥妥的，就像给数据加了个“保险箱”，一键操作，省心又省力！\n\n\n## 升级建议\n1. **慢慢过渡**：在Vue 3项目里，别着急把Vuex全换掉，可以Vuex和Pinia一起用，慢慢把旧的store迁移到Pinia，稳扎稳打，降低升级风险。  \n2. **整理代码**：把Vuex里的`mutations`合并到`actions`里，让代码结构更贴合Pinia的风格，就像给旧衣服改个新款式，焕然一新！  \n3. **用好组合式API**：充分发挥Pinia和组合式API的“CP”优势，用`setup`函数写代码，灵活安排逻辑，怎么方便怎么来！  \n4. **享受类型安全**：Pinia的类型推导超厉害，一定要好好利用，减少手动写类型声明的麻烦，让代码又快又安全！  \n\n\n从Vuex换成Pinia，可不只是换个工具那么简单，更是开发体验的大升级！Pinia凭借简洁的设计、强大的功能，还有对Vue 3的“完美适配”，妥妥成了Vue开发者状态管理的“新宠”。希望这篇文章能帮你快速上手Pinia，在Vue 3的开发路上一路“狂飙”！\n# 从Vuex到Pinia：Vue 3状态管理的全面升级\n\n家人们！在Vue 3的“江湖”里，状态管理这块可是发生了大变化！当咱们从Vue 2“升级打怪”到Vue 3，以前常用的Vuex逐渐被更“香”的Pinia替代了。今天就来唠唠Vuex和Pinia到底有啥不一样，帮大家轻松拿捏新的状态管理姿势！\n\n\n## 1. API风格与设计：告别繁琐，拥抱简洁\nVuex就像个“老学究”，用的是类似Redux的那一套，非得让开发者把逻辑按`mutations`、`actions`、`getters`这些规矩分好类。虽然确实规范，但写起代码来可太啰嗦了，一堆模板代码看着就头大！  \n\nPinia就不一样，它紧跟Vue 3的“潮流”，用组合式API设计，直接把`mutations`“踢出局”（只保留`state`、`getters`、`actions`）。代码一下子变得超扁平、超直观，再也不用为那些复杂的条条框框费脑筋，开发起来轻松多啦！\n\n\n## 2. TypeScript支持：天生适配，用着超爽\n要是你用Vuex搭配TypeScript，那可得费点劲！得额外捣鼓不少配置和类型定义，不然根本用不顺手，就像给自行车硬装上火箭发动机，麻烦得很。  \n\nPinia可就贴心多了，它对TypeScript是“真爱”，天生适配！在定义store的时候，类型直接就能自动推导出来，完全不用手动写那些复杂的类型声明。这就好比有个贴心小助手，帮你把繁琐的活儿都干了，开发效率直接起飞，代码的安全性也拉满！\n\n\n## 3. 代码结构：新旧语法大PK\n先看看Vuex的store代码长啥样：  \n```javascript\n// Vuex store示例\nexport default new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment(state) {\n      state.count++;\n    }\n  },\n  actions: {\n    incrementAsync({ commit }) {\n      setTimeout(() => commit('increment'), 1000);\n    }\n  },\n  getters: {\n    doubleCount: state => state.count * 2\n  }\n});\n```  \n\n再瞅瞅Pinia的：  \n```javascript\n// Pinia store示例\nimport { defineStore } from 'pinia';\n\nexport const useCounterStore = defineStore('counter', {\n  state: () => ({\n    count: 0\n  }),\n  actions: {\n    increment() {\n      this.count++;\n    },\n    incrementAsync() {\n      setTimeout(() => this.increment(), 1000);\n    }\n  },\n  getters: {\n    doubleCount: state => state.count * 2\n  }\n});\n```  \n\n这么一对比，是不是瞬间觉得Pinia的代码清爽多了？没有那么多复杂的层级和重复的结构，就像把乱糟糟的房间收拾得整整齐齐，看着就舒服，写代码也更顺手！\n\n\n## 4. 响应式原理：Proxy带来的“黑科技”\nVuex用的是Vue 2的`Object.defineProperty`实现响应式，这就像给数据安了个“老旧监控”，在处理深层嵌套数据更新的时候，经常会“掉链子”，数据变了，视图却没反应，让人干着急。  \n\nPinia可就“高大上”了，它基于Vue 3的Proxy，相当于给数据配了个“智能管家”！不仅支持直接修改`state`，不用再走`mutations`那些弯弯绕绕，而且响应式超高效、超准确，数据一有风吹草动，它立马就能感知到，视图更新那叫一个快！\n\n\n## 5. 模块化方式：轻松管理，互不干扰\nVuex拆分store靠`modules`选项，但是模块之间的关系就像一团乱麻，命名空间管理起来也特别麻烦，稍不注意就容易“翻车”，把代码搞得一团糟。  \n\nPinia就聪明多了，每个store都是独立的“小个体”，用`defineStore`定义就行。模块之间井水不犯河水，完全解耦，命名空间也自动安排得明明白白。开发者管理起状态逻辑来，就像整理自己的小抽屉，想找啥一目了然，别提多轻松了！\n\n\n## 6. 插件系统：简单扩展，功能拉满\nVuex的插件机制复杂得很，开发者要是想实现点特定功能，就得自己写中间件或者插件，跟“造轮子”似的，费时又费力。  \n\nPinia的插件系统就“傻瓜式”多了，特别简洁明了。不管是扩展store功能，还是实现状态持久化，都超容易。比如用`pinia-plugin-persistedstate`插件，分分钟就能把状态存起来，就像用手机APP，点点按钮就能搞定，轻松实现功能自由！\n\n\n## 7. 与组合式API的集成：无缝配合，丝滑流畅\n在Vuex里想用组合式API？那得通过`useStore`获取store实例，写法又长又麻烦，就像绕了个大弯才能到达目的地。  \n\nPinia和组合式API简直是“最佳拍档”！直接在`setup`函数里调用`useStore()`就能拿到store，代码写起来行云流水，一点都不卡顿，用起来丝滑得不行！\n\n\n## 8. 开发工具支持：调试神器，效率翻倍\nVuex调试得靠Vue DevTools，但用起来总觉得差点意思，就像用一把不太顺手的钥匙开锁，费半天劲。  \n\nPinia和Vue DevTools那可是“深度绑定”！支持时间旅行调试，还能轻松追踪store变化。调试的时候就像拥有了“时光回溯”的超能力，哪里出问题一目了然，开发效率直接翻倍！\n\n\n## 9. 状态持久化：一键配置，轻松搞定\nVuex想实现状态持久化？得额外安装`vuex-persistedstate`插件，一顿操作猛如虎，才能把数据存起来。  \n\nPinia就简单多了，用`pinia-plugin-persistedstate`插件，简单配置一下，数据保存妥妥的，就像给数据加了个“保险箱”，一键操作，省心又省力！\n\n\n## 升级建议\n1. **慢慢过渡**：在Vue 3项目里，别着急把Vuex全换掉，可以Vuex和Pinia一起用，慢慢把旧的store迁移到Pinia，稳扎稳打，降低升级风险。  \n2. **整理代码**：把Vuex里的`mutations`合并到`actions`里，让代码结构更贴合Pinia的风格，就像给旧衣服改个新款式，焕然一新！  \n3. **用好组合式API**：充分发挥Pinia和组合式API的“CP”优势，用`setup`函数写代码，灵活安排逻辑，怎么方便怎么来！  \n4. **享受类型安全**：Pinia的类型推导超厉害，一定要好好利用，减少手动写类型声明的麻烦，让代码又快又安全！  \n\n\n从Vuex换成Pinia，可不只是换个工具那么简单，更是开发体验的大升级！Pinia凭借简洁的设计、强大的功能，还有对Vue 3的“完美适配”，妥妥成了Vue开发者状态管理的“新宠”。希望这篇文章能帮你快速上手Pinia，在Vue 3的开发路上一路“狂飙”！","slug":"from-vuex-to-pinia","published":1,"updated":"2025-08-26T10:44:54.544Z","_id":"cmckl78fc0000s8up55z65s6r","comments":1,"layout":"post","photos":[],"content":"<p>在Vue 3的“江湖”里，状态管理这块可是发生了大变化！当咱们从Vue 2“升级打怪”到Vue 3，以前常用的Vuex逐渐被更“香”的Pinia替代了。今天就来唠唠Vuex和Pinia到底有啥不一样，帮大家轻松拿捏新的状态管理姿势！</p>\n<h2 id=\"1-API风格与设计：告别繁琐，拥抱简洁\"><a href=\"#1-API风格与设计：告别繁琐，拥抱简洁\" class=\"headerlink\" title=\"1. API风格与设计：告别繁琐，拥抱简洁\"></a>1. API风格与设计：告别繁琐，拥抱简洁</h2><p>Vuex就像个“老学究”，用的是类似Redux的那一套，非得让开发者把逻辑按<code>mutations</code>、<code>actions</code>、<code>getters</code>这些规矩分好类。虽然确实规范，但写起代码来可太啰嗦了，一堆模板代码看着就头大！  </p>\n<p>Pinia就不一样，它紧跟Vue 3的“潮流”，用组合式API设计，直接把<code>mutations</code>“踢出局”（只保留<code>state</code>、<code>getters</code>、<code>actions</code>）。代码一下子变得超扁平、超直观，再也不用为那些复杂的条条框框费脑筋，开发起来轻松多啦！</p>\n<h2 id=\"2-TypeScript支持：天生适配，用着超爽\"><a href=\"#2-TypeScript支持：天生适配，用着超爽\" class=\"headerlink\" title=\"2. TypeScript支持：天生适配，用着超爽\"></a>2. TypeScript支持：天生适配，用着超爽</h2><p>要是你用Vuex搭配TypeScript，那可得费点劲！得额外捣鼓不少配置和类型定义，不然根本用不顺手，就像给自行车硬装上火箭发动机，麻烦得很。  </p>\n<p>Pinia可就贴心多了，它对TypeScript是“真爱”，天生适配！在定义store的时候，类型直接就能自动推导出来，完全不用手动写那些复杂的类型声明。这就好比有个贴心小助手，帮你把繁琐的活儿都干了，开发效率直接起飞，代码的安全性也拉满！</p>\n<h2 id=\"3-代码结构：新旧语法大PK\"><a href=\"#3-代码结构：新旧语法大PK\" class=\"headerlink\" title=\"3. 代码结构：新旧语法大PK\"></a>3. 代码结构：新旧语法大PK</h2><p>先看看Vuex的store代码长啥样：  </p>\n<pre><code class=\"javascript\">// Vuex store示例\nexport default new Vuex.Store(&#123;\n  state: &#123;\n    count: 0\n  &#125;,\n  mutations: &#123;\n    increment(state) &#123;\n      state.count++;\n    &#125;\n  &#125;,\n  actions: &#123;\n    incrementAsync(&#123; commit &#125;) &#123;\n      setTimeout(() =&gt; commit(&#39;increment&#39;), 1000);\n    &#125;\n  &#125;,\n  getters: &#123;\n    doubleCount: state =&gt; state.count * 2\n  &#125;\n&#125;);\n</code></pre>\n<p>再瞅瞅Pinia的：  </p>\n<pre><code class=\"javascript\">// Pinia store示例\nimport &#123; defineStore &#125; from &#39;pinia&#39;;\n\nexport const useCounterStore = defineStore(&#39;counter&#39;, &#123;\n  state: () =&gt; (&#123;\n    count: 0\n  &#125;),\n  actions: &#123;\n    increment() &#123;\n      this.count++;\n    &#125;,\n    incrementAsync() &#123;\n      setTimeout(() =&gt; this.increment(), 1000);\n    &#125;\n  &#125;,\n  getters: &#123;\n    doubleCount: state =&gt; state.count * 2\n  &#125;\n&#125;);\n</code></pre>\n<p>这么一对比，是不是瞬间觉得Pinia的代码清爽多了？没有那么多复杂的层级和重复的结构，就像把乱糟糟的房间收拾得整整齐齐，看着就舒服，写代码也更顺手！</p>\n<h2 id=\"4-响应式原理：Proxy带来的“黑科技”\"><a href=\"#4-响应式原理：Proxy带来的“黑科技”\" class=\"headerlink\" title=\"4. 响应式原理：Proxy带来的“黑科技”\"></a>4. 响应式原理：Proxy带来的“黑科技”</h2><p>Vuex用的是Vue 2的<code>Object.defineProperty</code>实现响应式，这就像给数据安了个“老旧监控”，在处理深层嵌套数据更新的时候，经常会“掉链子”，数据变了，视图却没反应，让人干着急。  </p>\n<p>Pinia可就“高大上”了，它基于Vue 3的Proxy，相当于给数据配了个“智能管家”！不仅支持直接修改<code>state</code>，不用再走<code>mutations</code>那些弯弯绕绕，而且响应式超高效、超准确，数据一有风吹草动，它立马就能感知到，视图更新那叫一个快！</p>\n<h2 id=\"5-模块化方式：轻松管理，互不干扰\"><a href=\"#5-模块化方式：轻松管理，互不干扰\" class=\"headerlink\" title=\"5. 模块化方式：轻松管理，互不干扰\"></a>5. 模块化方式：轻松管理，互不干扰</h2><p>Vuex拆分store靠<code>modules</code>选项，但是模块之间的关系就像一团乱麻，命名空间管理起来也特别麻烦，稍不注意就容易“翻车”，把代码搞得一团糟。  </p>\n<p>Pinia就聪明多了，每个store都是独立的“小个体”，用<code>defineStore</code>定义就行。模块之间井水不犯河水，完全解耦，命名空间也自动安排得明明白白。开发者管理起状态逻辑来，就像整理自己的小抽屉，想找啥一目了然，别提多轻松了！</p>\n<h2 id=\"6-插件系统：简单扩展，功能拉满\"><a href=\"#6-插件系统：简单扩展，功能拉满\" class=\"headerlink\" title=\"6. 插件系统：简单扩展，功能拉满\"></a>6. 插件系统：简单扩展，功能拉满</h2><p>Vuex的插件机制复杂得很，开发者要是想实现点特定功能，就得自己写中间件或者插件，跟“造轮子”似的，费时又费力。  </p>\n<p>Pinia的插件系统就“傻瓜式”多了，特别简洁明了。不管是扩展store功能，还是实现状态持久化，都超容易。比如用<code>pinia-plugin-persistedstate</code>插件，分分钟就能把状态存起来，就像用手机APP，点点按钮就能搞定，轻松实现功能自由！</p>\n<h2 id=\"7-与组合式API的集成：无缝配合，丝滑流畅\"><a href=\"#7-与组合式API的集成：无缝配合，丝滑流畅\" class=\"headerlink\" title=\"7. 与组合式API的集成：无缝配合，丝滑流畅\"></a>7. 与组合式API的集成：无缝配合，丝滑流畅</h2><p>在Vuex里想用组合式API？那得通过<code>useStore</code>获取store实例，写法又长又麻烦，就像绕了个大弯才能到达目的地。  </p>\n<p>Pinia和组合式API简直是“最佳拍档”！直接在<code>setup</code>函数里调用<code>useStore()</code>就能拿到store，代码写起来行云流水，一点都不卡顿，用起来丝滑得不行！</p>\n<h2 id=\"8-开发工具支持：调试神器，效率翻倍\"><a href=\"#8-开发工具支持：调试神器，效率翻倍\" class=\"headerlink\" title=\"8. 开发工具支持：调试神器，效率翻倍\"></a>8. 开发工具支持：调试神器，效率翻倍</h2><p>Vuex调试得靠Vue DevTools，但用起来总觉得差点意思，就像用一把不太顺手的钥匙开锁，费半天劲。  </p>\n<p>Pinia和Vue DevTools那可是“深度绑定”！支持时间旅行调试，还能轻松追踪store变化。调试的时候就像拥有了“时光回溯”的超能力，哪里出问题一目了然，开发效率直接翻倍！</p>\n<h2 id=\"9-状态持久化：一键配置，轻松搞定\"><a href=\"#9-状态持久化：一键配置，轻松搞定\" class=\"headerlink\" title=\"9. 状态持久化：一键配置，轻松搞定\"></a>9. 状态持久化：一键配置，轻松搞定</h2><p>Vuex想实现状态持久化？得额外安装<code>vuex-persistedstate</code>插件，一顿操作猛如虎，才能把数据存起来。  </p>\n<p>Pinia就简单多了，用<code>pinia-plugin-persistedstate</code>插件，简单配置一下，数据保存妥妥的，就像给数据加了个“保险箱”，一键操作，省心又省力！</p>\n<h2 id=\"升级建议\"><a href=\"#升级建议\" class=\"headerlink\" title=\"升级建议\"></a>升级建议</h2><ol>\n<li><strong>慢慢过渡</strong>：在Vue 3项目里，别着急把Vuex全换掉，可以Vuex和Pinia一起用，慢慢把旧的store迁移到Pinia，稳扎稳打，降低升级风险。  </li>\n<li><strong>整理代码</strong>：把Vuex里的<code>mutations</code>合并到<code>actions</code>里，让代码结构更贴合Pinia的风格，就像给旧衣服改个新款式，焕然一新！  </li>\n<li><strong>用好组合式API</strong>：充分发挥Pinia和组合式API的“CP”优势，用<code>setup</code>函数写代码，灵活安排逻辑，怎么方便怎么来！  </li>\n<li><strong>享受类型安全</strong>：Pinia的类型推导超厉害，一定要好好利用，减少手动写类型声明的麻烦，让代码又快又安全！</li>\n</ol>\n<p>从Vuex换成Pinia，可不只是换个工具那么简单，更是开发体验的大升级！Pinia凭借简洁的设计、强大的功能，还有对Vue 3的“完美适配”，妥妥成了Vue开发者状态管理的“新宠”。希望这篇文章能帮你快速上手Pinia，在Vue 3的开发路上一路“狂飙”！</p>\n<h1 id=\"从Vuex到Pinia：Vue-3状态管理的全面升级\"><a href=\"#从Vuex到Pinia：Vue-3状态管理的全面升级\" class=\"headerlink\" title=\"从Vuex到Pinia：Vue 3状态管理的全面升级\"></a>从Vuex到Pinia：Vue 3状态管理的全面升级</h1><p>家人们！在Vue 3的“江湖”里，状态管理这块可是发生了大变化！当咱们从Vue 2“升级打怪”到Vue 3，以前常用的Vuex逐渐被更“香”的Pinia替代了。今天就来唠唠Vuex和Pinia到底有啥不一样，帮大家轻松拿捏新的状态管理姿势！</p>\n<h2 id=\"1-API风格与设计：告别繁琐，拥抱简洁-1\"><a href=\"#1-API风格与设计：告别繁琐，拥抱简洁-1\" class=\"headerlink\" title=\"1. API风格与设计：告别繁琐，拥抱简洁\"></a>1. API风格与设计：告别繁琐，拥抱简洁</h2><p>Vuex就像个“老学究”，用的是类似Redux的那一套，非得让开发者把逻辑按<code>mutations</code>、<code>actions</code>、<code>getters</code>这些规矩分好类。虽然确实规范，但写起代码来可太啰嗦了，一堆模板代码看着就头大！  </p>\n<p>Pinia就不一样，它紧跟Vue 3的“潮流”，用组合式API设计，直接把<code>mutations</code>“踢出局”（只保留<code>state</code>、<code>getters</code>、<code>actions</code>）。代码一下子变得超扁平、超直观，再也不用为那些复杂的条条框框费脑筋，开发起来轻松多啦！</p>\n<h2 id=\"2-TypeScript支持：天生适配，用着超爽-1\"><a href=\"#2-TypeScript支持：天生适配，用着超爽-1\" class=\"headerlink\" title=\"2. TypeScript支持：天生适配，用着超爽\"></a>2. TypeScript支持：天生适配，用着超爽</h2><p>要是你用Vuex搭配TypeScript，那可得费点劲！得额外捣鼓不少配置和类型定义，不然根本用不顺手，就像给自行车硬装上火箭发动机，麻烦得很。  </p>\n<p>Pinia可就贴心多了，它对TypeScript是“真爱”，天生适配！在定义store的时候，类型直接就能自动推导出来，完全不用手动写那些复杂的类型声明。这就好比有个贴心小助手，帮你把繁琐的活儿都干了，开发效率直接起飞，代码的安全性也拉满！</p>\n<h2 id=\"3-代码结构：新旧语法大PK-1\"><a href=\"#3-代码结构：新旧语法大PK-1\" class=\"headerlink\" title=\"3. 代码结构：新旧语法大PK\"></a>3. 代码结构：新旧语法大PK</h2><p>先看看Vuex的store代码长啥样：  </p>\n<pre><code class=\"javascript\">// Vuex store示例\nexport default new Vuex.Store(&#123;\n  state: &#123;\n    count: 0\n  &#125;,\n  mutations: &#123;\n    increment(state) &#123;\n      state.count++;\n    &#125;\n  &#125;,\n  actions: &#123;\n    incrementAsync(&#123; commit &#125;) &#123;\n      setTimeout(() =&gt; commit(&#39;increment&#39;), 1000);\n    &#125;\n  &#125;,\n  getters: &#123;\n    doubleCount: state =&gt; state.count * 2\n  &#125;\n&#125;);\n</code></pre>\n<p>再瞅瞅Pinia的：  </p>\n<pre><code class=\"javascript\">// Pinia store示例\nimport &#123; defineStore &#125; from &#39;pinia&#39;;\n\nexport const useCounterStore = defineStore(&#39;counter&#39;, &#123;\n  state: () =&gt; (&#123;\n    count: 0\n  &#125;),\n  actions: &#123;\n    increment() &#123;\n      this.count++;\n    &#125;,\n    incrementAsync() &#123;\n      setTimeout(() =&gt; this.increment(), 1000);\n    &#125;\n  &#125;,\n  getters: &#123;\n    doubleCount: state =&gt; state.count * 2\n  &#125;\n&#125;);\n</code></pre>\n<p>这么一对比，是不是瞬间觉得Pinia的代码清爽多了？没有那么多复杂的层级和重复的结构，就像把乱糟糟的房间收拾得整整齐齐，看着就舒服，写代码也更顺手！</p>\n<h2 id=\"4-响应式原理：Proxy带来的“黑科技”-1\"><a href=\"#4-响应式原理：Proxy带来的“黑科技”-1\" class=\"headerlink\" title=\"4. 响应式原理：Proxy带来的“黑科技”\"></a>4. 响应式原理：Proxy带来的“黑科技”</h2><p>Vuex用的是Vue 2的<code>Object.defineProperty</code>实现响应式，这就像给数据安了个“老旧监控”，在处理深层嵌套数据更新的时候，经常会“掉链子”，数据变了，视图却没反应，让人干着急。  </p>\n<p>Pinia可就“高大上”了，它基于Vue 3的Proxy，相当于给数据配了个“智能管家”！不仅支持直接修改<code>state</code>，不用再走<code>mutations</code>那些弯弯绕绕，而且响应式超高效、超准确，数据一有风吹草动，它立马就能感知到，视图更新那叫一个快！</p>\n<h2 id=\"5-模块化方式：轻松管理，互不干扰-1\"><a href=\"#5-模块化方式：轻松管理，互不干扰-1\" class=\"headerlink\" title=\"5. 模块化方式：轻松管理，互不干扰\"></a>5. 模块化方式：轻松管理，互不干扰</h2><p>Vuex拆分store靠<code>modules</code>选项，但是模块之间的关系就像一团乱麻，命名空间管理起来也特别麻烦，稍不注意就容易“翻车”，把代码搞得一团糟。  </p>\n<p>Pinia就聪明多了，每个store都是独立的“小个体”，用<code>defineStore</code>定义就行。模块之间井水不犯河水，完全解耦，命名空间也自动安排得明明白白。开发者管理起状态逻辑来，就像整理自己的小抽屉，想找啥一目了然，别提多轻松了！</p>\n<h2 id=\"6-插件系统：简单扩展，功能拉满-1\"><a href=\"#6-插件系统：简单扩展，功能拉满-1\" class=\"headerlink\" title=\"6. 插件系统：简单扩展，功能拉满\"></a>6. 插件系统：简单扩展，功能拉满</h2><p>Vuex的插件机制复杂得很，开发者要是想实现点特定功能，就得自己写中间件或者插件，跟“造轮子”似的，费时又费力。  </p>\n<p>Pinia的插件系统就“傻瓜式”多了，特别简洁明了。不管是扩展store功能，还是实现状态持久化，都超容易。比如用<code>pinia-plugin-persistedstate</code>插件，分分钟就能把状态存起来，就像用手机APP，点点按钮就能搞定，轻松实现功能自由！</p>\n<h2 id=\"7-与组合式API的集成：无缝配合，丝滑流畅-1\"><a href=\"#7-与组合式API的集成：无缝配合，丝滑流畅-1\" class=\"headerlink\" title=\"7. 与组合式API的集成：无缝配合，丝滑流畅\"></a>7. 与组合式API的集成：无缝配合，丝滑流畅</h2><p>在Vuex里想用组合式API？那得通过<code>useStore</code>获取store实例，写法又长又麻烦，就像绕了个大弯才能到达目的地。  </p>\n<p>Pinia和组合式API简直是“最佳拍档”！直接在<code>setup</code>函数里调用<code>useStore()</code>就能拿到store，代码写起来行云流水，一点都不卡顿，用起来丝滑得不行！</p>\n<h2 id=\"8-开发工具支持：调试神器，效率翻倍-1\"><a href=\"#8-开发工具支持：调试神器，效率翻倍-1\" class=\"headerlink\" title=\"8. 开发工具支持：调试神器，效率翻倍\"></a>8. 开发工具支持：调试神器，效率翻倍</h2><p>Vuex调试得靠Vue DevTools，但用起来总觉得差点意思，就像用一把不太顺手的钥匙开锁，费半天劲。  </p>\n<p>Pinia和Vue DevTools那可是“深度绑定”！支持时间旅行调试，还能轻松追踪store变化。调试的时候就像拥有了“时光回溯”的超能力，哪里出问题一目了然，开发效率直接翻倍！</p>\n<h2 id=\"9-状态持久化：一键配置，轻松搞定-1\"><a href=\"#9-状态持久化：一键配置，轻松搞定-1\" class=\"headerlink\" title=\"9. 状态持久化：一键配置，轻松搞定\"></a>9. 状态持久化：一键配置，轻松搞定</h2><p>Vuex想实现状态持久化？得额外安装<code>vuex-persistedstate</code>插件，一顿操作猛如虎，才能把数据存起来。  </p>\n<p>Pinia就简单多了，用<code>pinia-plugin-persistedstate</code>插件，简单配置一下，数据保存妥妥的，就像给数据加了个“保险箱”，一键操作，省心又省力！</p>\n<h2 id=\"升级建议-1\"><a href=\"#升级建议-1\" class=\"headerlink\" title=\"升级建议\"></a>升级建议</h2><ol>\n<li><strong>慢慢过渡</strong>：在Vue 3项目里，别着急把Vuex全换掉，可以Vuex和Pinia一起用，慢慢把旧的store迁移到Pinia，稳扎稳打，降低升级风险。  </li>\n<li><strong>整理代码</strong>：把Vuex里的<code>mutations</code>合并到<code>actions</code>里，让代码结构更贴合Pinia的风格，就像给旧衣服改个新款式，焕然一新！  </li>\n<li><strong>用好组合式API</strong>：充分发挥Pinia和组合式API的“CP”优势，用<code>setup</code>函数写代码，灵活安排逻辑，怎么方便怎么来！  </li>\n<li><strong>享受类型安全</strong>：Pinia的类型推导超厉害，一定要好好利用，减少手动写类型声明的麻烦，让代码又快又安全！</li>\n</ol>\n<p>从Vuex换成Pinia，可不只是换个工具那么简单，更是开发体验的大升级！Pinia凭借简洁的设计、强大的功能，还有对Vue 3的“完美适配”，妥妥成了Vue开发者状态管理的“新宠”。希望这篇文章能帮你快速上手Pinia，在Vue 3的开发路上一路“狂飙”！</p>\n","excerpt":"","more":"<p>在Vue 3的“江湖”里，状态管理这块可是发生了大变化！当咱们从Vue 2“升级打怪”到Vue 3，以前常用的Vuex逐渐被更“香”的Pinia替代了。今天就来唠唠Vuex和Pinia到底有啥不一样，帮大家轻松拿捏新的状态管理姿势！</p>\n<h2 id=\"1-API风格与设计：告别繁琐，拥抱简洁\"><a href=\"#1-API风格与设计：告别繁琐，拥抱简洁\" class=\"headerlink\" title=\"1. API风格与设计：告别繁琐，拥抱简洁\"></a>1. API风格与设计：告别繁琐，拥抱简洁</h2><p>Vuex就像个“老学究”，用的是类似Redux的那一套，非得让开发者把逻辑按<code>mutations</code>、<code>actions</code>、<code>getters</code>这些规矩分好类。虽然确实规范，但写起代码来可太啰嗦了，一堆模板代码看着就头大！  </p>\n<p>Pinia就不一样，它紧跟Vue 3的“潮流”，用组合式API设计，直接把<code>mutations</code>“踢出局”（只保留<code>state</code>、<code>getters</code>、<code>actions</code>）。代码一下子变得超扁平、超直观，再也不用为那些复杂的条条框框费脑筋，开发起来轻松多啦！</p>\n<h2 id=\"2-TypeScript支持：天生适配，用着超爽\"><a href=\"#2-TypeScript支持：天生适配，用着超爽\" class=\"headerlink\" title=\"2. TypeScript支持：天生适配，用着超爽\"></a>2. TypeScript支持：天生适配，用着超爽</h2><p>要是你用Vuex搭配TypeScript，那可得费点劲！得额外捣鼓不少配置和类型定义，不然根本用不顺手，就像给自行车硬装上火箭发动机，麻烦得很。  </p>\n<p>Pinia可就贴心多了，它对TypeScript是“真爱”，天生适配！在定义store的时候，类型直接就能自动推导出来，完全不用手动写那些复杂的类型声明。这就好比有个贴心小助手，帮你把繁琐的活儿都干了，开发效率直接起飞，代码的安全性也拉满！</p>\n<h2 id=\"3-代码结构：新旧语法大PK\"><a href=\"#3-代码结构：新旧语法大PK\" class=\"headerlink\" title=\"3. 代码结构：新旧语法大PK\"></a>3. 代码结构：新旧语法大PK</h2><p>先看看Vuex的store代码长啥样：  </p>\n<pre><code class=\"javascript\">// Vuex store示例\nexport default new Vuex.Store(&#123;\n  state: &#123;\n    count: 0\n  &#125;,\n  mutations: &#123;\n    increment(state) &#123;\n      state.count++;\n    &#125;\n  &#125;,\n  actions: &#123;\n    incrementAsync(&#123; commit &#125;) &#123;\n      setTimeout(() =&gt; commit(&#39;increment&#39;), 1000);\n    &#125;\n  &#125;,\n  getters: &#123;\n    doubleCount: state =&gt; state.count * 2\n  &#125;\n&#125;);\n</code></pre>\n<p>再瞅瞅Pinia的：  </p>\n<pre><code class=\"javascript\">// Pinia store示例\nimport &#123; defineStore &#125; from &#39;pinia&#39;;\n\nexport const useCounterStore = defineStore(&#39;counter&#39;, &#123;\n  state: () =&gt; (&#123;\n    count: 0\n  &#125;),\n  actions: &#123;\n    increment() &#123;\n      this.count++;\n    &#125;,\n    incrementAsync() &#123;\n      setTimeout(() =&gt; this.increment(), 1000);\n    &#125;\n  &#125;,\n  getters: &#123;\n    doubleCount: state =&gt; state.count * 2\n  &#125;\n&#125;);\n</code></pre>\n<p>这么一对比，是不是瞬间觉得Pinia的代码清爽多了？没有那么多复杂的层级和重复的结构，就像把乱糟糟的房间收拾得整整齐齐，看着就舒服，写代码也更顺手！</p>\n<h2 id=\"4-响应式原理：Proxy带来的“黑科技”\"><a href=\"#4-响应式原理：Proxy带来的“黑科技”\" class=\"headerlink\" title=\"4. 响应式原理：Proxy带来的“黑科技”\"></a>4. 响应式原理：Proxy带来的“黑科技”</h2><p>Vuex用的是Vue 2的<code>Object.defineProperty</code>实现响应式，这就像给数据安了个“老旧监控”，在处理深层嵌套数据更新的时候，经常会“掉链子”，数据变了，视图却没反应，让人干着急。  </p>\n<p>Pinia可就“高大上”了，它基于Vue 3的Proxy，相当于给数据配了个“智能管家”！不仅支持直接修改<code>state</code>，不用再走<code>mutations</code>那些弯弯绕绕，而且响应式超高效、超准确，数据一有风吹草动，它立马就能感知到，视图更新那叫一个快！</p>\n<h2 id=\"5-模块化方式：轻松管理，互不干扰\"><a href=\"#5-模块化方式：轻松管理，互不干扰\" class=\"headerlink\" title=\"5. 模块化方式：轻松管理，互不干扰\"></a>5. 模块化方式：轻松管理，互不干扰</h2><p>Vuex拆分store靠<code>modules</code>选项，但是模块之间的关系就像一团乱麻，命名空间管理起来也特别麻烦，稍不注意就容易“翻车”，把代码搞得一团糟。  </p>\n<p>Pinia就聪明多了，每个store都是独立的“小个体”，用<code>defineStore</code>定义就行。模块之间井水不犯河水，完全解耦，命名空间也自动安排得明明白白。开发者管理起状态逻辑来，就像整理自己的小抽屉，想找啥一目了然，别提多轻松了！</p>\n<h2 id=\"6-插件系统：简单扩展，功能拉满\"><a href=\"#6-插件系统：简单扩展，功能拉满\" class=\"headerlink\" title=\"6. 插件系统：简单扩展，功能拉满\"></a>6. 插件系统：简单扩展，功能拉满</h2><p>Vuex的插件机制复杂得很，开发者要是想实现点特定功能，就得自己写中间件或者插件，跟“造轮子”似的，费时又费力。  </p>\n<p>Pinia的插件系统就“傻瓜式”多了，特别简洁明了。不管是扩展store功能，还是实现状态持久化，都超容易。比如用<code>pinia-plugin-persistedstate</code>插件，分分钟就能把状态存起来，就像用手机APP，点点按钮就能搞定，轻松实现功能自由！</p>\n<h2 id=\"7-与组合式API的集成：无缝配合，丝滑流畅\"><a href=\"#7-与组合式API的集成：无缝配合，丝滑流畅\" class=\"headerlink\" title=\"7. 与组合式API的集成：无缝配合，丝滑流畅\"></a>7. 与组合式API的集成：无缝配合，丝滑流畅</h2><p>在Vuex里想用组合式API？那得通过<code>useStore</code>获取store实例，写法又长又麻烦，就像绕了个大弯才能到达目的地。  </p>\n<p>Pinia和组合式API简直是“最佳拍档”！直接在<code>setup</code>函数里调用<code>useStore()</code>就能拿到store，代码写起来行云流水，一点都不卡顿，用起来丝滑得不行！</p>\n<h2 id=\"8-开发工具支持：调试神器，效率翻倍\"><a href=\"#8-开发工具支持：调试神器，效率翻倍\" class=\"headerlink\" title=\"8. 开发工具支持：调试神器，效率翻倍\"></a>8. 开发工具支持：调试神器，效率翻倍</h2><p>Vuex调试得靠Vue DevTools，但用起来总觉得差点意思，就像用一把不太顺手的钥匙开锁，费半天劲。  </p>\n<p>Pinia和Vue DevTools那可是“深度绑定”！支持时间旅行调试，还能轻松追踪store变化。调试的时候就像拥有了“时光回溯”的超能力，哪里出问题一目了然，开发效率直接翻倍！</p>\n<h2 id=\"9-状态持久化：一键配置，轻松搞定\"><a href=\"#9-状态持久化：一键配置，轻松搞定\" class=\"headerlink\" title=\"9. 状态持久化：一键配置，轻松搞定\"></a>9. 状态持久化：一键配置，轻松搞定</h2><p>Vuex想实现状态持久化？得额外安装<code>vuex-persistedstate</code>插件，一顿操作猛如虎，才能把数据存起来。  </p>\n<p>Pinia就简单多了，用<code>pinia-plugin-persistedstate</code>插件，简单配置一下，数据保存妥妥的，就像给数据加了个“保险箱”，一键操作，省心又省力！</p>\n<h2 id=\"升级建议\"><a href=\"#升级建议\" class=\"headerlink\" title=\"升级建议\"></a>升级建议</h2><ol>\n<li><strong>慢慢过渡</strong>：在Vue 3项目里，别着急把Vuex全换掉，可以Vuex和Pinia一起用，慢慢把旧的store迁移到Pinia，稳扎稳打，降低升级风险。  </li>\n<li><strong>整理代码</strong>：把Vuex里的<code>mutations</code>合并到<code>actions</code>里，让代码结构更贴合Pinia的风格，就像给旧衣服改个新款式，焕然一新！  </li>\n<li><strong>用好组合式API</strong>：充分发挥Pinia和组合式API的“CP”优势，用<code>setup</code>函数写代码，灵活安排逻辑，怎么方便怎么来！  </li>\n<li><strong>享受类型安全</strong>：Pinia的类型推导超厉害，一定要好好利用，减少手动写类型声明的麻烦，让代码又快又安全！</li>\n</ol>\n<p>从Vuex换成Pinia，可不只是换个工具那么简单，更是开发体验的大升级！Pinia凭借简洁的设计、强大的功能，还有对Vue 3的“完美适配”，妥妥成了Vue开发者状态管理的“新宠”。希望这篇文章能帮你快速上手Pinia，在Vue 3的开发路上一路“狂飙”！</p>\n<h1 id=\"从Vuex到Pinia：Vue-3状态管理的全面升级\"><a href=\"#从Vuex到Pinia：Vue-3状态管理的全面升级\" class=\"headerlink\" title=\"从Vuex到Pinia：Vue 3状态管理的全面升级\"></a>从Vuex到Pinia：Vue 3状态管理的全面升级</h1><p>家人们！在Vue 3的“江湖”里，状态管理这块可是发生了大变化！当咱们从Vue 2“升级打怪”到Vue 3，以前常用的Vuex逐渐被更“香”的Pinia替代了。今天就来唠唠Vuex和Pinia到底有啥不一样，帮大家轻松拿捏新的状态管理姿势！</p>\n<h2 id=\"1-API风格与设计：告别繁琐，拥抱简洁-1\"><a href=\"#1-API风格与设计：告别繁琐，拥抱简洁-1\" class=\"headerlink\" title=\"1. API风格与设计：告别繁琐，拥抱简洁\"></a>1. API风格与设计：告别繁琐，拥抱简洁</h2><p>Vuex就像个“老学究”，用的是类似Redux的那一套，非得让开发者把逻辑按<code>mutations</code>、<code>actions</code>、<code>getters</code>这些规矩分好类。虽然确实规范，但写起代码来可太啰嗦了，一堆模板代码看着就头大！  </p>\n<p>Pinia就不一样，它紧跟Vue 3的“潮流”，用组合式API设计，直接把<code>mutations</code>“踢出局”（只保留<code>state</code>、<code>getters</code>、<code>actions</code>）。代码一下子变得超扁平、超直观，再也不用为那些复杂的条条框框费脑筋，开发起来轻松多啦！</p>\n<h2 id=\"2-TypeScript支持：天生适配，用着超爽-1\"><a href=\"#2-TypeScript支持：天生适配，用着超爽-1\" class=\"headerlink\" title=\"2. TypeScript支持：天生适配，用着超爽\"></a>2. TypeScript支持：天生适配，用着超爽</h2><p>要是你用Vuex搭配TypeScript，那可得费点劲！得额外捣鼓不少配置和类型定义，不然根本用不顺手，就像给自行车硬装上火箭发动机，麻烦得很。  </p>\n<p>Pinia可就贴心多了，它对TypeScript是“真爱”，天生适配！在定义store的时候，类型直接就能自动推导出来，完全不用手动写那些复杂的类型声明。这就好比有个贴心小助手，帮你把繁琐的活儿都干了，开发效率直接起飞，代码的安全性也拉满！</p>\n<h2 id=\"3-代码结构：新旧语法大PK-1\"><a href=\"#3-代码结构：新旧语法大PK-1\" class=\"headerlink\" title=\"3. 代码结构：新旧语法大PK\"></a>3. 代码结构：新旧语法大PK</h2><p>先看看Vuex的store代码长啥样：  </p>\n<pre><code class=\"javascript\">// Vuex store示例\nexport default new Vuex.Store(&#123;\n  state: &#123;\n    count: 0\n  &#125;,\n  mutations: &#123;\n    increment(state) &#123;\n      state.count++;\n    &#125;\n  &#125;,\n  actions: &#123;\n    incrementAsync(&#123; commit &#125;) &#123;\n      setTimeout(() =&gt; commit(&#39;increment&#39;), 1000);\n    &#125;\n  &#125;,\n  getters: &#123;\n    doubleCount: state =&gt; state.count * 2\n  &#125;\n&#125;);\n</code></pre>\n<p>再瞅瞅Pinia的：  </p>\n<pre><code class=\"javascript\">// Pinia store示例\nimport &#123; defineStore &#125; from &#39;pinia&#39;;\n\nexport const useCounterStore = defineStore(&#39;counter&#39;, &#123;\n  state: () =&gt; (&#123;\n    count: 0\n  &#125;),\n  actions: &#123;\n    increment() &#123;\n      this.count++;\n    &#125;,\n    incrementAsync() &#123;\n      setTimeout(() =&gt; this.increment(), 1000);\n    &#125;\n  &#125;,\n  getters: &#123;\n    doubleCount: state =&gt; state.count * 2\n  &#125;\n&#125;);\n</code></pre>\n<p>这么一对比，是不是瞬间觉得Pinia的代码清爽多了？没有那么多复杂的层级和重复的结构，就像把乱糟糟的房间收拾得整整齐齐，看着就舒服，写代码也更顺手！</p>\n<h2 id=\"4-响应式原理：Proxy带来的“黑科技”-1\"><a href=\"#4-响应式原理：Proxy带来的“黑科技”-1\" class=\"headerlink\" title=\"4. 响应式原理：Proxy带来的“黑科技”\"></a>4. 响应式原理：Proxy带来的“黑科技”</h2><p>Vuex用的是Vue 2的<code>Object.defineProperty</code>实现响应式，这就像给数据安了个“老旧监控”，在处理深层嵌套数据更新的时候，经常会“掉链子”，数据变了，视图却没反应，让人干着急。  </p>\n<p>Pinia可就“高大上”了，它基于Vue 3的Proxy，相当于给数据配了个“智能管家”！不仅支持直接修改<code>state</code>，不用再走<code>mutations</code>那些弯弯绕绕，而且响应式超高效、超准确，数据一有风吹草动，它立马就能感知到，视图更新那叫一个快！</p>\n<h2 id=\"5-模块化方式：轻松管理，互不干扰-1\"><a href=\"#5-模块化方式：轻松管理，互不干扰-1\" class=\"headerlink\" title=\"5. 模块化方式：轻松管理，互不干扰\"></a>5. 模块化方式：轻松管理，互不干扰</h2><p>Vuex拆分store靠<code>modules</code>选项，但是模块之间的关系就像一团乱麻，命名空间管理起来也特别麻烦，稍不注意就容易“翻车”，把代码搞得一团糟。  </p>\n<p>Pinia就聪明多了，每个store都是独立的“小个体”，用<code>defineStore</code>定义就行。模块之间井水不犯河水，完全解耦，命名空间也自动安排得明明白白。开发者管理起状态逻辑来，就像整理自己的小抽屉，想找啥一目了然，别提多轻松了！</p>\n<h2 id=\"6-插件系统：简单扩展，功能拉满-1\"><a href=\"#6-插件系统：简单扩展，功能拉满-1\" class=\"headerlink\" title=\"6. 插件系统：简单扩展，功能拉满\"></a>6. 插件系统：简单扩展，功能拉满</h2><p>Vuex的插件机制复杂得很，开发者要是想实现点特定功能，就得自己写中间件或者插件，跟“造轮子”似的，费时又费力。  </p>\n<p>Pinia的插件系统就“傻瓜式”多了，特别简洁明了。不管是扩展store功能，还是实现状态持久化，都超容易。比如用<code>pinia-plugin-persistedstate</code>插件，分分钟就能把状态存起来，就像用手机APP，点点按钮就能搞定，轻松实现功能自由！</p>\n<h2 id=\"7-与组合式API的集成：无缝配合，丝滑流畅-1\"><a href=\"#7-与组合式API的集成：无缝配合，丝滑流畅-1\" class=\"headerlink\" title=\"7. 与组合式API的集成：无缝配合，丝滑流畅\"></a>7. 与组合式API的集成：无缝配合，丝滑流畅</h2><p>在Vuex里想用组合式API？那得通过<code>useStore</code>获取store实例，写法又长又麻烦，就像绕了个大弯才能到达目的地。  </p>\n<p>Pinia和组合式API简直是“最佳拍档”！直接在<code>setup</code>函数里调用<code>useStore()</code>就能拿到store，代码写起来行云流水，一点都不卡顿，用起来丝滑得不行！</p>\n<h2 id=\"8-开发工具支持：调试神器，效率翻倍-1\"><a href=\"#8-开发工具支持：调试神器，效率翻倍-1\" class=\"headerlink\" title=\"8. 开发工具支持：调试神器，效率翻倍\"></a>8. 开发工具支持：调试神器，效率翻倍</h2><p>Vuex调试得靠Vue DevTools，但用起来总觉得差点意思，就像用一把不太顺手的钥匙开锁，费半天劲。  </p>\n<p>Pinia和Vue DevTools那可是“深度绑定”！支持时间旅行调试，还能轻松追踪store变化。调试的时候就像拥有了“时光回溯”的超能力，哪里出问题一目了然，开发效率直接翻倍！</p>\n<h2 id=\"9-状态持久化：一键配置，轻松搞定-1\"><a href=\"#9-状态持久化：一键配置，轻松搞定-1\" class=\"headerlink\" title=\"9. 状态持久化：一键配置，轻松搞定\"></a>9. 状态持久化：一键配置，轻松搞定</h2><p>Vuex想实现状态持久化？得额外安装<code>vuex-persistedstate</code>插件，一顿操作猛如虎，才能把数据存起来。  </p>\n<p>Pinia就简单多了，用<code>pinia-plugin-persistedstate</code>插件，简单配置一下，数据保存妥妥的，就像给数据加了个“保险箱”，一键操作，省心又省力！</p>\n<h2 id=\"升级建议-1\"><a href=\"#升级建议-1\" class=\"headerlink\" title=\"升级建议\"></a>升级建议</h2><ol>\n<li><strong>慢慢过渡</strong>：在Vue 3项目里，别着急把Vuex全换掉，可以Vuex和Pinia一起用，慢慢把旧的store迁移到Pinia，稳扎稳打，降低升级风险。  </li>\n<li><strong>整理代码</strong>：把Vuex里的<code>mutations</code>合并到<code>actions</code>里，让代码结构更贴合Pinia的风格，就像给旧衣服改个新款式，焕然一新！  </li>\n<li><strong>用好组合式API</strong>：充分发挥Pinia和组合式API的“CP”优势，用<code>setup</code>函数写代码，灵活安排逻辑，怎么方便怎么来！  </li>\n<li><strong>享受类型安全</strong>：Pinia的类型推导超厉害，一定要好好利用，减少手动写类型声明的麻烦，让代码又快又安全！</li>\n</ol>\n<p>从Vuex换成Pinia，可不只是换个工具那么简单，更是开发体验的大升级！Pinia凭借简洁的设计、强大的功能，还有对Vue 3的“完美适配”，妥妥成了Vue开发者状态管理的“新宠”。希望这篇文章能帮你快速上手Pinia，在Vue 3的开发路上一路“狂飙”！</p>\n"},{"title":"从第一个静态网页到 Vue：Web 技术的 “逆袭史”","date":"2025-07-10T04:51:16.000Z","keywords":["Web开发，JQuery","Vue","MVVM"],"banner_img":"/imgs/web-history/first-web.jpg","index_img":"/imgs/web-history/first-web.jpg","_content":"\n**1991年**，有个叫蒂姆・博纳斯・李的英国科学家，写了世界上第一个静态网页。这个牛人不仅创造了超文本标记语言（HTML），而且还开发出世界上第一个网页浏览器，同时也由此发明了万维网(World Wide Web), 因此他也被称为万维网之父。\n\n![蒂姆・博纳斯・李](https://www.jvxiao.cn/imgs/web-history/TIM.png)\n\n早期的网页是静态的，当时的HTML标签并不丰富，当时的内容除了直接链接条状之外，没有任何的交互。到了**1994年**的时候，当时有一家有名的浏览器公司，大家应该也都听说过，叫网景(Netscape)， 它觉得页面缺少交互太单调了。脑袋一拍，Mocha出来了--也就是后来的JavaScript, JavaScript 的交互能力为网页广告弹窗(~~真讨厌~~)提供了技术基础。\n\n![Javascript](https://www.jvxiao.cn/imgs/web-history/Javascript.png)\n\n页面是可以动了，但是样式还是单调了些，而且还完全取决于浏览器开发商。页面缺少布局和美化手段，太粗糙了点。在**1994年**的时候，一个叫Hkon Wiumlie的开发者提出了CSS (层叠样式表)的想法，通过编写样式实现对页面内容的布局和美化。因为后来各大浏览器厂商对CSS的支持与差异，直到两年后的1996 年，W3才推出CSS规范的第一版本。 虽然CSS因此遗留了很多历史的BUG, 但终究还是统一了战线，不读不说这是个奇迹。\n\n![CSS](https://www.jvxiao.cn/imgs/web-history/CSS.png)\n\n到了**1995年**，网页迎来了一个巨大的转折，因为一门编程界的老梗编程语言诞生了--PHP(~~PHP是世界上最好的语言，不介绍反驳~~，不，JavaScript才是)。\n\nPHP的出现，让页面可以访问数据内容了，不再是单一静态页面加简单的动态交互了。通过把数据从数据库中取出来，然后塞到页面里，然后再返回给浏览器，从而实现了内容上的更新。\n\n![PHP](https://www.jvxiao.cn/imgs/web-history/PHP.png)\n\n但是这种前后端耦合的方式也带来了一个问题，就是页面需要频繁的刷新。页面中很小的变动，都会导致页面刷新，速度慢和流量消耗是个大问题。\n\n三步之内，必有解药，不行就三年。到了**1998年**，Ajax（Asynchronous JavaScript and XML）技术概念被提出，它大喊一声，学着点。Ajax通过动态加载数据，然后通过DOM操作将数据更新到页面的方式，完美的解决了页面频繁刷新的问题。\n\n![Jquery](https://www.jvxiao.cn/imgs/web-history/Jquery.png)\n\n想必后面的事情，大家都知道了，或者多少都有耳闻。 **2006年**，JQuery1.0 发布了，然后就是在Web开发中10年漫长的统治期，根据估计，到2010年，全球约90%的网站使用了JQuery。直到诸如Angular，React以及Vue等前端框架的崛起，这个Web界的王，才依依不舍离开曾经的宝座。\n\n## 传统Web技术的痛点\n\n类似JQuery这样封装了Ajax, DOM操作和时间处理的JS库，在很长一段时间里都是Web开发的主流技术，功能强大而且还简单易用。世界上总是没有免费的午餐的，对与JQuery来说，也是如此，它也存在着一定的不足之处。\n\n  - 性能问题\n    **DOM操作**： JQuery在处理大量DOM元素的时候可能不如原生JavaScript高效，因为其方法通常涉及遍历元素，增加了计算的开销\n    **选择器**: 岁让选择器方便，但复杂的选择器可能不如现在浏览器原生方法高效，影响性能。\n\n  - 体积问题\n    它的功能很强大，代码量自然也不会少，包的体积自然光也大。在弱网或移动端情况下，影响性能。\n\n  - 依赖性问题\n   项目可能仅使用部分功能却加载整个库，造成资源浪费。与其他库的冲突可能需要额外的处理，如使用noConflict模式。\n\n此外，2010年代，AngularJS, React和Vue.js等框架的出现，对JQuery的统治地位也构成了调账。新的MVC/MVVM模式，让用户更加方便的更新视图，在性能方面，采用虚拟DOM比传统的直接操作DOM消耗更少，更具优势。\n\n## MVVM技术框架\n\n- 定义：\n  - `Model: 数据层`，与MVC的Model类似。\n  - `View: 视图层`，负责数据展示。\n  - `ViewModel`: 将Model转化为View的友好格式，并处理用户交互。\n\n- 特点：\n  - `双向数据绑定`：ViewModel和View之间通过数据绑定自动同步数据。\n  - `简化逻辑`： ViewModel承担了部分Controller的职责，简化了View和Model的交换。\n  - `适用于声明编程`：适合使用声明式语法（如HTML）构建视图。\n\n![MVVM](https://www.jvxiao.cn/imgs/web-history/mvvm.jpg)\n\nMVVM通过数据双向绑定，分离关注点，简化视图逻辑、提高可测试性、支持响应式涉及和组件化开发等优势，极大地提升了前端开发的效率和代码质量。它特别适合需要复杂交互和动态数据的应用场景，如单页面应用和富客户端应用。选择MVVM模式能够帮助开发者构建更高效、更易于维护的前端应用。\n\n## 说回 Vue\n\n\n讲了那么多，终于回到我们的主题Vue了。之所以啰嗦，是希望你能够明白，无论是多么新的技术，都是有其发展历程和背景的。同时呢，无论看着多牛的技术框架，也是会有这样那样的问题的--人在挑毛病这块是无题的，而这也是技术不断往前发展的原因之一。\n\n![Vue](https://www.jvxiao.cn/imgs/web-history/Vue.png)\n\n技术的更新发展，往往都是对前一项主流技术上进行突破或者颠覆。比如，Vue这样的JS框架，解决的不就是视图渲染问题嘛，不再需要用户去操作DOM, 用户可以更加关注数据流和用户交互。从JavaScript刚刚实现用户交互直接跨越到Vue框架，一般我们称之为神话或者穿越...\n\n也许有一天 Vue 也被新的框架替代，但Web的故事还在继续，而我们，既是这段历史的见证者，也是下一章的书写人\n","source":"_posts/web-history.md","raw":"---\ntitle: 从第一个静态网页到 Vue：Web 技术的 “逆袭史”\ndate: 2025-07-10 12:51:16\ntags: [Web开发，JQuery, Vue, MVVM]\nkeywords: [Web开发，JQuery, Vue, MVVM]\ncategory: Web开发\nbanner_img: /imgs/web-history/first-web.jpg\nindex_img: /imgs/web-history/first-web.jpg\n\n---\n\n**1991年**，有个叫蒂姆・博纳斯・李的英国科学家，写了世界上第一个静态网页。这个牛人不仅创造了超文本标记语言（HTML），而且还开发出世界上第一个网页浏览器，同时也由此发明了万维网(World Wide Web), 因此他也被称为万维网之父。\n\n![蒂姆・博纳斯・李](https://www.jvxiao.cn/imgs/web-history/TIM.png)\n\n早期的网页是静态的，当时的HTML标签并不丰富，当时的内容除了直接链接条状之外，没有任何的交互。到了**1994年**的时候，当时有一家有名的浏览器公司，大家应该也都听说过，叫网景(Netscape)， 它觉得页面缺少交互太单调了。脑袋一拍，Mocha出来了--也就是后来的JavaScript, JavaScript 的交互能力为网页广告弹窗(~~真讨厌~~)提供了技术基础。\n\n![Javascript](https://www.jvxiao.cn/imgs/web-history/Javascript.png)\n\n页面是可以动了，但是样式还是单调了些，而且还完全取决于浏览器开发商。页面缺少布局和美化手段，太粗糙了点。在**1994年**的时候，一个叫Hkon Wiumlie的开发者提出了CSS (层叠样式表)的想法，通过编写样式实现对页面内容的布局和美化。因为后来各大浏览器厂商对CSS的支持与差异，直到两年后的1996 年，W3才推出CSS规范的第一版本。 虽然CSS因此遗留了很多历史的BUG, 但终究还是统一了战线，不读不说这是个奇迹。\n\n![CSS](https://www.jvxiao.cn/imgs/web-history/CSS.png)\n\n到了**1995年**，网页迎来了一个巨大的转折，因为一门编程界的老梗编程语言诞生了--PHP(~~PHP是世界上最好的语言，不介绍反驳~~，不，JavaScript才是)。\n\nPHP的出现，让页面可以访问数据内容了，不再是单一静态页面加简单的动态交互了。通过把数据从数据库中取出来，然后塞到页面里，然后再返回给浏览器，从而实现了内容上的更新。\n\n![PHP](https://www.jvxiao.cn/imgs/web-history/PHP.png)\n\n但是这种前后端耦合的方式也带来了一个问题，就是页面需要频繁的刷新。页面中很小的变动，都会导致页面刷新，速度慢和流量消耗是个大问题。\n\n三步之内，必有解药，不行就三年。到了**1998年**，Ajax（Asynchronous JavaScript and XML）技术概念被提出，它大喊一声，学着点。Ajax通过动态加载数据，然后通过DOM操作将数据更新到页面的方式，完美的解决了页面频繁刷新的问题。\n\n![Jquery](https://www.jvxiao.cn/imgs/web-history/Jquery.png)\n\n想必后面的事情，大家都知道了，或者多少都有耳闻。 **2006年**，JQuery1.0 发布了，然后就是在Web开发中10年漫长的统治期，根据估计，到2010年，全球约90%的网站使用了JQuery。直到诸如Angular，React以及Vue等前端框架的崛起，这个Web界的王，才依依不舍离开曾经的宝座。\n\n## 传统Web技术的痛点\n\n类似JQuery这样封装了Ajax, DOM操作和时间处理的JS库，在很长一段时间里都是Web开发的主流技术，功能强大而且还简单易用。世界上总是没有免费的午餐的，对与JQuery来说，也是如此，它也存在着一定的不足之处。\n\n  - 性能问题\n    **DOM操作**： JQuery在处理大量DOM元素的时候可能不如原生JavaScript高效，因为其方法通常涉及遍历元素，增加了计算的开销\n    **选择器**: 岁让选择器方便，但复杂的选择器可能不如现在浏览器原生方法高效，影响性能。\n\n  - 体积问题\n    它的功能很强大，代码量自然也不会少，包的体积自然光也大。在弱网或移动端情况下，影响性能。\n\n  - 依赖性问题\n   项目可能仅使用部分功能却加载整个库，造成资源浪费。与其他库的冲突可能需要额外的处理，如使用noConflict模式。\n\n此外，2010年代，AngularJS, React和Vue.js等框架的出现，对JQuery的统治地位也构成了调账。新的MVC/MVVM模式，让用户更加方便的更新视图，在性能方面，采用虚拟DOM比传统的直接操作DOM消耗更少，更具优势。\n\n## MVVM技术框架\n\n- 定义：\n  - `Model: 数据层`，与MVC的Model类似。\n  - `View: 视图层`，负责数据展示。\n  - `ViewModel`: 将Model转化为View的友好格式，并处理用户交互。\n\n- 特点：\n  - `双向数据绑定`：ViewModel和View之间通过数据绑定自动同步数据。\n  - `简化逻辑`： ViewModel承担了部分Controller的职责，简化了View和Model的交换。\n  - `适用于声明编程`：适合使用声明式语法（如HTML）构建视图。\n\n![MVVM](https://www.jvxiao.cn/imgs/web-history/mvvm.jpg)\n\nMVVM通过数据双向绑定，分离关注点，简化视图逻辑、提高可测试性、支持响应式涉及和组件化开发等优势，极大地提升了前端开发的效率和代码质量。它特别适合需要复杂交互和动态数据的应用场景，如单页面应用和富客户端应用。选择MVVM模式能够帮助开发者构建更高效、更易于维护的前端应用。\n\n## 说回 Vue\n\n\n讲了那么多，终于回到我们的主题Vue了。之所以啰嗦，是希望你能够明白，无论是多么新的技术，都是有其发展历程和背景的。同时呢，无论看着多牛的技术框架，也是会有这样那样的问题的--人在挑毛病这块是无题的，而这也是技术不断往前发展的原因之一。\n\n![Vue](https://www.jvxiao.cn/imgs/web-history/Vue.png)\n\n技术的更新发展，往往都是对前一项主流技术上进行突破或者颠覆。比如，Vue这样的JS框架，解决的不就是视图渲染问题嘛，不再需要用户去操作DOM, 用户可以更加关注数据流和用户交互。从JavaScript刚刚实现用户交互直接跨越到Vue框架，一般我们称之为神话或者穿越...\n\n也许有一天 Vue 也被新的框架替代，但Web的故事还在继续，而我们，既是这段历史的见证者，也是下一章的书写人\n","slug":"web-history","published":1,"updated":"2025-08-26T10:42:59.644Z","_id":"cmcxijx4a0000o8upd07525ju","comments":1,"layout":"post","photos":[],"content":"<p><strong>1991年</strong>，有个叫蒂姆・博纳斯・李的英国科学家，写了世界上第一个静态网页。这个牛人不仅创造了超文本标记语言（HTML），而且还开发出世界上第一个网页浏览器，同时也由此发明了万维网(World Wide Web), 因此他也被称为万维网之父。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/web-history/TIM.png\" alt=\"蒂姆・博纳斯・李\"></p>\n<p>早期的网页是静态的，当时的HTML标签并不丰富，当时的内容除了直接链接条状之外，没有任何的交互。到了<strong>1994年</strong>的时候，当时有一家有名的浏览器公司，大家应该也都听说过，叫网景(Netscape)， 它觉得页面缺少交互太单调了。脑袋一拍，Mocha出来了–也就是后来的JavaScript, JavaScript 的交互能力为网页广告弹窗(<del>真讨厌</del>)提供了技术基础。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/web-history/Javascript.png\" alt=\"Javascript\"></p>\n<p>页面是可以动了，但是样式还是单调了些，而且还完全取决于浏览器开发商。页面缺少布局和美化手段，太粗糙了点。在<strong>1994年</strong>的时候，一个叫Hkon Wiumlie的开发者提出了CSS (层叠样式表)的想法，通过编写样式实现对页面内容的布局和美化。因为后来各大浏览器厂商对CSS的支持与差异，直到两年后的1996 年，W3才推出CSS规范的第一版本。 虽然CSS因此遗留了很多历史的BUG, 但终究还是统一了战线，不读不说这是个奇迹。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/web-history/CSS.png\" alt=\"CSS\"></p>\n<p>到了<strong>1995年</strong>，网页迎来了一个巨大的转折，因为一门编程界的老梗编程语言诞生了–PHP(<del>PHP是世界上最好的语言，不介绍反驳</del>，不，JavaScript才是)。</p>\n<p>PHP的出现，让页面可以访问数据内容了，不再是单一静态页面加简单的动态交互了。通过把数据从数据库中取出来，然后塞到页面里，然后再返回给浏览器，从而实现了内容上的更新。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/web-history/PHP.png\" alt=\"PHP\"></p>\n<p>但是这种前后端耦合的方式也带来了一个问题，就是页面需要频繁的刷新。页面中很小的变动，都会导致页面刷新，速度慢和流量消耗是个大问题。</p>\n<p>三步之内，必有解药，不行就三年。到了<strong>1998年</strong>，Ajax（Asynchronous JavaScript and XML）技术概念被提出，它大喊一声，学着点。Ajax通过动态加载数据，然后通过DOM操作将数据更新到页面的方式，完美的解决了页面频繁刷新的问题。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/web-history/Jquery.png\" alt=\"Jquery\"></p>\n<p>想必后面的事情，大家都知道了，或者多少都有耳闻。 <strong>2006年</strong>，JQuery1.0 发布了，然后就是在Web开发中10年漫长的统治期，根据估计，到2010年，全球约90%的网站使用了JQuery。直到诸如Angular，React以及Vue等前端框架的崛起，这个Web界的王，才依依不舍离开曾经的宝座。</p>\n<h2 id=\"传统Web技术的痛点\"><a href=\"#传统Web技术的痛点\" class=\"headerlink\" title=\"传统Web技术的痛点\"></a>传统Web技术的痛点</h2><p>类似JQuery这样封装了Ajax, DOM操作和时间处理的JS库，在很长一段时间里都是Web开发的主流技术，功能强大而且还简单易用。世界上总是没有免费的午餐的，对与JQuery来说，也是如此，它也存在着一定的不足之处。</p>\n<ul>\n<li><p>性能问题<br><strong>DOM操作</strong>： JQuery在处理大量DOM元素的时候可能不如原生JavaScript高效，因为其方法通常涉及遍历元素，增加了计算的开销<br><strong>选择器</strong>: 岁让选择器方便，但复杂的选择器可能不如现在浏览器原生方法高效，影响性能。</p>\n</li>\n<li><p>体积问题<br>它的功能很强大，代码量自然也不会少，包的体积自然光也大。在弱网或移动端情况下，影响性能。</p>\n</li>\n<li><p>依赖性问题<br>   项目可能仅使用部分功能却加载整个库，造成资源浪费。与其他库的冲突可能需要额外的处理，如使用noConflict模式。</p>\n</li>\n</ul>\n<p>此外，2010年代，AngularJS, React和Vue.js等框架的出现，对JQuery的统治地位也构成了调账。新的MVC&#x2F;MVVM模式，让用户更加方便的更新视图，在性能方面，采用虚拟DOM比传统的直接操作DOM消耗更少，更具优势。</p>\n<h2 id=\"MVVM技术框架\"><a href=\"#MVVM技术框架\" class=\"headerlink\" title=\"MVVM技术框架\"></a>MVVM技术框架</h2><ul>\n<li><p>定义：</p>\n<ul>\n<li><code>Model: 数据层</code>，与MVC的Model类似。</li>\n<li><code>View: 视图层</code>，负责数据展示。</li>\n<li><code>ViewModel</code>: 将Model转化为View的友好格式，并处理用户交互。</li>\n</ul>\n</li>\n<li><p>特点：</p>\n<ul>\n<li><code>双向数据绑定</code>：ViewModel和View之间通过数据绑定自动同步数据。</li>\n<li><code>简化逻辑</code>： ViewModel承担了部分Controller的职责，简化了View和Model的交换。</li>\n<li><code>适用于声明编程</code>：适合使用声明式语法（如HTML）构建视图。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://www.jvxiao.cn/imgs/web-history/mvvm.jpg\" alt=\"MVVM\"></p>\n<p>MVVM通过数据双向绑定，分离关注点，简化视图逻辑、提高可测试性、支持响应式涉及和组件化开发等优势，极大地提升了前端开发的效率和代码质量。它特别适合需要复杂交互和动态数据的应用场景，如单页面应用和富客户端应用。选择MVVM模式能够帮助开发者构建更高效、更易于维护的前端应用。</p>\n<h2 id=\"说回-Vue\"><a href=\"#说回-Vue\" class=\"headerlink\" title=\"说回 Vue\"></a>说回 Vue</h2><p>讲了那么多，终于回到我们的主题Vue了。之所以啰嗦，是希望你能够明白，无论是多么新的技术，都是有其发展历程和背景的。同时呢，无论看着多牛的技术框架，也是会有这样那样的问题的–人在挑毛病这块是无题的，而这也是技术不断往前发展的原因之一。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/web-history/Vue.png\" alt=\"Vue\"></p>\n<p>技术的更新发展，往往都是对前一项主流技术上进行突破或者颠覆。比如，Vue这样的JS框架，解决的不就是视图渲染问题嘛，不再需要用户去操作DOM, 用户可以更加关注数据流和用户交互。从JavaScript刚刚实现用户交互直接跨越到Vue框架，一般我们称之为神话或者穿越…</p>\n<p>也许有一天 Vue 也被新的框架替代，但Web的故事还在继续，而我们，既是这段历史的见证者，也是下一章的书写人</p>\n","excerpt":"","more":"<p><strong>1991年</strong>，有个叫蒂姆・博纳斯・李的英国科学家，写了世界上第一个静态网页。这个牛人不仅创造了超文本标记语言（HTML），而且还开发出世界上第一个网页浏览器，同时也由此发明了万维网(World Wide Web), 因此他也被称为万维网之父。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/web-history/TIM.png\" alt=\"蒂姆・博纳斯・李\"></p>\n<p>早期的网页是静态的，当时的HTML标签并不丰富，当时的内容除了直接链接条状之外，没有任何的交互。到了<strong>1994年</strong>的时候，当时有一家有名的浏览器公司，大家应该也都听说过，叫网景(Netscape)， 它觉得页面缺少交互太单调了。脑袋一拍，Mocha出来了–也就是后来的JavaScript, JavaScript 的交互能力为网页广告弹窗(<del>真讨厌</del>)提供了技术基础。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/web-history/Javascript.png\" alt=\"Javascript\"></p>\n<p>页面是可以动了，但是样式还是单调了些，而且还完全取决于浏览器开发商。页面缺少布局和美化手段，太粗糙了点。在<strong>1994年</strong>的时候，一个叫Hkon Wiumlie的开发者提出了CSS (层叠样式表)的想法，通过编写样式实现对页面内容的布局和美化。因为后来各大浏览器厂商对CSS的支持与差异，直到两年后的1996 年，W3才推出CSS规范的第一版本。 虽然CSS因此遗留了很多历史的BUG, 但终究还是统一了战线，不读不说这是个奇迹。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/web-history/CSS.png\" alt=\"CSS\"></p>\n<p>到了<strong>1995年</strong>，网页迎来了一个巨大的转折，因为一门编程界的老梗编程语言诞生了–PHP(<del>PHP是世界上最好的语言，不介绍反驳</del>，不，JavaScript才是)。</p>\n<p>PHP的出现，让页面可以访问数据内容了，不再是单一静态页面加简单的动态交互了。通过把数据从数据库中取出来，然后塞到页面里，然后再返回给浏览器，从而实现了内容上的更新。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/web-history/PHP.png\" alt=\"PHP\"></p>\n<p>但是这种前后端耦合的方式也带来了一个问题，就是页面需要频繁的刷新。页面中很小的变动，都会导致页面刷新，速度慢和流量消耗是个大问题。</p>\n<p>三步之内，必有解药，不行就三年。到了<strong>1998年</strong>，Ajax（Asynchronous JavaScript and XML）技术概念被提出，它大喊一声，学着点。Ajax通过动态加载数据，然后通过DOM操作将数据更新到页面的方式，完美的解决了页面频繁刷新的问题。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/web-history/Jquery.png\" alt=\"Jquery\"></p>\n<p>想必后面的事情，大家都知道了，或者多少都有耳闻。 <strong>2006年</strong>，JQuery1.0 发布了，然后就是在Web开发中10年漫长的统治期，根据估计，到2010年，全球约90%的网站使用了JQuery。直到诸如Angular，React以及Vue等前端框架的崛起，这个Web界的王，才依依不舍离开曾经的宝座。</p>\n<h2 id=\"传统Web技术的痛点\"><a href=\"#传统Web技术的痛点\" class=\"headerlink\" title=\"传统Web技术的痛点\"></a>传统Web技术的痛点</h2><p>类似JQuery这样封装了Ajax, DOM操作和时间处理的JS库，在很长一段时间里都是Web开发的主流技术，功能强大而且还简单易用。世界上总是没有免费的午餐的，对与JQuery来说，也是如此，它也存在着一定的不足之处。</p>\n<ul>\n<li><p>性能问题<br><strong>DOM操作</strong>： JQuery在处理大量DOM元素的时候可能不如原生JavaScript高效，因为其方法通常涉及遍历元素，增加了计算的开销<br><strong>选择器</strong>: 岁让选择器方便，但复杂的选择器可能不如现在浏览器原生方法高效，影响性能。</p>\n</li>\n<li><p>体积问题<br>它的功能很强大，代码量自然也不会少，包的体积自然光也大。在弱网或移动端情况下，影响性能。</p>\n</li>\n<li><p>依赖性问题<br>   项目可能仅使用部分功能却加载整个库，造成资源浪费。与其他库的冲突可能需要额外的处理，如使用noConflict模式。</p>\n</li>\n</ul>\n<p>此外，2010年代，AngularJS, React和Vue.js等框架的出现，对JQuery的统治地位也构成了调账。新的MVC&#x2F;MVVM模式，让用户更加方便的更新视图，在性能方面，采用虚拟DOM比传统的直接操作DOM消耗更少，更具优势。</p>\n<h2 id=\"MVVM技术框架\"><a href=\"#MVVM技术框架\" class=\"headerlink\" title=\"MVVM技术框架\"></a>MVVM技术框架</h2><ul>\n<li><p>定义：</p>\n<ul>\n<li><code>Model: 数据层</code>，与MVC的Model类似。</li>\n<li><code>View: 视图层</code>，负责数据展示。</li>\n<li><code>ViewModel</code>: 将Model转化为View的友好格式，并处理用户交互。</li>\n</ul>\n</li>\n<li><p>特点：</p>\n<ul>\n<li><code>双向数据绑定</code>：ViewModel和View之间通过数据绑定自动同步数据。</li>\n<li><code>简化逻辑</code>： ViewModel承担了部分Controller的职责，简化了View和Model的交换。</li>\n<li><code>适用于声明编程</code>：适合使用声明式语法（如HTML）构建视图。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://www.jvxiao.cn/imgs/web-history/mvvm.jpg\" alt=\"MVVM\"></p>\n<p>MVVM通过数据双向绑定，分离关注点，简化视图逻辑、提高可测试性、支持响应式涉及和组件化开发等优势，极大地提升了前端开发的效率和代码质量。它特别适合需要复杂交互和动态数据的应用场景，如单页面应用和富客户端应用。选择MVVM模式能够帮助开发者构建更高效、更易于维护的前端应用。</p>\n<h2 id=\"说回-Vue\"><a href=\"#说回-Vue\" class=\"headerlink\" title=\"说回 Vue\"></a>说回 Vue</h2><p>讲了那么多，终于回到我们的主题Vue了。之所以啰嗦，是希望你能够明白，无论是多么新的技术，都是有其发展历程和背景的。同时呢，无论看着多牛的技术框架，也是会有这样那样的问题的–人在挑毛病这块是无题的，而这也是技术不断往前发展的原因之一。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/web-history/Vue.png\" alt=\"Vue\"></p>\n<p>技术的更新发展，往往都是对前一项主流技术上进行突破或者颠覆。比如，Vue这样的JS框架，解决的不就是视图渲染问题嘛，不再需要用户去操作DOM, 用户可以更加关注数据流和用户交互。从JavaScript刚刚实现用户交互直接跨越到Vue框架，一般我们称之为神话或者穿越…</p>\n<p>也许有一天 Vue 也被新的框架替代，但Web的故事还在继续，而我们，既是这段历史的见证者，也是下一章的书写人</p>\n"},{"title":"从崩溃到稳定：前端开发者必学的 Node.js 守护进程实战指南","date":"2025-07-15T13:37:08.000Z","index_img":"imgs/daemon/640.jfif","banner_img":"imgs/daemon/640.jfif","_content":"\n说到守护进程，绝大多数开发者其实都不陌生，甚至有些记性比较好的同学还能大段背诵关于进程的面试八股文呢。虽然在日常的Web开发工作中很少使用到它，而且可能从写Web第一天到离职都没有真正写过一个守护进程，即使有或许还是学校里教学用的--使用C语言实现的Demo。\n\n不要怪作者嘴巴毒，事实就是这样的，即使一个工作5,6年的老Web开发，你让他现场写个守护进程，还真不一定就能立马写出来。今天就尝试着使用Node来实现一个守护进程，试着唤醒你那将要死去的记忆。\n\n把一个大象关进冰箱分几步？ 写一个守护进程又分几步？\n\n## 1. 创建子进程并脱离控制终端\n\n当我们使用Node执行某一个js脚本时，Node会创建一个进程，当脚本执行结束了，进程也就结束了。\n\n为了创建守护进程，需要在脚本执行的过程中(父进程)创建一个子进程，并且在子进程创建之后，要让其自立门户，脱离父进程，这样即使父进程退出，也不会影响子进程\n\n```javascript\n// start.js\nconst { fork } = require('child_process');\nconst path = require('path');\n\n// 创建子进程\nconst child = fork(path.join(__dirname, 'daemon.js'), {\n    detached: true,  // 使子进程成为新的进程组领导\n    stdio: 'ignore'  // 忽略标准输入/输出/错误\n});\n\n// 解除父进程对子进程的引用\nchild.unref();\n\n//父进程退出\nprocess.exit(0);\n```\n\n如上述代码所示，使用 `chilrd_process`中的 `fork`方法创建一个子进程，它会自动建立父子进程间的 IPC 通信通道。其中的几个参数，详细讲解一下：\n\n- 第一个参数 daemon.js 是要执行的子进程脚本路径，通过 `path.join(__dirname, ...)` 确保路径正确。\n- 第二个参数是配置对象，包含关键选项：\n\n  - **detached: true**​：使子进程成为新进程组的领导者（非 Windows 系统）或拥有独立控制台（Windows），允许子进程在父进程退出后继续运行\n\n  - ​**stdio\\: ignore**​：忽略子进程的标准输入/输出/错误流，避免管道阻塞问题\n\n## 2. 设置工作目录和文件权限\n\n```javascript\n// daemon.js\n\n// 改变工作目录到根目录或特定目录\nprocess.chdir('/');\n\n// 重设文件权限掩码\nprocess.umask(0);\n```\n\n为了将守护进程独立于启动它的环境，我们通过改变工作目录来实现隔离，而且这样还可以避免挂载点无法卸载。\n\n另外还需要关注一下权限的问题，将掩码设置为0，这样守护进程创建的文件和目录将使用系统的默认权限。\n\n\n## 3. 配置日志模块\n\n守护进程不同于在终端执行命令行的进程，它是不占用终端的，所以是看不到它输出内容在终端上。因此，需要配置一个日志模块，用于记录下一些关键信息，避免在报错或者调试的时候两眼抓瞎。\n\n日志模块其实很简单，功能就是将内容记录到文本中即可\n\n```javascript\n// daemon.js\n\n// 设置日志记录\nconst util = require('util');\nconst logFile = fs.createWriteStream('daemon.log', { flags: 'a' });\nconst log = function(msg) {\n    logFile.write(util.format(msg) + '\\n');\n};\n\n```\n\n\n## 4. 处理信号和错误\n\n为了提高守护进程的稳定性和可靠性，需要对一些系统信号做处理，从而应对各种意外，毕竟总不希望守护进程挂掉了，而自己却连什么时候挂掉了都不知道吧。\n\n其中，重点是以下几个信号量：\n\n- **SIGINT (Ctrl+C)**: \n通常由用户在终端中按下 `Ctrl+C` 发送\n\n- **SIGTERM**: \n系统关闭或通过 kill <pid> 发送的默认信号\n\n- **SIGHUP**: \n传统上表示控制终端关闭,守护进程通常忽略此信号或用于重新加载配置\n\n```javascript\n// 处理进程信号\nprocess.on('SIGINT', () => {\n  log('收到 SIGINT 信号，准备停止...');\n  // 执行清理和停止逻辑\n});\n\nprocess.on('SIGTERM', () => {\n log('收到 SIGTERM 信号，准备停止...');\n  // 执行清理和停止逻辑\n});\n\n// 忽略挂起信号(SIGHUP)\nprocess.on('SIGHUP', () => {});\n\n// 全局错误处理\nprocess.on('uncaughtException', (err) => {\n    log(`未捕获异常: ${err}`);\n    // 可以添加重启逻辑\n});\n\nprocess.on('unhandledRejection', (reason, promise) => {\n    log(`未处理的Promise拒绝:', ${reason}`);\n});\n\n```\n\n## 5. 实现守护进程主体内容\n\n前面的一些列操作，都是为了保证守护进程能够正常启动和执行，接下来就到了相对来说简单的部分了。\n\n守护进程主体内容，通常来说最好是个循环，定时任务，或者对外的请求监听，这样才不会运行之后马上就结束。\n\n下面以一个简单的 `httpServer`作为例子。\n\n```javascript\nconst http = require('http');\nconst port = 5000;\nconst app = http.createServer((req, res) => {\n  console.log(`${req.method} ${req.url}`);\n  res.end('Hello daemon');\n})\n\napp.listen(port, '0.0.0.0', () => {\n  console.log(`Server listening on: http://localhost:${port}`);\n})\n\n```\n\n## 6. 启动服务并验证\n\n完成代码编写之后，我们尝试着启动服务并验证服务是否启动成功了。打开终端，执行 `node start.js`。父进程在执行完之后，会立即退出，因此不会占用终端。\n\n通过浏览器访问地址 `http://localhost:5000`, 能够正确显示内容，说明守护进程启动成功了。\n\n![success](https://www.jvxiao.cn/imgs/daemon/success.png)\n\n另外查看一下日志文件 `daemon.log`，可以看到服务启动和请求的记录。\n![success](https://www.jvxiao.cn/imgs/daemon/logs.png)\n\n\n在任务管理中，也能看到一个一直活跃的 node 进程。\n![success](https://www.jvxiao.cn/imgs/daemon/panel.png)\n\nBingo~~~, 一个简单的守护进程就这么实现了。\n\n\n## 写在最后\n\n除了上面的方法，其实也还有其它一些快捷的方式来创建守护进程，如使用`pm2` 或者 `forever`, 但是纯手工创建守护进程的基本功不能丢了。\n\n实现守护进程的过程，也是深入理解 Node.js 进程模型和操作系统交互的绝佳机会。从工作目录设置、权限管理到信号处理、错误捕获，每一个细节都体现了对系统编程的深刻理解。这些知识不仅适用于守护进程开发，更能帮助我们编写更健壮的 Node.js 应用。","source":"_posts/create-daemond-with-node.md","raw":"---\ntitle: 从崩溃到稳定：前端开发者必学的 Node.js 守护进程实战指南\ndate: 2025-07-15 21:37:08\ntags: [守护进程, Node]\ncategory: Web开发\nindex_img: imgs/daemon/640.jfif\nbanner_img: imgs/daemon/640.jfif\n---\n\n说到守护进程，绝大多数开发者其实都不陌生，甚至有些记性比较好的同学还能大段背诵关于进程的面试八股文呢。虽然在日常的Web开发工作中很少使用到它，而且可能从写Web第一天到离职都没有真正写过一个守护进程，即使有或许还是学校里教学用的--使用C语言实现的Demo。\n\n不要怪作者嘴巴毒，事实就是这样的，即使一个工作5,6年的老Web开发，你让他现场写个守护进程，还真不一定就能立马写出来。今天就尝试着使用Node来实现一个守护进程，试着唤醒你那将要死去的记忆。\n\n把一个大象关进冰箱分几步？ 写一个守护进程又分几步？\n\n## 1. 创建子进程并脱离控制终端\n\n当我们使用Node执行某一个js脚本时，Node会创建一个进程，当脚本执行结束了，进程也就结束了。\n\n为了创建守护进程，需要在脚本执行的过程中(父进程)创建一个子进程，并且在子进程创建之后，要让其自立门户，脱离父进程，这样即使父进程退出，也不会影响子进程\n\n```javascript\n// start.js\nconst { fork } = require('child_process');\nconst path = require('path');\n\n// 创建子进程\nconst child = fork(path.join(__dirname, 'daemon.js'), {\n    detached: true,  // 使子进程成为新的进程组领导\n    stdio: 'ignore'  // 忽略标准输入/输出/错误\n});\n\n// 解除父进程对子进程的引用\nchild.unref();\n\n//父进程退出\nprocess.exit(0);\n```\n\n如上述代码所示，使用 `chilrd_process`中的 `fork`方法创建一个子进程，它会自动建立父子进程间的 IPC 通信通道。其中的几个参数，详细讲解一下：\n\n- 第一个参数 daemon.js 是要执行的子进程脚本路径，通过 `path.join(__dirname, ...)` 确保路径正确。\n- 第二个参数是配置对象，包含关键选项：\n\n  - **detached: true**​：使子进程成为新进程组的领导者（非 Windows 系统）或拥有独立控制台（Windows），允许子进程在父进程退出后继续运行\n\n  - ​**stdio\\: ignore**​：忽略子进程的标准输入/输出/错误流，避免管道阻塞问题\n\n## 2. 设置工作目录和文件权限\n\n```javascript\n// daemon.js\n\n// 改变工作目录到根目录或特定目录\nprocess.chdir('/');\n\n// 重设文件权限掩码\nprocess.umask(0);\n```\n\n为了将守护进程独立于启动它的环境，我们通过改变工作目录来实现隔离，而且这样还可以避免挂载点无法卸载。\n\n另外还需要关注一下权限的问题，将掩码设置为0，这样守护进程创建的文件和目录将使用系统的默认权限。\n\n\n## 3. 配置日志模块\n\n守护进程不同于在终端执行命令行的进程，它是不占用终端的，所以是看不到它输出内容在终端上。因此，需要配置一个日志模块，用于记录下一些关键信息，避免在报错或者调试的时候两眼抓瞎。\n\n日志模块其实很简单，功能就是将内容记录到文本中即可\n\n```javascript\n// daemon.js\n\n// 设置日志记录\nconst util = require('util');\nconst logFile = fs.createWriteStream('daemon.log', { flags: 'a' });\nconst log = function(msg) {\n    logFile.write(util.format(msg) + '\\n');\n};\n\n```\n\n\n## 4. 处理信号和错误\n\n为了提高守护进程的稳定性和可靠性，需要对一些系统信号做处理，从而应对各种意外，毕竟总不希望守护进程挂掉了，而自己却连什么时候挂掉了都不知道吧。\n\n其中，重点是以下几个信号量：\n\n- **SIGINT (Ctrl+C)**: \n通常由用户在终端中按下 `Ctrl+C` 发送\n\n- **SIGTERM**: \n系统关闭或通过 kill <pid> 发送的默认信号\n\n- **SIGHUP**: \n传统上表示控制终端关闭,守护进程通常忽略此信号或用于重新加载配置\n\n```javascript\n// 处理进程信号\nprocess.on('SIGINT', () => {\n  log('收到 SIGINT 信号，准备停止...');\n  // 执行清理和停止逻辑\n});\n\nprocess.on('SIGTERM', () => {\n log('收到 SIGTERM 信号，准备停止...');\n  // 执行清理和停止逻辑\n});\n\n// 忽略挂起信号(SIGHUP)\nprocess.on('SIGHUP', () => {});\n\n// 全局错误处理\nprocess.on('uncaughtException', (err) => {\n    log(`未捕获异常: ${err}`);\n    // 可以添加重启逻辑\n});\n\nprocess.on('unhandledRejection', (reason, promise) => {\n    log(`未处理的Promise拒绝:', ${reason}`);\n});\n\n```\n\n## 5. 实现守护进程主体内容\n\n前面的一些列操作，都是为了保证守护进程能够正常启动和执行，接下来就到了相对来说简单的部分了。\n\n守护进程主体内容，通常来说最好是个循环，定时任务，或者对外的请求监听，这样才不会运行之后马上就结束。\n\n下面以一个简单的 `httpServer`作为例子。\n\n```javascript\nconst http = require('http');\nconst port = 5000;\nconst app = http.createServer((req, res) => {\n  console.log(`${req.method} ${req.url}`);\n  res.end('Hello daemon');\n})\n\napp.listen(port, '0.0.0.0', () => {\n  console.log(`Server listening on: http://localhost:${port}`);\n})\n\n```\n\n## 6. 启动服务并验证\n\n完成代码编写之后，我们尝试着启动服务并验证服务是否启动成功了。打开终端，执行 `node start.js`。父进程在执行完之后，会立即退出，因此不会占用终端。\n\n通过浏览器访问地址 `http://localhost:5000`, 能够正确显示内容，说明守护进程启动成功了。\n\n![success](https://www.jvxiao.cn/imgs/daemon/success.png)\n\n另外查看一下日志文件 `daemon.log`，可以看到服务启动和请求的记录。\n![success](https://www.jvxiao.cn/imgs/daemon/logs.png)\n\n\n在任务管理中，也能看到一个一直活跃的 node 进程。\n![success](https://www.jvxiao.cn/imgs/daemon/panel.png)\n\nBingo~~~, 一个简单的守护进程就这么实现了。\n\n\n## 写在最后\n\n除了上面的方法，其实也还有其它一些快捷的方式来创建守护进程，如使用`pm2` 或者 `forever`, 但是纯手工创建守护进程的基本功不能丢了。\n\n实现守护进程的过程，也是深入理解 Node.js 进程模型和操作系统交互的绝佳机会。从工作目录设置、权限管理到信号处理、错误捕获，每一个细节都体现了对系统编程的深刻理解。这些知识不仅适用于守护进程开发，更能帮助我们编写更健壮的 Node.js 应用。","slug":"create-daemond-with-node","published":1,"updated":"2025-08-26T10:41:18.347Z","_id":"cmd79bx86000018up16wx4uvn","comments":1,"layout":"post","photos":[],"content":"<p>说到守护进程，绝大多数开发者其实都不陌生，甚至有些记性比较好的同学还能大段背诵关于进程的面试八股文呢。虽然在日常的Web开发工作中很少使用到它，而且可能从写Web第一天到离职都没有真正写过一个守护进程，即使有或许还是学校里教学用的–使用C语言实现的Demo。</p>\n<p>不要怪作者嘴巴毒，事实就是这样的，即使一个工作5,6年的老Web开发，你让他现场写个守护进程，还真不一定就能立马写出来。今天就尝试着使用Node来实现一个守护进程，试着唤醒你那将要死去的记忆。</p>\n<p>把一个大象关进冰箱分几步？ 写一个守护进程又分几步？</p>\n<h2 id=\"1-创建子进程并脱离控制终端\"><a href=\"#1-创建子进程并脱离控制终端\" class=\"headerlink\" title=\"1. 创建子进程并脱离控制终端\"></a>1. 创建子进程并脱离控制终端</h2><p>当我们使用Node执行某一个js脚本时，Node会创建一个进程，当脚本执行结束了，进程也就结束了。</p>\n<p>为了创建守护进程，需要在脚本执行的过程中(父进程)创建一个子进程，并且在子进程创建之后，要让其自立门户，脱离父进程，这样即使父进程退出，也不会影响子进程</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// start.js</span><br><span class=\"hljs-keyword\">const</span> &#123; fork &#125; = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;child_process&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;path&#x27;</span>);<br><br><span class=\"hljs-comment\">// 创建子进程</span><br><span class=\"hljs-keyword\">const</span> child = <span class=\"hljs-title function_\">fork</span>(path.<span class=\"hljs-title function_\">join</span>(__dirname, <span class=\"hljs-string\">&#x27;daemon.js&#x27;</span>), &#123;<br>    <span class=\"hljs-attr\">detached</span>: <span class=\"hljs-literal\">true</span>,  <span class=\"hljs-comment\">// 使子进程成为新的进程组领导</span><br>    <span class=\"hljs-attr\">stdio</span>: <span class=\"hljs-string\">&#x27;ignore&#x27;</span>  <span class=\"hljs-comment\">// 忽略标准输入/输出/错误</span><br>&#125;);<br><br><span class=\"hljs-comment\">// 解除父进程对子进程的引用</span><br>child.<span class=\"hljs-title function_\">unref</span>();<br><br><span class=\"hljs-comment\">//父进程退出</span><br>process.<span class=\"hljs-title function_\">exit</span>(<span class=\"hljs-number\">0</span>);<br></code></pre></td></tr></table></figure>\n\n<p>如上述代码所示，使用 <code>chilrd_process</code>中的 <code>fork</code>方法创建一个子进程，它会自动建立父子进程间的 IPC 通信通道。其中的几个参数，详细讲解一下：</p>\n<ul>\n<li><p>第一个参数 daemon.js 是要执行的子进程脚本路径，通过 <code>path.join(__dirname, ...)</code> 确保路径正确。</p>\n</li>\n<li><p>第二个参数是配置对象，包含关键选项：</p>\n<ul>\n<li><p><strong>detached: true</strong>​：使子进程成为新进程组的领导者（非 Windows 系统）或拥有独立控制台（Windows），允许子进程在父进程退出后继续运行</p>\n</li>\n<li><p>​<strong>stdio: ignore</strong>​：忽略子进程的标准输入&#x2F;输出&#x2F;错误流，避免管道阻塞问题</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-设置工作目录和文件权限\"><a href=\"#2-设置工作目录和文件权限\" class=\"headerlink\" title=\"2. 设置工作目录和文件权限\"></a>2. 设置工作目录和文件权限</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// daemon.js</span><br><br><span class=\"hljs-comment\">// 改变工作目录到根目录或特定目录</span><br>process.<span class=\"hljs-title function_\">chdir</span>(<span class=\"hljs-string\">&#x27;/&#x27;</span>);<br><br><span class=\"hljs-comment\">// 重设文件权限掩码</span><br>process.<span class=\"hljs-title function_\">umask</span>(<span class=\"hljs-number\">0</span>);<br></code></pre></td></tr></table></figure>\n\n<p>为了将守护进程独立于启动它的环境，我们通过改变工作目录来实现隔离，而且这样还可以避免挂载点无法卸载。</p>\n<p>另外还需要关注一下权限的问题，将掩码设置为0，这样守护进程创建的文件和目录将使用系统的默认权限。</p>\n<h2 id=\"3-配置日志模块\"><a href=\"#3-配置日志模块\" class=\"headerlink\" title=\"3. 配置日志模块\"></a>3. 配置日志模块</h2><p>守护进程不同于在终端执行命令行的进程，它是不占用终端的，所以是看不到它输出内容在终端上。因此，需要配置一个日志模块，用于记录下一些关键信息，避免在报错或者调试的时候两眼抓瞎。</p>\n<p>日志模块其实很简单，功能就是将内容记录到文本中即可</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// daemon.js</span><br><br><span class=\"hljs-comment\">// 设置日志记录</span><br><span class=\"hljs-keyword\">const</span> util = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;util&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> logFile = fs.<span class=\"hljs-title function_\">createWriteStream</span>(<span class=\"hljs-string\">&#x27;daemon.log&#x27;</span>, &#123; <span class=\"hljs-attr\">flags</span>: <span class=\"hljs-string\">&#x27;a&#x27;</span> &#125;);<br><span class=\"hljs-keyword\">const</span> log = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">msg</span>) &#123;<br>    logFile.<span class=\"hljs-title function_\">write</span>(util.<span class=\"hljs-title function_\">format</span>(msg) + <span class=\"hljs-string\">&#x27;\\n&#x27;</span>);<br>&#125;;<br><br></code></pre></td></tr></table></figure>\n\n\n<h2 id=\"4-处理信号和错误\"><a href=\"#4-处理信号和错误\" class=\"headerlink\" title=\"4. 处理信号和错误\"></a>4. 处理信号和错误</h2><p>为了提高守护进程的稳定性和可靠性，需要对一些系统信号做处理，从而应对各种意外，毕竟总不希望守护进程挂掉了，而自己却连什么时候挂掉了都不知道吧。</p>\n<p>其中，重点是以下几个信号量：</p>\n<ul>\n<li><p><strong>SIGINT (Ctrl+C)</strong>:<br>通常由用户在终端中按下 <code>Ctrl+C</code> 发送</p>\n</li>\n<li><p><strong>SIGTERM</strong>:<br>系统关闭或通过 kill <pid> 发送的默认信号</p>\n</li>\n<li><p><strong>SIGHUP</strong>:<br>传统上表示控制终端关闭,守护进程通常忽略此信号或用于重新加载配置</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 处理进程信号</span><br>process.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;SIGINT&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;收到 SIGINT 信号，准备停止...&#x27;</span>);<br>  <span class=\"hljs-comment\">// 执行清理和停止逻辑</span><br>&#125;);<br><br>process.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;SIGTERM&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;<br> <span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;收到 SIGTERM 信号，准备停止...&#x27;</span>);<br>  <span class=\"hljs-comment\">// 执行清理和停止逻辑</span><br>&#125;);<br><br><span class=\"hljs-comment\">// 忽略挂起信号(SIGHUP)</span><br>process.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;SIGHUP&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;&#125;);<br><br><span class=\"hljs-comment\">// 全局错误处理</span><br>process.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;uncaughtException&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">err</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`未捕获异常: <span class=\"hljs-subst\">$&#123;err&#125;</span>`</span>);<br>    <span class=\"hljs-comment\">// 可以添加重启逻辑</span><br>&#125;);<br><br>process.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;unhandledRejection&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">reason, promise</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`未处理的Promise拒绝:&#x27;, <span class=\"hljs-subst\">$&#123;reason&#125;</span>`</span>);<br>&#125;);<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"5-实现守护进程主体内容\"><a href=\"#5-实现守护进程主体内容\" class=\"headerlink\" title=\"5. 实现守护进程主体内容\"></a>5. 实现守护进程主体内容</h2><p>前面的一些列操作，都是为了保证守护进程能够正常启动和执行，接下来就到了相对来说简单的部分了。</p>\n<p>守护进程主体内容，通常来说最好是个循环，定时任务，或者对外的请求监听，这样才不会运行之后马上就结束。</p>\n<p>下面以一个简单的 <code>httpServer</code>作为例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;http&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> port = <span class=\"hljs-number\">5000</span>;<br><span class=\"hljs-keyword\">const</span> app = http.<span class=\"hljs-title function_\">createServer</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">req, res</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;req.method&#125;</span> <span class=\"hljs-subst\">$&#123;req.url&#125;</span>`</span>);<br>  res.<span class=\"hljs-title function_\">end</span>(<span class=\"hljs-string\">&#x27;Hello daemon&#x27;</span>);<br>&#125;)<br><br>app.<span class=\"hljs-title function_\">listen</span>(port, <span class=\"hljs-string\">&#x27;0.0.0.0&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`Server listening on: http://localhost:<span class=\"hljs-subst\">$&#123;port&#125;</span>`</span>);<br>&#125;)<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"6-启动服务并验证\"><a href=\"#6-启动服务并验证\" class=\"headerlink\" title=\"6. 启动服务并验证\"></a>6. 启动服务并验证</h2><p>完成代码编写之后，我们尝试着启动服务并验证服务是否启动成功了。打开终端，执行 <code>node start.js</code>。父进程在执行完之后，会立即退出，因此不会占用终端。</p>\n<p>通过浏览器访问地址 <code>http://localhost:5000</code>, 能够正确显示内容，说明守护进程启动成功了。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/daemon/success.png\" alt=\"success\"></p>\n<p>另外查看一下日志文件 <code>daemon.log</code>，可以看到服务启动和请求的记录。<br><img src=\"https://www.jvxiao.cn/imgs/daemon/logs.png\" alt=\"success\"></p>\n<p>在任务管理中，也能看到一个一直活跃的 node 进程。<br><img src=\"https://www.jvxiao.cn/imgs/daemon/panel.png\" alt=\"success\"></p>\n<p>Bingo~~~, 一个简单的守护进程就这么实现了。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>除了上面的方法，其实也还有其它一些快捷的方式来创建守护进程，如使用<code>pm2</code> 或者 <code>forever</code>, 但是纯手工创建守护进程的基本功不能丢了。</p>\n<p>实现守护进程的过程，也是深入理解 Node.js 进程模型和操作系统交互的绝佳机会。从工作目录设置、权限管理到信号处理、错误捕获，每一个细节都体现了对系统编程的深刻理解。这些知识不仅适用于守护进程开发，更能帮助我们编写更健壮的 Node.js 应用。</p>\n","excerpt":"","more":"<p>说到守护进程，绝大多数开发者其实都不陌生，甚至有些记性比较好的同学还能大段背诵关于进程的面试八股文呢。虽然在日常的Web开发工作中很少使用到它，而且可能从写Web第一天到离职都没有真正写过一个守护进程，即使有或许还是学校里教学用的–使用C语言实现的Demo。</p>\n<p>不要怪作者嘴巴毒，事实就是这样的，即使一个工作5,6年的老Web开发，你让他现场写个守护进程，还真不一定就能立马写出来。今天就尝试着使用Node来实现一个守护进程，试着唤醒你那将要死去的记忆。</p>\n<p>把一个大象关进冰箱分几步？ 写一个守护进程又分几步？</p>\n<h2 id=\"1-创建子进程并脱离控制终端\"><a href=\"#1-创建子进程并脱离控制终端\" class=\"headerlink\" title=\"1. 创建子进程并脱离控制终端\"></a>1. 创建子进程并脱离控制终端</h2><p>当我们使用Node执行某一个js脚本时，Node会创建一个进程，当脚本执行结束了，进程也就结束了。</p>\n<p>为了创建守护进程，需要在脚本执行的过程中(父进程)创建一个子进程，并且在子进程创建之后，要让其自立门户，脱离父进程，这样即使父进程退出，也不会影响子进程</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// start.js</span><br><span class=\"hljs-keyword\">const</span> &#123; fork &#125; = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;child_process&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;path&#x27;</span>);<br><br><span class=\"hljs-comment\">// 创建子进程</span><br><span class=\"hljs-keyword\">const</span> child = <span class=\"hljs-title function_\">fork</span>(path.<span class=\"hljs-title function_\">join</span>(__dirname, <span class=\"hljs-string\">&#x27;daemon.js&#x27;</span>), &#123;<br>    <span class=\"hljs-attr\">detached</span>: <span class=\"hljs-literal\">true</span>,  <span class=\"hljs-comment\">// 使子进程成为新的进程组领导</span><br>    <span class=\"hljs-attr\">stdio</span>: <span class=\"hljs-string\">&#x27;ignore&#x27;</span>  <span class=\"hljs-comment\">// 忽略标准输入/输出/错误</span><br>&#125;);<br><br><span class=\"hljs-comment\">// 解除父进程对子进程的引用</span><br>child.<span class=\"hljs-title function_\">unref</span>();<br><br><span class=\"hljs-comment\">//父进程退出</span><br>process.<span class=\"hljs-title function_\">exit</span>(<span class=\"hljs-number\">0</span>);<br></code></pre></td></tr></table></figure>\n\n<p>如上述代码所示，使用 <code>chilrd_process</code>中的 <code>fork</code>方法创建一个子进程，它会自动建立父子进程间的 IPC 通信通道。其中的几个参数，详细讲解一下：</p>\n<ul>\n<li><p>第一个参数 daemon.js 是要执行的子进程脚本路径，通过 <code>path.join(__dirname, ...)</code> 确保路径正确。</p>\n</li>\n<li><p>第二个参数是配置对象，包含关键选项：</p>\n<ul>\n<li><p><strong>detached: true</strong>​：使子进程成为新进程组的领导者（非 Windows 系统）或拥有独立控制台（Windows），允许子进程在父进程退出后继续运行</p>\n</li>\n<li><p>​<strong>stdio: ignore</strong>​：忽略子进程的标准输入&#x2F;输出&#x2F;错误流，避免管道阻塞问题</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-设置工作目录和文件权限\"><a href=\"#2-设置工作目录和文件权限\" class=\"headerlink\" title=\"2. 设置工作目录和文件权限\"></a>2. 设置工作目录和文件权限</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// daemon.js</span><br><br><span class=\"hljs-comment\">// 改变工作目录到根目录或特定目录</span><br>process.<span class=\"hljs-title function_\">chdir</span>(<span class=\"hljs-string\">&#x27;/&#x27;</span>);<br><br><span class=\"hljs-comment\">// 重设文件权限掩码</span><br>process.<span class=\"hljs-title function_\">umask</span>(<span class=\"hljs-number\">0</span>);<br></code></pre></td></tr></table></figure>\n\n<p>为了将守护进程独立于启动它的环境，我们通过改变工作目录来实现隔离，而且这样还可以避免挂载点无法卸载。</p>\n<p>另外还需要关注一下权限的问题，将掩码设置为0，这样守护进程创建的文件和目录将使用系统的默认权限。</p>\n<h2 id=\"3-配置日志模块\"><a href=\"#3-配置日志模块\" class=\"headerlink\" title=\"3. 配置日志模块\"></a>3. 配置日志模块</h2><p>守护进程不同于在终端执行命令行的进程，它是不占用终端的，所以是看不到它输出内容在终端上。因此，需要配置一个日志模块，用于记录下一些关键信息，避免在报错或者调试的时候两眼抓瞎。</p>\n<p>日志模块其实很简单，功能就是将内容记录到文本中即可</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// daemon.js</span><br><br><span class=\"hljs-comment\">// 设置日志记录</span><br><span class=\"hljs-keyword\">const</span> util = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;util&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> logFile = fs.<span class=\"hljs-title function_\">createWriteStream</span>(<span class=\"hljs-string\">&#x27;daemon.log&#x27;</span>, &#123; <span class=\"hljs-attr\">flags</span>: <span class=\"hljs-string\">&#x27;a&#x27;</span> &#125;);<br><span class=\"hljs-keyword\">const</span> log = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">msg</span>) &#123;<br>    logFile.<span class=\"hljs-title function_\">write</span>(util.<span class=\"hljs-title function_\">format</span>(msg) + <span class=\"hljs-string\">&#x27;\\n&#x27;</span>);<br>&#125;;<br><br></code></pre></td></tr></table></figure>\n\n\n<h2 id=\"4-处理信号和错误\"><a href=\"#4-处理信号和错误\" class=\"headerlink\" title=\"4. 处理信号和错误\"></a>4. 处理信号和错误</h2><p>为了提高守护进程的稳定性和可靠性，需要对一些系统信号做处理，从而应对各种意外，毕竟总不希望守护进程挂掉了，而自己却连什么时候挂掉了都不知道吧。</p>\n<p>其中，重点是以下几个信号量：</p>\n<ul>\n<li><p><strong>SIGINT (Ctrl+C)</strong>:<br>通常由用户在终端中按下 <code>Ctrl+C</code> 发送</p>\n</li>\n<li><p><strong>SIGTERM</strong>:<br>系统关闭或通过 kill <pid> 发送的默认信号</p>\n</li>\n<li><p><strong>SIGHUP</strong>:<br>传统上表示控制终端关闭,守护进程通常忽略此信号或用于重新加载配置</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 处理进程信号</span><br>process.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;SIGINT&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;收到 SIGINT 信号，准备停止...&#x27;</span>);<br>  <span class=\"hljs-comment\">// 执行清理和停止逻辑</span><br>&#125;);<br><br>process.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;SIGTERM&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;<br> <span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;收到 SIGTERM 信号，准备停止...&#x27;</span>);<br>  <span class=\"hljs-comment\">// 执行清理和停止逻辑</span><br>&#125;);<br><br><span class=\"hljs-comment\">// 忽略挂起信号(SIGHUP)</span><br>process.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;SIGHUP&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;&#125;);<br><br><span class=\"hljs-comment\">// 全局错误处理</span><br>process.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;uncaughtException&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">err</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`未捕获异常: <span class=\"hljs-subst\">$&#123;err&#125;</span>`</span>);<br>    <span class=\"hljs-comment\">// 可以添加重启逻辑</span><br>&#125;);<br><br>process.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;unhandledRejection&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">reason, promise</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`未处理的Promise拒绝:&#x27;, <span class=\"hljs-subst\">$&#123;reason&#125;</span>`</span>);<br>&#125;);<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"5-实现守护进程主体内容\"><a href=\"#5-实现守护进程主体内容\" class=\"headerlink\" title=\"5. 实现守护进程主体内容\"></a>5. 实现守护进程主体内容</h2><p>前面的一些列操作，都是为了保证守护进程能够正常启动和执行，接下来就到了相对来说简单的部分了。</p>\n<p>守护进程主体内容，通常来说最好是个循环，定时任务，或者对外的请求监听，这样才不会运行之后马上就结束。</p>\n<p>下面以一个简单的 <code>httpServer</code>作为例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;http&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> port = <span class=\"hljs-number\">5000</span>;<br><span class=\"hljs-keyword\">const</span> app = http.<span class=\"hljs-title function_\">createServer</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">req, res</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;req.method&#125;</span> <span class=\"hljs-subst\">$&#123;req.url&#125;</span>`</span>);<br>  res.<span class=\"hljs-title function_\">end</span>(<span class=\"hljs-string\">&#x27;Hello daemon&#x27;</span>);<br>&#125;)<br><br>app.<span class=\"hljs-title function_\">listen</span>(port, <span class=\"hljs-string\">&#x27;0.0.0.0&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`Server listening on: http://localhost:<span class=\"hljs-subst\">$&#123;port&#125;</span>`</span>);<br>&#125;)<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"6-启动服务并验证\"><a href=\"#6-启动服务并验证\" class=\"headerlink\" title=\"6. 启动服务并验证\"></a>6. 启动服务并验证</h2><p>完成代码编写之后，我们尝试着启动服务并验证服务是否启动成功了。打开终端，执行 <code>node start.js</code>。父进程在执行完之后，会立即退出，因此不会占用终端。</p>\n<p>通过浏览器访问地址 <code>http://localhost:5000</code>, 能够正确显示内容，说明守护进程启动成功了。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/daemon/success.png\" alt=\"success\"></p>\n<p>另外查看一下日志文件 <code>daemon.log</code>，可以看到服务启动和请求的记录。<br><img src=\"https://www.jvxiao.cn/imgs/daemon/logs.png\" alt=\"success\"></p>\n<p>在任务管理中，也能看到一个一直活跃的 node 进程。<br><img src=\"https://www.jvxiao.cn/imgs/daemon/panel.png\" alt=\"success\"></p>\n<p>Bingo~~~, 一个简单的守护进程就这么实现了。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>除了上面的方法，其实也还有其它一些快捷的方式来创建守护进程，如使用<code>pm2</code> 或者 <code>forever</code>, 但是纯手工创建守护进程的基本功不能丢了。</p>\n<p>实现守护进程的过程，也是深入理解 Node.js 进程模型和操作系统交互的绝佳机会。从工作目录设置、权限管理到信号处理、错误捕获，每一个细节都体现了对系统编程的深刻理解。这些知识不仅适用于守护进程开发，更能帮助我们编写更健壮的 Node.js 应用。</p>\n"},{"title":"搞前端还有出路吗？如果有，在哪里？","date":"2025-07-28T10:25:42.000Z","keywords":["前端开发，职业规划"],"banner_img":"/imgs/feature-of-fe/design.jpg","index_img":"/imgs/feature-of-fe/design.jpg","_content":"\n写代码对我来说是一件很开心的事，通过写代码来糊口，也算得上是一件很幸运的事了。但工作的时间久了，一些危机感和职业的通病，多多少少也会暴露出来。\n\n从毕业到现在5年多了，算上加班，凑个7年工作经验，应该不算过分。\n\n写前端写得越久，人往往也容易麻木。有时候在想，这玩意也算是个体力活吧，找个稍微动打字的人，学习两个多礼拜，也能上手啊。\n\n这么想的人，必定不止我一人。\n\n\n## 在互联网公司也是打螺丝\n\n就现在的Web开发而言，一个项目脚手架，渲染框架，状态管理，路由等等，几乎所有的东西都已经实现了模块化以及灵活集成。而开发者需要做的，就像是小孩子给格子涂颜色一样，给指定的格子涂上颜色，工作内容本身，并没有多大的难度。\n\n“面试造火箭，上班打螺丝”，这还真不是句玩笑话。面试时的各种性能优化方式，代码规范，还有算法等等，基本上都是白扯。说到组件封装，很多时候都是个人自嗨。相似的功能，在不同的项目或者页面中却是高度定制化的，甚至在设计风格上都无法保持一致，再谈封装，多少有点自讨没趣。\n\n![design](https://www.jvxiao.cn/imgs/feature-of-fe/design.jpg)\n\n前端开发被叫成 “切图仔” 不是没有道理的，长期的、重复性的写高度相似的东西，个人能力无法得到提升，而且还容易陷入舒适圈，当然了，舒适圈没什么不好的，就是跳槽时会痛苦一些。\n\n\n## 现在搞前端，还有搞头么？\n\n就现在的情况来说，虽然说整个就业大环境不是很好，但类似金融，互联网这类的行业的就业质量还是可以的，至少 “窝囊费” 多一些。\n像前端开发这一块，不管是传统行业还是互联网公司，都需要通过网站、移动应用程序等数字化平台来展示产品和服务，对前端开发人员的需求还是比较旺盛的。\n\n![](https://www.jvxiao.cn/imgs//feature-of-fe/code.jpg)\n\n从个人编程体验来说，前端的编程体验是优于后端。你写的东西，能够在视觉层面立马呈现出来，好看还是不好看，交互是否友好，都是能够立即感受到的。\n\n此外，对于喜欢自己捣鼓一些小程序，App之类的小伙伴来说，搞前端上手相对来说比较快一些，成就感会强一些。\n\n\n## 老前端开发可以往哪些方向走？\n\n**低代码 / 零代码平台开发方向**：个人觉得这个东西比较鸡肋，但奈何几乎稍微大一点的公司，都会要求要搞一套自己的低代码或零代码平台。至于能不能用，好不好用，有没有人用，不重要的，重要的是要有。既然有这样离谱的需求，又给钱了，不妨试试。\n\n**跨平台与多端融合方向**：一套代码多端运行，这样的需求在未来很长一段时间都会比较旺盛，未来很多App都将会依托平台来进行开发，比如抖音小程序，微信小程序，快手小程序等等，使用多端融合技术，减少开发工作量。像 React Native, Flutter, Tauri 等框架在这一块做得还是不错的，社区氛围也不错。\n\n![](https://www.jvxiao.cn/imgs//feature-of-fe/tauri.png)\n\n**微前端架构方向**：微前端在大型项目中的应用会越来越多，这种架构方式能够实现多个团队独立开发和部署，提高协作效率。你需要掌握 Module Federation 等技术，实现更好的组件化和模块化管理，适应大型复杂项目的开发需求。\n\n**音视频组件开发**：这个还是有搞头的，圈子里有一些在大厂的朋友有好些个都是在做这方面的开发。音视频组件开发是前端领域中专业性强、需求旺盛的细分方向，尤其在直播、短视频、在线会议、在线教育等场景爆发的当下，相关技术人才缺口较大，发展前景广阔，这个还是值得一试的。\n\n## 写在最后\n\n个人觉得，如果你是一个新人，需要找一份开发相关的工作，个人觉得前端开发还是算不错。而如果你是一个老前端开发，在工作这么多年之后，开始进入舒适区，亦或者有危机感了，那么不妨尝试着在新的方向探索了。\n\n在当前的就业环境下，不建议频繁跳槽搞钱，毕竟打工发财是不现实的。有一份工作，能够养家糊口，上班偶尔还能摸摸鱼，差不多就可以了。大环境好的时候都搞不到钱，现在说要搞钱不是为难自己么？健康饮食，适当运动，保持一个好的身体，这就是在省钱了！\n\n扯远了...上述内容皆为个人观点，如有不同看法，欢迎评论区交流。\n","source":"_posts/future-of-front-end-development.md","raw":"---\ntitle: 搞前端还有出路吗？如果有，在哪里？\ndate: 2025-07-28 18:25:42\ntags: 前端开发\nkeywords: [前端开发，职业规划]\ncategory: Web开发\nbanner_img: /imgs/feature-of-fe/design.jpg\nindex_img: /imgs/feature-of-fe/design.jpg\n---\n\n写代码对我来说是一件很开心的事，通过写代码来糊口，也算得上是一件很幸运的事了。但工作的时间久了，一些危机感和职业的通病，多多少少也会暴露出来。\n\n从毕业到现在5年多了，算上加班，凑个7年工作经验，应该不算过分。\n\n写前端写得越久，人往往也容易麻木。有时候在想，这玩意也算是个体力活吧，找个稍微动打字的人，学习两个多礼拜，也能上手啊。\n\n这么想的人，必定不止我一人。\n\n\n## 在互联网公司也是打螺丝\n\n就现在的Web开发而言，一个项目脚手架，渲染框架，状态管理，路由等等，几乎所有的东西都已经实现了模块化以及灵活集成。而开发者需要做的，就像是小孩子给格子涂颜色一样，给指定的格子涂上颜色，工作内容本身，并没有多大的难度。\n\n“面试造火箭，上班打螺丝”，这还真不是句玩笑话。面试时的各种性能优化方式，代码规范，还有算法等等，基本上都是白扯。说到组件封装，很多时候都是个人自嗨。相似的功能，在不同的项目或者页面中却是高度定制化的，甚至在设计风格上都无法保持一致，再谈封装，多少有点自讨没趣。\n\n![design](https://www.jvxiao.cn/imgs/feature-of-fe/design.jpg)\n\n前端开发被叫成 “切图仔” 不是没有道理的，长期的、重复性的写高度相似的东西，个人能力无法得到提升，而且还容易陷入舒适圈，当然了，舒适圈没什么不好的，就是跳槽时会痛苦一些。\n\n\n## 现在搞前端，还有搞头么？\n\n就现在的情况来说，虽然说整个就业大环境不是很好，但类似金融，互联网这类的行业的就业质量还是可以的，至少 “窝囊费” 多一些。\n像前端开发这一块，不管是传统行业还是互联网公司，都需要通过网站、移动应用程序等数字化平台来展示产品和服务，对前端开发人员的需求还是比较旺盛的。\n\n![](https://www.jvxiao.cn/imgs//feature-of-fe/code.jpg)\n\n从个人编程体验来说，前端的编程体验是优于后端。你写的东西，能够在视觉层面立马呈现出来，好看还是不好看，交互是否友好，都是能够立即感受到的。\n\n此外，对于喜欢自己捣鼓一些小程序，App之类的小伙伴来说，搞前端上手相对来说比较快一些，成就感会强一些。\n\n\n## 老前端开发可以往哪些方向走？\n\n**低代码 / 零代码平台开发方向**：个人觉得这个东西比较鸡肋，但奈何几乎稍微大一点的公司，都会要求要搞一套自己的低代码或零代码平台。至于能不能用，好不好用，有没有人用，不重要的，重要的是要有。既然有这样离谱的需求，又给钱了，不妨试试。\n\n**跨平台与多端融合方向**：一套代码多端运行，这样的需求在未来很长一段时间都会比较旺盛，未来很多App都将会依托平台来进行开发，比如抖音小程序，微信小程序，快手小程序等等，使用多端融合技术，减少开发工作量。像 React Native, Flutter, Tauri 等框架在这一块做得还是不错的，社区氛围也不错。\n\n![](https://www.jvxiao.cn/imgs//feature-of-fe/tauri.png)\n\n**微前端架构方向**：微前端在大型项目中的应用会越来越多，这种架构方式能够实现多个团队独立开发和部署，提高协作效率。你需要掌握 Module Federation 等技术，实现更好的组件化和模块化管理，适应大型复杂项目的开发需求。\n\n**音视频组件开发**：这个还是有搞头的，圈子里有一些在大厂的朋友有好些个都是在做这方面的开发。音视频组件开发是前端领域中专业性强、需求旺盛的细分方向，尤其在直播、短视频、在线会议、在线教育等场景爆发的当下，相关技术人才缺口较大，发展前景广阔，这个还是值得一试的。\n\n## 写在最后\n\n个人觉得，如果你是一个新人，需要找一份开发相关的工作，个人觉得前端开发还是算不错。而如果你是一个老前端开发，在工作这么多年之后，开始进入舒适区，亦或者有危机感了，那么不妨尝试着在新的方向探索了。\n\n在当前的就业环境下，不建议频繁跳槽搞钱，毕竟打工发财是不现实的。有一份工作，能够养家糊口，上班偶尔还能摸摸鱼，差不多就可以了。大环境好的时候都搞不到钱，现在说要搞钱不是为难自己么？健康饮食，适当运动，保持一个好的身体，这就是在省钱了！\n\n扯远了...上述内容皆为个人观点，如有不同看法，欢迎评论区交流。\n","slug":"future-of-front-end-development","published":1,"updated":"2025-08-26T10:36:13.808Z","_id":"cmdq1j89v0004voupf7ygdrql","comments":1,"layout":"post","photos":[],"content":"<p>写代码对我来说是一件很开心的事，通过写代码来糊口，也算得上是一件很幸运的事了。但工作的时间久了，一些危机感和职业的通病，多多少少也会暴露出来。</p>\n<p>从毕业到现在5年多了，算上加班，凑个7年工作经验，应该不算过分。</p>\n<p>写前端写得越久，人往往也容易麻木。有时候在想，这玩意也算是个体力活吧，找个稍微动打字的人，学习两个多礼拜，也能上手啊。</p>\n<p>这么想的人，必定不止我一人。</p>\n<h2 id=\"在互联网公司也是打螺丝\"><a href=\"#在互联网公司也是打螺丝\" class=\"headerlink\" title=\"在互联网公司也是打螺丝\"></a>在互联网公司也是打螺丝</h2><p>就现在的Web开发而言，一个项目脚手架，渲染框架，状态管理，路由等等，几乎所有的东西都已经实现了模块化以及灵活集成。而开发者需要做的，就像是小孩子给格子涂颜色一样，给指定的格子涂上颜色，工作内容本身，并没有多大的难度。</p>\n<p>“面试造火箭，上班打螺丝”，这还真不是句玩笑话。面试时的各种性能优化方式，代码规范，还有算法等等，基本上都是白扯。说到组件封装，很多时候都是个人自嗨。相似的功能，在不同的项目或者页面中却是高度定制化的，甚至在设计风格上都无法保持一致，再谈封装，多少有点自讨没趣。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/feature-of-fe/design.jpg\" alt=\"design\"></p>\n<p>前端开发被叫成 “切图仔” 不是没有道理的，长期的、重复性的写高度相似的东西，个人能力无法得到提升，而且还容易陷入舒适圈，当然了，舒适圈没什么不好的，就是跳槽时会痛苦一些。</p>\n<h2 id=\"现在搞前端，还有搞头么？\"><a href=\"#现在搞前端，还有搞头么？\" class=\"headerlink\" title=\"现在搞前端，还有搞头么？\"></a>现在搞前端，还有搞头么？</h2><p>就现在的情况来说，虽然说整个就业大环境不是很好，但类似金融，互联网这类的行业的就业质量还是可以的，至少 “窝囊费” 多一些。<br>像前端开发这一块，不管是传统行业还是互联网公司，都需要通过网站、移动应用程序等数字化平台来展示产品和服务，对前端开发人员的需求还是比较旺盛的。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs//feature-of-fe/code.jpg\"></p>\n<p>从个人编程体验来说，前端的编程体验是优于后端。你写的东西，能够在视觉层面立马呈现出来，好看还是不好看，交互是否友好，都是能够立即感受到的。</p>\n<p>此外，对于喜欢自己捣鼓一些小程序，App之类的小伙伴来说，搞前端上手相对来说比较快一些，成就感会强一些。</p>\n<h2 id=\"老前端开发可以往哪些方向走？\"><a href=\"#老前端开发可以往哪些方向走？\" class=\"headerlink\" title=\"老前端开发可以往哪些方向走？\"></a>老前端开发可以往哪些方向走？</h2><p><strong>低代码 &#x2F; 零代码平台开发方向</strong>：个人觉得这个东西比较鸡肋，但奈何几乎稍微大一点的公司，都会要求要搞一套自己的低代码或零代码平台。至于能不能用，好不好用，有没有人用，不重要的，重要的是要有。既然有这样离谱的需求，又给钱了，不妨试试。</p>\n<p><strong>跨平台与多端融合方向</strong>：一套代码多端运行，这样的需求在未来很长一段时间都会比较旺盛，未来很多App都将会依托平台来进行开发，比如抖音小程序，微信小程序，快手小程序等等，使用多端融合技术，减少开发工作量。像 React Native, Flutter, Tauri 等框架在这一块做得还是不错的，社区氛围也不错。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs//feature-of-fe/tauri.png\"></p>\n<p><strong>微前端架构方向</strong>：微前端在大型项目中的应用会越来越多，这种架构方式能够实现多个团队独立开发和部署，提高协作效率。你需要掌握 Module Federation 等技术，实现更好的组件化和模块化管理，适应大型复杂项目的开发需求。</p>\n<p><strong>音视频组件开发</strong>：这个还是有搞头的，圈子里有一些在大厂的朋友有好些个都是在做这方面的开发。音视频组件开发是前端领域中专业性强、需求旺盛的细分方向，尤其在直播、短视频、在线会议、在线教育等场景爆发的当下，相关技术人才缺口较大，发展前景广阔，这个还是值得一试的。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>个人觉得，如果你是一个新人，需要找一份开发相关的工作，个人觉得前端开发还是算不错。而如果你是一个老前端开发，在工作这么多年之后，开始进入舒适区，亦或者有危机感了，那么不妨尝试着在新的方向探索了。</p>\n<p>在当前的就业环境下，不建议频繁跳槽搞钱，毕竟打工发财是不现实的。有一份工作，能够养家糊口，上班偶尔还能摸摸鱼，差不多就可以了。大环境好的时候都搞不到钱，现在说要搞钱不是为难自己么？健康饮食，适当运动，保持一个好的身体，这就是在省钱了！</p>\n<p>扯远了…上述内容皆为个人观点，如有不同看法，欢迎评论区交流。</p>\n","excerpt":"","more":"<p>写代码对我来说是一件很开心的事，通过写代码来糊口，也算得上是一件很幸运的事了。但工作的时间久了，一些危机感和职业的通病，多多少少也会暴露出来。</p>\n<p>从毕业到现在5年多了，算上加班，凑个7年工作经验，应该不算过分。</p>\n<p>写前端写得越久，人往往也容易麻木。有时候在想，这玩意也算是个体力活吧，找个稍微动打字的人，学习两个多礼拜，也能上手啊。</p>\n<p>这么想的人，必定不止我一人。</p>\n<h2 id=\"在互联网公司也是打螺丝\"><a href=\"#在互联网公司也是打螺丝\" class=\"headerlink\" title=\"在互联网公司也是打螺丝\"></a>在互联网公司也是打螺丝</h2><p>就现在的Web开发而言，一个项目脚手架，渲染框架，状态管理，路由等等，几乎所有的东西都已经实现了模块化以及灵活集成。而开发者需要做的，就像是小孩子给格子涂颜色一样，给指定的格子涂上颜色，工作内容本身，并没有多大的难度。</p>\n<p>“面试造火箭，上班打螺丝”，这还真不是句玩笑话。面试时的各种性能优化方式，代码规范，还有算法等等，基本上都是白扯。说到组件封装，很多时候都是个人自嗨。相似的功能，在不同的项目或者页面中却是高度定制化的，甚至在设计风格上都无法保持一致，再谈封装，多少有点自讨没趣。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/feature-of-fe/design.jpg\" alt=\"design\"></p>\n<p>前端开发被叫成 “切图仔” 不是没有道理的，长期的、重复性的写高度相似的东西，个人能力无法得到提升，而且还容易陷入舒适圈，当然了，舒适圈没什么不好的，就是跳槽时会痛苦一些。</p>\n<h2 id=\"现在搞前端，还有搞头么？\"><a href=\"#现在搞前端，还有搞头么？\" class=\"headerlink\" title=\"现在搞前端，还有搞头么？\"></a>现在搞前端，还有搞头么？</h2><p>就现在的情况来说，虽然说整个就业大环境不是很好，但类似金融，互联网这类的行业的就业质量还是可以的，至少 “窝囊费” 多一些。<br>像前端开发这一块，不管是传统行业还是互联网公司，都需要通过网站、移动应用程序等数字化平台来展示产品和服务，对前端开发人员的需求还是比较旺盛的。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs//feature-of-fe/code.jpg\"></p>\n<p>从个人编程体验来说，前端的编程体验是优于后端。你写的东西，能够在视觉层面立马呈现出来，好看还是不好看，交互是否友好，都是能够立即感受到的。</p>\n<p>此外，对于喜欢自己捣鼓一些小程序，App之类的小伙伴来说，搞前端上手相对来说比较快一些，成就感会强一些。</p>\n<h2 id=\"老前端开发可以往哪些方向走？\"><a href=\"#老前端开发可以往哪些方向走？\" class=\"headerlink\" title=\"老前端开发可以往哪些方向走？\"></a>老前端开发可以往哪些方向走？</h2><p><strong>低代码 &#x2F; 零代码平台开发方向</strong>：个人觉得这个东西比较鸡肋，但奈何几乎稍微大一点的公司，都会要求要搞一套自己的低代码或零代码平台。至于能不能用，好不好用，有没有人用，不重要的，重要的是要有。既然有这样离谱的需求，又给钱了，不妨试试。</p>\n<p><strong>跨平台与多端融合方向</strong>：一套代码多端运行，这样的需求在未来很长一段时间都会比较旺盛，未来很多App都将会依托平台来进行开发，比如抖音小程序，微信小程序，快手小程序等等，使用多端融合技术，减少开发工作量。像 React Native, Flutter, Tauri 等框架在这一块做得还是不错的，社区氛围也不错。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs//feature-of-fe/tauri.png\"></p>\n<p><strong>微前端架构方向</strong>：微前端在大型项目中的应用会越来越多，这种架构方式能够实现多个团队独立开发和部署，提高协作效率。你需要掌握 Module Federation 等技术，实现更好的组件化和模块化管理，适应大型复杂项目的开发需求。</p>\n<p><strong>音视频组件开发</strong>：这个还是有搞头的，圈子里有一些在大厂的朋友有好些个都是在做这方面的开发。音视频组件开发是前端领域中专业性强、需求旺盛的细分方向，尤其在直播、短视频、在线会议、在线教育等场景爆发的当下，相关技术人才缺口较大，发展前景广阔，这个还是值得一试的。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>个人觉得，如果你是一个新人，需要找一份开发相关的工作，个人觉得前端开发还是算不错。而如果你是一个老前端开发，在工作这么多年之后，开始进入舒适区，亦或者有危机感了，那么不妨尝试着在新的方向探索了。</p>\n<p>在当前的就业环境下，不建议频繁跳槽搞钱，毕竟打工发财是不现实的。有一份工作，能够养家糊口，上班偶尔还能摸摸鱼，差不多就可以了。大环境好的时候都搞不到钱，现在说要搞钱不是为难自己么？健康饮食，适当运动，保持一个好的身体，这就是在省钱了！</p>\n<p>扯远了…上述内容皆为个人观点，如有不同看法，欢迎评论区交流。</p>\n"},{"title":"别再被闭包 “绕晕”！3 分钟搞懂定义、形成与实战作用","date":"2025-08-14T00:04:55.000Z","keywords":["闭包，作用域"],"index_img":"imgs/closure/closure.png","banner_img":"imgs/closure/closure.png","_content":"---\n\n闭包，算得上是JavaScript中的一个难点，在面试时也被时常提及。\n\n多年前的一次面试，被问及闭包时，那种脑子里一团乱麻的感觉，至今依然清晰。\n\n本文力求以简单移动柜的语言，彻底讲清楚闭包，让读者在日后的面试和工作中，少走一些弯路，少掉一些头发。\n\n\n## 什么是闭包？\n\n要讲清楚闭包，那么我们首先得了解闭包是什么。为此，我翻阅许多资料收集了其中关于闭包的定义：\n\n- **《JavaScript权威指南（第六版）》**： 函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称之为“闭包”。\n\n- **《JavaScript 高级程序设计》**： 闭包指的是那些引用了另外一个函数作用域中变量的函数，通常是嵌套在函数中实现的。\n\n- **《你不知道的JavaScript》**： 函数可以记住并访问所在词法作用域，即使函数实在当前词法作用域之外执行，这就产生了闭包。\n\n- **MDN**: 闭包是由捆绑起来（封闭的）的函数和函数周围状态（词法环境）引用组合而成，闭包让函数能够访问它的外部作用域。\n\n\n\n好嘛，真是一看一个不吱声，根本没有一个统一的定义。有的说闭包是特性，有的直说是怎么形成的，各讲各话。\n\n你就说，看这些东西，你能不蒙？\n\n按我们的理解，定义就应该是 `xx是xx` 的格式，在这里我们以最简单的格式来定义闭包\n\n**闭包是一个函数与其周围词法环境的集合**。当函数被定义时，他会捕获其外部作用域中的变量，即使外部函数已经执行完毕，这些变量依然可以被访问和修改。\n\n以后再被问及什么是闭包的时候，粗体部分文字就是答案，剩下的则可以作为解释。\n\n\n## 闭包的形成\n\n搞清楚了闭包的定义，下面通过一个简单的案例直观地理解一下闭包的形成。\n\n```\nfunction outer() {\n  let outerVar = \"我是外部变量\"; // 外部函数的局部变量\n\n  // 内部函数定义（满足“函数嵌套”）\n  function inner() {\n    console.log(outerVar); // 内部函数引用外部变量（满足“作用域访问”）\n  }\n\n  return inner; // 内部函数被返回（满足“外部返回”）\n}\n\n// 内部函数被“带出”外部作用域，并赋值给全局变量\nconst closureFunc = outer(); \n\n// 在外部调用内部函数，闭包生效\nclosureFunc(); // 输出：\"我是外部变量\"（成功访问outer的局部变量）\n```\n\n从上面的例子我们可以看出，outer执行完毕后，outerVar本应被销毁，但由于inner被返回并赋值给closureFunc，inner仍保留对outer作用域的引用。当closureFunc()调用时，inner通过闭包访问到了outerVar。\n\n![example](../imgs/closure/example.png)\n\n闭包形成的关键就在于内部函数在外部函数中定义时，会捕获当前的作用域链（包含外部函数的作用域和全局作用域）。即使内部函数未被立即调用，它也会保留对这些作用域的引用。\n\n## 闭包的作用\n\n明白了闭包的形成之后，我们再来看看闭包在实际开发过程中的一些用途。\n\n当然了，下面的内容都是围绕着闭包的核心作用展开的：**让内部函数能够保留对外部作用域的引用，即使外部函数已经执行完毕**。\n\n- **保存变量状态（数据私有化与封装）**\n\n闭包可以将变量 “隐藏” 在外部函数的作用域中，只通过内部函数暴露操作接口，实现类似 “私有变量” 的效果，避免全局变量污染。\n\n```javascript\nfunction createCounter() {\n  let count = 0; // 被闭包“保护”的变量，外部无法直接访问\n  return {\n    increment: () => { count++; return count; },\n    decrement: () => { count--; return count; }\n  };\n}\n\nconst counter = createCounter();\nconsole.log(counter.increment()); // 1（count被修改并保留状态）\nconsole.log(counter.increment()); // 2（状态持续保留）\n```\n\n- **实现函数工厂（动态生成定制化函数）**\n\n通过闭包可以创建带有 “记忆” 能力的函数，根据外部变量的不同生成不同逻辑的函数，提高代码复用性。\n\n```javascript\nfunction createGreeting(prefix) {\n  return function(name) { // 内部函数记住prefix的值\n    console.log(`${prefix}, ${name}!`);\n  };\n}\n\nconst sayHello = createGreeting(\"Hello\");\nconst sayHi = createGreeting(\"Hi\");\n\nsayHello(\"Alice\"); // \"Hello, Alice!\"（记住prefix为\"Hello\"）\nsayHi(\"Bob\");      // \"Hi, Bob!\"（记住prefix为\"Hi\"）\n```\n\n- **延迟执行与回调函数中的状态保留**\n\n闭包可以保留回调函数创建时的上下文状态，避免因变量作用域变化导致的问题, 这个在涉及一些定时器、或者事件监听等操作时非常有用。\n\n来一个大家都熟悉的例子\n\n```\nfor (var i = 0; i < 3; i++) {\n  // 使用闭包保留每次循环的i值\n  (function(j) {\n    setTimeout(() => {\n      console.log(j); // 输出0、1、2（而非3次3）\n    }, 1000);\n  })(i);\n}\n```\n若不使用闭包，定时器回调会共享全局的i，最终输出 3 次3；闭包则让每次循环的i值被独立保存。\n\n- **模块化开发**\n\n在 ES6 模块出现之前，闭包是实现模块化的核心方式：通过外部函数包裹代码，只暴露需要公开的接口，隐藏内部实现细节。\n\n\n## 写在最后\n\nOkay, 到这里想必都已经清楚了闭包的定义，它的形成和作用了，在日后的面试中和工作中遇到了闭包也用不着犯难了。\n\n闭包在开发过程中应用非常广，在一些高级函数，封装操作或者状态管理中都能看到闭包的影子。\n\n虽然好用，但是也不要滥用，过多的使用闭包可能占用过多内存，甚至引发内存泄漏，毕竟不是所有开发者都会自觉清理掉不必要引用的，哈哈，偷笑~。","source":"_posts/closure.md","raw":"---\ntitle: 别再被闭包 “绕晕”！3 分钟搞懂定义、形成与实战作用\ndate: 2025-08-14 08:04:55\ntags: [闭包，作用域]\nkeywords: [闭包，作用域]\nindex_img: imgs/closure/closure.png\nbanner_img: imgs/closure/closure.png\n---\n---\n\n闭包，算得上是JavaScript中的一个难点，在面试时也被时常提及。\n\n多年前的一次面试，被问及闭包时，那种脑子里一团乱麻的感觉，至今依然清晰。\n\n本文力求以简单移动柜的语言，彻底讲清楚闭包，让读者在日后的面试和工作中，少走一些弯路，少掉一些头发。\n\n\n## 什么是闭包？\n\n要讲清楚闭包，那么我们首先得了解闭包是什么。为此，我翻阅许多资料收集了其中关于闭包的定义：\n\n- **《JavaScript权威指南（第六版）》**： 函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称之为“闭包”。\n\n- **《JavaScript 高级程序设计》**： 闭包指的是那些引用了另外一个函数作用域中变量的函数，通常是嵌套在函数中实现的。\n\n- **《你不知道的JavaScript》**： 函数可以记住并访问所在词法作用域，即使函数实在当前词法作用域之外执行，这就产生了闭包。\n\n- **MDN**: 闭包是由捆绑起来（封闭的）的函数和函数周围状态（词法环境）引用组合而成，闭包让函数能够访问它的外部作用域。\n\n\n\n好嘛，真是一看一个不吱声，根本没有一个统一的定义。有的说闭包是特性，有的直说是怎么形成的，各讲各话。\n\n你就说，看这些东西，你能不蒙？\n\n按我们的理解，定义就应该是 `xx是xx` 的格式，在这里我们以最简单的格式来定义闭包\n\n**闭包是一个函数与其周围词法环境的集合**。当函数被定义时，他会捕获其外部作用域中的变量，即使外部函数已经执行完毕，这些变量依然可以被访问和修改。\n\n以后再被问及什么是闭包的时候，粗体部分文字就是答案，剩下的则可以作为解释。\n\n\n## 闭包的形成\n\n搞清楚了闭包的定义，下面通过一个简单的案例直观地理解一下闭包的形成。\n\n```\nfunction outer() {\n  let outerVar = \"我是外部变量\"; // 外部函数的局部变量\n\n  // 内部函数定义（满足“函数嵌套”）\n  function inner() {\n    console.log(outerVar); // 内部函数引用外部变量（满足“作用域访问”）\n  }\n\n  return inner; // 内部函数被返回（满足“外部返回”）\n}\n\n// 内部函数被“带出”外部作用域，并赋值给全局变量\nconst closureFunc = outer(); \n\n// 在外部调用内部函数，闭包生效\nclosureFunc(); // 输出：\"我是外部变量\"（成功访问outer的局部变量）\n```\n\n从上面的例子我们可以看出，outer执行完毕后，outerVar本应被销毁，但由于inner被返回并赋值给closureFunc，inner仍保留对outer作用域的引用。当closureFunc()调用时，inner通过闭包访问到了outerVar。\n\n![example](../imgs/closure/example.png)\n\n闭包形成的关键就在于内部函数在外部函数中定义时，会捕获当前的作用域链（包含外部函数的作用域和全局作用域）。即使内部函数未被立即调用，它也会保留对这些作用域的引用。\n\n## 闭包的作用\n\n明白了闭包的形成之后，我们再来看看闭包在实际开发过程中的一些用途。\n\n当然了，下面的内容都是围绕着闭包的核心作用展开的：**让内部函数能够保留对外部作用域的引用，即使外部函数已经执行完毕**。\n\n- **保存变量状态（数据私有化与封装）**\n\n闭包可以将变量 “隐藏” 在外部函数的作用域中，只通过内部函数暴露操作接口，实现类似 “私有变量” 的效果，避免全局变量污染。\n\n```javascript\nfunction createCounter() {\n  let count = 0; // 被闭包“保护”的变量，外部无法直接访问\n  return {\n    increment: () => { count++; return count; },\n    decrement: () => { count--; return count; }\n  };\n}\n\nconst counter = createCounter();\nconsole.log(counter.increment()); // 1（count被修改并保留状态）\nconsole.log(counter.increment()); // 2（状态持续保留）\n```\n\n- **实现函数工厂（动态生成定制化函数）**\n\n通过闭包可以创建带有 “记忆” 能力的函数，根据外部变量的不同生成不同逻辑的函数，提高代码复用性。\n\n```javascript\nfunction createGreeting(prefix) {\n  return function(name) { // 内部函数记住prefix的值\n    console.log(`${prefix}, ${name}!`);\n  };\n}\n\nconst sayHello = createGreeting(\"Hello\");\nconst sayHi = createGreeting(\"Hi\");\n\nsayHello(\"Alice\"); // \"Hello, Alice!\"（记住prefix为\"Hello\"）\nsayHi(\"Bob\");      // \"Hi, Bob!\"（记住prefix为\"Hi\"）\n```\n\n- **延迟执行与回调函数中的状态保留**\n\n闭包可以保留回调函数创建时的上下文状态，避免因变量作用域变化导致的问题, 这个在涉及一些定时器、或者事件监听等操作时非常有用。\n\n来一个大家都熟悉的例子\n\n```\nfor (var i = 0; i < 3; i++) {\n  // 使用闭包保留每次循环的i值\n  (function(j) {\n    setTimeout(() => {\n      console.log(j); // 输出0、1、2（而非3次3）\n    }, 1000);\n  })(i);\n}\n```\n若不使用闭包，定时器回调会共享全局的i，最终输出 3 次3；闭包则让每次循环的i值被独立保存。\n\n- **模块化开发**\n\n在 ES6 模块出现之前，闭包是实现模块化的核心方式：通过外部函数包裹代码，只暴露需要公开的接口，隐藏内部实现细节。\n\n\n## 写在最后\n\nOkay, 到这里想必都已经清楚了闭包的定义，它的形成和作用了，在日后的面试中和工作中遇到了闭包也用不着犯难了。\n\n闭包在开发过程中应用非常广，在一些高级函数，封装操作或者状态管理中都能看到闭包的影子。\n\n虽然好用，但是也不要滥用，过多的使用闭包可能占用过多内存，甚至引发内存泄漏，毕竟不是所有开发者都会自觉清理掉不必要引用的，哈哈，偷笑~。","slug":"closure","published":1,"updated":"2025-08-26T10:34:20.653Z","_id":"cmebfg7xu0000nsup2536f2xd","comments":1,"layout":"post","photos":[],"content":"<hr>\n<p>闭包，算得上是JavaScript中的一个难点，在面试时也被时常提及。</p>\n<p>多年前的一次面试，被问及闭包时，那种脑子里一团乱麻的感觉，至今依然清晰。</p>\n<p>本文力求以简单移动柜的语言，彻底讲清楚闭包，让读者在日后的面试和工作中，少走一些弯路，少掉一些头发。</p>\n<h2 id=\"什么是闭包？\"><a href=\"#什么是闭包？\" class=\"headerlink\" title=\"什么是闭包？\"></a>什么是闭包？</h2><p>要讲清楚闭包，那么我们首先得了解闭包是什么。为此，我翻阅许多资料收集了其中关于闭包的定义：</p>\n<ul>\n<li><p><strong>《JavaScript权威指南（第六版）》</strong>： 函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称之为“闭包”。</p>\n</li>\n<li><p><strong>《JavaScript 高级程序设计》</strong>： 闭包指的是那些引用了另外一个函数作用域中变量的函数，通常是嵌套在函数中实现的。</p>\n</li>\n<li><p><strong>《你不知道的JavaScript》</strong>： 函数可以记住并访问所在词法作用域，即使函数实在当前词法作用域之外执行，这就产生了闭包。</p>\n</li>\n<li><p><strong>MDN</strong>: 闭包是由捆绑起来（封闭的）的函数和函数周围状态（词法环境）引用组合而成，闭包让函数能够访问它的外部作用域。</p>\n</li>\n</ul>\n<p>好嘛，真是一看一个不吱声，根本没有一个统一的定义。有的说闭包是特性，有的直说是怎么形成的，各讲各话。</p>\n<p>你就说，看这些东西，你能不蒙？</p>\n<p>按我们的理解，定义就应该是 <code>xx是xx</code> 的格式，在这里我们以最简单的格式来定义闭包</p>\n<p><strong>闭包是一个函数与其周围词法环境的集合</strong>。当函数被定义时，他会捕获其外部作用域中的变量，即使外部函数已经执行完毕，这些变量依然可以被访问和修改。</p>\n<p>以后再被问及什么是闭包的时候，粗体部分文字就是答案，剩下的则可以作为解释。</p>\n<h2 id=\"闭包的形成\"><a href=\"#闭包的形成\" class=\"headerlink\" title=\"闭包的形成\"></a>闭包的形成</h2><p>搞清楚了闭包的定义，下面通过一个简单的案例直观地理解一下闭包的形成。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">outer</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> outerVar = <span class=\"hljs-string\">&quot;我是外部变量&quot;</span>; <span class=\"hljs-comment\">// 外部函数的局部变量</span><br><br>  <span class=\"hljs-comment\">// 内部函数定义（满足“函数嵌套”）</span><br>  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">inner</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(outerVar); <span class=\"hljs-comment\">// 内部函数引用外部变量（满足“作用域访问”）</span><br>  &#125;<br><br>  <span class=\"hljs-keyword\">return</span> inner; <span class=\"hljs-comment\">// 内部函数被返回（满足“外部返回”）</span><br>&#125;<br><br><span class=\"hljs-comment\">// 内部函数被“带出”外部作用域，并赋值给全局变量</span><br><span class=\"hljs-keyword\">const</span> closureFunc = <span class=\"hljs-title function_\">outer</span>(); <br><br><span class=\"hljs-comment\">// 在外部调用内部函数，闭包生效</span><br><span class=\"hljs-title function_\">closureFunc</span>(); <span class=\"hljs-comment\">// 输出：&quot;我是外部变量&quot;（成功访问outer的局部变量）</span><br></code></pre></td></tr></table></figure>\n\n<p>从上面的例子我们可以看出，outer执行完毕后，outerVar本应被销毁，但由于inner被返回并赋值给closureFunc，inner仍保留对outer作用域的引用。当closureFunc()调用时，inner通过闭包访问到了outerVar。</p>\n<p><img src=\"/../imgs/closure/example.png\" alt=\"example\"></p>\n<p>闭包形成的关键就在于内部函数在外部函数中定义时，会捕获当前的作用域链（包含外部函数的作用域和全局作用域）。即使内部函数未被立即调用，它也会保留对这些作用域的引用。</p>\n<h2 id=\"闭包的作用\"><a href=\"#闭包的作用\" class=\"headerlink\" title=\"闭包的作用\"></a>闭包的作用</h2><p>明白了闭包的形成之后，我们再来看看闭包在实际开发过程中的一些用途。</p>\n<p>当然了，下面的内容都是围绕着闭包的核心作用展开的：<strong>让内部函数能够保留对外部作用域的引用，即使外部函数已经执行完毕</strong>。</p>\n<ul>\n<li><strong>保存变量状态（数据私有化与封装）</strong></li>\n</ul>\n<p>闭包可以将变量 “隐藏” 在外部函数的作用域中，只通过内部函数暴露操作接口，实现类似 “私有变量” 的效果，避免全局变量污染。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createCounter</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> count = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// 被闭包“保护”的变量，外部无法直接访问</span><br>  <span class=\"hljs-keyword\">return</span> &#123;<br>    <span class=\"hljs-attr\">increment</span>: <span class=\"hljs-function\">() =&gt;</span> &#123; count++; <span class=\"hljs-keyword\">return</span> count; &#125;,<br>    <span class=\"hljs-attr\">decrement</span>: <span class=\"hljs-function\">() =&gt;</span> &#123; count--; <span class=\"hljs-keyword\">return</span> count; &#125;<br>  &#125;;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> counter = <span class=\"hljs-title function_\">createCounter</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(counter.<span class=\"hljs-title function_\">increment</span>()); <span class=\"hljs-comment\">// 1（count被修改并保留状态）</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(counter.<span class=\"hljs-title function_\">increment</span>()); <span class=\"hljs-comment\">// 2（状态持续保留）</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>实现函数工厂（动态生成定制化函数）</strong></li>\n</ul>\n<p>通过闭包可以创建带有 “记忆” 能力的函数，根据外部变量的不同生成不同逻辑的函数，提高代码复用性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createGreeting</span>(<span class=\"hljs-params\">prefix</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">name</span>) &#123; <span class=\"hljs-comment\">// 内部函数记住prefix的值</span><br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;prefix&#125;</span>, <span class=\"hljs-subst\">$&#123;name&#125;</span>!`</span>);<br>  &#125;;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> sayHello = <span class=\"hljs-title function_\">createGreeting</span>(<span class=\"hljs-string\">&quot;Hello&quot;</span>);<br><span class=\"hljs-keyword\">const</span> sayHi = <span class=\"hljs-title function_\">createGreeting</span>(<span class=\"hljs-string\">&quot;Hi&quot;</span>);<br><br><span class=\"hljs-title function_\">sayHello</span>(<span class=\"hljs-string\">&quot;Alice&quot;</span>); <span class=\"hljs-comment\">// &quot;Hello, Alice!&quot;（记住prefix为&quot;Hello&quot;）</span><br><span class=\"hljs-title function_\">sayHi</span>(<span class=\"hljs-string\">&quot;Bob&quot;</span>);      <span class=\"hljs-comment\">// &quot;Hi, Bob!&quot;（记住prefix为&quot;Hi&quot;）</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>延迟执行与回调函数中的状态保留</strong></li>\n</ul>\n<p>闭包可以保留回调函数创建时的上下文状态，避免因变量作用域变化导致的问题, 这个在涉及一些定时器、或者事件监听等操作时非常有用。</p>\n<p>来一个大家都熟悉的例子</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">3</span>; i++) &#123;<br>  <span class=\"hljs-comment\">// 使用闭包保留每次循环的i值</span><br>  (<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">j</span>) &#123;<br>    setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> &#123;<br>      <span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(j); <span class=\"hljs-comment\">// 输出0、1、2（而非3次3）</span><br>    &#125;, <span class=\"hljs-number\">1000</span>);<br>  &#125;)(i);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>若不使用闭包，定时器回调会共享全局的i，最终输出 3 次3；闭包则让每次循环的i值被独立保存。</p>\n<ul>\n<li><strong>模块化开发</strong></li>\n</ul>\n<p>在 ES6 模块出现之前，闭包是实现模块化的核心方式：通过外部函数包裹代码，只暴露需要公开的接口，隐藏内部实现细节。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>Okay, 到这里想必都已经清楚了闭包的定义，它的形成和作用了，在日后的面试中和工作中遇到了闭包也用不着犯难了。</p>\n<p>闭包在开发过程中应用非常广，在一些高级函数，封装操作或者状态管理中都能看到闭包的影子。</p>\n<p>虽然好用，但是也不要滥用，过多的使用闭包可能占用过多内存，甚至引发内存泄漏，毕竟不是所有开发者都会自觉清理掉不必要引用的，哈哈，偷笑~。</p>\n","excerpt":"","more":"<hr>\n<p>闭包，算得上是JavaScript中的一个难点，在面试时也被时常提及。</p>\n<p>多年前的一次面试，被问及闭包时，那种脑子里一团乱麻的感觉，至今依然清晰。</p>\n<p>本文力求以简单移动柜的语言，彻底讲清楚闭包，让读者在日后的面试和工作中，少走一些弯路，少掉一些头发。</p>\n<h2 id=\"什么是闭包？\"><a href=\"#什么是闭包？\" class=\"headerlink\" title=\"什么是闭包？\"></a>什么是闭包？</h2><p>要讲清楚闭包，那么我们首先得了解闭包是什么。为此，我翻阅许多资料收集了其中关于闭包的定义：</p>\n<ul>\n<li><p><strong>《JavaScript权威指南（第六版）》</strong>： 函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称之为“闭包”。</p>\n</li>\n<li><p><strong>《JavaScript 高级程序设计》</strong>： 闭包指的是那些引用了另外一个函数作用域中变量的函数，通常是嵌套在函数中实现的。</p>\n</li>\n<li><p><strong>《你不知道的JavaScript》</strong>： 函数可以记住并访问所在词法作用域，即使函数实在当前词法作用域之外执行，这就产生了闭包。</p>\n</li>\n<li><p><strong>MDN</strong>: 闭包是由捆绑起来（封闭的）的函数和函数周围状态（词法环境）引用组合而成，闭包让函数能够访问它的外部作用域。</p>\n</li>\n</ul>\n<p>好嘛，真是一看一个不吱声，根本没有一个统一的定义。有的说闭包是特性，有的直说是怎么形成的，各讲各话。</p>\n<p>你就说，看这些东西，你能不蒙？</p>\n<p>按我们的理解，定义就应该是 <code>xx是xx</code> 的格式，在这里我们以最简单的格式来定义闭包</p>\n<p><strong>闭包是一个函数与其周围词法环境的集合</strong>。当函数被定义时，他会捕获其外部作用域中的变量，即使外部函数已经执行完毕，这些变量依然可以被访问和修改。</p>\n<p>以后再被问及什么是闭包的时候，粗体部分文字就是答案，剩下的则可以作为解释。</p>\n<h2 id=\"闭包的形成\"><a href=\"#闭包的形成\" class=\"headerlink\" title=\"闭包的形成\"></a>闭包的形成</h2><p>搞清楚了闭包的定义，下面通过一个简单的案例直观地理解一下闭包的形成。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">outer</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> outerVar = <span class=\"hljs-string\">&quot;我是外部变量&quot;</span>; <span class=\"hljs-comment\">// 外部函数的局部变量</span><br><br>  <span class=\"hljs-comment\">// 内部函数定义（满足“函数嵌套”）</span><br>  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">inner</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(outerVar); <span class=\"hljs-comment\">// 内部函数引用外部变量（满足“作用域访问”）</span><br>  &#125;<br><br>  <span class=\"hljs-keyword\">return</span> inner; <span class=\"hljs-comment\">// 内部函数被返回（满足“外部返回”）</span><br>&#125;<br><br><span class=\"hljs-comment\">// 内部函数被“带出”外部作用域，并赋值给全局变量</span><br><span class=\"hljs-keyword\">const</span> closureFunc = <span class=\"hljs-title function_\">outer</span>(); <br><br><span class=\"hljs-comment\">// 在外部调用内部函数，闭包生效</span><br><span class=\"hljs-title function_\">closureFunc</span>(); <span class=\"hljs-comment\">// 输出：&quot;我是外部变量&quot;（成功访问outer的局部变量）</span><br></code></pre></td></tr></table></figure>\n\n<p>从上面的例子我们可以看出，outer执行完毕后，outerVar本应被销毁，但由于inner被返回并赋值给closureFunc，inner仍保留对outer作用域的引用。当closureFunc()调用时，inner通过闭包访问到了outerVar。</p>\n<p><img src=\"/../imgs/closure/example.png\" alt=\"example\"></p>\n<p>闭包形成的关键就在于内部函数在外部函数中定义时，会捕获当前的作用域链（包含外部函数的作用域和全局作用域）。即使内部函数未被立即调用，它也会保留对这些作用域的引用。</p>\n<h2 id=\"闭包的作用\"><a href=\"#闭包的作用\" class=\"headerlink\" title=\"闭包的作用\"></a>闭包的作用</h2><p>明白了闭包的形成之后，我们再来看看闭包在实际开发过程中的一些用途。</p>\n<p>当然了，下面的内容都是围绕着闭包的核心作用展开的：<strong>让内部函数能够保留对外部作用域的引用，即使外部函数已经执行完毕</strong>。</p>\n<ul>\n<li><strong>保存变量状态（数据私有化与封装）</strong></li>\n</ul>\n<p>闭包可以将变量 “隐藏” 在外部函数的作用域中，只通过内部函数暴露操作接口，实现类似 “私有变量” 的效果，避免全局变量污染。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createCounter</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> count = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// 被闭包“保护”的变量，外部无法直接访问</span><br>  <span class=\"hljs-keyword\">return</span> &#123;<br>    <span class=\"hljs-attr\">increment</span>: <span class=\"hljs-function\">() =&gt;</span> &#123; count++; <span class=\"hljs-keyword\">return</span> count; &#125;,<br>    <span class=\"hljs-attr\">decrement</span>: <span class=\"hljs-function\">() =&gt;</span> &#123; count--; <span class=\"hljs-keyword\">return</span> count; &#125;<br>  &#125;;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> counter = <span class=\"hljs-title function_\">createCounter</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(counter.<span class=\"hljs-title function_\">increment</span>()); <span class=\"hljs-comment\">// 1（count被修改并保留状态）</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(counter.<span class=\"hljs-title function_\">increment</span>()); <span class=\"hljs-comment\">// 2（状态持续保留）</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>实现函数工厂（动态生成定制化函数）</strong></li>\n</ul>\n<p>通过闭包可以创建带有 “记忆” 能力的函数，根据外部变量的不同生成不同逻辑的函数，提高代码复用性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createGreeting</span>(<span class=\"hljs-params\">prefix</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">name</span>) &#123; <span class=\"hljs-comment\">// 内部函数记住prefix的值</span><br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;prefix&#125;</span>, <span class=\"hljs-subst\">$&#123;name&#125;</span>!`</span>);<br>  &#125;;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> sayHello = <span class=\"hljs-title function_\">createGreeting</span>(<span class=\"hljs-string\">&quot;Hello&quot;</span>);<br><span class=\"hljs-keyword\">const</span> sayHi = <span class=\"hljs-title function_\">createGreeting</span>(<span class=\"hljs-string\">&quot;Hi&quot;</span>);<br><br><span class=\"hljs-title function_\">sayHello</span>(<span class=\"hljs-string\">&quot;Alice&quot;</span>); <span class=\"hljs-comment\">// &quot;Hello, Alice!&quot;（记住prefix为&quot;Hello&quot;）</span><br><span class=\"hljs-title function_\">sayHi</span>(<span class=\"hljs-string\">&quot;Bob&quot;</span>);      <span class=\"hljs-comment\">// &quot;Hi, Bob!&quot;（记住prefix为&quot;Hi&quot;）</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>延迟执行与回调函数中的状态保留</strong></li>\n</ul>\n<p>闭包可以保留回调函数创建时的上下文状态，避免因变量作用域变化导致的问题, 这个在涉及一些定时器、或者事件监听等操作时非常有用。</p>\n<p>来一个大家都熟悉的例子</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">3</span>; i++) &#123;<br>  <span class=\"hljs-comment\">// 使用闭包保留每次循环的i值</span><br>  (<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">j</span>) &#123;<br>    setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> &#123;<br>      <span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(j); <span class=\"hljs-comment\">// 输出0、1、2（而非3次3）</span><br>    &#125;, <span class=\"hljs-number\">1000</span>);<br>  &#125;)(i);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>若不使用闭包，定时器回调会共享全局的i，最终输出 3 次3；闭包则让每次循环的i值被独立保存。</p>\n<ul>\n<li><strong>模块化开发</strong></li>\n</ul>\n<p>在 ES6 模块出现之前，闭包是实现模块化的核心方式：通过外部函数包裹代码，只暴露需要公开的接口，隐藏内部实现细节。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>Okay, 到这里想必都已经清楚了闭包的定义，它的形成和作用了，在日后的面试中和工作中遇到了闭包也用不着犯难了。</p>\n<p>闭包在开发过程中应用非常广，在一些高级函数，封装操作或者状态管理中都能看到闭包的影子。</p>\n<p>虽然好用，但是也不要滥用，过多的使用闭包可能占用过多内存，甚至引发内存泄漏，毕竟不是所有开发者都会自觉清理掉不必要引用的，哈哈，偷笑~。</p>\n"},{"title":"Vue vs React 多维度剖析: 哪一个更适合大型项目？","date":"2025-08-08T00:05:44.000Z","keywords":["Vue","React"],"banner_img":"/imgs/react-vs-vue/react-vs-vue.png","index_img":"/imgs/react-vs-vue/react-vs-vue.png","_content":"\nVue 和 React 作为前端开发框架中的两个扛把子，在日常的开发工作中我们需要频繁的与它们打交道。Vue 和 React 都是成熟的前端框架，都能胜任大型项目开发，但它们的设计理念、生态特点和适用场景存在差异。\n\n今天让我们先抛开写 React 更高级这种莫名奇妙的优越感，来唠一唠哪一个更适合大型项目。\n\n\n## 架构设计与可维护性\n\n大型项目的核心挑战之一是代码组织的可维护性，尤其是随着团队规模和代码量增长，需要清晰的架构规范，否则逃不过屎山代码的命运。\n\nReact采用了 `函数式组件 + JSX`的设计，强调 `组件化` 和 `单向数据流`, 灵活性极高。对于一些复杂逻辑，它可以使用 `Hooks` （如 `useState`、`useReducer`, `useContext`）或自定义 Hooks 来拆分代码。\n\n\n它本身并不强制特定架构，所以使用 React 开发需要开发团队自行制定规范（如目录结构，状态管理方案），因此更适合有经验的团队灵活设计符合项目需求的架构。\n\n![vue sfc](https://www.jvxiao.cn/imgs/react-vs-vue/vue-sfc.png)\n\n\nVue 采用的是 `模板 + 脚本 + 样式`的单文件组件（SFC），说白了就是这么写我定好了，你们按照我这个格式来写就 OK 了。不要问为什么，问就是海龟的屁股-龟腚。\n\nVue3 的 Composition Api 解决了 Vue2 中 Options Api 在大型项目中逻辑复用的痛点，支持按功能拆分，有点类似 React Hooks。\n\n\n## 状态管理与复杂逻辑\n\n大型项目往往涉及复杂的全局状态管理（如用户信息、权限、多模块数据交互）。\n\nReact 本身不内置状态管理方案，依赖生态中的第三方库，复杂场景可选择 Redux，Zustand（轻量灵活）、Recoil（专注原子化状态）等。\n\n![vue state](https://www.jvxiao.cn/imgs/react-vs-vue/state.png)\n\n\nVue 在这一块官方提供了完整的状态管理方案，Vue 2 中常用 Vuex，Vue 3 中已升级为 Pinia，集成和使用起来都很方便。\n\n从个人过往编程体验上来说，Vue 的状态管理在开发过程中会比 React 舒服很多。\n\n## 类型支持与工程化\n\n无论是主动升级还是被动升级，现在越来越多的项目都在使用 Typescript 来替代 JavaScript, 同时还配备工程化工具链，以减少运行时错误和提升开发效率。\n\nReact 与 TypeScript 集成极为成熟，从框架到生态库（如 React Router、Redux）都有完善的类型定义。函数式组件和 Hooks 天然适合 TypeScript 的类型推断，复杂场景下的类型定义更直观。\n\n![react-typescript](https://www.jvxiao.cn/imgs/react-vs-vue/react-typescript.png)\n\n\n此外， React 的工程化工具链也很丰富。如 Create React App、Next.js 等，适合复杂项目的工程化需求。\n\nVue 的话 Vue3 版本是使用 Typescript重写的，在类型支持大幅提升，但完善度略逊于 React。\n\n它的官方工具链Vite、Vue Router、Pinia）的类型集成无缝，且 Vite 的开发体验（热更新速度）在大型项目中优势明显。\n\n## 团队与学习成本\n\n大型项目通常由多团队协作，框架的学习曲线和团队熟悉度会直接影响开发效率。\n\n就目前开发者对两者的评价来说，React 的学习曲线还是比较陡峭的，尤其是JSX 语法、函数式编程思想（纯函数、不可变数据）对新手有一定门槛，但掌握后灵活性极高。\n\n![learning-curves](https://www.jvxiao.cn/imgs/react-vs-vue/learning-curves.jpg)\n\n\nVue 在学习曲线上对新手算是非常友好的，学习曲线平缓，模板语法接近 HTML。 其官方文档被称为 “前端最佳文档”，降低了团队培训成本，适合成员技术背景多样的大型团队。\n\n\n## 写在最后：如何选择？\n\n虽然很多时候，使用哪一个框架的选择权不在自己手上，但是，你得懂怎么选不是？\n\n如果说一个团队中有较多新手，或者团队整体水平差距较大，亦或者项目追求开发效率和低决策成本，那么 Vue 自然是首选了。\n\n如果项目需要高度定制化架构、强 TypeScript 集成、跨平台开发（Web + 移动端），或团队有丰富的 JavaScript / 函数式编程经验, 那么 选择 React 优先于 Vue。\n\n用一句很有哲理的话作为结束语吧：无论你怎么选，你都会遗憾。\n\n","source":"_posts/vue-vs-react.md","raw":"---\ntitle: 'Vue vs React 多维度剖析: 哪一个更适合大型项目？'\ndate: 2025-08-08 08:05:44\ntags: [Vue, React]\nkeywords: [Vue, React]\nbanner_img: /imgs/react-vs-vue/react-vs-vue.png\nindex_img: /imgs/react-vs-vue/react-vs-vue.png\n---\n\nVue 和 React 作为前端开发框架中的两个扛把子，在日常的开发工作中我们需要频繁的与它们打交道。Vue 和 React 都是成熟的前端框架，都能胜任大型项目开发，但它们的设计理念、生态特点和适用场景存在差异。\n\n今天让我们先抛开写 React 更高级这种莫名奇妙的优越感，来唠一唠哪一个更适合大型项目。\n\n\n## 架构设计与可维护性\n\n大型项目的核心挑战之一是代码组织的可维护性，尤其是随着团队规模和代码量增长，需要清晰的架构规范，否则逃不过屎山代码的命运。\n\nReact采用了 `函数式组件 + JSX`的设计，强调 `组件化` 和 `单向数据流`, 灵活性极高。对于一些复杂逻辑，它可以使用 `Hooks` （如 `useState`、`useReducer`, `useContext`）或自定义 Hooks 来拆分代码。\n\n\n它本身并不强制特定架构，所以使用 React 开发需要开发团队自行制定规范（如目录结构，状态管理方案），因此更适合有经验的团队灵活设计符合项目需求的架构。\n\n![vue sfc](https://www.jvxiao.cn/imgs/react-vs-vue/vue-sfc.png)\n\n\nVue 采用的是 `模板 + 脚本 + 样式`的单文件组件（SFC），说白了就是这么写我定好了，你们按照我这个格式来写就 OK 了。不要问为什么，问就是海龟的屁股-龟腚。\n\nVue3 的 Composition Api 解决了 Vue2 中 Options Api 在大型项目中逻辑复用的痛点，支持按功能拆分，有点类似 React Hooks。\n\n\n## 状态管理与复杂逻辑\n\n大型项目往往涉及复杂的全局状态管理（如用户信息、权限、多模块数据交互）。\n\nReact 本身不内置状态管理方案，依赖生态中的第三方库，复杂场景可选择 Redux，Zustand（轻量灵活）、Recoil（专注原子化状态）等。\n\n![vue state](https://www.jvxiao.cn/imgs/react-vs-vue/state.png)\n\n\nVue 在这一块官方提供了完整的状态管理方案，Vue 2 中常用 Vuex，Vue 3 中已升级为 Pinia，集成和使用起来都很方便。\n\n从个人过往编程体验上来说，Vue 的状态管理在开发过程中会比 React 舒服很多。\n\n## 类型支持与工程化\n\n无论是主动升级还是被动升级，现在越来越多的项目都在使用 Typescript 来替代 JavaScript, 同时还配备工程化工具链，以减少运行时错误和提升开发效率。\n\nReact 与 TypeScript 集成极为成熟，从框架到生态库（如 React Router、Redux）都有完善的类型定义。函数式组件和 Hooks 天然适合 TypeScript 的类型推断，复杂场景下的类型定义更直观。\n\n![react-typescript](https://www.jvxiao.cn/imgs/react-vs-vue/react-typescript.png)\n\n\n此外， React 的工程化工具链也很丰富。如 Create React App、Next.js 等，适合复杂项目的工程化需求。\n\nVue 的话 Vue3 版本是使用 Typescript重写的，在类型支持大幅提升，但完善度略逊于 React。\n\n它的官方工具链Vite、Vue Router、Pinia）的类型集成无缝，且 Vite 的开发体验（热更新速度）在大型项目中优势明显。\n\n## 团队与学习成本\n\n大型项目通常由多团队协作，框架的学习曲线和团队熟悉度会直接影响开发效率。\n\n就目前开发者对两者的评价来说，React 的学习曲线还是比较陡峭的，尤其是JSX 语法、函数式编程思想（纯函数、不可变数据）对新手有一定门槛，但掌握后灵活性极高。\n\n![learning-curves](https://www.jvxiao.cn/imgs/react-vs-vue/learning-curves.jpg)\n\n\nVue 在学习曲线上对新手算是非常友好的，学习曲线平缓，模板语法接近 HTML。 其官方文档被称为 “前端最佳文档”，降低了团队培训成本，适合成员技术背景多样的大型团队。\n\n\n## 写在最后：如何选择？\n\n虽然很多时候，使用哪一个框架的选择权不在自己手上，但是，你得懂怎么选不是？\n\n如果说一个团队中有较多新手，或者团队整体水平差距较大，亦或者项目追求开发效率和低决策成本，那么 Vue 自然是首选了。\n\n如果项目需要高度定制化架构、强 TypeScript 集成、跨平台开发（Web + 移动端），或团队有丰富的 JavaScript / 函数式编程经验, 那么 选择 React 优先于 Vue。\n\n用一句很有哲理的话作为结束语吧：无论你怎么选，你都会遗憾。\n\n","slug":"vue-vs-react","published":1,"updated":"2025-08-26T10:34:44.957Z","_id":"cmebfg7xx0001nsuphr99cws6","comments":1,"layout":"post","photos":[],"content":"<p>Vue 和 React 作为前端开发框架中的两个扛把子，在日常的开发工作中我们需要频繁的与它们打交道。Vue 和 React 都是成熟的前端框架，都能胜任大型项目开发，但它们的设计理念、生态特点和适用场景存在差异。</p>\n<p>今天让我们先抛开写 React 更高级这种莫名奇妙的优越感，来唠一唠哪一个更适合大型项目。</p>\n<h2 id=\"架构设计与可维护性\"><a href=\"#架构设计与可维护性\" class=\"headerlink\" title=\"架构设计与可维护性\"></a>架构设计与可维护性</h2><p>大型项目的核心挑战之一是代码组织的可维护性，尤其是随着团队规模和代码量增长，需要清晰的架构规范，否则逃不过屎山代码的命运。</p>\n<p>React采用了 <code>函数式组件 + JSX</code>的设计，强调 <code>组件化</code> 和 <code>单向数据流</code>, 灵活性极高。对于一些复杂逻辑，它可以使用 <code>Hooks</code> （如 <code>useState</code>、<code>useReducer</code>, <code>useContext</code>）或自定义 Hooks 来拆分代码。</p>\n<p>它本身并不强制特定架构，所以使用 React 开发需要开发团队自行制定规范（如目录结构，状态管理方案），因此更适合有经验的团队灵活设计符合项目需求的架构。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/react-vs-vue/vue-sfc.png\" alt=\"vue sfc\"></p>\n<p>Vue 采用的是 <code>模板 + 脚本 + 样式</code>的单文件组件（SFC），说白了就是这么写我定好了，你们按照我这个格式来写就 OK 了。不要问为什么，问就是海龟的屁股-龟腚。</p>\n<p>Vue3 的 Composition Api 解决了 Vue2 中 Options Api 在大型项目中逻辑复用的痛点，支持按功能拆分，有点类似 React Hooks。</p>\n<h2 id=\"状态管理与复杂逻辑\"><a href=\"#状态管理与复杂逻辑\" class=\"headerlink\" title=\"状态管理与复杂逻辑\"></a>状态管理与复杂逻辑</h2><p>大型项目往往涉及复杂的全局状态管理（如用户信息、权限、多模块数据交互）。</p>\n<p>React 本身不内置状态管理方案，依赖生态中的第三方库，复杂场景可选择 Redux，Zustand（轻量灵活）、Recoil（专注原子化状态）等。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/react-vs-vue/state.png\" alt=\"vue state\"></p>\n<p>Vue 在这一块官方提供了完整的状态管理方案，Vue 2 中常用 Vuex，Vue 3 中已升级为 Pinia，集成和使用起来都很方便。</p>\n<p>从个人过往编程体验上来说，Vue 的状态管理在开发过程中会比 React 舒服很多。</p>\n<h2 id=\"类型支持与工程化\"><a href=\"#类型支持与工程化\" class=\"headerlink\" title=\"类型支持与工程化\"></a>类型支持与工程化</h2><p>无论是主动升级还是被动升级，现在越来越多的项目都在使用 Typescript 来替代 JavaScript, 同时还配备工程化工具链，以减少运行时错误和提升开发效率。</p>\n<p>React 与 TypeScript 集成极为成熟，从框架到生态库（如 React Router、Redux）都有完善的类型定义。函数式组件和 Hooks 天然适合 TypeScript 的类型推断，复杂场景下的类型定义更直观。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/react-vs-vue/react-typescript.png\" alt=\"react-typescript\"></p>\n<p>此外， React 的工程化工具链也很丰富。如 Create React App、Next.js 等，适合复杂项目的工程化需求。</p>\n<p>Vue 的话 Vue3 版本是使用 Typescript重写的，在类型支持大幅提升，但完善度略逊于 React。</p>\n<p>它的官方工具链Vite、Vue Router、Pinia）的类型集成无缝，且 Vite 的开发体验（热更新速度）在大型项目中优势明显。</p>\n<h2 id=\"团队与学习成本\"><a href=\"#团队与学习成本\" class=\"headerlink\" title=\"团队与学习成本\"></a>团队与学习成本</h2><p>大型项目通常由多团队协作，框架的学习曲线和团队熟悉度会直接影响开发效率。</p>\n<p>就目前开发者对两者的评价来说，React 的学习曲线还是比较陡峭的，尤其是JSX 语法、函数式编程思想（纯函数、不可变数据）对新手有一定门槛，但掌握后灵活性极高。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/react-vs-vue/learning-curves.jpg\" alt=\"learning-curves\"></p>\n<p>Vue 在学习曲线上对新手算是非常友好的，学习曲线平缓，模板语法接近 HTML。 其官方文档被称为 “前端最佳文档”，降低了团队培训成本，适合成员技术背景多样的大型团队。</p>\n<h2 id=\"写在最后：如何选择？\"><a href=\"#写在最后：如何选择？\" class=\"headerlink\" title=\"写在最后：如何选择？\"></a>写在最后：如何选择？</h2><p>虽然很多时候，使用哪一个框架的选择权不在自己手上，但是，你得懂怎么选不是？</p>\n<p>如果说一个团队中有较多新手，或者团队整体水平差距较大，亦或者项目追求开发效率和低决策成本，那么 Vue 自然是首选了。</p>\n<p>如果项目需要高度定制化架构、强 TypeScript 集成、跨平台开发（Web + 移动端），或团队有丰富的 JavaScript &#x2F; 函数式编程经验, 那么 选择 React 优先于 Vue。</p>\n<p>用一句很有哲理的话作为结束语吧：无论你怎么选，你都会遗憾。</p>\n","excerpt":"","more":"<p>Vue 和 React 作为前端开发框架中的两个扛把子，在日常的开发工作中我们需要频繁的与它们打交道。Vue 和 React 都是成熟的前端框架，都能胜任大型项目开发，但它们的设计理念、生态特点和适用场景存在差异。</p>\n<p>今天让我们先抛开写 React 更高级这种莫名奇妙的优越感，来唠一唠哪一个更适合大型项目。</p>\n<h2 id=\"架构设计与可维护性\"><a href=\"#架构设计与可维护性\" class=\"headerlink\" title=\"架构设计与可维护性\"></a>架构设计与可维护性</h2><p>大型项目的核心挑战之一是代码组织的可维护性，尤其是随着团队规模和代码量增长，需要清晰的架构规范，否则逃不过屎山代码的命运。</p>\n<p>React采用了 <code>函数式组件 + JSX</code>的设计，强调 <code>组件化</code> 和 <code>单向数据流</code>, 灵活性极高。对于一些复杂逻辑，它可以使用 <code>Hooks</code> （如 <code>useState</code>、<code>useReducer</code>, <code>useContext</code>）或自定义 Hooks 来拆分代码。</p>\n<p>它本身并不强制特定架构，所以使用 React 开发需要开发团队自行制定规范（如目录结构，状态管理方案），因此更适合有经验的团队灵活设计符合项目需求的架构。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/react-vs-vue/vue-sfc.png\" alt=\"vue sfc\"></p>\n<p>Vue 采用的是 <code>模板 + 脚本 + 样式</code>的单文件组件（SFC），说白了就是这么写我定好了，你们按照我这个格式来写就 OK 了。不要问为什么，问就是海龟的屁股-龟腚。</p>\n<p>Vue3 的 Composition Api 解决了 Vue2 中 Options Api 在大型项目中逻辑复用的痛点，支持按功能拆分，有点类似 React Hooks。</p>\n<h2 id=\"状态管理与复杂逻辑\"><a href=\"#状态管理与复杂逻辑\" class=\"headerlink\" title=\"状态管理与复杂逻辑\"></a>状态管理与复杂逻辑</h2><p>大型项目往往涉及复杂的全局状态管理（如用户信息、权限、多模块数据交互）。</p>\n<p>React 本身不内置状态管理方案，依赖生态中的第三方库，复杂场景可选择 Redux，Zustand（轻量灵活）、Recoil（专注原子化状态）等。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/react-vs-vue/state.png\" alt=\"vue state\"></p>\n<p>Vue 在这一块官方提供了完整的状态管理方案，Vue 2 中常用 Vuex，Vue 3 中已升级为 Pinia，集成和使用起来都很方便。</p>\n<p>从个人过往编程体验上来说，Vue 的状态管理在开发过程中会比 React 舒服很多。</p>\n<h2 id=\"类型支持与工程化\"><a href=\"#类型支持与工程化\" class=\"headerlink\" title=\"类型支持与工程化\"></a>类型支持与工程化</h2><p>无论是主动升级还是被动升级，现在越来越多的项目都在使用 Typescript 来替代 JavaScript, 同时还配备工程化工具链，以减少运行时错误和提升开发效率。</p>\n<p>React 与 TypeScript 集成极为成熟，从框架到生态库（如 React Router、Redux）都有完善的类型定义。函数式组件和 Hooks 天然适合 TypeScript 的类型推断，复杂场景下的类型定义更直观。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/react-vs-vue/react-typescript.png\" alt=\"react-typescript\"></p>\n<p>此外， React 的工程化工具链也很丰富。如 Create React App、Next.js 等，适合复杂项目的工程化需求。</p>\n<p>Vue 的话 Vue3 版本是使用 Typescript重写的，在类型支持大幅提升，但完善度略逊于 React。</p>\n<p>它的官方工具链Vite、Vue Router、Pinia）的类型集成无缝，且 Vite 的开发体验（热更新速度）在大型项目中优势明显。</p>\n<h2 id=\"团队与学习成本\"><a href=\"#团队与学习成本\" class=\"headerlink\" title=\"团队与学习成本\"></a>团队与学习成本</h2><p>大型项目通常由多团队协作，框架的学习曲线和团队熟悉度会直接影响开发效率。</p>\n<p>就目前开发者对两者的评价来说，React 的学习曲线还是比较陡峭的，尤其是JSX 语法、函数式编程思想（纯函数、不可变数据）对新手有一定门槛，但掌握后灵活性极高。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/react-vs-vue/learning-curves.jpg\" alt=\"learning-curves\"></p>\n<p>Vue 在学习曲线上对新手算是非常友好的，学习曲线平缓，模板语法接近 HTML。 其官方文档被称为 “前端最佳文档”，降低了团队培训成本，适合成员技术背景多样的大型团队。</p>\n<h2 id=\"写在最后：如何选择？\"><a href=\"#写在最后：如何选择？\" class=\"headerlink\" title=\"写在最后：如何选择？\"></a>写在最后：如何选择？</h2><p>虽然很多时候，使用哪一个框架的选择权不在自己手上，但是，你得懂怎么选不是？</p>\n<p>如果说一个团队中有较多新手，或者团队整体水平差距较大，亦或者项目追求开发效率和低决策成本，那么 Vue 自然是首选了。</p>\n<p>如果项目需要高度定制化架构、强 TypeScript 集成、跨平台开发（Web + 移动端），或团队有丰富的 JavaScript &#x2F; 函数式编程经验, 那么 选择 React 优先于 Vue。</p>\n<p>用一句很有哲理的话作为结束语吧：无论你怎么选，你都会遗憾。</p>\n"},{"title":"爆肝三周，我终于上线了自己的第一个小程序","date":"2025-08-24T15:03:53.000Z","banner_img":"/imgs/wxprogram/微信小程序.png","index_img":"/imgs/wxprogram/微信小程序.png","_content":"\n三周前，帮朋友拍证件照时差点吵起来 —— 他要白底一寸照，我用修图软件改背景，边缘总留着灰边，最后还是花 30 块去照相馆拍的。看着他吐槽 “拍个照还要跑一趟”，我突然冒了个念头：要不自己做个证件照小程序？当时也就随口一说，转头就打开电脑，真的开始琢磨起来了。\n\n## 半路出家\n选方向没纠结，就定证件照制作。之前帮人改照片总出错，要么尺寸不对，要么背景色不标准；身边朋友也常说，临时要个证件照，找修图软件半天弄不明白，去照相馆又费时间。想着做个轻量化工具，核心功能就三个：标准化尺寸调整（覆盖一寸、二寸、社保照等常用规格）、背景色一键替换（白 / 蓝 / 红三色标准色值）、电子版保存，暂时不做复杂的美颜功能，先保证基础可用性。\n\n\n真正动手才知道难。我是个半路出家的，之前只跟着网课学过基础的微信小程序开发，真要搭项目框架时，对着微信开发者工具的文档发呆能发一下午。第一天晚上熬到两点，好不容易弄出个能上传照片的静态页面，结果点击 “确认上传” 按钮毫无反应，排查半天才发现绑定的事件函数名写错了；更糟的是保存代码时误删了 pages 目录，当时坐在电脑前盯着黑屏，差点把鼠标扔了。\n\n## 这坑啊，真的一填一个不吱声\n\n中间那周简直是跟 bug 死磕。最头疼的先是**背景替换功能**，用户上传照片后，人物边缘总带着原背景的杂色，明明照着教程调了 mask 遮罩参数，到我这就变成 “大花脸”。凌晨三点蹲在开发者论坛发帖，有个匿名网友回了句 “试试把边缘羽化值从 5px 调至 7px，同时增加色彩容差阈值”，试完真的好了，盯着屏幕里干净的白底照片，傻笑到天边泛白。\n\n紧接着又遇到**图片大小的问题** —— 很多用户上传的照片是相机直出图，动辄 3-5M，远超小程序默认 1M 的上传限制，一上传就卡住闪退。一开始我试着用前端压缩插件，通过调整图片分辨率和质量参数（把 JPG 质量压缩到 80%，分辨率限制在 1080px 以内），但压缩后画质损失严重，证件照打印出来会模糊。后来查资料发现可以用云存储，对比了几家云服务后，选了有免费额度的腾讯云对象存储，花了一天时间学怎么调用 SDK 接口，把用户上传的原图先传到云服务器，再在云端完成压缩和处理，最后返回压缩后的标准图，这才解决了大小和画质的矛盾。\n\n**尺寸功能**也踩过坑，一寸照（2.5cm×3.5cm）、二寸照（3.5cm×4.9cm）的像素比例总弄混，按公式换算后（1 英寸 = 96 像素），打印出来要么头顶被截，要么两边留白太多。最后拿着尺子在纸上画实际尺寸，对着屏幕一点点校准像素值，还专门找了照相馆的标准模板对比，蹲在桌前调参数时，被蚊子叮了好几个包都没察觉。\n\n最崩溃的是上线前的流程。审核第一次被打回来，说 “涉及用户图像信息，缺少**隐私保护声明**”，我这纯工具类小程序，哪想到还要这个？打电话给微信客服，听着机器人语音转了八次人工，才搞懂要加弹窗式隐私协议，明确告知用户 “照片仅用于当前编辑，不存储服务器、编辑后自动删除”。\n\n改完隐私声明提交，又卡在了**备案上** —— 小程序要上线，必须先完成 ICP 备案。之前完全没接触过备案流程，只能跟着云服务商的指引填资料，各种证件扫描件反复改格式（要求小于 200KB 且背景纯白），负责人信息核验时因为身份证照片反光被打回两次，还得等管局审核，期间打了三次客服电话催进度，前前后后花了五天，比改 bug 还耗精力。等备案通过那天，整个人瘫在椅子上，外卖到了都没力气拆，闻着香味就睡着了。\n\n## 幸福的眼泪(假的)\n今早收到小程序审核通过的短信时，我正在给绿萝浇水。手一抖，水洒了一地，赶紧擦干净去看手机。点开自己做的小程序，上传了张旧照片，点 “换蓝底”“调一寸”，几秒就生成了标准证件照，虽然按钮排版还有点歪，但核心功能全正常。刚才朋友发消息来，说用我的小程序做了社保照片，打印出来完全合格，省了去照相馆的钱，我跟他讲 “以后要证件照就用这个”，挂了电话眼泪就下来了。\n\n\n## 写在最后\n原来自己做的工具能真正帮到别人，是这么踏实的感觉。现在回头看，那些熬到凌晨的夜晚、反复调试的代码、流程里的磕磕绊绊，都成了最实在的收获。\n\n最后，给大家分享一下我做的小程序吧，直接扫码或者搜索“**豆豆证照工坊**”，如果你觉得能帮到你，不妨分享给你的朋友们，如果觉得有做得不好的地方，欢迎留言区提建议（轻喷）。\n\n![qrcode](../imgs/wxprogram/code.png)\n\n","source":"_posts/my-first-miniprogram.md","raw":"---\ntitle: 爆肝三周，我终于上线了自己的第一个小程序\ndate: 2025-08-24 23:03:53\ntags: [微信小程序]\nbanner_img: /imgs/wxprogram/微信小程序.png\nindex_img: /imgs/wxprogram/微信小程序.png\n---\n\n三周前，帮朋友拍证件照时差点吵起来 —— 他要白底一寸照，我用修图软件改背景，边缘总留着灰边，最后还是花 30 块去照相馆拍的。看着他吐槽 “拍个照还要跑一趟”，我突然冒了个念头：要不自己做个证件照小程序？当时也就随口一说，转头就打开电脑，真的开始琢磨起来了。\n\n## 半路出家\n选方向没纠结，就定证件照制作。之前帮人改照片总出错，要么尺寸不对，要么背景色不标准；身边朋友也常说，临时要个证件照，找修图软件半天弄不明白，去照相馆又费时间。想着做个轻量化工具，核心功能就三个：标准化尺寸调整（覆盖一寸、二寸、社保照等常用规格）、背景色一键替换（白 / 蓝 / 红三色标准色值）、电子版保存，暂时不做复杂的美颜功能，先保证基础可用性。\n\n\n真正动手才知道难。我是个半路出家的，之前只跟着网课学过基础的微信小程序开发，真要搭项目框架时，对着微信开发者工具的文档发呆能发一下午。第一天晚上熬到两点，好不容易弄出个能上传照片的静态页面，结果点击 “确认上传” 按钮毫无反应，排查半天才发现绑定的事件函数名写错了；更糟的是保存代码时误删了 pages 目录，当时坐在电脑前盯着黑屏，差点把鼠标扔了。\n\n## 这坑啊，真的一填一个不吱声\n\n中间那周简直是跟 bug 死磕。最头疼的先是**背景替换功能**，用户上传照片后，人物边缘总带着原背景的杂色，明明照着教程调了 mask 遮罩参数，到我这就变成 “大花脸”。凌晨三点蹲在开发者论坛发帖，有个匿名网友回了句 “试试把边缘羽化值从 5px 调至 7px，同时增加色彩容差阈值”，试完真的好了，盯着屏幕里干净的白底照片，傻笑到天边泛白。\n\n紧接着又遇到**图片大小的问题** —— 很多用户上传的照片是相机直出图，动辄 3-5M，远超小程序默认 1M 的上传限制，一上传就卡住闪退。一开始我试着用前端压缩插件，通过调整图片分辨率和质量参数（把 JPG 质量压缩到 80%，分辨率限制在 1080px 以内），但压缩后画质损失严重，证件照打印出来会模糊。后来查资料发现可以用云存储，对比了几家云服务后，选了有免费额度的腾讯云对象存储，花了一天时间学怎么调用 SDK 接口，把用户上传的原图先传到云服务器，再在云端完成压缩和处理，最后返回压缩后的标准图，这才解决了大小和画质的矛盾。\n\n**尺寸功能**也踩过坑，一寸照（2.5cm×3.5cm）、二寸照（3.5cm×4.9cm）的像素比例总弄混，按公式换算后（1 英寸 = 96 像素），打印出来要么头顶被截，要么两边留白太多。最后拿着尺子在纸上画实际尺寸，对着屏幕一点点校准像素值，还专门找了照相馆的标准模板对比，蹲在桌前调参数时，被蚊子叮了好几个包都没察觉。\n\n最崩溃的是上线前的流程。审核第一次被打回来，说 “涉及用户图像信息，缺少**隐私保护声明**”，我这纯工具类小程序，哪想到还要这个？打电话给微信客服，听着机器人语音转了八次人工，才搞懂要加弹窗式隐私协议，明确告知用户 “照片仅用于当前编辑，不存储服务器、编辑后自动删除”。\n\n改完隐私声明提交，又卡在了**备案上** —— 小程序要上线，必须先完成 ICP 备案。之前完全没接触过备案流程，只能跟着云服务商的指引填资料，各种证件扫描件反复改格式（要求小于 200KB 且背景纯白），负责人信息核验时因为身份证照片反光被打回两次，还得等管局审核，期间打了三次客服电话催进度，前前后后花了五天，比改 bug 还耗精力。等备案通过那天，整个人瘫在椅子上，外卖到了都没力气拆，闻着香味就睡着了。\n\n## 幸福的眼泪(假的)\n今早收到小程序审核通过的短信时，我正在给绿萝浇水。手一抖，水洒了一地，赶紧擦干净去看手机。点开自己做的小程序，上传了张旧照片，点 “换蓝底”“调一寸”，几秒就生成了标准证件照，虽然按钮排版还有点歪，但核心功能全正常。刚才朋友发消息来，说用我的小程序做了社保照片，打印出来完全合格，省了去照相馆的钱，我跟他讲 “以后要证件照就用这个”，挂了电话眼泪就下来了。\n\n\n## 写在最后\n原来自己做的工具能真正帮到别人，是这么踏实的感觉。现在回头看，那些熬到凌晨的夜晚、反复调试的代码、流程里的磕磕绊绊，都成了最实在的收获。\n\n最后，给大家分享一下我做的小程序吧，直接扫码或者搜索“**豆豆证照工坊**”，如果你觉得能帮到你，不妨分享给你的朋友们，如果觉得有做得不好的地方，欢迎留言区提建议（轻喷）。\n\n![qrcode](../imgs/wxprogram/code.png)\n\n","slug":"my-first-miniprogram","published":1,"updated":"2025-08-26T10:32:52.772Z","_id":"cmeptkpqg00024cup0zgz4asn","comments":1,"layout":"post","photos":[],"content":"<p>三周前，帮朋友拍证件照时差点吵起来 —— 他要白底一寸照，我用修图软件改背景，边缘总留着灰边，最后还是花 30 块去照相馆拍的。看着他吐槽 “拍个照还要跑一趟”，我突然冒了个念头：要不自己做个证件照小程序？当时也就随口一说，转头就打开电脑，真的开始琢磨起来了。</p>\n<h2 id=\"半路出家\"><a href=\"#半路出家\" class=\"headerlink\" title=\"半路出家\"></a>半路出家</h2><p>选方向没纠结，就定证件照制作。之前帮人改照片总出错，要么尺寸不对，要么背景色不标准；身边朋友也常说，临时要个证件照，找修图软件半天弄不明白，去照相馆又费时间。想着做个轻量化工具，核心功能就三个：标准化尺寸调整（覆盖一寸、二寸、社保照等常用规格）、背景色一键替换（白 &#x2F; 蓝 &#x2F; 红三色标准色值）、电子版保存，暂时不做复杂的美颜功能，先保证基础可用性。</p>\n<p>真正动手才知道难。我是个半路出家的，之前只跟着网课学过基础的微信小程序开发，真要搭项目框架时，对着微信开发者工具的文档发呆能发一下午。第一天晚上熬到两点，好不容易弄出个能上传照片的静态页面，结果点击 “确认上传” 按钮毫无反应，排查半天才发现绑定的事件函数名写错了；更糟的是保存代码时误删了 pages 目录，当时坐在电脑前盯着黑屏，差点把鼠标扔了。</p>\n<h2 id=\"这坑啊，真的一填一个不吱声\"><a href=\"#这坑啊，真的一填一个不吱声\" class=\"headerlink\" title=\"这坑啊，真的一填一个不吱声\"></a>这坑啊，真的一填一个不吱声</h2><p>中间那周简直是跟 bug 死磕。最头疼的先是<strong>背景替换功能</strong>，用户上传照片后，人物边缘总带着原背景的杂色，明明照着教程调了 mask 遮罩参数，到我这就变成 “大花脸”。凌晨三点蹲在开发者论坛发帖，有个匿名网友回了句 “试试把边缘羽化值从 5px 调至 7px，同时增加色彩容差阈值”，试完真的好了，盯着屏幕里干净的白底照片，傻笑到天边泛白。</p>\n<p>紧接着又遇到<strong>图片大小的问题</strong> —— 很多用户上传的照片是相机直出图，动辄 3-5M，远超小程序默认 1M 的上传限制，一上传就卡住闪退。一开始我试着用前端压缩插件，通过调整图片分辨率和质量参数（把 JPG 质量压缩到 80%，分辨率限制在 1080px 以内），但压缩后画质损失严重，证件照打印出来会模糊。后来查资料发现可以用云存储，对比了几家云服务后，选了有免费额度的腾讯云对象存储，花了一天时间学怎么调用 SDK 接口，把用户上传的原图先传到云服务器，再在云端完成压缩和处理，最后返回压缩后的标准图，这才解决了大小和画质的矛盾。</p>\n<p><strong>尺寸功能</strong>也踩过坑，一寸照（2.5cm×3.5cm）、二寸照（3.5cm×4.9cm）的像素比例总弄混，按公式换算后（1 英寸 &#x3D; 96 像素），打印出来要么头顶被截，要么两边留白太多。最后拿着尺子在纸上画实际尺寸，对着屏幕一点点校准像素值，还专门找了照相馆的标准模板对比，蹲在桌前调参数时，被蚊子叮了好几个包都没察觉。</p>\n<p>最崩溃的是上线前的流程。审核第一次被打回来，说 “涉及用户图像信息，缺少<strong>隐私保护声明</strong>”，我这纯工具类小程序，哪想到还要这个？打电话给微信客服，听着机器人语音转了八次人工，才搞懂要加弹窗式隐私协议，明确告知用户 “照片仅用于当前编辑，不存储服务器、编辑后自动删除”。</p>\n<p>改完隐私声明提交，又卡在了<strong>备案上</strong> —— 小程序要上线，必须先完成 ICP 备案。之前完全没接触过备案流程，只能跟着云服务商的指引填资料，各种证件扫描件反复改格式（要求小于 200KB 且背景纯白），负责人信息核验时因为身份证照片反光被打回两次，还得等管局审核，期间打了三次客服电话催进度，前前后后花了五天，比改 bug 还耗精力。等备案通过那天，整个人瘫在椅子上，外卖到了都没力气拆，闻着香味就睡着了。</p>\n<h2 id=\"幸福的眼泪-假的\"><a href=\"#幸福的眼泪-假的\" class=\"headerlink\" title=\"幸福的眼泪(假的)\"></a>幸福的眼泪(假的)</h2><p>今早收到小程序审核通过的短信时，我正在给绿萝浇水。手一抖，水洒了一地，赶紧擦干净去看手机。点开自己做的小程序，上传了张旧照片，点 “换蓝底”“调一寸”，几秒就生成了标准证件照，虽然按钮排版还有点歪，但核心功能全正常。刚才朋友发消息来，说用我的小程序做了社保照片，打印出来完全合格，省了去照相馆的钱，我跟他讲 “以后要证件照就用这个”，挂了电话眼泪就下来了。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>原来自己做的工具能真正帮到别人，是这么踏实的感觉。现在回头看，那些熬到凌晨的夜晚、反复调试的代码、流程里的磕磕绊绊，都成了最实在的收获。</p>\n<p>最后，给大家分享一下我做的小程序吧，直接扫码或者搜索“<strong>豆豆证照工坊</strong>”，如果你觉得能帮到你，不妨分享给你的朋友们，如果觉得有做得不好的地方，欢迎留言区提建议（轻喷）。</p>\n<p><img src=\"/../imgs/wxprogram/code.png\" alt=\"qrcode\"></p>\n","excerpt":"","more":"<p>三周前，帮朋友拍证件照时差点吵起来 —— 他要白底一寸照，我用修图软件改背景，边缘总留着灰边，最后还是花 30 块去照相馆拍的。看着他吐槽 “拍个照还要跑一趟”，我突然冒了个念头：要不自己做个证件照小程序？当时也就随口一说，转头就打开电脑，真的开始琢磨起来了。</p>\n<h2 id=\"半路出家\"><a href=\"#半路出家\" class=\"headerlink\" title=\"半路出家\"></a>半路出家</h2><p>选方向没纠结，就定证件照制作。之前帮人改照片总出错，要么尺寸不对，要么背景色不标准；身边朋友也常说，临时要个证件照，找修图软件半天弄不明白，去照相馆又费时间。想着做个轻量化工具，核心功能就三个：标准化尺寸调整（覆盖一寸、二寸、社保照等常用规格）、背景色一键替换（白 &#x2F; 蓝 &#x2F; 红三色标准色值）、电子版保存，暂时不做复杂的美颜功能，先保证基础可用性。</p>\n<p>真正动手才知道难。我是个半路出家的，之前只跟着网课学过基础的微信小程序开发，真要搭项目框架时，对着微信开发者工具的文档发呆能发一下午。第一天晚上熬到两点，好不容易弄出个能上传照片的静态页面，结果点击 “确认上传” 按钮毫无反应，排查半天才发现绑定的事件函数名写错了；更糟的是保存代码时误删了 pages 目录，当时坐在电脑前盯着黑屏，差点把鼠标扔了。</p>\n<h2 id=\"这坑啊，真的一填一个不吱声\"><a href=\"#这坑啊，真的一填一个不吱声\" class=\"headerlink\" title=\"这坑啊，真的一填一个不吱声\"></a>这坑啊，真的一填一个不吱声</h2><p>中间那周简直是跟 bug 死磕。最头疼的先是<strong>背景替换功能</strong>，用户上传照片后，人物边缘总带着原背景的杂色，明明照着教程调了 mask 遮罩参数，到我这就变成 “大花脸”。凌晨三点蹲在开发者论坛发帖，有个匿名网友回了句 “试试把边缘羽化值从 5px 调至 7px，同时增加色彩容差阈值”，试完真的好了，盯着屏幕里干净的白底照片，傻笑到天边泛白。</p>\n<p>紧接着又遇到<strong>图片大小的问题</strong> —— 很多用户上传的照片是相机直出图，动辄 3-5M，远超小程序默认 1M 的上传限制，一上传就卡住闪退。一开始我试着用前端压缩插件，通过调整图片分辨率和质量参数（把 JPG 质量压缩到 80%，分辨率限制在 1080px 以内），但压缩后画质损失严重，证件照打印出来会模糊。后来查资料发现可以用云存储，对比了几家云服务后，选了有免费额度的腾讯云对象存储，花了一天时间学怎么调用 SDK 接口，把用户上传的原图先传到云服务器，再在云端完成压缩和处理，最后返回压缩后的标准图，这才解决了大小和画质的矛盾。</p>\n<p><strong>尺寸功能</strong>也踩过坑，一寸照（2.5cm×3.5cm）、二寸照（3.5cm×4.9cm）的像素比例总弄混，按公式换算后（1 英寸 &#x3D; 96 像素），打印出来要么头顶被截，要么两边留白太多。最后拿着尺子在纸上画实际尺寸，对着屏幕一点点校准像素值，还专门找了照相馆的标准模板对比，蹲在桌前调参数时，被蚊子叮了好几个包都没察觉。</p>\n<p>最崩溃的是上线前的流程。审核第一次被打回来，说 “涉及用户图像信息，缺少<strong>隐私保护声明</strong>”，我这纯工具类小程序，哪想到还要这个？打电话给微信客服，听着机器人语音转了八次人工，才搞懂要加弹窗式隐私协议，明确告知用户 “照片仅用于当前编辑，不存储服务器、编辑后自动删除”。</p>\n<p>改完隐私声明提交，又卡在了<strong>备案上</strong> —— 小程序要上线，必须先完成 ICP 备案。之前完全没接触过备案流程，只能跟着云服务商的指引填资料，各种证件扫描件反复改格式（要求小于 200KB 且背景纯白），负责人信息核验时因为身份证照片反光被打回两次，还得等管局审核，期间打了三次客服电话催进度，前前后后花了五天，比改 bug 还耗精力。等备案通过那天，整个人瘫在椅子上，外卖到了都没力气拆，闻着香味就睡着了。</p>\n<h2 id=\"幸福的眼泪-假的\"><a href=\"#幸福的眼泪-假的\" class=\"headerlink\" title=\"幸福的眼泪(假的)\"></a>幸福的眼泪(假的)</h2><p>今早收到小程序审核通过的短信时，我正在给绿萝浇水。手一抖，水洒了一地，赶紧擦干净去看手机。点开自己做的小程序，上传了张旧照片，点 “换蓝底”“调一寸”，几秒就生成了标准证件照，虽然按钮排版还有点歪，但核心功能全正常。刚才朋友发消息来，说用我的小程序做了社保照片，打印出来完全合格，省了去照相馆的钱，我跟他讲 “以后要证件照就用这个”，挂了电话眼泪就下来了。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>原来自己做的工具能真正帮到别人，是这么踏实的感觉。现在回头看，那些熬到凌晨的夜晚、反复调试的代码、流程里的磕磕绊绊，都成了最实在的收获。</p>\n<p>最后，给大家分享一下我做的小程序吧，直接扫码或者搜索“<strong>豆豆证照工坊</strong>”，如果你觉得能帮到你，不妨分享给你的朋友们，如果觉得有做得不好的地方，欢迎留言区提建议（轻喷）。</p>\n<p><img src=\"/../imgs/wxprogram/code.png\" alt=\"qrcode\"></p>\n"},{"title":"深入理解 JavaScript 中的原型与原型链","date":"2025-08-25T13:37:57.000Z","index_img":"imgs/prototype/banner.png","banner_img":"imgs/prototype/banner.png","_content":"\n\n在 JavaScript 的世界里，原型和原型链是绕不开的核心概念，它们构建了 JS 独特的继承机制，也让许多开发者既好奇又头疼。今天我们就从几个关键角度，一起揭开它们的神秘面纱。\n\n## 基于类与基于原型：两种不同的编程范式\n在传统的面向对象编程语言中，比如 Java、C++，**基于类（Class-based）** 是主流的编程思想。在这种范式里，类就像是一个模具，它定义了对象所具有的属性和方法，而对象则是类的实例。我们必须先定义好类，然后通过new关键字来创建该类的对象，对象之间的关系是通过类的继承来确立的。\n\n而 JavaScript 则不同，它采用的是**基于原型（Prototype-based）** 的编程范式。在这种模式下，并没有严格意义上的类的概念（虽然 ES6 引入了class语法，但这只是语法糖，底层依然是基于原型实现的）。对象可以直接从其他对象继承属性和方法，我们可以把原型看作是一个模板对象，新创建的对象会以这个模板为基础，共享它的属性和方法。\n\n举个简单的例子，在基于类的编程中，我们先定义一个 “动物” 类，规定动物有 “名字” 属性和 “移动” 方法，然后 “猫” 类继承 “动物” 类，再创建 “猫” 类的实例。而在基于原型的 JavaScript 中，我们可以先创建一个 “动物” 对象作为原型，然后创建 “猫” 对象时，让它的原型指向 “动物” 对象，“猫” 对象就自然拥有了 “动物” 对象的属性和方法。\n\n## 原型是啥，对象是如何产生的\n原型（Prototype） 其实就是一个普通的对象，它是其他对象的模板，被用于共享属性和方法。在 JavaScript 中，每个对象（除了null和undefined）都有一个与之关联的原型对象。\n\n那么对象是如何产生的呢？\n\n当我们使用new关键字调用构造函数时，会创建一个新的对象。这个新对象的原型会指向构造函数的prototype属性所指向的对象。\n\n例如，我们定义一个Person构造函数：\n\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\n```\n\n当我们通过 `new Person(\"张三\")` 创建一个对象时，这个新对象的原型就是 *Person.prototype*。\n\n此外，我们还可以使用 `Object.create()` 方法来创建对象，这个方法会以传入的对象为原型来创建新的对象。比如 `Object.create(prototypeObj)`  创建的新对象，其原型就是 prototypeObj。\n\n## 原型链的用处\n原型链（Prototype Chain） 是由对象的原型串联起来形成的链式结构。当我们访问一个对象的属性或方法时，如果该对象本身没有这个属性或方法，JavaScript 就会沿着原型链向上查找，直到找到该属性或方法，或者到达原型链的顶端（null）。\n\n原型链的用处和好处主要有以下几点：\n\n**实现继承**：这是原型链最主要的作用。通过原型链，一个对象可以继承多个原型对象的属性和方法，实现了代码的复用。比如，子对象的原型指向父对象，子对象就可以使用父对象的属性和方法，当父对象的原型又指向其他对象时，就形成了更长的继承链。\n\n**节省内存空间**：由于多个对象可以共享同一个原型对象的属性和方法，不需要为每个对象都重复定义这些属性和方法，大大节省了内存。例如，所有通过同一个构造函数创建的对象，都会共享该构造函数prototype对象中的方法，而不是每个对象都拥有一份独立的方法副本。\n\n**动态扩展属性和方法**：我们可以在原型对象上动态地添加属性和方法，这些添加的属性和方法会立即被所有依赖该原型的对象所共享。比如，给 `Person.prototype` 添加一个 `sayHello` 方法，那么所有通过 *Person* 构造函数创建的对象都能立即使用这个 sayHello 方法。\n\n\n## 写在最后\n原型和原型链是 JavaScript 实现面向对象编程的核心机制，理解它们对于掌握 JavaScript 有着至关重要的意义。\n\n对于开发者而言，理解它们不仅是掌握 “继承”“内存优化” 等基础能力的关键，更是后续学习闭包、原型继承实战、甚至框架源码（如 Vue、React 中部分组件复用逻辑）的前提。","source":"_posts/prototype-in-js.md","raw":"---\ntitle: 深入理解 JavaScript 中的原型与原型链\ndate: 2025-08-25 21:37:57\ntags: [JavaScript, 前端进阶]\nindex_img: imgs/prototype/banner.png\nbanner_img: imgs/prototype/banner.png\n---\n\n\n在 JavaScript 的世界里，原型和原型链是绕不开的核心概念，它们构建了 JS 独特的继承机制，也让许多开发者既好奇又头疼。今天我们就从几个关键角度，一起揭开它们的神秘面纱。\n\n## 基于类与基于原型：两种不同的编程范式\n在传统的面向对象编程语言中，比如 Java、C++，**基于类（Class-based）** 是主流的编程思想。在这种范式里，类就像是一个模具，它定义了对象所具有的属性和方法，而对象则是类的实例。我们必须先定义好类，然后通过new关键字来创建该类的对象，对象之间的关系是通过类的继承来确立的。\n\n而 JavaScript 则不同，它采用的是**基于原型（Prototype-based）** 的编程范式。在这种模式下，并没有严格意义上的类的概念（虽然 ES6 引入了class语法，但这只是语法糖，底层依然是基于原型实现的）。对象可以直接从其他对象继承属性和方法，我们可以把原型看作是一个模板对象，新创建的对象会以这个模板为基础，共享它的属性和方法。\n\n举个简单的例子，在基于类的编程中，我们先定义一个 “动物” 类，规定动物有 “名字” 属性和 “移动” 方法，然后 “猫” 类继承 “动物” 类，再创建 “猫” 类的实例。而在基于原型的 JavaScript 中，我们可以先创建一个 “动物” 对象作为原型，然后创建 “猫” 对象时，让它的原型指向 “动物” 对象，“猫” 对象就自然拥有了 “动物” 对象的属性和方法。\n\n## 原型是啥，对象是如何产生的\n原型（Prototype） 其实就是一个普通的对象，它是其他对象的模板，被用于共享属性和方法。在 JavaScript 中，每个对象（除了null和undefined）都有一个与之关联的原型对象。\n\n那么对象是如何产生的呢？\n\n当我们使用new关键字调用构造函数时，会创建一个新的对象。这个新对象的原型会指向构造函数的prototype属性所指向的对象。\n\n例如，我们定义一个Person构造函数：\n\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\n```\n\n当我们通过 `new Person(\"张三\")` 创建一个对象时，这个新对象的原型就是 *Person.prototype*。\n\n此外，我们还可以使用 `Object.create()` 方法来创建对象，这个方法会以传入的对象为原型来创建新的对象。比如 `Object.create(prototypeObj)`  创建的新对象，其原型就是 prototypeObj。\n\n## 原型链的用处\n原型链（Prototype Chain） 是由对象的原型串联起来形成的链式结构。当我们访问一个对象的属性或方法时，如果该对象本身没有这个属性或方法，JavaScript 就会沿着原型链向上查找，直到找到该属性或方法，或者到达原型链的顶端（null）。\n\n原型链的用处和好处主要有以下几点：\n\n**实现继承**：这是原型链最主要的作用。通过原型链，一个对象可以继承多个原型对象的属性和方法，实现了代码的复用。比如，子对象的原型指向父对象，子对象就可以使用父对象的属性和方法，当父对象的原型又指向其他对象时，就形成了更长的继承链。\n\n**节省内存空间**：由于多个对象可以共享同一个原型对象的属性和方法，不需要为每个对象都重复定义这些属性和方法，大大节省了内存。例如，所有通过同一个构造函数创建的对象，都会共享该构造函数prototype对象中的方法，而不是每个对象都拥有一份独立的方法副本。\n\n**动态扩展属性和方法**：我们可以在原型对象上动态地添加属性和方法，这些添加的属性和方法会立即被所有依赖该原型的对象所共享。比如，给 `Person.prototype` 添加一个 `sayHello` 方法，那么所有通过 *Person* 构造函数创建的对象都能立即使用这个 sayHello 方法。\n\n\n## 写在最后\n原型和原型链是 JavaScript 实现面向对象编程的核心机制，理解它们对于掌握 JavaScript 有着至关重要的意义。\n\n对于开发者而言，理解它们不仅是掌握 “继承”“内存优化” 等基础能力的关键，更是后续学习闭包、原型继承实战、甚至框架源码（如 Vue、React 中部分组件复用逻辑）的前提。","slug":"prototype-in-js","published":1,"updated":"2025-08-26T10:20:59.250Z","_id":"cmer7zcuk0000rcupbi070nis","comments":1,"layout":"post","photos":[],"content":"<p>在 JavaScript 的世界里，原型和原型链是绕不开的核心概念，它们构建了 JS 独特的继承机制，也让许多开发者既好奇又头疼。今天我们就从几个关键角度，一起揭开它们的神秘面纱。</p>\n<h2 id=\"基于类与基于原型：两种不同的编程范式\"><a href=\"#基于类与基于原型：两种不同的编程范式\" class=\"headerlink\" title=\"基于类与基于原型：两种不同的编程范式\"></a>基于类与基于原型：两种不同的编程范式</h2><p>在传统的面向对象编程语言中，比如 Java、C++，<strong>基于类（Class-based）</strong> 是主流的编程思想。在这种范式里，类就像是一个模具，它定义了对象所具有的属性和方法，而对象则是类的实例。我们必须先定义好类，然后通过new关键字来创建该类的对象，对象之间的关系是通过类的继承来确立的。</p>\n<p>而 JavaScript 则不同，它采用的是<strong>基于原型（Prototype-based）</strong> 的编程范式。在这种模式下，并没有严格意义上的类的概念（虽然 ES6 引入了class语法，但这只是语法糖，底层依然是基于原型实现的）。对象可以直接从其他对象继承属性和方法，我们可以把原型看作是一个模板对象，新创建的对象会以这个模板为基础，共享它的属性和方法。</p>\n<p>举个简单的例子，在基于类的编程中，我们先定义一个 “动物” 类，规定动物有 “名字” 属性和 “移动” 方法，然后 “猫” 类继承 “动物” 类，再创建 “猫” 类的实例。而在基于原型的 JavaScript 中，我们可以先创建一个 “动物” 对象作为原型，然后创建 “猫” 对象时，让它的原型指向 “动物” 对象，“猫” 对象就自然拥有了 “动物” 对象的属性和方法。</p>\n<h2 id=\"原型是啥，对象是如何产生的\"><a href=\"#原型是啥，对象是如何产生的\" class=\"headerlink\" title=\"原型是啥，对象是如何产生的\"></a>原型是啥，对象是如何产生的</h2><p>原型（Prototype） 其实就是一个普通的对象，它是其他对象的模板，被用于共享属性和方法。在 JavaScript 中，每个对象（除了null和undefined）都有一个与之关联的原型对象。</p>\n<p>那么对象是如何产生的呢？</p>\n<p>当我们使用new关键字调用构造函数时，会创建一个新的对象。这个新对象的原型会指向构造函数的prototype属性所指向的对象。</p>\n<p>例如，我们定义一个Person构造函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Person</span>(<span class=\"hljs-params\">name</span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>当我们通过 <code>new Person(&quot;张三&quot;)</code> 创建一个对象时，这个新对象的原型就是 <em>Person.prototype</em>。</p>\n<p>此外，我们还可以使用 <code>Object.create()</code> 方法来创建对象，这个方法会以传入的对象为原型来创建新的对象。比如 <code>Object.create(prototypeObj)</code>  创建的新对象，其原型就是 prototypeObj。</p>\n<h2 id=\"原型链的用处\"><a href=\"#原型链的用处\" class=\"headerlink\" title=\"原型链的用处\"></a>原型链的用处</h2><p>原型链（Prototype Chain） 是由对象的原型串联起来形成的链式结构。当我们访问一个对象的属性或方法时，如果该对象本身没有这个属性或方法，JavaScript 就会沿着原型链向上查找，直到找到该属性或方法，或者到达原型链的顶端（null）。</p>\n<p>原型链的用处和好处主要有以下几点：</p>\n<p><strong>实现继承</strong>：这是原型链最主要的作用。通过原型链，一个对象可以继承多个原型对象的属性和方法，实现了代码的复用。比如，子对象的原型指向父对象，子对象就可以使用父对象的属性和方法，当父对象的原型又指向其他对象时，就形成了更长的继承链。</p>\n<p><strong>节省内存空间</strong>：由于多个对象可以共享同一个原型对象的属性和方法，不需要为每个对象都重复定义这些属性和方法，大大节省了内存。例如，所有通过同一个构造函数创建的对象，都会共享该构造函数prototype对象中的方法，而不是每个对象都拥有一份独立的方法副本。</p>\n<p><strong>动态扩展属性和方法</strong>：我们可以在原型对象上动态地添加属性和方法，这些添加的属性和方法会立即被所有依赖该原型的对象所共享。比如，给 <code>Person.prototype</code> 添加一个 <code>sayHello</code> 方法，那么所有通过 <em>Person</em> 构造函数创建的对象都能立即使用这个 sayHello 方法。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>原型和原型链是 JavaScript 实现面向对象编程的核心机制，理解它们对于掌握 JavaScript 有着至关重要的意义。</p>\n<p>对于开发者而言，理解它们不仅是掌握 “继承”“内存优化” 等基础能力的关键，更是后续学习闭包、原型继承实战、甚至框架源码（如 Vue、React 中部分组件复用逻辑）的前提。</p>\n","excerpt":"","more":"<p>在 JavaScript 的世界里，原型和原型链是绕不开的核心概念，它们构建了 JS 独特的继承机制，也让许多开发者既好奇又头疼。今天我们就从几个关键角度，一起揭开它们的神秘面纱。</p>\n<h2 id=\"基于类与基于原型：两种不同的编程范式\"><a href=\"#基于类与基于原型：两种不同的编程范式\" class=\"headerlink\" title=\"基于类与基于原型：两种不同的编程范式\"></a>基于类与基于原型：两种不同的编程范式</h2><p>在传统的面向对象编程语言中，比如 Java、C++，<strong>基于类（Class-based）</strong> 是主流的编程思想。在这种范式里，类就像是一个模具，它定义了对象所具有的属性和方法，而对象则是类的实例。我们必须先定义好类，然后通过new关键字来创建该类的对象，对象之间的关系是通过类的继承来确立的。</p>\n<p>而 JavaScript 则不同，它采用的是<strong>基于原型（Prototype-based）</strong> 的编程范式。在这种模式下，并没有严格意义上的类的概念（虽然 ES6 引入了class语法，但这只是语法糖，底层依然是基于原型实现的）。对象可以直接从其他对象继承属性和方法，我们可以把原型看作是一个模板对象，新创建的对象会以这个模板为基础，共享它的属性和方法。</p>\n<p>举个简单的例子，在基于类的编程中，我们先定义一个 “动物” 类，规定动物有 “名字” 属性和 “移动” 方法，然后 “猫” 类继承 “动物” 类，再创建 “猫” 类的实例。而在基于原型的 JavaScript 中，我们可以先创建一个 “动物” 对象作为原型，然后创建 “猫” 对象时，让它的原型指向 “动物” 对象，“猫” 对象就自然拥有了 “动物” 对象的属性和方法。</p>\n<h2 id=\"原型是啥，对象是如何产生的\"><a href=\"#原型是啥，对象是如何产生的\" class=\"headerlink\" title=\"原型是啥，对象是如何产生的\"></a>原型是啥，对象是如何产生的</h2><p>原型（Prototype） 其实就是一个普通的对象，它是其他对象的模板，被用于共享属性和方法。在 JavaScript 中，每个对象（除了null和undefined）都有一个与之关联的原型对象。</p>\n<p>那么对象是如何产生的呢？</p>\n<p>当我们使用new关键字调用构造函数时，会创建一个新的对象。这个新对象的原型会指向构造函数的prototype属性所指向的对象。</p>\n<p>例如，我们定义一个Person构造函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Person</span>(<span class=\"hljs-params\">name</span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>当我们通过 <code>new Person(&quot;张三&quot;)</code> 创建一个对象时，这个新对象的原型就是 <em>Person.prototype</em>。</p>\n<p>此外，我们还可以使用 <code>Object.create()</code> 方法来创建对象，这个方法会以传入的对象为原型来创建新的对象。比如 <code>Object.create(prototypeObj)</code>  创建的新对象，其原型就是 prototypeObj。</p>\n<h2 id=\"原型链的用处\"><a href=\"#原型链的用处\" class=\"headerlink\" title=\"原型链的用处\"></a>原型链的用处</h2><p>原型链（Prototype Chain） 是由对象的原型串联起来形成的链式结构。当我们访问一个对象的属性或方法时，如果该对象本身没有这个属性或方法，JavaScript 就会沿着原型链向上查找，直到找到该属性或方法，或者到达原型链的顶端（null）。</p>\n<p>原型链的用处和好处主要有以下几点：</p>\n<p><strong>实现继承</strong>：这是原型链最主要的作用。通过原型链，一个对象可以继承多个原型对象的属性和方法，实现了代码的复用。比如，子对象的原型指向父对象，子对象就可以使用父对象的属性和方法，当父对象的原型又指向其他对象时，就形成了更长的继承链。</p>\n<p><strong>节省内存空间</strong>：由于多个对象可以共享同一个原型对象的属性和方法，不需要为每个对象都重复定义这些属性和方法，大大节省了内存。例如，所有通过同一个构造函数创建的对象，都会共享该构造函数prototype对象中的方法，而不是每个对象都拥有一份独立的方法副本。</p>\n<p><strong>动态扩展属性和方法</strong>：我们可以在原型对象上动态地添加属性和方法，这些添加的属性和方法会立即被所有依赖该原型的对象所共享。比如，给 <code>Person.prototype</code> 添加一个 <code>sayHello</code> 方法，那么所有通过 <em>Person</em> 构造函数创建的对象都能立即使用这个 sayHello 方法。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>原型和原型链是 JavaScript 实现面向对象编程的核心机制，理解它们对于掌握 JavaScript 有着至关重要的意义。</p>\n<p>对于开发者而言，理解它们不仅是掌握 “继承”“内存优化” 等基础能力的关键，更是后续学习闭包、原型继承实战、甚至框架源码（如 Vue、React 中部分组件复用逻辑）的前提。</p>\n"},{"title":"没想到！上周写证照小程序的博文火了","date":"2025-09-02T10:13:50.000Z","banner_img":"/imgs/wxprogram/微信小程序.png","index_img":"/imgs/wxprogram/微信小程序.png","_content":"\n\n\n最近后台收到好多朋友的留言，说刷到了我之前写的那篇关于证照制作小程序的文章（[传送门](https://www.cnblogs.com/jvxiao/p/19059712)），还跟着体验了小程序。\n\n说实话，看到文章突然 “火” 起来的时候，我第一反应是惊讶，紧接着就是满满的感动 —— 原来认真分享的东西，真的能被这么多人看见和需要。\n\n## 最意外的：被 “戳中” 的共鸣感\n\n一开始写这篇文章，只是想记录下自己用小程序拍证件照的惊喜体验。毕竟谁没经历过 “为了一张一寸照，请假跑照相馆，排队 1 小时、拍照 5 分钟，最后拿到的照片还不像自己” 的糟心时刻呢？\n\n没想到文章发出去后，评论区彻底 “炸” 了 —— 有朋友说 “我去, 好用啊 白花了25去照相馆换底色”，也有用户在小程序后台留言说“很好用，给老人办理证件的时候很方便”。看着这些留言，我突然明白：这篇文章能火，不是我写得有多好，而是它刚好戳中了大家对 “便捷生活工具” 的需求。原来我们都在期待：生活里那些琐碎的小事，能少一点麻烦，多一点省心。\n\n## 最实在的：小程序被 “看见” 的喜悦\n\n文章爆火后，最直接的变化就是小程序的用户量涨得特别快。后台数据显示，文章发完的第二天，就涌入了将近200的用户，其中绝大多数都是来自咱们园子(博客园)的朋友，非常感谢大家的支持。\n\n也有很多老哥在评论区和后台提了许多非常宝贵的建议，比如“涉及用户隐私的照片建议不做存储”，比如 “希望增加儿童证件照模板”—— 这些反馈不是冷冰冰的文字，而是实实在在的认可，也让我更有动力去优化功能。\n\n其实做这个小程序的初衷很简单：就是想让大家不用再为证件照 “折腾”。现在看到它真的能帮到这么多人，那种 “被需要” 的感觉，比任何流量都珍贵。\n\n\n## 最深刻的：科技该有的 “温度”\n\n回头想想，这篇文章和小程序的 “火”，其实也藏着一个小感悟：科技从来不是冷冰冰的代码，而是能解决实际问题的 “温暖工具”。\n\n以前提到 “证件照”，大家想到的都是传统照相馆 —— 固定的营业时间、有限的风格、不菲的价格。但这个小程序打破了这些限制：在家就能拍，手机上就能调整，几秒钟就能拿到符合标准的照片。它没有多复杂的技术，但刚好解决了 “时间紧、需求急、怕麻烦” 的痛点。\n\n这也让我明白：真正有价值的技术革新，不是追求多炫酷的功能，而是能贴近普通人的生活，把 “麻烦事” 变 “省事”。就像这个小程序，它或许不算什么 “大创新”，但能让老人少跑一趟路，让年轻人少请假一次，这就是它的意义。\n\n## 最后想说的：谢谢每一份 “看见”\n\n这段时间，看着文章的阅读量一点点涨，看着小程序被越来越多人使用，我最大的感受就是：很幸运，能做一个 “连接者”—— 把好用的工具分享给需要的人，也把大家的需求传递给开发团队，昂，开发团队就是我自己了。\n\n未来我还会继续分享这些 “能解决实际问题” 的生活工具和体验，也希望大家如果有什么使用心得或者建议，都可以在评论区告诉我～毕竟好的东西，需要我们一起打磨，一起让生活变得更省心呀～\n\n再次谢谢大家的喜欢和支持💛\n\n","source":"_posts/last-popular-article.md","raw":"---\ntitle: 没想到！上周写证照小程序的博文火了\ndate: 2025-09-02 18:13:50\ntags: 微信小程序\nbanner_img: /imgs/wxprogram/微信小程序.png\nindex_img: /imgs/wxprogram/微信小程序.png\n---\n\n\n\n最近后台收到好多朋友的留言，说刷到了我之前写的那篇关于证照制作小程序的文章（[传送门](https://www.cnblogs.com/jvxiao/p/19059712)），还跟着体验了小程序。\n\n说实话，看到文章突然 “火” 起来的时候，我第一反应是惊讶，紧接着就是满满的感动 —— 原来认真分享的东西，真的能被这么多人看见和需要。\n\n## 最意外的：被 “戳中” 的共鸣感\n\n一开始写这篇文章，只是想记录下自己用小程序拍证件照的惊喜体验。毕竟谁没经历过 “为了一张一寸照，请假跑照相馆，排队 1 小时、拍照 5 分钟，最后拿到的照片还不像自己” 的糟心时刻呢？\n\n没想到文章发出去后，评论区彻底 “炸” 了 —— 有朋友说 “我去, 好用啊 白花了25去照相馆换底色”，也有用户在小程序后台留言说“很好用，给老人办理证件的时候很方便”。看着这些留言，我突然明白：这篇文章能火，不是我写得有多好，而是它刚好戳中了大家对 “便捷生活工具” 的需求。原来我们都在期待：生活里那些琐碎的小事，能少一点麻烦，多一点省心。\n\n## 最实在的：小程序被 “看见” 的喜悦\n\n文章爆火后，最直接的变化就是小程序的用户量涨得特别快。后台数据显示，文章发完的第二天，就涌入了将近200的用户，其中绝大多数都是来自咱们园子(博客园)的朋友，非常感谢大家的支持。\n\n也有很多老哥在评论区和后台提了许多非常宝贵的建议，比如“涉及用户隐私的照片建议不做存储”，比如 “希望增加儿童证件照模板”—— 这些反馈不是冷冰冰的文字，而是实实在在的认可，也让我更有动力去优化功能。\n\n其实做这个小程序的初衷很简单：就是想让大家不用再为证件照 “折腾”。现在看到它真的能帮到这么多人，那种 “被需要” 的感觉，比任何流量都珍贵。\n\n\n## 最深刻的：科技该有的 “温度”\n\n回头想想，这篇文章和小程序的 “火”，其实也藏着一个小感悟：科技从来不是冷冰冰的代码，而是能解决实际问题的 “温暖工具”。\n\n以前提到 “证件照”，大家想到的都是传统照相馆 —— 固定的营业时间、有限的风格、不菲的价格。但这个小程序打破了这些限制：在家就能拍，手机上就能调整，几秒钟就能拿到符合标准的照片。它没有多复杂的技术，但刚好解决了 “时间紧、需求急、怕麻烦” 的痛点。\n\n这也让我明白：真正有价值的技术革新，不是追求多炫酷的功能，而是能贴近普通人的生活，把 “麻烦事” 变 “省事”。就像这个小程序，它或许不算什么 “大创新”，但能让老人少跑一趟路，让年轻人少请假一次，这就是它的意义。\n\n## 最后想说的：谢谢每一份 “看见”\n\n这段时间，看着文章的阅读量一点点涨，看着小程序被越来越多人使用，我最大的感受就是：很幸运，能做一个 “连接者”—— 把好用的工具分享给需要的人，也把大家的需求传递给开发团队，昂，开发团队就是我自己了。\n\n未来我还会继续分享这些 “能解决实际问题” 的生活工具和体验，也希望大家如果有什么使用心得或者建议，都可以在评论区告诉我～毕竟好的东西，需要我们一起打磨，一起让生活变得更省心呀～\n\n再次谢谢大家的喜欢和支持💛\n\n","slug":"last-popular-article","published":1,"updated":"2025-09-02T14:23:04.597Z","_id":"cmf2eym3l0000houpdoq9bgh8","comments":1,"layout":"post","photos":[],"content":"<p>最近后台收到好多朋友的留言，说刷到了我之前写的那篇关于证照制作小程序的文章（<a href=\"https://www.cnblogs.com/jvxiao/p/19059712\">传送门</a>），还跟着体验了小程序。</p>\n<p>说实话，看到文章突然 “火” 起来的时候，我第一反应是惊讶，紧接着就是满满的感动 —— 原来认真分享的东西，真的能被这么多人看见和需要。</p>\n<h2 id=\"最意外的：被-“戳中”-的共鸣感\"><a href=\"#最意外的：被-“戳中”-的共鸣感\" class=\"headerlink\" title=\"最意外的：被 “戳中” 的共鸣感\"></a>最意外的：被 “戳中” 的共鸣感</h2><p>一开始写这篇文章，只是想记录下自己用小程序拍证件照的惊喜体验。毕竟谁没经历过 “为了一张一寸照，请假跑照相馆，排队 1 小时、拍照 5 分钟，最后拿到的照片还不像自己” 的糟心时刻呢？</p>\n<p>没想到文章发出去后，评论区彻底 “炸” 了 —— 有朋友说 “我去, 好用啊 白花了25去照相馆换底色”，也有用户在小程序后台留言说“很好用，给老人办理证件的时候很方便”。看着这些留言，我突然明白：这篇文章能火，不是我写得有多好，而是它刚好戳中了大家对 “便捷生活工具” 的需求。原来我们都在期待：生活里那些琐碎的小事，能少一点麻烦，多一点省心。</p>\n<h2 id=\"最实在的：小程序被-“看见”-的喜悦\"><a href=\"#最实在的：小程序被-“看见”-的喜悦\" class=\"headerlink\" title=\"最实在的：小程序被 “看见” 的喜悦\"></a>最实在的：小程序被 “看见” 的喜悦</h2><p>文章爆火后，最直接的变化就是小程序的用户量涨得特别快。后台数据显示，文章发完的第二天，就涌入了将近200的用户，其中绝大多数都是来自咱们园子(博客园)的朋友，非常感谢大家的支持。</p>\n<p>也有很多老哥在评论区和后台提了许多非常宝贵的建议，比如“涉及用户隐私的照片建议不做存储”，比如 “希望增加儿童证件照模板”—— 这些反馈不是冷冰冰的文字，而是实实在在的认可，也让我更有动力去优化功能。</p>\n<p>其实做这个小程序的初衷很简单：就是想让大家不用再为证件照 “折腾”。现在看到它真的能帮到这么多人，那种 “被需要” 的感觉，比任何流量都珍贵。</p>\n<h2 id=\"最深刻的：科技该有的-“温度”\"><a href=\"#最深刻的：科技该有的-“温度”\" class=\"headerlink\" title=\"最深刻的：科技该有的 “温度”\"></a>最深刻的：科技该有的 “温度”</h2><p>回头想想，这篇文章和小程序的 “火”，其实也藏着一个小感悟：科技从来不是冷冰冰的代码，而是能解决实际问题的 “温暖工具”。</p>\n<p>以前提到 “证件照”，大家想到的都是传统照相馆 —— 固定的营业时间、有限的风格、不菲的价格。但这个小程序打破了这些限制：在家就能拍，手机上就能调整，几秒钟就能拿到符合标准的照片。它没有多复杂的技术，但刚好解决了 “时间紧、需求急、怕麻烦” 的痛点。</p>\n<p>这也让我明白：真正有价值的技术革新，不是追求多炫酷的功能，而是能贴近普通人的生活，把 “麻烦事” 变 “省事”。就像这个小程序，它或许不算什么 “大创新”，但能让老人少跑一趟路，让年轻人少请假一次，这就是它的意义。</p>\n<h2 id=\"最后想说的：谢谢每一份-“看见”\"><a href=\"#最后想说的：谢谢每一份-“看见”\" class=\"headerlink\" title=\"最后想说的：谢谢每一份 “看见”\"></a>最后想说的：谢谢每一份 “看见”</h2><p>这段时间，看着文章的阅读量一点点涨，看着小程序被越来越多人使用，我最大的感受就是：很幸运，能做一个 “连接者”—— 把好用的工具分享给需要的人，也把大家的需求传递给开发团队，昂，开发团队就是我自己了。</p>\n<p>未来我还会继续分享这些 “能解决实际问题” 的生活工具和体验，也希望大家如果有什么使用心得或者建议，都可以在评论区告诉我～毕竟好的东西，需要我们一起打磨，一起让生活变得更省心呀～</p>\n<p>再次谢谢大家的喜欢和支持💛</p>\n","excerpt":"","more":"<p>最近后台收到好多朋友的留言，说刷到了我之前写的那篇关于证照制作小程序的文章（<a href=\"https://www.cnblogs.com/jvxiao/p/19059712\">传送门</a>），还跟着体验了小程序。</p>\n<p>说实话，看到文章突然 “火” 起来的时候，我第一反应是惊讶，紧接着就是满满的感动 —— 原来认真分享的东西，真的能被这么多人看见和需要。</p>\n<h2 id=\"最意外的：被-“戳中”-的共鸣感\"><a href=\"#最意外的：被-“戳中”-的共鸣感\" class=\"headerlink\" title=\"最意外的：被 “戳中” 的共鸣感\"></a>最意外的：被 “戳中” 的共鸣感</h2><p>一开始写这篇文章，只是想记录下自己用小程序拍证件照的惊喜体验。毕竟谁没经历过 “为了一张一寸照，请假跑照相馆，排队 1 小时、拍照 5 分钟，最后拿到的照片还不像自己” 的糟心时刻呢？</p>\n<p>没想到文章发出去后，评论区彻底 “炸” 了 —— 有朋友说 “我去, 好用啊 白花了25去照相馆换底色”，也有用户在小程序后台留言说“很好用，给老人办理证件的时候很方便”。看着这些留言，我突然明白：这篇文章能火，不是我写得有多好，而是它刚好戳中了大家对 “便捷生活工具” 的需求。原来我们都在期待：生活里那些琐碎的小事，能少一点麻烦，多一点省心。</p>\n<h2 id=\"最实在的：小程序被-“看见”-的喜悦\"><a href=\"#最实在的：小程序被-“看见”-的喜悦\" class=\"headerlink\" title=\"最实在的：小程序被 “看见” 的喜悦\"></a>最实在的：小程序被 “看见” 的喜悦</h2><p>文章爆火后，最直接的变化就是小程序的用户量涨得特别快。后台数据显示，文章发完的第二天，就涌入了将近200的用户，其中绝大多数都是来自咱们园子(博客园)的朋友，非常感谢大家的支持。</p>\n<p>也有很多老哥在评论区和后台提了许多非常宝贵的建议，比如“涉及用户隐私的照片建议不做存储”，比如 “希望增加儿童证件照模板”—— 这些反馈不是冷冰冰的文字，而是实实在在的认可，也让我更有动力去优化功能。</p>\n<p>其实做这个小程序的初衷很简单：就是想让大家不用再为证件照 “折腾”。现在看到它真的能帮到这么多人，那种 “被需要” 的感觉，比任何流量都珍贵。</p>\n<h2 id=\"最深刻的：科技该有的-“温度”\"><a href=\"#最深刻的：科技该有的-“温度”\" class=\"headerlink\" title=\"最深刻的：科技该有的 “温度”\"></a>最深刻的：科技该有的 “温度”</h2><p>回头想想，这篇文章和小程序的 “火”，其实也藏着一个小感悟：科技从来不是冷冰冰的代码，而是能解决实际问题的 “温暖工具”。</p>\n<p>以前提到 “证件照”，大家想到的都是传统照相馆 —— 固定的营业时间、有限的风格、不菲的价格。但这个小程序打破了这些限制：在家就能拍，手机上就能调整，几秒钟就能拿到符合标准的照片。它没有多复杂的技术，但刚好解决了 “时间紧、需求急、怕麻烦” 的痛点。</p>\n<p>这也让我明白：真正有价值的技术革新，不是追求多炫酷的功能，而是能贴近普通人的生活，把 “麻烦事” 变 “省事”。就像这个小程序，它或许不算什么 “大创新”，但能让老人少跑一趟路，让年轻人少请假一次，这就是它的意义。</p>\n<h2 id=\"最后想说的：谢谢每一份-“看见”\"><a href=\"#最后想说的：谢谢每一份-“看见”\" class=\"headerlink\" title=\"最后想说的：谢谢每一份 “看见”\"></a>最后想说的：谢谢每一份 “看见”</h2><p>这段时间，看着文章的阅读量一点点涨，看着小程序被越来越多人使用，我最大的感受就是：很幸运，能做一个 “连接者”—— 把好用的工具分享给需要的人，也把大家的需求传递给开发团队，昂，开发团队就是我自己了。</p>\n<p>未来我还会继续分享这些 “能解决实际问题” 的生活工具和体验，也希望大家如果有什么使用心得或者建议，都可以在评论区告诉我～毕竟好的东西，需要我们一起打磨，一起让生活变得更省心呀～</p>\n<p>再次谢谢大家的喜欢和支持💛</p>\n"},{"title":"打破软件“收费”羞愧感，勇敢要钱","date":"2025-09-21T14:31:47.000Z","_content":"\n每个开发者大概都有个小梦想——做一款属于自己的软件，被很多人用，要是还能赚点钱就更好了。可现实是，不少好想法哪怕做成了产品，最后也难免中途夭折。原因五花八门，运营恰恰是很多开发者的短板；更现实的是“收益”问题——纯靠“爱发电”的项目能走多远，其实谁也说不准。\n\n我的小程序《豆豆证照工坊》上线半个多月后，我也遇上了这个难题。\n\n上周微信团队发消息说，我的云环境欠费了。一开始我以为这东西是免费的，后来才搞明白：小程序上线前，云环境对开发者是免费的；可一旦正式上线，就得开始付费了。\n\n登录后台一看，好家伙——两周的瑞幸咖啡钱直接没了，还没算那个每月19.9元的“穷鬼套餐”（基础版）。这哪儿是“爱发电”啊，分明是拿我的咖啡钱在发电。这下我不得不认真想了：软件得有收益，至少得能覆盖基础支出吧？\n\n纠结这事儿的时候，心里其实挺矛盾的。一方面，总希望自己花时间琢磨出来的产品，能被更多人喜欢、用上，还能帮到大家；可另一方面，“得靠收益支撑软件运行”的现实又摆在哪儿——每一次接口调用、图片处理、数据存储，都在消耗资源，总有人得为这些买单。\n\n纠结了好一阵，最后还是选了“要钱不要脸”——开始考虑收费。\n\n不过以前不管是学习还是生活里，遇到过不少简单的线上工具，非要注册、开会员才能用，我对这种收费模式一直很不感冒。所以“付费会员”这条路，我肯定不碰。毕竟“屠龙者终成恶龙”的事儿，不如一开始就别做。\n\n之前写文的评论区里，有网友提议可以在小程序里加赞赏功能，这个想法倒是点醒了我。这感觉像极了以前街头卖艺——“有钱的捧个钱场，没钱的捧个人场”，只不过现在这叫“开源精神”吧。\n\n接入赞赏的方式倒简单：用户点一下赞赏按钮，会弹出赞赏二维码，要么长按保存，要么截图存到手机里，再用微信扫一下就行。可问题是，小程序里没法直接长按识别赞赏码，整套流程一下就变繁琐了；更麻烦的是，还得下载图片、退出小程序去扫码——操作一中断，靠这种“收费”方式赚钱，概率实在太低了。\n\n既然赞赏太鸡肋，想稳定有笔收益，自然就得考虑加广告了。为了“吃相”好看点，直接在操作页面插广告的方式肯定排除——得保住用户用的时候的好体验。\n\n现在选的是激励广告：用户要是做一些耗资源多的操作（比如复杂的图片处理），就得看一次广告，相当于付了这次操作的“费”；除此之外的基础操作，全是免费的。这样既不影响大多数人的使用，也能勉强覆盖云服务的支出，算是目前最平衡的办法了。\n\n可即便选了激励广告，我心里其实还是没底——到底能不能真的覆盖掉每月的运营支出，谁也说不准。毕竟在国内，“免费使用软件”早就成了大家的默认习惯，不管是看几十秒广告，还是掏哪怕一块钱，只要沾了“付费”的边，都像在无形中“冒犯”用户——说不定人家眉头一皱，随手就把小程序关了，下次再也不会打开。\n\n这种担忧不是没道理。我自己刷手机时，要是遇到必须看广告才能用的功能，也会忍不住吐槽两句，有时候干脆换个工具。可即便知道可能会流失用户，我还是不想退回到“完全免费”的老路上去。\n\n倒不是我贪心，想靠这小程序赚多少钱，而是我始终觉得，一款真正成熟、能长久走下去的软件，不该只有“设计”和“开发”这两个环节。“盈利”其实是补上最后一块关键拼图——只有形成“设计-开发-盈利”的完整闭环，软件才不用一直靠我的“咖啡钱”贴补，才不用担心里程碑式的“欠费通知”，才能真的稳定地活下去，继续给需要的人解决证照处理的麻烦。\n\n哪怕最后每个月只赚一块钱，和“完全免费”比起来，也是天差地别的。那一块钱不是收益，更像一个小小的“认可信号”——说明有人觉得这个工具有用，愿意为它消耗的资源、为我花在上面的时间买单。这份认可，比单纯的“用户量”更让我踏实，也更能支撑我继续优化功能、解决bug，把它做得更顺手。\n\n我也知道，这种“想打破免费惯性”的想法，可能有点理想化，甚至会被人说“矫情”。但还是想试试——毕竟做《豆豆证照工坊》的初衷，从来不是“做个一次性的玩具”，而是希望它能真的帮到大家，并且能一直帮下去。如果这点小小的“收益闭环”，能让这个初衷实现，那就已经足够了。\n","source":"_posts/about-software-charges.md","raw":"---\ntitle: 打破软件“收费”羞愧感，勇敢要钱\ndate: 2025-09-21 22:31:47\ntags: 小程序\n---\n\n每个开发者大概都有个小梦想——做一款属于自己的软件，被很多人用，要是还能赚点钱就更好了。可现实是，不少好想法哪怕做成了产品，最后也难免中途夭折。原因五花八门，运营恰恰是很多开发者的短板；更现实的是“收益”问题——纯靠“爱发电”的项目能走多远，其实谁也说不准。\n\n我的小程序《豆豆证照工坊》上线半个多月后，我也遇上了这个难题。\n\n上周微信团队发消息说，我的云环境欠费了。一开始我以为这东西是免费的，后来才搞明白：小程序上线前，云环境对开发者是免费的；可一旦正式上线，就得开始付费了。\n\n登录后台一看，好家伙——两周的瑞幸咖啡钱直接没了，还没算那个每月19.9元的“穷鬼套餐”（基础版）。这哪儿是“爱发电”啊，分明是拿我的咖啡钱在发电。这下我不得不认真想了：软件得有收益，至少得能覆盖基础支出吧？\n\n纠结这事儿的时候，心里其实挺矛盾的。一方面，总希望自己花时间琢磨出来的产品，能被更多人喜欢、用上，还能帮到大家；可另一方面，“得靠收益支撑软件运行”的现实又摆在哪儿——每一次接口调用、图片处理、数据存储，都在消耗资源，总有人得为这些买单。\n\n纠结了好一阵，最后还是选了“要钱不要脸”——开始考虑收费。\n\n不过以前不管是学习还是生活里，遇到过不少简单的线上工具，非要注册、开会员才能用，我对这种收费模式一直很不感冒。所以“付费会员”这条路，我肯定不碰。毕竟“屠龙者终成恶龙”的事儿，不如一开始就别做。\n\n之前写文的评论区里，有网友提议可以在小程序里加赞赏功能，这个想法倒是点醒了我。这感觉像极了以前街头卖艺——“有钱的捧个钱场，没钱的捧个人场”，只不过现在这叫“开源精神”吧。\n\n接入赞赏的方式倒简单：用户点一下赞赏按钮，会弹出赞赏二维码，要么长按保存，要么截图存到手机里，再用微信扫一下就行。可问题是，小程序里没法直接长按识别赞赏码，整套流程一下就变繁琐了；更麻烦的是，还得下载图片、退出小程序去扫码——操作一中断，靠这种“收费”方式赚钱，概率实在太低了。\n\n既然赞赏太鸡肋，想稳定有笔收益，自然就得考虑加广告了。为了“吃相”好看点，直接在操作页面插广告的方式肯定排除——得保住用户用的时候的好体验。\n\n现在选的是激励广告：用户要是做一些耗资源多的操作（比如复杂的图片处理），就得看一次广告，相当于付了这次操作的“费”；除此之外的基础操作，全是免费的。这样既不影响大多数人的使用，也能勉强覆盖云服务的支出，算是目前最平衡的办法了。\n\n可即便选了激励广告，我心里其实还是没底——到底能不能真的覆盖掉每月的运营支出，谁也说不准。毕竟在国内，“免费使用软件”早就成了大家的默认习惯，不管是看几十秒广告，还是掏哪怕一块钱，只要沾了“付费”的边，都像在无形中“冒犯”用户——说不定人家眉头一皱，随手就把小程序关了，下次再也不会打开。\n\n这种担忧不是没道理。我自己刷手机时，要是遇到必须看广告才能用的功能，也会忍不住吐槽两句，有时候干脆换个工具。可即便知道可能会流失用户，我还是不想退回到“完全免费”的老路上去。\n\n倒不是我贪心，想靠这小程序赚多少钱，而是我始终觉得，一款真正成熟、能长久走下去的软件，不该只有“设计”和“开发”这两个环节。“盈利”其实是补上最后一块关键拼图——只有形成“设计-开发-盈利”的完整闭环，软件才不用一直靠我的“咖啡钱”贴补，才不用担心里程碑式的“欠费通知”，才能真的稳定地活下去，继续给需要的人解决证照处理的麻烦。\n\n哪怕最后每个月只赚一块钱，和“完全免费”比起来，也是天差地别的。那一块钱不是收益，更像一个小小的“认可信号”——说明有人觉得这个工具有用，愿意为它消耗的资源、为我花在上面的时间买单。这份认可，比单纯的“用户量”更让我踏实，也更能支撑我继续优化功能、解决bug，把它做得更顺手。\n\n我也知道，这种“想打破免费惯性”的想法，可能有点理想化，甚至会被人说“矫情”。但还是想试试——毕竟做《豆豆证照工坊》的初衷，从来不是“做个一次性的玩具”，而是希望它能真的帮到大家，并且能一直帮下去。如果这点小小的“收益闭环”，能让这个初衷实现，那就已经足够了。\n","slug":"about-software-charges","published":1,"updated":"2025-09-24T12:47:17.888Z","comments":1,"layout":"post","photos":[],"_id":"cmgrur9gi0000xwup1ka5e15h","content":"<p>每个开发者大概都有个小梦想——做一款属于自己的软件，被很多人用，要是还能赚点钱就更好了。可现实是，不少好想法哪怕做成了产品，最后也难免中途夭折。原因五花八门，运营恰恰是很多开发者的短板；更现实的是“收益”问题——纯靠“爱发电”的项目能走多远，其实谁也说不准。</p>\n<p>我的小程序《豆豆证照工坊》上线半个多月后，我也遇上了这个难题。</p>\n<p>上周微信团队发消息说，我的云环境欠费了。一开始我以为这东西是免费的，后来才搞明白：小程序上线前，云环境对开发者是免费的；可一旦正式上线，就得开始付费了。</p>\n<p>登录后台一看，好家伙——两周的瑞幸咖啡钱直接没了，还没算那个每月19.9元的“穷鬼套餐”（基础版）。这哪儿是“爱发电”啊，分明是拿我的咖啡钱在发电。这下我不得不认真想了：软件得有收益，至少得能覆盖基础支出吧？</p>\n<p>纠结这事儿的时候，心里其实挺矛盾的。一方面，总希望自己花时间琢磨出来的产品，能被更多人喜欢、用上，还能帮到大家；可另一方面，“得靠收益支撑软件运行”的现实又摆在哪儿——每一次接口调用、图片处理、数据存储，都在消耗资源，总有人得为这些买单。</p>\n<p>纠结了好一阵，最后还是选了“要钱不要脸”——开始考虑收费。</p>\n<p>不过以前不管是学习还是生活里，遇到过不少简单的线上工具，非要注册、开会员才能用，我对这种收费模式一直很不感冒。所以“付费会员”这条路，我肯定不碰。毕竟“屠龙者终成恶龙”的事儿，不如一开始就别做。</p>\n<p>之前写文的评论区里，有网友提议可以在小程序里加赞赏功能，这个想法倒是点醒了我。这感觉像极了以前街头卖艺——“有钱的捧个钱场，没钱的捧个人场”，只不过现在这叫“开源精神”吧。</p>\n<p>接入赞赏的方式倒简单：用户点一下赞赏按钮，会弹出赞赏二维码，要么长按保存，要么截图存到手机里，再用微信扫一下就行。可问题是，小程序里没法直接长按识别赞赏码，整套流程一下就变繁琐了；更麻烦的是，还得下载图片、退出小程序去扫码——操作一中断，靠这种“收费”方式赚钱，概率实在太低了。</p>\n<p>既然赞赏太鸡肋，想稳定有笔收益，自然就得考虑加广告了。为了“吃相”好看点，直接在操作页面插广告的方式肯定排除——得保住用户用的时候的好体验。</p>\n<p>现在选的是激励广告：用户要是做一些耗资源多的操作（比如复杂的图片处理），就得看一次广告，相当于付了这次操作的“费”；除此之外的基础操作，全是免费的。这样既不影响大多数人的使用，也能勉强覆盖云服务的支出，算是目前最平衡的办法了。</p>\n<p>可即便选了激励广告，我心里其实还是没底——到底能不能真的覆盖掉每月的运营支出，谁也说不准。毕竟在国内，“免费使用软件”早就成了大家的默认习惯，不管是看几十秒广告，还是掏哪怕一块钱，只要沾了“付费”的边，都像在无形中“冒犯”用户——说不定人家眉头一皱，随手就把小程序关了，下次再也不会打开。</p>\n<p>这种担忧不是没道理。我自己刷手机时，要是遇到必须看广告才能用的功能，也会忍不住吐槽两句，有时候干脆换个工具。可即便知道可能会流失用户，我还是不想退回到“完全免费”的老路上去。</p>\n<p>倒不是我贪心，想靠这小程序赚多少钱，而是我始终觉得，一款真正成熟、能长久走下去的软件，不该只有“设计”和“开发”这两个环节。“盈利”其实是补上最后一块关键拼图——只有形成“设计-开发-盈利”的完整闭环，软件才不用一直靠我的“咖啡钱”贴补，才不用担心里程碑式的“欠费通知”，才能真的稳定地活下去，继续给需要的人解决证照处理的麻烦。</p>\n<p>哪怕最后每个月只赚一块钱，和“完全免费”比起来，也是天差地别的。那一块钱不是收益，更像一个小小的“认可信号”——说明有人觉得这个工具有用，愿意为它消耗的资源、为我花在上面的时间买单。这份认可，比单纯的“用户量”更让我踏实，也更能支撑我继续优化功能、解决bug，把它做得更顺手。</p>\n<p>我也知道，这种“想打破免费惯性”的想法，可能有点理想化，甚至会被人说“矫情”。但还是想试试——毕竟做《豆豆证照工坊》的初衷，从来不是“做个一次性的玩具”，而是希望它能真的帮到大家，并且能一直帮下去。如果这点小小的“收益闭环”，能让这个初衷实现，那就已经足够了。</p>\n","excerpt":"","more":"<p>每个开发者大概都有个小梦想——做一款属于自己的软件，被很多人用，要是还能赚点钱就更好了。可现实是，不少好想法哪怕做成了产品，最后也难免中途夭折。原因五花八门，运营恰恰是很多开发者的短板；更现实的是“收益”问题——纯靠“爱发电”的项目能走多远，其实谁也说不准。</p>\n<p>我的小程序《豆豆证照工坊》上线半个多月后，我也遇上了这个难题。</p>\n<p>上周微信团队发消息说，我的云环境欠费了。一开始我以为这东西是免费的，后来才搞明白：小程序上线前，云环境对开发者是免费的；可一旦正式上线，就得开始付费了。</p>\n<p>登录后台一看，好家伙——两周的瑞幸咖啡钱直接没了，还没算那个每月19.9元的“穷鬼套餐”（基础版）。这哪儿是“爱发电”啊，分明是拿我的咖啡钱在发电。这下我不得不认真想了：软件得有收益，至少得能覆盖基础支出吧？</p>\n<p>纠结这事儿的时候，心里其实挺矛盾的。一方面，总希望自己花时间琢磨出来的产品，能被更多人喜欢、用上，还能帮到大家；可另一方面，“得靠收益支撑软件运行”的现实又摆在哪儿——每一次接口调用、图片处理、数据存储，都在消耗资源，总有人得为这些买单。</p>\n<p>纠结了好一阵，最后还是选了“要钱不要脸”——开始考虑收费。</p>\n<p>不过以前不管是学习还是生活里，遇到过不少简单的线上工具，非要注册、开会员才能用，我对这种收费模式一直很不感冒。所以“付费会员”这条路，我肯定不碰。毕竟“屠龙者终成恶龙”的事儿，不如一开始就别做。</p>\n<p>之前写文的评论区里，有网友提议可以在小程序里加赞赏功能，这个想法倒是点醒了我。这感觉像极了以前街头卖艺——“有钱的捧个钱场，没钱的捧个人场”，只不过现在这叫“开源精神”吧。</p>\n<p>接入赞赏的方式倒简单：用户点一下赞赏按钮，会弹出赞赏二维码，要么长按保存，要么截图存到手机里，再用微信扫一下就行。可问题是，小程序里没法直接长按识别赞赏码，整套流程一下就变繁琐了；更麻烦的是，还得下载图片、退出小程序去扫码——操作一中断，靠这种“收费”方式赚钱，概率实在太低了。</p>\n<p>既然赞赏太鸡肋，想稳定有笔收益，自然就得考虑加广告了。为了“吃相”好看点，直接在操作页面插广告的方式肯定排除——得保住用户用的时候的好体验。</p>\n<p>现在选的是激励广告：用户要是做一些耗资源多的操作（比如复杂的图片处理），就得看一次广告，相当于付了这次操作的“费”；除此之外的基础操作，全是免费的。这样既不影响大多数人的使用，也能勉强覆盖云服务的支出，算是目前最平衡的办法了。</p>\n<p>可即便选了激励广告，我心里其实还是没底——到底能不能真的覆盖掉每月的运营支出，谁也说不准。毕竟在国内，“免费使用软件”早就成了大家的默认习惯，不管是看几十秒广告，还是掏哪怕一块钱，只要沾了“付费”的边，都像在无形中“冒犯”用户——说不定人家眉头一皱，随手就把小程序关了，下次再也不会打开。</p>\n<p>这种担忧不是没道理。我自己刷手机时，要是遇到必须看广告才能用的功能，也会忍不住吐槽两句，有时候干脆换个工具。可即便知道可能会流失用户，我还是不想退回到“完全免费”的老路上去。</p>\n<p>倒不是我贪心，想靠这小程序赚多少钱，而是我始终觉得，一款真正成熟、能长久走下去的软件，不该只有“设计”和“开发”这两个环节。“盈利”其实是补上最后一块关键拼图——只有形成“设计-开发-盈利”的完整闭环，软件才不用一直靠我的“咖啡钱”贴补，才不用担心里程碑式的“欠费通知”，才能真的稳定地活下去，继续给需要的人解决证照处理的麻烦。</p>\n<p>哪怕最后每个月只赚一块钱，和“完全免费”比起来，也是天差地别的。那一块钱不是收益，更像一个小小的“认可信号”——说明有人觉得这个工具有用，愿意为它消耗的资源、为我花在上面的时间买单。这份认可，比单纯的“用户量”更让我踏实，也更能支撑我继续优化功能、解决bug，把它做得更顺手。</p>\n<p>我也知道，这种“想打破免费惯性”的想法，可能有点理想化，甚至会被人说“矫情”。但还是想试试——毕竟做《豆豆证照工坊》的初衷，从来不是“做个一次性的玩具”，而是希望它能真的帮到大家，并且能一直帮下去。如果这点小小的“收益闭环”，能让这个初衷实现，那就已经足够了。</p>\n"},{"title":"Web开发这些年：从“小油条”到“老油条”的成长之路。","date":"2025-10-15T10:14:30.000Z","_content":"做 Web 开发有些年头了，目前头发还算茂密，只是人已不再少年。​\n\n当年上班摸鱼都有负罪感的 “小油条”，如今也成了佛系的 “老油条”。​\n\n相似的业务代码写得越多，那种难以压抑的枯燥感就越强烈 —— 写这坨代码有什么用？像极了一个渣男，经历过一次次短暂的感情后，最终丢掉了最初初见佳人时的心动。​\n\n今天想简单聊聊个人能力提升那点事，以及自己是如何从 “小油条” 走到 “老油条” 这条路上的。​\n\n## 能力提升的两个关键期\n\n对于靠互联网开发谋生的程序员来说，我觉得有两个时期是个人能力提升的关键期。​\n\n### 初遇编程的 “热恋期”\n第一个关键期，自然是刚接触编程那会儿。对新事物的好奇，还有靠自己编程实现功能的喜悦，像磁石一样深深地吸引着你。\n\n想起自己刚开始做 Web 开发时，常常因为一些问题折腾到凌晨三四点。分析问题、上网查解决方案、修改验证，一遍又一遍。没有因一次次失败而沮丧，只有对一次次接近成功的欣喜。现在回想起来，都忍不住夸自己一句 “好小子”。​\n\n### 独挑项目的 “破茧期”\n第二个关键期，是需要独自负责一个项目开发的时候。2021 年去北京出差时，当时 Web 开发还处于 “炼气期” 的我，直接被甲方推上去负责一个项目的开发。那时候每天都特别焦虑 —— 没有外援帮忙，总怕把项目搞砸。所以白天赶业务进度，遇到问题先记下来，晚上再偷偷琢磨解决。那时候的状态，是既上进又心虚，总怕别人发现自己其实很 “菜”。​\n\n但随着项目慢慢进入收尾阶段，我不知不觉有了种顿悟的感觉 —— 人不焦虑了，遇到问题也不慌了，一股说不出的自信和踏实感涌上心头。​\n\n最意外的是，那个耗时两个多月的项目不仅如期交付，还在交付评估里拿了 A 评级。那天晚上甲方的庆功宴上，他们的一个测试领导大概是喝多了，搂着我脖子感慨：“多亏了你们啊！这项目总算过了，之前搞了两轮都没成……” 从那天起，我才算明白，这世界其实是个 “草台班子”。​\n\n## 成长的双重维度：能力与心态\n\n一个程序员的成长，主要体现在两个层面：能力和心态。​\n### 能力成长\n能力上的成长，能通过自学或参与项目开发获得 —— 只要人不懒、脑子还灵光，靠自己的努力，短时间内就能快速提升。关键是在学习和工作后要记录、思考、总结，形成自己的一套方法论，这样学新知识时才有方向，解决问题时也有思路。​\n\n### 心态成长\n心态上的成长，一方面依赖能力的提升，另一方面也受自身认知的影响。自己能力必须过硬，能完成开发任务、解决过程中遇到的问题，这是基本要求。要是能在技术上有点突破，那就更好了 —— 手里有 “刷子”，心里才踏实。​\n\n## 认知觉醒：走向 “老油条” 的起点\n至于认知，这一点老程序员比新手更有发言权。这世界真就是个 “草台班子”：你可以把一件事做得很完美，但没必要非追求完美。你觉得做得很烂的东西，别人说不定用得挺开心；你觉得自己做得很棒的东西，别人反倒觉得浮夸、没必要。​\n\n所以你会发现：公司里那些有想法、特别上进的，往往是想证明自己的新人；而老油条们，大多在一旁观望，盼着出点笑话。​\n\n而当你意识到这一点时，你就已经走在成为老油条的路上了。","source":"_posts/self-improve.md","raw":"---\ntitle: Web开发这些年：从“小油条”到“老油条”的成长之路。\ndate: 2025-10-15 18:14:30\ntags: 程序人生\n---\n做 Web 开发有些年头了，目前头发还算茂密，只是人已不再少年。​\n\n当年上班摸鱼都有负罪感的 “小油条”，如今也成了佛系的 “老油条”。​\n\n相似的业务代码写得越多，那种难以压抑的枯燥感就越强烈 —— 写这坨代码有什么用？像极了一个渣男，经历过一次次短暂的感情后，最终丢掉了最初初见佳人时的心动。​\n\n今天想简单聊聊个人能力提升那点事，以及自己是如何从 “小油条” 走到 “老油条” 这条路上的。​\n\n## 能力提升的两个关键期\n\n对于靠互联网开发谋生的程序员来说，我觉得有两个时期是个人能力提升的关键期。​\n\n### 初遇编程的 “热恋期”\n第一个关键期，自然是刚接触编程那会儿。对新事物的好奇，还有靠自己编程实现功能的喜悦，像磁石一样深深地吸引着你。\n\n想起自己刚开始做 Web 开发时，常常因为一些问题折腾到凌晨三四点。分析问题、上网查解决方案、修改验证，一遍又一遍。没有因一次次失败而沮丧，只有对一次次接近成功的欣喜。现在回想起来，都忍不住夸自己一句 “好小子”。​\n\n### 独挑项目的 “破茧期”\n第二个关键期，是需要独自负责一个项目开发的时候。2021 年去北京出差时，当时 Web 开发还处于 “炼气期” 的我，直接被甲方推上去负责一个项目的开发。那时候每天都特别焦虑 —— 没有外援帮忙，总怕把项目搞砸。所以白天赶业务进度，遇到问题先记下来，晚上再偷偷琢磨解决。那时候的状态，是既上进又心虚，总怕别人发现自己其实很 “菜”。​\n\n但随着项目慢慢进入收尾阶段，我不知不觉有了种顿悟的感觉 —— 人不焦虑了，遇到问题也不慌了，一股说不出的自信和踏实感涌上心头。​\n\n最意外的是，那个耗时两个多月的项目不仅如期交付，还在交付评估里拿了 A 评级。那天晚上甲方的庆功宴上，他们的一个测试领导大概是喝多了，搂着我脖子感慨：“多亏了你们啊！这项目总算过了，之前搞了两轮都没成……” 从那天起，我才算明白，这世界其实是个 “草台班子”。​\n\n## 成长的双重维度：能力与心态\n\n一个程序员的成长，主要体现在两个层面：能力和心态。​\n### 能力成长\n能力上的成长，能通过自学或参与项目开发获得 —— 只要人不懒、脑子还灵光，靠自己的努力，短时间内就能快速提升。关键是在学习和工作后要记录、思考、总结，形成自己的一套方法论，这样学新知识时才有方向，解决问题时也有思路。​\n\n### 心态成长\n心态上的成长，一方面依赖能力的提升，另一方面也受自身认知的影响。自己能力必须过硬，能完成开发任务、解决过程中遇到的问题，这是基本要求。要是能在技术上有点突破，那就更好了 —— 手里有 “刷子”，心里才踏实。​\n\n## 认知觉醒：走向 “老油条” 的起点\n至于认知，这一点老程序员比新手更有发言权。这世界真就是个 “草台班子”：你可以把一件事做得很完美，但没必要非追求完美。你觉得做得很烂的东西，别人说不定用得挺开心；你觉得自己做得很棒的东西，别人反倒觉得浮夸、没必要。​\n\n所以你会发现：公司里那些有想法、特别上进的，往往是想证明自己的新人；而老油条们，大多在一旁观望，盼着出点笑话。​\n\n而当你意识到这一点时，你就已经走在成为老油条的路上了。","slug":"self-improve","published":1,"updated":"2025-10-16T14:36:44.383Z","_id":"cmgrur9gp0002xwupfw3486h2","comments":1,"layout":"post","photos":[],"content":"<p>做 Web 开发有些年头了，目前头发还算茂密，只是人已不再少年。​</p>\n<p>当年上班摸鱼都有负罪感的 “小油条”，如今也成了佛系的 “老油条”。​</p>\n<p>相似的业务代码写得越多，那种难以压抑的枯燥感就越强烈 —— 写这坨代码有什么用？像极了一个渣男，经历过一次次短暂的感情后，最终丢掉了最初初见佳人时的心动。​</p>\n<p>今天想简单聊聊个人能力提升那点事，以及自己是如何从 “小油条” 走到 “老油条” 这条路上的。​</p>\n<h2 id=\"能力提升的两个关键期\"><a href=\"#能力提升的两个关键期\" class=\"headerlink\" title=\"能力提升的两个关键期\"></a>能力提升的两个关键期</h2><p>对于靠互联网开发谋生的程序员来说，我觉得有两个时期是个人能力提升的关键期。​</p>\n<h3 id=\"初遇编程的-“热恋期”\"><a href=\"#初遇编程的-“热恋期”\" class=\"headerlink\" title=\"初遇编程的 “热恋期”\"></a>初遇编程的 “热恋期”</h3><p>第一个关键期，自然是刚接触编程那会儿。对新事物的好奇，还有靠自己编程实现功能的喜悦，像磁石一样深深地吸引着你。</p>\n<p>想起自己刚开始做 Web 开发时，常常因为一些问题折腾到凌晨三四点。分析问题、上网查解决方案、修改验证，一遍又一遍。没有因一次次失败而沮丧，只有对一次次接近成功的欣喜。现在回想起来，都忍不住夸自己一句 “好小子”。​</p>\n<h3 id=\"独挑项目的-“破茧期”\"><a href=\"#独挑项目的-“破茧期”\" class=\"headerlink\" title=\"独挑项目的 “破茧期”\"></a>独挑项目的 “破茧期”</h3><p>第二个关键期，是需要独自负责一个项目开发的时候。2021 年去北京出差时，当时 Web 开发还处于 “炼气期” 的我，直接被甲方推上去负责一个项目的开发。那时候每天都特别焦虑 —— 没有外援帮忙，总怕把项目搞砸。所以白天赶业务进度，遇到问题先记下来，晚上再偷偷琢磨解决。那时候的状态，是既上进又心虚，总怕别人发现自己其实很 “菜”。​</p>\n<p>但随着项目慢慢进入收尾阶段，我不知不觉有了种顿悟的感觉 —— 人不焦虑了，遇到问题也不慌了，一股说不出的自信和踏实感涌上心头。​</p>\n<p>最意外的是，那个耗时两个多月的项目不仅如期交付，还在交付评估里拿了 A 评级。那天晚上甲方的庆功宴上，他们的一个测试领导大概是喝多了，搂着我脖子感慨：“多亏了你们啊！这项目总算过了，之前搞了两轮都没成……” 从那天起，我才算明白，这世界其实是个 “草台班子”。​</p>\n<h2 id=\"成长的双重维度：能力与心态\"><a href=\"#成长的双重维度：能力与心态\" class=\"headerlink\" title=\"成长的双重维度：能力与心态\"></a>成长的双重维度：能力与心态</h2><p>一个程序员的成长，主要体现在两个层面：能力和心态。​</p>\n<h3 id=\"能力成长\"><a href=\"#能力成长\" class=\"headerlink\" title=\"能力成长\"></a>能力成长</h3><p>能力上的成长，能通过自学或参与项目开发获得 —— 只要人不懒、脑子还灵光，靠自己的努力，短时间内就能快速提升。关键是在学习和工作后要记录、思考、总结，形成自己的一套方法论，这样学新知识时才有方向，解决问题时也有思路。​</p>\n<h3 id=\"心态成长\"><a href=\"#心态成长\" class=\"headerlink\" title=\"心态成长\"></a>心态成长</h3><p>心态上的成长，一方面依赖能力的提升，另一方面也受自身认知的影响。自己能力必须过硬，能完成开发任务、解决过程中遇到的问题，这是基本要求。要是能在技术上有点突破，那就更好了 —— 手里有 “刷子”，心里才踏实。​</p>\n<h2 id=\"认知觉醒：走向-“老油条”-的起点\"><a href=\"#认知觉醒：走向-“老油条”-的起点\" class=\"headerlink\" title=\"认知觉醒：走向 “老油条” 的起点\"></a>认知觉醒：走向 “老油条” 的起点</h2><p>至于认知，这一点老程序员比新手更有发言权。这世界真就是个 “草台班子”：你可以把一件事做得很完美，但没必要非追求完美。你觉得做得很烂的东西，别人说不定用得挺开心；你觉得自己做得很棒的东西，别人反倒觉得浮夸、没必要。​</p>\n<p>所以你会发现：公司里那些有想法、特别上进的，往往是想证明自己的新人；而老油条们，大多在一旁观望，盼着出点笑话。​</p>\n<p>而当你意识到这一点时，你就已经走在成为老油条的路上了。</p>\n","excerpt":"","more":"<p>做 Web 开发有些年头了，目前头发还算茂密，只是人已不再少年。​</p>\n<p>当年上班摸鱼都有负罪感的 “小油条”，如今也成了佛系的 “老油条”。​</p>\n<p>相似的业务代码写得越多，那种难以压抑的枯燥感就越强烈 —— 写这坨代码有什么用？像极了一个渣男，经历过一次次短暂的感情后，最终丢掉了最初初见佳人时的心动。​</p>\n<p>今天想简单聊聊个人能力提升那点事，以及自己是如何从 “小油条” 走到 “老油条” 这条路上的。​</p>\n<h2 id=\"能力提升的两个关键期\"><a href=\"#能力提升的两个关键期\" class=\"headerlink\" title=\"能力提升的两个关键期\"></a>能力提升的两个关键期</h2><p>对于靠互联网开发谋生的程序员来说，我觉得有两个时期是个人能力提升的关键期。​</p>\n<h3 id=\"初遇编程的-“热恋期”\"><a href=\"#初遇编程的-“热恋期”\" class=\"headerlink\" title=\"初遇编程的 “热恋期”\"></a>初遇编程的 “热恋期”</h3><p>第一个关键期，自然是刚接触编程那会儿。对新事物的好奇，还有靠自己编程实现功能的喜悦，像磁石一样深深地吸引着你。</p>\n<p>想起自己刚开始做 Web 开发时，常常因为一些问题折腾到凌晨三四点。分析问题、上网查解决方案、修改验证，一遍又一遍。没有因一次次失败而沮丧，只有对一次次接近成功的欣喜。现在回想起来，都忍不住夸自己一句 “好小子”。​</p>\n<h3 id=\"独挑项目的-“破茧期”\"><a href=\"#独挑项目的-“破茧期”\" class=\"headerlink\" title=\"独挑项目的 “破茧期”\"></a>独挑项目的 “破茧期”</h3><p>第二个关键期，是需要独自负责一个项目开发的时候。2021 年去北京出差时，当时 Web 开发还处于 “炼气期” 的我，直接被甲方推上去负责一个项目的开发。那时候每天都特别焦虑 —— 没有外援帮忙，总怕把项目搞砸。所以白天赶业务进度，遇到问题先记下来，晚上再偷偷琢磨解决。那时候的状态，是既上进又心虚，总怕别人发现自己其实很 “菜”。​</p>\n<p>但随着项目慢慢进入收尾阶段，我不知不觉有了种顿悟的感觉 —— 人不焦虑了，遇到问题也不慌了，一股说不出的自信和踏实感涌上心头。​</p>\n<p>最意外的是，那个耗时两个多月的项目不仅如期交付，还在交付评估里拿了 A 评级。那天晚上甲方的庆功宴上，他们的一个测试领导大概是喝多了，搂着我脖子感慨：“多亏了你们啊！这项目总算过了，之前搞了两轮都没成……” 从那天起，我才算明白，这世界其实是个 “草台班子”。​</p>\n<h2 id=\"成长的双重维度：能力与心态\"><a href=\"#成长的双重维度：能力与心态\" class=\"headerlink\" title=\"成长的双重维度：能力与心态\"></a>成长的双重维度：能力与心态</h2><p>一个程序员的成长，主要体现在两个层面：能力和心态。​</p>\n<h3 id=\"能力成长\"><a href=\"#能力成长\" class=\"headerlink\" title=\"能力成长\"></a>能力成长</h3><p>能力上的成长，能通过自学或参与项目开发获得 —— 只要人不懒、脑子还灵光，靠自己的努力，短时间内就能快速提升。关键是在学习和工作后要记录、思考、总结，形成自己的一套方法论，这样学新知识时才有方向，解决问题时也有思路。​</p>\n<h3 id=\"心态成长\"><a href=\"#心态成长\" class=\"headerlink\" title=\"心态成长\"></a>心态成长</h3><p>心态上的成长，一方面依赖能力的提升，另一方面也受自身认知的影响。自己能力必须过硬，能完成开发任务、解决过程中遇到的问题，这是基本要求。要是能在技术上有点突破，那就更好了 —— 手里有 “刷子”，心里才踏实。​</p>\n<h2 id=\"认知觉醒：走向-“老油条”-的起点\"><a href=\"#认知觉醒：走向-“老油条”-的起点\" class=\"headerlink\" title=\"认知觉醒：走向 “老油条” 的起点\"></a>认知觉醒：走向 “老油条” 的起点</h2><p>至于认知，这一点老程序员比新手更有发言权。这世界真就是个 “草台班子”：你可以把一件事做得很完美，但没必要非追求完美。你觉得做得很烂的东西，别人说不定用得挺开心；你觉得自己做得很棒的东西，别人反倒觉得浮夸、没必要。​</p>\n<p>所以你会发现：公司里那些有想法、特别上进的，往往是想证明自己的新人；而老油条们，大多在一旁观望，盼着出点笑话。​</p>\n<p>而当你意识到这一点时，你就已经走在成为老油条的路上了。</p>\n"},{"title":"程序员如何打破职业瓶颈？先搬开这3块绊脚石。","date":"2025-10-19T13:46:02.000Z","keywords":"程序人生","_content":"\n## 摆烂心态\n\n在一个程序员短暂的职业生涯中，真正能够得到提升的可能也就那么几年，而就是这么几年的经验，在一个大厂子里搬个砖户口，问题是不大的。\n\n从入职一家公司，从新人变成老油条，断则半年一年，长则两年。为什么不是更长时间呢？你觉得两年不给你涨工资，你还会在领导面前扮演奋斗逼吗？\n\n于是进入摆烂起，佛性的工作态度自然无法带来个人能力和技术上的提升，摆烂心态是造成个人能力瓶颈的一大原因。\n\n\n## 基础不牢，地动山摇\n\n“这个世界就是个草台班子”，这句话你永远可以相信。因为那些看似很牛逼的软件，可能都是几千块请来的外包仔（作者自己也是）写得，也不会想到一个代码里面建党的功能被写成10几个 `if else` 判断语句，又或者是3,4层嵌套的 `for` 循环。\n\n上班的本质是为了挣钱糊口，不是因为要学技术装X，反正最后我东西做成了不就行了。大多数本着这样想法的人，并没有什么错。\n\n可是如果自己明明技术一般般，还一天天说着自己到了瓶颈期，那多少有点让人贻笑大方了。\n\n现在的开发工作真就是搬砖，把砖头放在一个个已经搭好的框架上，比较基础的功能，已经全部通过脚手架实现了，不需要自己刀耕火种造轮子了。这样的开发方式给开发者带来了方便，对新手来说更是十分友好，属于有手就行那种。\n\n但给开发者带来了方便的同时，也弱化了开发者自己动手造轮子，写底层代码的能力。有些用Vue写页面写的飞起，用element-plus用的炉火纯青，可是需要写一个Vue指令，或者写一个Vite插件时却两眼空空，面露难色。\n\n说到底，终究是基础不够牢固，对一个框架，对一个工具的理解水平还停留在使用其中少数几个功能的水平，没有去了解其原理，也灭有尝试着对其功能进行模仿或者拓展。\n\n## 知识的混乱\n\n技术在不断地发展，新的框架，新的工具也重视层出不穷，作为开发者如果没有一套自己清晰的知识体系，那么将是一件很糟糕的事情。\n\n以web开发为例，需要学那些知识呢？最基础的三剑客JS, CSS, HTML, 然后是UI渲染框架Vue, React, Angluar, 打包工具Vite, Webpack, rollup。页面需要进行网络数据交互，那么http和tcp相关协议也得学，还有更复杂的浏览器原理...而这里，还只是冰山一角，这里面任何一样拿出来都能写成几本字典那么厚的书。\n\n学到东西多，感觉什么都懂一点，但深入理解又讲不出所以然，然后各种知识还相互串在了一起，脑子里知识很乱，像一团乱麻却找不到线头。而这种困惑，绝不是少数人才有的。\n\n衣服乱放，房间会乱，书本乱放，桌子会乱，知识乱发，那么脑子会乱。\n\n\n## 如何打破瓶颈期\n\n不管是什么原因陷入了所谓的瓶颈期，其实都应该尝试着走出来。\n\n如果是因为受了委屈，或者嫌钱给少了，在以摆烂的工作状态做一种沉默的抗争，其实没有必要的。与其在一个地方内耗，不如挪一挪，换个环境，换个心态。\n\n而基础不牢靠或者脑子里知识混乱，其实说来说去，其实还是一句，就是小老弟，你还得练。该看网课的去看网课，该看官网文档的看文档，该做梳理分类的做梳理分类。时间和努力付出去，改变自然会来。","source":"_posts/bottleneck-porid.md","raw":"---\ntitle: 程序员如何打破职业瓶颈？先搬开这3块绊脚石。\ndate: 2025-10-19 21:46:02\ntags: 程序人生\nkeywords: 程序人生\n---\n\n## 摆烂心态\n\n在一个程序员短暂的职业生涯中，真正能够得到提升的可能也就那么几年，而就是这么几年的经验，在一个大厂子里搬个砖户口，问题是不大的。\n\n从入职一家公司，从新人变成老油条，断则半年一年，长则两年。为什么不是更长时间呢？你觉得两年不给你涨工资，你还会在领导面前扮演奋斗逼吗？\n\n于是进入摆烂起，佛性的工作态度自然无法带来个人能力和技术上的提升，摆烂心态是造成个人能力瓶颈的一大原因。\n\n\n## 基础不牢，地动山摇\n\n“这个世界就是个草台班子”，这句话你永远可以相信。因为那些看似很牛逼的软件，可能都是几千块请来的外包仔（作者自己也是）写得，也不会想到一个代码里面建党的功能被写成10几个 `if else` 判断语句，又或者是3,4层嵌套的 `for` 循环。\n\n上班的本质是为了挣钱糊口，不是因为要学技术装X，反正最后我东西做成了不就行了。大多数本着这样想法的人，并没有什么错。\n\n可是如果自己明明技术一般般，还一天天说着自己到了瓶颈期，那多少有点让人贻笑大方了。\n\n现在的开发工作真就是搬砖，把砖头放在一个个已经搭好的框架上，比较基础的功能，已经全部通过脚手架实现了，不需要自己刀耕火种造轮子了。这样的开发方式给开发者带来了方便，对新手来说更是十分友好，属于有手就行那种。\n\n但给开发者带来了方便的同时，也弱化了开发者自己动手造轮子，写底层代码的能力。有些用Vue写页面写的飞起，用element-plus用的炉火纯青，可是需要写一个Vue指令，或者写一个Vite插件时却两眼空空，面露难色。\n\n说到底，终究是基础不够牢固，对一个框架，对一个工具的理解水平还停留在使用其中少数几个功能的水平，没有去了解其原理，也灭有尝试着对其功能进行模仿或者拓展。\n\n## 知识的混乱\n\n技术在不断地发展，新的框架，新的工具也重视层出不穷，作为开发者如果没有一套自己清晰的知识体系，那么将是一件很糟糕的事情。\n\n以web开发为例，需要学那些知识呢？最基础的三剑客JS, CSS, HTML, 然后是UI渲染框架Vue, React, Angluar, 打包工具Vite, Webpack, rollup。页面需要进行网络数据交互，那么http和tcp相关协议也得学，还有更复杂的浏览器原理...而这里，还只是冰山一角，这里面任何一样拿出来都能写成几本字典那么厚的书。\n\n学到东西多，感觉什么都懂一点，但深入理解又讲不出所以然，然后各种知识还相互串在了一起，脑子里知识很乱，像一团乱麻却找不到线头。而这种困惑，绝不是少数人才有的。\n\n衣服乱放，房间会乱，书本乱放，桌子会乱，知识乱发，那么脑子会乱。\n\n\n## 如何打破瓶颈期\n\n不管是什么原因陷入了所谓的瓶颈期，其实都应该尝试着走出来。\n\n如果是因为受了委屈，或者嫌钱给少了，在以摆烂的工作状态做一种沉默的抗争，其实没有必要的。与其在一个地方内耗，不如挪一挪，换个环境，换个心态。\n\n而基础不牢靠或者脑子里知识混乱，其实说来说去，其实还是一句，就是小老弟，你还得练。该看网课的去看网课，该看官网文档的看文档，该做梳理分类的做梳理分类。时间和努力付出去，改变自然会来。","slug":"bottleneck-porid","published":1,"updated":"2025-10-19T14:33:13.103Z","_id":"cmgxsofy60000w4upc4x9fnyc","comments":1,"layout":"post","photos":[],"content":"<h2 id=\"摆烂心态\"><a href=\"#摆烂心态\" class=\"headerlink\" title=\"摆烂心态\"></a>摆烂心态</h2><p>在一个程序员短暂的职业生涯中，真正能够得到提升的可能也就那么几年，而就是这么几年的经验，在一个大厂子里搬个砖户口，问题是不大的。</p>\n<p>从入职一家公司，从新人变成老油条，断则半年一年，长则两年。为什么不是更长时间呢？你觉得两年不给你涨工资，你还会在领导面前扮演奋斗逼吗？</p>\n<p>于是进入摆烂起，佛性的工作态度自然无法带来个人能力和技术上的提升，摆烂心态是造成个人能力瓶颈的一大原因。</p>\n<h2 id=\"基础不牢，地动山摇\"><a href=\"#基础不牢，地动山摇\" class=\"headerlink\" title=\"基础不牢，地动山摇\"></a>基础不牢，地动山摇</h2><p>“这个世界就是个草台班子”，这句话你永远可以相信。因为那些看似很牛逼的软件，可能都是几千块请来的外包仔（作者自己也是）写得，也不会想到一个代码里面建党的功能被写成10几个 <code>if else</code> 判断语句，又或者是3,4层嵌套的 <code>for</code> 循环。</p>\n<p>上班的本质是为了挣钱糊口，不是因为要学技术装X，反正最后我东西做成了不就行了。大多数本着这样想法的人，并没有什么错。</p>\n<p>可是如果自己明明技术一般般，还一天天说着自己到了瓶颈期，那多少有点让人贻笑大方了。</p>\n<p>现在的开发工作真就是搬砖，把砖头放在一个个已经搭好的框架上，比较基础的功能，已经全部通过脚手架实现了，不需要自己刀耕火种造轮子了。这样的开发方式给开发者带来了方便，对新手来说更是十分友好，属于有手就行那种。</p>\n<p>但给开发者带来了方便的同时，也弱化了开发者自己动手造轮子，写底层代码的能力。有些用Vue写页面写的飞起，用element-plus用的炉火纯青，可是需要写一个Vue指令，或者写一个Vite插件时却两眼空空，面露难色。</p>\n<p>说到底，终究是基础不够牢固，对一个框架，对一个工具的理解水平还停留在使用其中少数几个功能的水平，没有去了解其原理，也灭有尝试着对其功能进行模仿或者拓展。</p>\n<h2 id=\"知识的混乱\"><a href=\"#知识的混乱\" class=\"headerlink\" title=\"知识的混乱\"></a>知识的混乱</h2><p>技术在不断地发展，新的框架，新的工具也重视层出不穷，作为开发者如果没有一套自己清晰的知识体系，那么将是一件很糟糕的事情。</p>\n<p>以web开发为例，需要学那些知识呢？最基础的三剑客JS, CSS, HTML, 然后是UI渲染框架Vue, React, Angluar, 打包工具Vite, Webpack, rollup。页面需要进行网络数据交互，那么http和tcp相关协议也得学，还有更复杂的浏览器原理…而这里，还只是冰山一角，这里面任何一样拿出来都能写成几本字典那么厚的书。</p>\n<p>学到东西多，感觉什么都懂一点，但深入理解又讲不出所以然，然后各种知识还相互串在了一起，脑子里知识很乱，像一团乱麻却找不到线头。而这种困惑，绝不是少数人才有的。</p>\n<p>衣服乱放，房间会乱，书本乱放，桌子会乱，知识乱发，那么脑子会乱。</p>\n<h2 id=\"如何打破瓶颈期\"><a href=\"#如何打破瓶颈期\" class=\"headerlink\" title=\"如何打破瓶颈期\"></a>如何打破瓶颈期</h2><p>不管是什么原因陷入了所谓的瓶颈期，其实都应该尝试着走出来。</p>\n<p>如果是因为受了委屈，或者嫌钱给少了，在以摆烂的工作状态做一种沉默的抗争，其实没有必要的。与其在一个地方内耗，不如挪一挪，换个环境，换个心态。</p>\n<p>而基础不牢靠或者脑子里知识混乱，其实说来说去，其实还是一句，就是小老弟，你还得练。该看网课的去看网课，该看官网文档的看文档，该做梳理分类的做梳理分类。时间和努力付出去，改变自然会来。</p>\n","excerpt":"","more":"<h2 id=\"摆烂心态\"><a href=\"#摆烂心态\" class=\"headerlink\" title=\"摆烂心态\"></a>摆烂心态</h2><p>在一个程序员短暂的职业生涯中，真正能够得到提升的可能也就那么几年，而就是这么几年的经验，在一个大厂子里搬个砖户口，问题是不大的。</p>\n<p>从入职一家公司，从新人变成老油条，断则半年一年，长则两年。为什么不是更长时间呢？你觉得两年不给你涨工资，你还会在领导面前扮演奋斗逼吗？</p>\n<p>于是进入摆烂起，佛性的工作态度自然无法带来个人能力和技术上的提升，摆烂心态是造成个人能力瓶颈的一大原因。</p>\n<h2 id=\"基础不牢，地动山摇\"><a href=\"#基础不牢，地动山摇\" class=\"headerlink\" title=\"基础不牢，地动山摇\"></a>基础不牢，地动山摇</h2><p>“这个世界就是个草台班子”，这句话你永远可以相信。因为那些看似很牛逼的软件，可能都是几千块请来的外包仔（作者自己也是）写得，也不会想到一个代码里面建党的功能被写成10几个 <code>if else</code> 判断语句，又或者是3,4层嵌套的 <code>for</code> 循环。</p>\n<p>上班的本质是为了挣钱糊口，不是因为要学技术装X，反正最后我东西做成了不就行了。大多数本着这样想法的人，并没有什么错。</p>\n<p>可是如果自己明明技术一般般，还一天天说着自己到了瓶颈期，那多少有点让人贻笑大方了。</p>\n<p>现在的开发工作真就是搬砖，把砖头放在一个个已经搭好的框架上，比较基础的功能，已经全部通过脚手架实现了，不需要自己刀耕火种造轮子了。这样的开发方式给开发者带来了方便，对新手来说更是十分友好，属于有手就行那种。</p>\n<p>但给开发者带来了方便的同时，也弱化了开发者自己动手造轮子，写底层代码的能力。有些用Vue写页面写的飞起，用element-plus用的炉火纯青，可是需要写一个Vue指令，或者写一个Vite插件时却两眼空空，面露难色。</p>\n<p>说到底，终究是基础不够牢固，对一个框架，对一个工具的理解水平还停留在使用其中少数几个功能的水平，没有去了解其原理，也灭有尝试着对其功能进行模仿或者拓展。</p>\n<h2 id=\"知识的混乱\"><a href=\"#知识的混乱\" class=\"headerlink\" title=\"知识的混乱\"></a>知识的混乱</h2><p>技术在不断地发展，新的框架，新的工具也重视层出不穷，作为开发者如果没有一套自己清晰的知识体系，那么将是一件很糟糕的事情。</p>\n<p>以web开发为例，需要学那些知识呢？最基础的三剑客JS, CSS, HTML, 然后是UI渲染框架Vue, React, Angluar, 打包工具Vite, Webpack, rollup。页面需要进行网络数据交互，那么http和tcp相关协议也得学，还有更复杂的浏览器原理…而这里，还只是冰山一角，这里面任何一样拿出来都能写成几本字典那么厚的书。</p>\n<p>学到东西多，感觉什么都懂一点，但深入理解又讲不出所以然，然后各种知识还相互串在了一起，脑子里知识很乱，像一团乱麻却找不到线头。而这种困惑，绝不是少数人才有的。</p>\n<p>衣服乱放，房间会乱，书本乱放，桌子会乱，知识乱发，那么脑子会乱。</p>\n<h2 id=\"如何打破瓶颈期\"><a href=\"#如何打破瓶颈期\" class=\"headerlink\" title=\"如何打破瓶颈期\"></a>如何打破瓶颈期</h2><p>不管是什么原因陷入了所谓的瓶颈期，其实都应该尝试着走出来。</p>\n<p>如果是因为受了委屈，或者嫌钱给少了，在以摆烂的工作状态做一种沉默的抗争，其实没有必要的。与其在一个地方内耗，不如挪一挪，换个环境，换个心态。</p>\n<p>而基础不牢靠或者脑子里知识混乱，其实说来说去，其实还是一句，就是小老弟，你还得练。该看网课的去看网课，该看官网文档的看文档，该做梳理分类的做梳理分类。时间和努力付出去，改变自然会来。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cmb6cfzp200082wup6kkdbh2b","category_id":"cmc6bkbeh00009wup9dwxcteb","_id":"cmc6bkbej00019wupetl0f1i9"},{"post_id":"cmbkxc9p00001koupe3jv27tn","category_id":"cmcbtzcup00002gup8w90c81j","_id":"cmcbtzcux00022gupghekgn82"},{"post_id":"cmbf62vvl000duoup8jpg6zb0","category_id":"cmc6bkbeh00009wup9dwxcteb","_id":"cmcbtzcuy00052gup6p4jc3et"},{"post_id":"cmbmg2vsx0000loup2bgwc9c7","category_id":"cmc6bkbeh00009wup9dwxcteb","_id":"cmcbtzcuz00062gup2qfu8k77"},{"post_id":"cmb0qjkpr000250up21mk5ky1","category_id":"cmcbtzcuv00012gup1hcads2f","_id":"cmcbtzcv000092gupg9u1aiz1"},{"post_id":"cmc0k7zum0000iwupcmfjci7e","category_id":"cmc6bkbeh00009wup9dwxcteb","_id":"cmcbtzcv0000a2gup43jf4xjf"},{"post_id":"cmcbtzcuy00042gup8b7mgn4o","category_id":"cmcbtzcuv00012gup1hcads2f","_id":"cmcbtzcv0000b2gup81g91she"},{"post_id":"cmb0qjkps000350up5hzhbjyl","category_id":"cmcbtzcux00032gup1x8e8jv9","_id":"cmcbtzcv1000d2gupepjx726k"},{"post_id":"cmb0qjkpt000450upatq31y8w","category_id":"cmcbtzcuv00012gup1hcads2f","_id":"cmcbtzcv1000f2gup9bz0dfu0"},{"post_id":"cmbni3a1f0003loup86tygfqi","category_id":"cmcbtzcuv00012gup1hcads2f","_id":"cmcbtzcv2000g2gup2w4khx62"},{"post_id":"cmckk1h8m0000ioup68xi86ww","category_id":"cmcbtzcuv00012gup1hcads2f","_id":"cmckk1h8t0004ioup20dx49pn"},{"post_id":"cmckk1h8m0000ioup68xi86ww","category_id":"cmckk1h8s0002ioup5v5243m1","_id":"cmckk1h8u0006ioupc83r0vw1"},{"post_id":"cmcxijx4a0000o8upd07525ju","category_id":"cmcbtzcuv00012gup1hcads2f","_id":"cmcxijx4l0002o8upb7jl0nzu"},{"post_id":"cmckl78fc0000s8up55z65s6r","category_id":"cmcbtzcuv00012gup1hcads2f","_id":"cmcxijx4o0008o8updu4edmvt"},{"post_id":"cmd79bx86000018up16wx4uvn","category_id":"cmcbtzcuv00012gup1hcads2f","_id":"cmdq1j89t0001voupfnx40z51"},{"post_id":"cmdq1j89v0004voupf7ygdrql","category_id":"cmcbtzcuv00012gup1hcads2f","_id":"cmdq1j89x0006voup3858cv2o"}],"PostTag":[{"post_id":"cmb6cfzp200082wup6kkdbh2b","tag_id":"cmb6cfzp300092wup9fpwexjc","_id":"cmb6cfzp3000b2wup6mt74cq0"},{"post_id":"cmb6cfzp200082wup6kkdbh2b","tag_id":"cmb6cfzp3000a2wup8g2385yb","_id":"cmb6cfzp4000c2wupea9s5kb8"},{"post_id":"cmb0qjkps000350up5hzhbjyl","tag_id":"cmbf62vvg0003uoup2o7zedgq","_id":"cmbf62vvh0009uoup72ef6c3z"},{"post_id":"cmb0qjkps000350up5hzhbjyl","tag_id":"cmbf62vvh0006uoup0d5m5abw","_id":"cmbf62vvh000auoup9dav49pj"},{"post_id":"cmb0qjkps000350up5hzhbjyl","tag_id":"cmbf62vvh0008uoup48omfr5u","_id":"cmbf62vvh000buoupabscd2mo"},{"post_id":"cmbf62vvl000duoup8jpg6zb0","tag_id":"cmb6cfzp300092wup9fpwexjc","_id":"cmbf62vvm000fuoupcdjedekl"},{"post_id":"cmbf62vvl000duoup8jpg6zb0","tag_id":"cmb6cfzp3000a2wup8g2385yb","_id":"cmbf62vvm000guoupbnc40kqn"},{"post_id":"cmb0qjkpt000450upatq31y8w","tag_id":"cmbf62vvk000cuoup58no4wg9","_id":"cmbf62vvm000iuoupd0c6aile"},{"post_id":"cmb0qjkpt000450upatq31y8w","tag_id":"cmbf62vvl000euoup01xd6gv8","_id":"cmbf62vvm000juoupeao4b54n"},{"post_id":"cmb0qjkpt000450upatq31y8w","tag_id":"cmbf62vvm000huoup9pzoe7pi","_id":"cmbf62vvm000kuoupg4w76bop"},{"post_id":"cmbkxc9ov0000koup1mpldhh3","tag_id":"cmb6cfzoz00002wupdyqs1vk1","_id":"cmbkxc9p20002koup31h77j44"},{"post_id":"cmbkxc9ov0000koup1mpldhh3","tag_id":"cmb6cfzp000012wupag44c8zo","_id":"cmbkxc9p20003kouph363203r"},{"post_id":"cmbkxc9ov0000koup1mpldhh3","tag_id":"cmb6cfzp100022wup8md954bi","_id":"cmbkxc9p20004koupe1p669ck"},{"post_id":"cmbkxc9ov0000koup1mpldhh3","tag_id":"cmb6cfzp100032wup85ts5je3","_id":"cmbkxc9p20005koup22a5dk71"},{"post_id":"cmbkxc9p00001koupe3jv27tn","tag_id":"cmbf62vve0000uoup3ixh4wp3","_id":"cmbkxc9p30006koupbykufueq"},{"post_id":"cmbkxc9p00001koupe3jv27tn","tag_id":"cmbf62vvg0001uoupb5206syj","_id":"cmbkxc9p30007koup7jwv0x9u"},{"post_id":"cmbkxc9p00001koupe3jv27tn","tag_id":"cmbf62vvg0002uoupdhpb5dtb","_id":"cmbkxc9p30008kouperbk499s"},{"post_id":"cmbmg2vsx0000loup2bgwc9c7","tag_id":"cmb6cfzp300092wup9fpwexjc","_id":"cmbmg2vsy0001loup9kl45x79"},{"post_id":"cmbmg2vsx0000loup2bgwc9c7","tag_id":"cmb6cfzp3000a2wup8g2385yb","_id":"cmbmg2vsy0002loup4c9lak8v"},{"post_id":"cmbni3a1f0003loup86tygfqi","tag_id":"cmbnpx65w0000h4upb6wi0i49","_id":"cmbnpx65x0002h4upcnqvhpz2"},{"post_id":"cmbni3a1f0003loup86tygfqi","tag_id":"cmbnpx65x0001h4upcb4re4cb","_id":"cmbnpx65y0003h4upfrjm2brz"},{"post_id":"cmc0k7zum0000iwupcmfjci7e","tag_id":"cmb6cfzp300092wup9fpwexjc","_id":"cmc0k7zuq0001iwup7m363e06"},{"post_id":"cmc0k7zum0000iwupcmfjci7e","tag_id":"cmb6cfzp3000a2wup8g2385yb","_id":"cmc0k7zuq0002iwup69df77p0"},{"post_id":"cmcbtzcuy00042gup8b7mgn4o","tag_id":"cmbf62vve0000uoup3ixh4wp3","_id":"cmcbtzcv0000c2gupenojh3y0"},{"post_id":"cmcbtzcuy00042gup8b7mgn4o","tag_id":"cmcbtzcuz00082gup0v4i7zk2","_id":"cmcbtzcv1000e2gup0hw41yn7"},{"post_id":"cmcexlrxm0000bcupenyp0yis","tag_id":"cmcexlrxp0002bcupamhsgwl8","_id":"cmcexlrxq0004bcup33uc9hjq"},{"post_id":"cmckk1h8m0000ioup68xi86ww","tag_id":"cmckk1h8q0001ioup9kw52rrn","_id":"cmckk1h8u0007ioup87on1p55"},{"post_id":"cmckk1h8m0000ioup68xi86ww","tag_id":"cmckk1h8t0003ioup81h67c3q","_id":"cmckk1h8u0008ioupbgkebiwe"},{"post_id":"cmckk1h8m0000ioup68xi86ww","tag_id":"cmckk1h8u0005ioup85mfglxq","_id":"cmckk1h8u0009ioup21154a92"},{"post_id":"cmcexlrxm0000bcupenyp0yis","tag_id":"cmckkbnr7000aioup8pl9a7q7","_id":"cmckkbnr8000cioup22i7dwzf"},{"post_id":"cmcexlrxm0000bcupenyp0yis","tag_id":"cmckkbnr7000bioup63p16rj7","_id":"cmckkbnr8000dioupgo4w99xl"},{"post_id":"cmcxijx4a0000o8upd07525ju","tag_id":"cmcxijx4i0001o8upgqd95tn5","_id":"cmcxijx4m0004o8uphost9q3h"},{"post_id":"cmcxijx4a0000o8upd07525ju","tag_id":"cmbf62vve0000uoup3ixh4wp3","_id":"cmcxijx4m0005o8up2v2o2crm"},{"post_id":"cmcxijx4a0000o8upd07525ju","tag_id":"cmcxijx4l0003o8up5twy07iq","_id":"cmcxijx4m0006o8updn6rgirq"},{"post_id":"cmckl78fc0000s8up55z65s6r","tag_id":"cmcxijx4n0007o8up6qm9aql6","_id":"cmcxijx4o000ao8upa6lq0efz"},{"post_id":"cmckl78fc0000s8up55z65s6r","tag_id":"cmcxijx4o0009o8upe7ebdy1f","_id":"cmcxijx4o000bo8upgbwtbecn"},{"post_id":"cmckl78fc0000s8up55z65s6r","tag_id":"cmbf62vve0000uoup3ixh4wp3","_id":"cmcxijx4o000co8updmkecqqb"},{"post_id":"cmd79bx86000018up16wx4uvn","tag_id":"cmdq1j89q0000voup0gsic5ls","_id":"cmdq1j89t0002voupcbe535ek"},{"post_id":"cmd79bx86000018up16wx4uvn","tag_id":"cmckkbnr7000bioup63p16rj7","_id":"cmdq1j89t0003voup9il807dp"},{"post_id":"cmdq1j89v0004voupf7ygdrql","tag_id":"cmdq1j89w0005voup8sceekfx","_id":"cmdq1j89x0007voupa5c972gc"},{"post_id":"cmebfg7xx0001nsuphr99cws6","tag_id":"cmbf62vve0000uoup3ixh4wp3","_id":"cmebfg7y10003nsup6edmbfbk"},{"post_id":"cmebfg7xx0001nsuphr99cws6","tag_id":"cmebfg7xz0002nsup7y6290uh","_id":"cmebfg7y10004nsup4mytdqvp"},{"post_id":"cmebfg7xu0000nsup2536f2xd","tag_id":"cmeptkpqb00004cupal41e4ym","_id":"cmeptkpqf00014cup3hkwfome"},{"post_id":"cmeptkpqg00024cup0zgz4asn","tag_id":"cmeptp2eo00034cupg68o3zzd","_id":"cmeptp2eo00044cup7wo28yho"},{"post_id":"cmer7zcuk0000rcupbi070nis","tag_id":"cmer7zcum0001rcup2ouh57tm","_id":"cmer7zcuq0003rcup9bhs9kqo"},{"post_id":"cmer7zcuk0000rcupbi070nis","tag_id":"cmer7zcup0002rcup5kc8bqmu","_id":"cmer7zcuq0004rcup8ksm767y"},{"post_id":"cmf2eym3l0000houpdoq9bgh8","tag_id":"cmeptp2eo00034cupg68o3zzd","_id":"cmf2f8vik0001houp46gsd2tz"},{"post_id":"cmgrur9gi0000xwup1ka5e15h","tag_id":"cmbf62vvg0003uoup2o7zedgq","_id":"cmgrur9gp0001xwupg4ej5bb8"},{"post_id":"cmgrur9gp0002xwupfw3486h2","tag_id":"cmgruvwfr0003xwupbdywbcfh","_id":"cmgruvwfs0004xwup93us4xoa"},{"post_id":"cmgxsofy60000w4upc4x9fnyc","tag_id":"cmgruvwfr0003xwupbdywbcfh","_id":"cmgxsofye0001w4upfsqodxcz"}],"Tag":[{"name":"Javascript","_id":"cmb6cfzoz00002wupdyqs1vk1"},{"name":"Array","_id":"cmb6cfzp000012wupag44c8zo"},{"name":"Set","_id":"cmb6cfzp100022wup8md954bi"},{"name":"Map","_id":"cmb6cfzp100032wup85ts5je3"},{"name":"博客搭建","_id":"cmb6cfzp300092wup9fpwexjc"},{"name":"个人IP","_id":"cmb6cfzp3000a2wup8g2385yb"},{"name":"Vue","_id":"cmbf62vve0000uoup3ixh4wp3"},{"name":"源码阅读","_id":"cmbf62vvg0001uoupb5206syj"},{"name":"依赖收集","_id":"cmbf62vvg0002uoupdhpb5dtb"},{"name":"小程序","_id":"cmbf62vvg0003uoup2o7zedgq"},{"name":"微信云","_id":"cmbf62vvh0006uoup0d5m5abw"},{"name":"对象存储","_id":"cmbf62vvh0008uoup48omfr5u"},{"name":"Vite","_id":"cmbf62vvk000cuoup58no4wg9"},{"name":"Proxy","_id":"cmbf62vvl000euoup01xd6gv8"},{"name":"error","_id":"cmbf62vvm000huoup9pzoe7pi"},{"name":"Node安装","_id":"cmbnpx65w0000h4upb6wi0i49"},{"name":"npm","_id":"cmbnpx65x0001h4upcb4re4cb"},{"name":"组件","_id":"cmcbtzcuz00082gup0v4i7zk2"},{"name":"Web开发，Node","_id":"cmcexlrxn0001bcup7uj2bqen"},{"name":"packages","_id":"cmcexlrxp0002bcupamhsgwl8"},{"name":"Cookie","_id":"cmckk1h8q0001ioup9kw52rrn"},{"name":"Session","_id":"cmckk1h8t0003ioup81h67c3q"},{"name":"Token","_id":"cmckk1h8u0005ioup85mfglxq"},{"name":"Web开发","_id":"cmckkbnr7000aioup8pl9a7q7"},{"name":"Node","_id":"cmckkbnr7000bioup63p16rj7"},{"name":"Web开发，JQuery","_id":"cmcxijx4i0001o8upgqd95tn5"},{"name":"MVVM","_id":"cmcxijx4l0003o8up5twy07iq"},{"name":"Vuex","_id":"cmcxijx4n0007o8up6qm9aql6"},{"name":"Pinia","_id":"cmcxijx4o0009o8upe7ebdy1f"},{"name":"守护进程","_id":"cmdq1j89q0000voup0gsic5ls"},{"name":"前端开发","_id":"cmdq1j89w0005voup8sceekfx"},{"name":"React","_id":"cmebfg7xz0002nsup7y6290uh"},{"name":"闭包，作用域","_id":"cmeptkpqb00004cupal41e4ym"},{"name":"微信小程序","_id":"cmeptp2eo00034cupg68o3zzd"},{"name":"JavaScript","_id":"cmer7zcum0001rcup2ouh57tm"},{"name":"前端进阶","_id":"cmer7zcup0002rcup5kc8bqmu"},{"name":"程序人生","_id":"cmgruvwfr0003xwupbdywbcfh"}]}}