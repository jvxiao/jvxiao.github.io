{"meta":{"version":1,"warehouse":"5.0.1"},"models":{"Asset":[{"_id":"themes/fluid/source/css/custom.css","path":"css/custom.css","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/drawn.jpg","path":"img/drawn.jpg","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/fluid.png","path":"img/fluid.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/favicon.jpg","path":"img/favicon.jpg","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/boot.js","path":"js/boot.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/wild-fire.jpg","path":"img/wild-fire.jpg","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/events.js","path":"js/events.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/plugins.js","path":"js/plugins.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/umami-view.js","path":"js/umami-view.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"source/BingSiteAuth.xml","path":"BingSiteAuth.xml","modified":0,"renderable":0},{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"source/b9845fe647a6579b4eb9925de54a5832.txt","path":"b9845fe647a6579b4eb9925de54a5832.txt","modified":0,"renderable":0},{"_id":"source/baidu_verify_codeva-fVR3SShMVh.html","path":"baidu_verify_codeva-fVR3SShMVh.html","modified":0,"renderable":0},{"_id":"source/robots.txt","path":"robots.txt","modified":0,"renderable":0},{"_id":"source/imgs/logo.png","path":"imgs/logo.png","modified":0,"renderable":0},{"_id":"source/imgs/logo2.jpg","path":"imgs/logo2.jpg","modified":0,"renderable":0},{"_id":"source/imgs/logo3.png","path":"imgs/logo3.png","modified":0,"renderable":0},{"_id":"source/imgs/微信云对象存储..png","path":"imgs/微信云对象存储..png","modified":0,"renderable":0},{"_id":"source/imgs/bad-code/en.jfif","path":"imgs/bad-code/en.jfif","modified":0,"renderable":0},{"_id":"source/imgs/build-blog1/blog1.jpg","path":"imgs/build-blog1/blog1.jpg","modified":0,"renderable":0},{"_id":"source/imgs/build-blog1/blog2.jpg","path":"imgs/build-blog1/blog2.jpg","modified":0,"renderable":0},{"_id":"source/imgs/build-blog1/blog3.jpg","path":"imgs/build-blog1/blog3.jpg","modified":0,"renderable":0},{"_id":"source/imgs/build-blog1/blog4.jpg","path":"imgs/build-blog1/blog4.jpg","modified":0,"renderable":0},{"_id":"source/imgs/build-blog1/blog6.jpg","path":"imgs/build-blog1/blog6.jpg","modified":0,"renderable":0},{"_id":"source/imgs/build-blog1/blog5.jpg","path":"imgs/build-blog1/blog5.jpg","modified":0,"renderable":0},{"_id":"source/imgs/build-blog1/step1.png","path":"imgs/build-blog1/step1.png","modified":0,"renderable":0},{"_id":"source/imgs/baners/break.jfif","path":"imgs/baners/break.jfif","modified":0,"renderable":0},{"_id":"source/imgs/baners/cash.jpg","path":"imgs/baners/cash.jpg","modified":0,"renderable":0},{"_id":"source/imgs/baners/coding.jfif","path":"imgs/baners/coding.jfif","modified":0,"renderable":0},{"_id":"source/imgs/baners/glasses.jfif","path":"imgs/baners/glasses.jfif","modified":0,"renderable":0},{"_id":"source/imgs/baners/node.png","path":"imgs/baners/node.png","modified":0,"renderable":0},{"_id":"source/imgs/baners/numpy-in-node.jfif","path":"imgs/baners/numpy-in-node.jfif","modified":0,"renderable":0},{"_id":"source/imgs/baners/pinia.png","path":"imgs/baners/pinia.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/Node-folder.png","path":"imgs/build-blog3/Node-folder.png","modified":0,"renderable":0},{"_id":"source/imgs/baners/security.jfif","path":"imgs/baners/security.jfif","modified":0,"renderable":0},{"_id":"source/imgs/baners/team.jfif","path":"imgs/baners/team.jfif","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/Node2.png","path":"imgs/build-blog3/Node2.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/Node1.png","path":"imgs/build-blog3/Node1.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/Node4.png","path":"imgs/build-blog3/Node4.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/Node3.png","path":"imgs/build-blog3/Node3.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/Node5.png","path":"imgs/build-blog3/Node5.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/environment1.png","path":"imgs/build-blog3/environment1.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/NodeSite.png","path":"imgs/build-blog3/NodeSite.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/environment3.png","path":"imgs/build-blog3/environment3.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/environment2.png","path":"imgs/build-blog3/environment2.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/environment4.png","path":"imgs/build-blog3/environment4.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/hexo.png","path":"imgs/build-blog3/hexo.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/landscape.png","path":"imgs/build-blog3/landscape.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/environment5.png","path":"imgs/build-blog3/environment5.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/md2html.png","path":"imgs/build-blog3/md2html.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/site-generator.png","path":"imgs/build-blog3/site-generator.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog4/actions.png","path":"imgs/build-blog4/actions.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/step2.png","path":"imgs/build-blog3/step2.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/site-generator2.png","path":"imgs/build-blog3/site-generator2.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blogs2/my-sit.png","path":"imgs/build-blogs2/my-sit.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blog3/success.png","path":"imgs/build-blog3/success.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blogs2/step1.png","path":"imgs/build-blogs2/step1.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blogs2/step2.png","path":"imgs/build-blogs2/step2.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blogs2/step3.png","path":"imgs/build-blogs2/step3.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blogs2/step5.png","path":"imgs/build-blogs2/step5.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blogs2/step4.png","path":"imgs/build-blogs2/step4.png","modified":0,"renderable":0},{"_id":"source/imgs/closure/closure.png","path":"imgs/closure/closure.png","modified":0,"renderable":0},{"_id":"source/imgs/closure/example.png","path":"imgs/closure/example.png","modified":0,"renderable":0},{"_id":"source/imgs/build-blogs2/step6.png","path":"imgs/build-blogs2/step6.png","modified":0,"renderable":0},{"_id":"source/imgs/daemon/640.jfif","path":"imgs/daemon/640.jfif","modified":0,"renderable":0},{"_id":"source/imgs/daemon/logs.png","path":"imgs/daemon/logs.png","modified":0,"renderable":0},{"_id":"source/imgs/daemon/success.png","path":"imgs/daemon/success.png","modified":0,"renderable":0},{"_id":"source/imgs/daemon/panel.png","path":"imgs/daemon/panel.png","modified":0,"renderable":0},{"_id":"source/imgs/feature-of-fe/code.jpg","path":"imgs/feature-of-fe/code.jpg","modified":0,"renderable":0},{"_id":"source/imgs/prototype/banner.png","path":"imgs/prototype/banner.png","modified":0,"renderable":0},{"_id":"source/imgs/feature-of-fe/design.jpg","path":"imgs/feature-of-fe/design.jpg","modified":0,"renderable":0},{"_id":"source/imgs/feature-of-fe/lang.jpeg","path":"imgs/feature-of-fe/lang.jpeg","modified":0,"renderable":0},{"_id":"source/imgs/feature-of-fe/tauri.png","path":"imgs/feature-of-fe/tauri.png","modified":0,"renderable":0},{"_id":"source/imgs/react-vs-vue/learning-curves.jpg","path":"imgs/react-vs-vue/learning-curves.jpg","modified":0,"renderable":0},{"_id":"source/imgs/react-vs-vue/react-typescript.png","path":"imgs/react-vs-vue/react-typescript.png","modified":0,"renderable":0},{"_id":"source/imgs/react-vs-vue/react-vs-vue.png","path":"imgs/react-vs-vue/react-vs-vue.png","modified":0,"renderable":0},{"_id":"source/imgs/react-vs-vue/state.png","path":"imgs/react-vs-vue/state.png","modified":0,"renderable":0},{"_id":"source/imgs/react-vs-vue/vue-sfc.png","path":"imgs/react-vs-vue/vue-sfc.png","modified":0,"renderable":0},{"_id":"source/imgs/storage/guide1.png","path":"imgs/storage/guide1.png","modified":0,"renderable":0},{"_id":"source/imgs/storage/guide2.png","path":"imgs/storage/guide2.png","modified":0,"renderable":0},{"_id":"source/imgs/storage/guide3.png","path":"imgs/storage/guide3.png","modified":0,"renderable":0},{"_id":"source/imgs/wxprogram/code.png","path":"imgs/wxprogram/code.png","modified":0,"renderable":0},{"_id":"source/imgs/storage/guide5.png","path":"imgs/storage/guide5.png","modified":0,"renderable":0},{"_id":"source/imgs/storage/guide4.png","path":"imgs/storage/guide4.png","modified":0,"renderable":0},{"_id":"source/imgs/wxprogram/guide.png","path":"imgs/wxprogram/guide.png","modified":0,"renderable":0},{"_id":"source/imgs/wxprogram/home.png","path":"imgs/wxprogram/home.png","modified":0,"renderable":0},{"_id":"source/imgs/web-history/CSS.png","path":"imgs/web-history/CSS.png","modified":0,"renderable":0},{"_id":"source/imgs/wxprogram/result.png","path":"imgs/wxprogram/result.png","modified":0,"renderable":0},{"_id":"source/imgs/wxprogram/微信小程序.png","path":"imgs/wxprogram/微信小程序.png","modified":0,"renderable":0},{"_id":"source/imgs/web-history/Javascript.png","path":"imgs/web-history/Javascript.png","modified":0,"renderable":0},{"_id":"source/imgs/web-history/PHP.png","path":"imgs/web-history/PHP.png","modified":0,"renderable":0},{"_id":"source/imgs/web-history/Jquery.png","path":"imgs/web-history/Jquery.png","modified":0,"renderable":0},{"_id":"source/imgs/web-history/TIM.png","path":"imgs/web-history/TIM.png","modified":0,"renderable":0},{"_id":"source/imgs/web-history/Vue.png","path":"imgs/web-history/Vue.png","modified":0,"renderable":0},{"_id":"source/imgs/web-history/first-web.jpg","path":"imgs/web-history/first-web.jpg","modified":0,"renderable":0},{"_id":"source/imgs/web-history/mvvm.jpg","path":"imgs/web-history/mvvm.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/BingSiteAuth.xml","hash":"f2d151fb6d0d33ba6f3085c226173a069f7a44b3","modified":1749822925946},{"_id":"source/CNAME","hash":"d675053c77f7d0d901b00e800fba6471d1083778","modified":1766053258099},{"_id":"source/b9845fe647a6579b4eb9925de54a5832.txt","hash":"0c0d17b5ae2a2d38d7f2816c34c3fcfa428905cd","modified":1749811078175},{"_id":"source/baidu_verify_codeva-fVR3SShMVh.html","hash":"09e554351f969b229ae91d76101bae10651bb03e","modified":1749313095823},{"_id":"source/robots.txt","hash":"6b7a2f0efb2c683cc187a15d7116e0512abb49db","modified":1750166927517},{"_id":"source/_posts/Array-set-map-summary.md","hash":"36e53f01c4d0cd6b6f8100879302ebfe2f5f4ab4","modified":1749313095823},{"_id":"source/_posts/Dependencies-collecting-of-vue3.md","hash":"23b30f23d8950924b3dfa2568d14c149070e6c19","modified":1750515344943},{"_id":"source/_posts/Manage-wx-could-service.md","hash":"2d53f528712b111a646a8f086e2d277023b925af","modified":1750515404677},{"_id":"source/_posts/Differences-between-two-kinds-inherit-approches.md","hash":"ac525492c30241456bdf98946b0da402d8962c4d","modified":1750515374913},{"_id":"source/_posts/Vite-server-error.md","hash":"c07a5fa240f0986d682e67da5e09ff77c8ee50e8","modified":1750515416740},{"_id":"source/_posts/about-software-charges.md","hash":"cff0db2a17d1d45f2a39930b09727115330d7cba","modified":1761659186985},{"_id":"source/_posts/array-in-es6.md","hash":"6475293042568da1b31940b00f082537442b2819","modified":1764996461765},{"_id":"source/_posts/bidirection-data-binding.md","hash":"4a2fe31b9e99d74ac97c392ea355129dd67a20d1","modified":1764996461769},{"_id":"source/_posts/bottleneck-porid.md","hash":"034ddf53d8abe37cc847d82c91d579c1a5db0d4d","modified":1761658883261},{"_id":"source/_posts/break-out-of-the-cocoon.md","hash":"60600e00637fd5debbe14b9be9cf5a2b1b62e6ff","modified":1761658915016},{"_id":"source/_posts/build-personal-blog-1.md","hash":"ce1e4de8c412297c576cd57c7d7176dca36c69fc","modified":1756203276206},{"_id":"source/_posts/build-personal-blog2.md","hash":"9da5d15d9544b126b0b9b65a60c6d66a457ce3e7","modified":1756203322050},{"_id":"source/_posts/build-personal-blog3.md","hash":"989f6947aeb5f8bcb14772358d02fd20b8d82a2b","modified":1756203397605},{"_id":"source/_posts/build-personal-blog4.md","hash":"c4f720bdb45a455c3bbd6b1e5f409054ca62daca","modified":1756203472503},{"_id":"source/_posts/closure.md","hash":"bc69c16db68ce3948a59d970ed35c396e12883b4","modified":1756204460653},{"_id":"source/_posts/component-versatility.md","hash":"6548e5262592a0b0dc432a842b988e97dc5792c5","modified":1756205485343},{"_id":"source/_posts/cookie-session-token.md","hash":"ceac46ba870ee8f5bd0ada36220dbc9452ef4a07","modified":1756205245358},{"_id":"source/_posts/create-daemond-with-node.md","hash":"18c4cf9e0a6aecf22e40e24812499153c95f738a","modified":1756204878347},{"_id":"source/_posts/decorator-in-es6.md","hash":"9bec6d1f1a1cad511f90df604eb411dac84bb856","modified":1764996461769},{"_id":"source/_posts/from-vuex-to-pinia.md","hash":"995019992999e361529a41b1f5edc091736d40d5","modified":1756205094544},{"_id":"source/_posts/function-in-es6.md","hash":"5d291e383a547b9a26b307c4e546dbbd1670df18","modified":1764996461765},{"_id":"source/_posts/future-of-front-end-development.md","hash":"7ce24098e6119da7bf32085d8f4b626ecf91bb6d","modified":1756204573808},{"_id":"source/_posts/generator-in-es6.md","hash":"cb52c0bf5e48bacc3e13f360fe6f566e1367c666","modified":1764996461768},{"_id":"source/_posts/install-node.md","hash":"41e1e34333830887130fab76207628f597e1d6b7","modified":1756205527157},{"_id":"source/_posts/last-popular-article.md","hash":"8f0c2368d05d833bc7f0521f6c4c16c9687cb60e","modified":1756822984597},{"_id":"source/_posts/my-first-miniprogram.md","hash":"71ab8e3f7a5633c3fe8423140ecafca32d710c63","modified":1756204372772},{"_id":"source/_posts/node-numpy.md","hash":"9cb5abc87e2e9ad12548b4b4f2b8011c0a6cced9","modified":1756205323926},{"_id":"source/_posts/module-in-es6.md","hash":"43455a59e2a0773ff03f7e67eef12d5bfba79bfe","modified":1764996461769},{"_id":"source/_posts/object-in-es6.md","hash":"2cb9b6b0747ced84892136955ecfc0060436ec93","modified":1764996461765},{"_id":"source/_posts/prototype-in-js.md","hash":"d7f4463d1486301b788a591210080e13dacbefbb","modified":1756203659250},{"_id":"source/_posts/promise-in-es6.md","hash":"f695b11d3109f45f1ecf47f2773efc32f3d2688e","modified":1764996461768},{"_id":"source/_posts/proxy-in-es6.md","hash":"6bc0cf8186be857ecb8c96fa43e37dc031fd5560","modified":1764996461768},{"_id":"source/_posts/self-improve.md","hash":"46a3420aa2b3dd8887b8652209f6018f32bf4474","modified":1761658900182},{"_id":"source/_posts/set-map.md","hash":"0b1bacec60b210ab1d25927ecc7e9761574f80e5","modified":1764996461766},{"_id":"source/_posts/vue-vs-react.md","hash":"b12d3a8f811217caa903995f595df553d27e461a","modified":1756204484957},{"_id":"source/_posts/web-history.md","hash":"94ee3ef8b8058ef6045c14bd14c22181c6f3abf6","modified":1756204979644},{"_id":"source/about/index.md","hash":"364ec52c99b2cc1874316e9ae5da6d564fd88671","modified":1750168462433},{"_id":"source/_posts/what-is-vue.md","hash":"520ba70cfb3c552fafc4b9f35903afe40dc73fec","modified":1764996442735},{"_id":"source/imgs/logo2.jpg","hash":"43db145f370066b409657f6cbc72066b9a80ab9b","modified":1754793304886},{"_id":"source/imgs/bad-code/en.jfif","hash":"188a8854a6bc25f91bd11fdafc4c0e1677facce3","modified":1750860915463},{"_id":"source/imgs/微信云对象存储..png","hash":"7b056d08b21247c00d5cbd834717fb39d98cb9ec","modified":1749313095918},{"_id":"source/imgs/baners/numpy-in-node.jfif","hash":"e8608b8747d462372f6408d9a50520611cdfd1d6","modified":1756205300972},{"_id":"source/imgs/baners/security.jfif","hash":"50868db14ab1cace7811692132c9f5a528600ce1","modified":1756205192630},{"_id":"source/imgs/baners/team.jfif","hash":"7d1bdd0f22c5f4b5bed862053a7dc3d6d557057e","modified":1756205453672},{"_id":"source/imgs/build-blog3/Node1.png","hash":"591ef5e5fdb097108293f893a631501931e67b38","modified":1749478196238},{"_id":"source/imgs/build-blog3/Node2.png","hash":"614523f08d105749081b439f647461a137fcbc6c","modified":1749478196242},{"_id":"source/imgs/build-blog3/Node3.png","hash":"97193904adddd2b64a742b36d4ac28052fc68117","modified":1749478196242},{"_id":"source/imgs/build-blog3/Node4.png","hash":"f5c3cfad516dd22e56ed076181feb8fc1366e8b8","modified":1749478196242},{"_id":"source/imgs/build-blog3/Node5.png","hash":"3fd0511638d580b100a713ea6113195f798fb71e","modified":1749478196242},{"_id":"source/imgs/build-blog3/hexo.png","hash":"24ab106e07dc9e398585bb6cc8a97e0bf835524c","modified":1749478196258},{"_id":"source/imgs/build-blog3/step2.png","hash":"f5f6e40335355783484b68f65af0084e8e24673d","modified":1749478196270},{"_id":"source/imgs/build-blog3/success.png","hash":"bf98fd9d229170cf98f0bc36a997df939a60c894","modified":1749478196270},{"_id":"source/imgs/closure/example.png","hash":"39c4e640211ae404aff09e786f4eaabaeafd111e","modified":1755177199407},{"_id":"source/imgs/build-blogs2/step6.png","hash":"86d9ba02ef7752faa3e24aaef96077948158029e","modified":1749313095918},{"_id":"source/imgs/daemon/logs.png","hash":"a52b8162631181b06240065140b18a2fd151af7b","modified":1752676512894},{"_id":"source/imgs/daemon/success.png","hash":"3705a479ee1f7732005745010fdb932d5770bccb","modified":1752676334367},{"_id":"source/imgs/feature-of-fe/lang.jpeg","hash":"842a2fac1442e1bc153b9ce382dc7199cbbb2ef6","modified":1753802527737},{"_id":"source/imgs/react-vs-vue/state.png","hash":"476d3196cc29af23a0d9d622ce0276b93b8419ac","modified":1754812127803},{"_id":"source/imgs/storage/guide1.png","hash":"40063f5727247047c17e15278db7cd9d8676ec16","modified":1755524462497},{"_id":"source/imgs/react-vs-vue/vue-sfc.png","hash":"2f9c75b3df25cf3b39aa238fc638e4c87210f3fe","modified":1754812007972},{"_id":"source/imgs/storage/guide2.png","hash":"d22bc8b48c052328c915ceedf3197f2ecad7c421","modified":1755524478343},{"_id":"source/imgs/storage/guide3.png","hash":"bb0e7b63867574111fbf56c272f1a9c120dd8091","modified":1755524495773},{"_id":"source/imgs/storage/guide5.png","hash":"5352338be3c9d037db61f06f85012f237a33bc2e","modified":1755524526328},{"_id":"source/imgs/storage/guide4.png","hash":"ca818923e0710d7dce22a4b9efd7fe132554a5ef","modified":1755524510231},{"_id":"source/imgs/web-history/Javascript.png","hash":"bb5ce5f403fa84dc917e67c5e8bcef99d847c55a","modified":1752130958000},{"_id":"source/imgs/web-history/Jquery.png","hash":"7eeff8a957fa4310749a0539f1d4c5171d70bac6","modified":1752130958000},{"_id":"source/imgs/web-history/Vue.png","hash":"31ee1ee2bf2549c94e49fcb2bd0973e6fd22e983","modified":1752130958000},{"_id":"source/imgs/web-history/mvvm.jpg","hash":"f93e7beac9c523011765dbc86c30ecdbcda749ef","modified":1752130958000},{"_id":"source/imgs/baners/break.jfif","hash":"c99285c6ef719f8f5db36d6ed772ea1851b0a331","modified":1761658806861},{"_id":"source/imgs/baners/coding.jfif","hash":"8e832b534d5788e44270338592bf61694dc83ee9","modified":1761058838926},{"_id":"source/imgs/baners/glasses.jfif","hash":"75ca71a7e436791902096bd361c367fd3aa40475","modified":1761658824148},{"_id":"source/imgs/build-blog3/environment3.png","hash":"b781ebc267a5f2356718ed7cc4d69bf0ddf50a95","modified":1749478196254},{"_id":"source/imgs/build-blog3/environment4.png","hash":"dba3ff701e1101b3176a524b82561ab581c391d5","modified":1749478196254},{"_id":"source/imgs/baners/pinia.png","hash":"8cb6221ba32b09859f0dbd0b7aa63237790b0c5f","modified":1756205075751},{"_id":"source/imgs/build-blog3/environment2.png","hash":"6742c24212564b134aa4450dab74360bdd581832","modified":1749478196254},{"_id":"source/imgs/build-blog3/environment5.png","hash":"00b40562694443e0b0be7303a9c8bac4e92ef0d0","modified":1749478196258},{"_id":"source/imgs/build-blog3/md2html.png","hash":"7c7eae0c82cb87699e3540c85d07454ff1a1668f","modified":1749478196262},{"_id":"source/imgs/build-blogs2/step3.png","hash":"2b02a0b60c175b40b26bcab15a4ced3b98cf3e0b","modified":1749313095918},{"_id":"source/imgs/daemon/640.jfif","hash":"5404707c6f2e2394dd6262503c827b464fa7d14d","modified":1756204838017},{"_id":"source/imgs/daemon/panel.png","hash":"dbb9bcdc3ce3e1dd68cd00a895cb6eb9682a56fc","modified":1752676664056},{"_id":"source/imgs/react-vs-vue/learning-curves.jpg","hash":"a96e5d140b329ef4d315be86bfdcc5fef61bc74b","modified":1754812249178},{"_id":"source/imgs/wxprogram/home.png","hash":"f64667e8ed97af94d71caae78ced11a04eb627db","modified":1755781406325},{"_id":"source/imgs/wxprogram/微信小程序.png","hash":"85328f753a67e28325e1238116d58dc4196b3b55","modified":1755782493793},{"_id":"source/imgs/build-blog3/Node-folder.png","hash":"ffde5efeff9f43940e304e0ddb41359d9ca5a669","modified":1749478196238},{"_id":"source/imgs/build-blog3/site-generator.png","hash":"ac0ac0acf6baf61cd8f4f1e7224a9a073b7487cc","modified":1749478196266},{"_id":"source/imgs/build-blogs2/step2.png","hash":"d3986fd605c513604b613b33fffe08558b533cc2","modified":1749313095912},{"_id":"source/imgs/build-blog4/actions.png","hash":"1b70af9d8e9d18633673ce52232de076a1183c5c","modified":1749998280512},{"_id":"source/imgs/build-blogs2/step4.png","hash":"29c14be4e9e80b8635d499750f5194cfa6b5acd2","modified":1749313095918},{"_id":"source/imgs/build-blogs2/step5.png","hash":"a5c84254c295a7d601e0018ac4b3037099f606d3","modified":1749313095918},{"_id":"source/imgs/react-vs-vue/react-typescript.png","hash":"ffb5e383ec31e82b598f2f36958bed31043f2dcc","modified":1754812163909},{"_id":"source/imgs/wxprogram/guide.png","hash":"9abb5734938fc9d2b9f22441fb1cbbb903bda3d5","modified":1755781468570},{"_id":"source/imgs/web-history/PHP.png","hash":"ddc971427b31f16b2849c5ef365cd5783b6e8e60","modified":1752130958000},{"_id":"source/imgs/web-history/first-web.jpg","hash":"0385aea7f11a5bd36064b023be7db33446bee564","modified":1752130958000},{"_id":"source/imgs/build-blog3/site-generator2.png","hash":"fd7f96858fa44b04a3889a70128f060f51a8f5d7","modified":1749478196270},{"_id":"source/imgs/build-blogs2/step1.png","hash":"db8d892d97fbc6980c201f5ec38a3f7a24bd85c3","modified":1749313095912},{"_id":"source/imgs/wxprogram/code.png","hash":"957787d277d208385220438a53f8fa20a78bef86","modified":1755782305966},{"_id":"source/imgs/wxprogram/result.png","hash":"575adc55fd5bcbe6b43fd4c235720eda36a763c4","modified":1755781585939},{"_id":"themes/fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1748000395387},{"_id":"source/imgs/build-blog3/NodeSite.png","hash":"f329461b13550c1d5250051abb17f8f86dbb525d","modified":1749478196246},{"_id":"source/imgs/baners/cash.jpg","hash":"680f80d7dd5bafa9d1395324b363683688124c38","modified":1761659112317},{"_id":"source/imgs/build-blog1/blog5.jpg","hash":"9bee4e5c47c165fe9d6398bc7c1da75a9d94b730","modified":1749313095875},{"_id":"themes/fluid/.gitattributes","hash":"3e00e1fb043438cd820d94ee3dc9ffb6718996f3","modified":1748000395336},{"_id":"themes/fluid/.eslintrc","hash":"3df89453e1f63051fafc90f16a8d83951050e316","modified":1748000395336},{"_id":"themes/fluid/.editorconfig","hash":"b595159772f3ee1ef5e6780ce307270e741cb309","modified":1748000395336},{"_id":"themes/fluid/.gitignore","hash":"9ede98b8d9dca802f82f651afb3b0366d69f05f1","modified":1748000395339},{"_id":"themes/fluid/languages/de.yml","hash":"f814263ded504cb4c50a8b66157bdd71f553be1b","modified":1748000395342},{"_id":"themes/fluid/README.md","hash":"b4bb8c50c0ce719b8cb37b7e3a899a9a1322c4fa","modified":1748000395340},{"_id":"themes/fluid/LICENSE","hash":"511e49f0bd8282a0d002c527474da8e1e5add393","modified":1748000395340},{"_id":"themes/fluid/README_en.md","hash":"85656f2a23cc5e31420f0118bf5541b6e9f058b6","modified":1748000395341},{"_id":"themes/fluid/_config.yml","hash":"1ca96e7e827043470e59752c8b99453fe4d15751","modified":1766104424379},{"_id":"themes/fluid/package.json","hash":"fd6756866314aaf4b15d734a83b85aa09aa0b5ed","modified":1748000395362},{"_id":"themes/fluid/languages/es.yml","hash":"0ad94ddf1ca868a67b5b84aed257a30572962210","modified":1748000395343},{"_id":"themes/fluid/languages/en.yml","hash":"415e3403182e1282386f28b9d61343f147519163","modified":1748000395342},{"_id":"themes/fluid/languages/eo.yml","hash":"314b97a7e68093328675acfd308d839b1d772ac9","modified":1748000395342},{"_id":"themes/fluid/languages/zh-CN.yml","hash":"497b3dea5058f718da225a7a443e916da895ea10","modified":1748000395343},{"_id":"themes/fluid/languages/ru.yml","hash":"998112b384b574e0e29c6ea16e4c1ebce1c15a4c","modified":1748000395343},{"_id":"themes/fluid/languages/ja.yml","hash":"65a90f294f6c73245e8250e87d124630ad10b389","modified":1748000395343},{"_id":"themes/fluid/languages/zh-TW.yml","hash":"ded0621e63b1f8b241be21f6e9b52d4f36edbcd0","modified":1748000395344},{"_id":"themes/fluid/layout/404.ejs","hash":"c49974dcbda02fe720498398e9778826335459c0","modified":1748000395344},{"_id":"themes/fluid/languages/zh-HK.yml","hash":"05418d0bca261de386872be65027bf4498758788","modified":1748000395344},{"_id":"themes/fluid/layout/archive.ejs","hash":"c524ce76747042ec2f9ed8d5025f80e01b462b3b","modified":1748000395359},{"_id":"themes/fluid/layout/about.ejs","hash":"2f3ea36713f0fa91d8d61d39fcf9e584372de818","modified":1748000395359},{"_id":"themes/fluid/layout/categories.ejs","hash":"838a68e210bddfca6d4ba070e1e2f1ca53cb7d06","modified":1748000395360},{"_id":"themes/fluid/layout/category.ejs","hash":"264f68cbf826787e683a30e1377c56c0895c7386","modified":1748000395360},{"_id":"themes/fluid/layout/index.ejs","hash":"dde1f6a27c8d09c38850a691089937f181b6c035","modified":1748000395360},{"_id":"themes/fluid/layout/layout.ejs","hash":"d4ffeb7eff398dea154340794bd277f75ddeedef","modified":1748000395361},{"_id":"themes/fluid/layout/links.ejs","hash":"fbed4b3d1e475b3de9d8ce05362abcc658a53408","modified":1748000395361},{"_id":"themes/fluid/layout/page.ejs","hash":"8ba210724c023d45a4564415762f3da299bd1d0e","modified":1748000395361},{"_id":"themes/fluid/layout/tag.ejs","hash":"e87fc58829ea214ac16e8e4f13cd5c389133697b","modified":1748000395362},{"_id":"themes/fluid/layout/post.ejs","hash":"c8da695dc1b01b715909ae6f1052ccaebdf9db4c","modified":1748000395361},{"_id":"themes/fluid/layout/tags.ejs","hash":"b7c1a6d8fc1097fc16d2300260297013cb692153","modified":1748000395362},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"7d7c1e5a1da6b4f7be6685beb4798ec76d5efd31","modified":1748000395337},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question.md","hash":"102213e5d6790d060c0e26b4a3a7ec744d753c52","modified":1748000395338},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"fea63a9a5c3befd8783705eed09adf1b596a6203","modified":1748000395337},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"5cc30e7b6e7b77c8b40b182ba02a5d93d37d2fc2","modified":1748000395338},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"7db378613df2b7d13e8c428c006399a879a4a852","modified":1748000395338},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"07e24578c25fcaca94618fd86569887dadf7a276","modified":1748000395338},{"_id":"themes/fluid/layout/_partials/archive-list.ejs","hash":"78c34e32746041f23678669bbadfbede15e4c6d2","modified":1748000395345},{"_id":"themes/fluid/.github/workflows/cr.yaml","hash":"fc31c7c6692424af1e08cd5e273a5a5814f9c577","modified":1748000395339},{"_id":"themes/fluid/.github/workflows/limit.yaml","hash":"bdbdb66da69ab7353b546f02150a6792f4787975","modified":1748000395339},{"_id":"themes/fluid/layout/_partials/category-chains.ejs","hash":"508254a648d8597e62e4012c8beab44bfa82e904","modified":1748000395345},{"_id":"themes/fluid/.github/workflows/publish.yaml","hash":"dcdbe1698a6ee61f741c29ef560f859f66ffa32c","modified":1748000395339},{"_id":"themes/fluid/layout/_partials/category-list.ejs","hash":"0c14869e15f7dc615c8353765569644238f38f2d","modified":1748000395345},{"_id":"themes/fluid/layout/_partials/comments.ejs","hash":"1ce9094faec6204949cdaf604aaf9200787e4218","modified":1748000395346},{"_id":"themes/fluid/layout/_partials/footer.ejs","hash":"6bb3335b5486d4bee2ed42f8bef57903066bc234","modified":1748000395350},{"_id":"themes/fluid/layout/_partials/head.ejs","hash":"b2646671f6328c99335b6b52afaac42eea96fef0","modified":1766104424381},{"_id":"themes/fluid/layout/_partials/css.ejs","hash":"e0aa87b9db37419b035f67a4fdb0d13f037b2805","modified":1766104424380},{"_id":"themes/fluid/layout/_partials/markdown-plugins.ejs","hash":"b5cd435b27f090939b6051bef41a38a3376044ac","modified":1748000395353},{"_id":"themes/fluid/layout/_partials/header.ejs","hash":"3668304d08c48b68d532532921a12069a2736150","modified":1748000395352},{"_id":"themes/fluid/layout/_partials/scripts.ejs","hash":"5cd7cff0ca20083f347117ce58163c68081478d0","modified":1766068940889},{"_id":"themes/fluid/scripts/events/index.js","hash":"6c3b24207e4ea3ae4edeb715af40ef23711b92b9","modified":1748000395363},{"_id":"themes/fluid/layout/_partials/paginator.ejs","hash":"0d443f23c459787338917900f50fec1c8b3b3bdd","modified":1748000395353},{"_id":"themes/fluid/layout/_partials/search.ejs","hash":"57a0f61242d9ce2bd2c51b2f84193f6dc1377ef9","modified":1748000395359},{"_id":"themes/fluid/scripts/generators/index-generator.js","hash":"3550976efc94500284795f13485f5a1765fc120b","modified":1748000395367},{"_id":"themes/fluid/scripts/filters/locals.js","hash":"2340a576635b16fd2456b3494f5afe89cd7764db","modified":1748000395366},{"_id":"themes/fluid/scripts/filters/default-injects.js","hash":"3d30c722b9e24c33577d6fab822628841fadf992","modified":1748000395366},{"_id":"themes/fluid/scripts/generators/local-search.js","hash":"33427308ca29f1d76336c83e704571c9de75df02","modified":1748000395367},{"_id":"themes/fluid/scripts/filters/post-filter.js","hash":"67637461e3f94f9e9675369eb7ff015355d9ec54","modified":1748000395367},{"_id":"themes/fluid/scripts/generators/pages.js","hash":"3fb72d3c2224c32d861a6e8a85e78a8b67e6a244","modified":1748000395368},{"_id":"themes/fluid/source/css/highlight.styl","hash":"57ce8b8f95ab1f40612a9dce1793de5ab9b4bbfc","modified":1748000395390},{"_id":"themes/fluid/source/css/custom.css","hash":"c454343084f6b8198ce6e6748dccba9e98fe5d67","modified":1766074139667},{"_id":"themes/fluid/source/css/gitalk.css","hash":"1fe60b2ab1d704f5a4f55e700dca5b8785fb390e","modified":1748000395389},{"_id":"themes/fluid/scripts/helpers/date.js","hash":"9bc9ba08d1d871394ee1c3a1cc2f21dc343f515a","modified":1748000395368},{"_id":"themes/fluid/source/css/main.styl","hash":"9e9171325bb7148c11ceee283d00c137c8a1c5c5","modified":1748000395390},{"_id":"themes/fluid/scripts/helpers/engine.js","hash":"96af7e55fdbe0819bacc554ecbfe42375a088df6","modified":1748000395368},{"_id":"themes/fluid/source/css/highlight-dark.styl","hash":"c74d7aed425d20f2fa096f386a9521b67b9ab269","modified":1748000395389},{"_id":"themes/fluid/scripts/helpers/injects.js","hash":"9219d59c51930c7a82fcde918d6efbc5aa572ea2","modified":1748000395369},{"_id":"themes/fluid/scripts/helpers/page.js","hash":"49b2c6449d7be35739c6cfea3cab4e790580983a","modified":1748000395369},{"_id":"themes/fluid/scripts/helpers/import.js","hash":"f9821f7789ea6f069977a8c642aa5ccb6d19077c","modified":1748000395369},{"_id":"themes/fluid/scripts/helpers/export-config.js","hash":"14a207a7d4e329382ab5d4e1da1ef85ff043daba","modified":1748000395368},{"_id":"themes/fluid/scripts/helpers/scope.js","hash":"3b67d50050158423c8fa47f1de6aedcfe916637b","modified":1748000395370},{"_id":"themes/fluid/scripts/helpers/url.js","hash":"f713ddb6c8018ec7b96d3567057f1f932609beea","modified":1748000395370},{"_id":"themes/fluid/scripts/tags/button.js","hash":"e1d0caed12e7cd9a35cf64272c41854b2901a58f","modified":1748000395371},{"_id":"themes/fluid/scripts/helpers/utils.js","hash":"f57be245e6e7228673e1dec3a3477e731492c5c1","modified":1748000395370},{"_id":"themes/fluid/scripts/helpers/wordcount.js","hash":"0bb33314aa5cfe326ab9bb14b545e343e4db4193","modified":1748000395371},{"_id":"themes/fluid/scripts/tags/checkbox.js","hash":"1ff4ea054f2c735dfaccb0be90f1708a2a750bc8","modified":1748000395372},{"_id":"themes/fluid/scripts/tags/fold.js","hash":"a93e2603021ad38714e870399767bea24e7cbe3e","modified":1748000395372},{"_id":"themes/fluid/scripts/tags/group-image.js","hash":"cc176cc1d7e7cc28cedf8397ae748c691d140be2","modified":1748000395372},{"_id":"themes/fluid/scripts/tags/label.js","hash":"6c5916d86c63795c7e910bf614b0e7ece5073702","modified":1748000395373},{"_id":"themes/fluid/scripts/tags/mermaid.js","hash":"dbfe59fde77d87b1d7d0c46480a2a729010988eb","modified":1748000395373},{"_id":"themes/fluid/scripts/utils/crypto.js","hash":"474b00a57f43dbe7bc2876d637ece4214d016c06","modified":1748000395374},{"_id":"themes/fluid/scripts/tags/note.js","hash":"e300ec4ee6c63464859ab000e987bf8dd7db4025","modified":1748000395373},{"_id":"themes/fluid/scripts/utils/object.js","hash":"3e03b534e2e92a6e17567b006d7e3eaad4b37598","modified":1748000395374},{"_id":"themes/fluid/scripts/utils/compare-versions.js","hash":"37f90bd4e35ce49457dc2a348b9f66e0b242c014","modified":1748000395374},{"_id":"themes/fluid/scripts/utils/url-join.js","hash":"dbdb10b23fcd3928e86a4cb46fa3455e060b4aa0","modified":1748000395375},{"_id":"themes/fluid/scripts/utils/resolve.js","hash":"a5d70005913ab03cea0a0dc601097628b4dbd5a8","modified":1748000395375},{"_id":"themes/fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1748000395390},{"_id":"themes/fluid/source/img/favicon.jpg","hash":"4d9939b7432e3123a74eb5ed0826decfa218654e","modified":1749313095940},{"_id":"themes/fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1748000395392},{"_id":"themes/fluid/source/js/boot.js","hash":"33bb7c8255d2e3c93a1bea8c9221399b3a868a63","modified":1748000395393},{"_id":"themes/fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1748000395392},{"_id":"themes/fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1748000395393},{"_id":"themes/fluid/source/js/color-schema.js","hash":"e7addcc88eb73dec4a9a8641a4bb68966a38a65d","modified":1748000395393},{"_id":"themes/fluid/source/js/events.js","hash":"3efd602cdb694902d6e74c4eb1e5bd70120ac5b1","modified":1748000395394},{"_id":"themes/fluid/source/xml/local-search.xml","hash":"85fcc23b4db654a7f91fc55b6fb0442bb3ed3a9a","modified":1748000395396},{"_id":"themes/fluid/source/js/img-lazyload.js","hash":"67f6250f98b36a6599ea982d11cbb060c5ffb92a","modified":1748000395394},{"_id":"themes/fluid/source/js/local-search.js","hash":"491021125d2579e841c83f36d3ab790d1eab9d1e","modified":1748000395395},{"_id":"themes/fluid/source/js/plugins.js","hash":"753c2cf95f2659fef80277b895f4da10c8888c72","modified":1748000395395},{"_id":"themes/fluid/layout/_partials/comments/changyan.ejs","hash":"0c410ef79785897c8de3da333b057a2936fd569b","modified":1748000395346},{"_id":"themes/fluid/layout/_partials/comments/cusdis.ejs","hash":"1e93ca89777e4beb0f0e5cb70e03aab48e958542","modified":1748000395346},{"_id":"themes/fluid/source/js/umami-view.js","hash":"370ab30ab88c596d85327dbd7db3bafd49489fdd","modified":1748000395395},{"_id":"themes/fluid/source/js/utils.js","hash":"9d0423db40a787f3b19968205b9ed92a848c9153","modified":1748000395396},{"_id":"themes/fluid/source/js/leancloud.js","hash":"e9ad1b5659f0af867174687daa0ecf4375e40b75","modified":1748000395394},{"_id":"themes/fluid/layout/_partials/comments/disqus.ejs","hash":"79ec17eec6e15076c685688e740230e92c66efa9","modified":1748000395347},{"_id":"themes/fluid/layout/_partials/comments/gitalk.ejs","hash":"7f04e5c22821bb94da791973d9c6692b03bac81d","modified":1748000395347},{"_id":"themes/fluid/layout/_partials/comments/giscus.ejs","hash":"66995ec9dab10ed35c2a775010c447113c6848d4","modified":1748000395347},{"_id":"themes/fluid/layout/_partials/comments/discuss.ejs","hash":"d400e5721af28cefecaf50b46c82dcdde4cda4a8","modified":1748000395347},{"_id":"themes/fluid/layout/_partials/comments/livere.ejs","hash":"bcceafab01fe695c59951d939f7cef502f3d7b48","modified":1748000395348},{"_id":"themes/fluid/layout/_partials/comments/remark42.ejs","hash":"45c879768b40ba56af62e18ad54bffbf73a6f3a1","modified":1748000395348},{"_id":"themes/fluid/layout/_partials/comments/twikoo.ejs","hash":"938eb60413ae8af83ffeaba4d85df88387cdd5be","modified":1748000395349},{"_id":"themes/fluid/layout/_partials/comments/utterances.ejs","hash":"d7bcc183fc31af643e7835b13da10fe2ab8614ce","modified":1748000395349},{"_id":"themes/fluid/layout/_partials/comments/valine.ejs","hash":"ef04d4fc3f26588ae9d8712938d648304fc05455","modified":1748000395349},{"_id":"themes/fluid/layout/_partials/footer/statistics.ejs","hash":"047bece1db5cdf96cb78a44c6420ce3e92e6a9ca","modified":1748000395351},{"_id":"themes/fluid/layout/_partials/comments/waline.ejs","hash":"df6bae1a93827991049f7a33f6a69681c60eab0e","modified":1748000395349},{"_id":"themes/fluid/layout/_partials/footer/beian.ejs","hash":"77d0c9df31a22ed8a3e341637bde4165a11a7ce9","modified":1748000395351},{"_id":"themes/fluid/layout/_partials/header/navigation.ejs","hash":"e5219b14410066bf8ab491379aca797304b4a914","modified":1748000395352},{"_id":"themes/fluid/scripts/events/lib/compatible-configs.js","hash":"31208a0db986ba864f756a8ec806b7d254440f9b","modified":1748000395363},{"_id":"themes/fluid/scripts/events/lib/footnote.js","hash":"9b1934c61dc78622a07da554413f6ad31854576d","modified":1748000395364},{"_id":"themes/fluid/layout/_partials/header/banner.ejs","hash":"48d817eb8e269719af1fb597cc4e586d24cd1bc0","modified":1766118455958},{"_id":"themes/fluid/scripts/events/lib/hello.js","hash":"da987411ae4a4e6896a9b8af1fce6209192af28e","modified":1748000395364},{"_id":"themes/fluid/scripts/events/lib/highlight.js","hash":"d103e4bf612b2445bb136712d57b81e784a313e2","modified":1748000395364},{"_id":"themes/fluid/scripts/events/lib/injects.js","hash":"92123b7280695b4ac6650f5e1d7fa0d772c71f5b","modified":1748000395365},{"_id":"themes/fluid/layout/_partials/plugins/analytics.ejs","hash":"f8fe8e58b83f627db82c0dbeb663389efc33c1c6","modified":1748000395353},{"_id":"themes/fluid/scripts/events/lib/lazyload.js","hash":"c9696633f77dd8055e900497469f9e64eca4d97f","modified":1748000395365},{"_id":"themes/fluid/scripts/events/lib/merge-configs.js","hash":"ec6bf395ccad3dd41f29dc0080aeabf413e30fd9","modified":1748000395366},{"_id":"themes/fluid/layout/_partials/plugins/anchorjs.ejs","hash":"8a4ea62c46f9a75c94096a27b2d3f5c10a2f82e5","modified":1748000395354},{"_id":"themes/fluid/layout/_partials/plugins/code-widget.ejs","hash":"03c7c69fbb1754fdccfa18671aac23b8637b869e","modified":1748000395354},{"_id":"themes/fluid/layout/_partials/plugins/fancybox.ejs","hash":"3900e54ade140e0e49c571a1955f0b1f3a59b281","modified":1748000395354},{"_id":"themes/fluid/layout/_partials/plugins/encrypt.ejs","hash":"018cab52ff696a6c78ebc01e10237a90a0c33603","modified":1748000395354},{"_id":"themes/fluid/layout/_partials/plugins/math.ejs","hash":"d0f06fb482e3a8f9a53dfd94c4e4a65a43f1ff34","modified":1748000395355},{"_id":"themes/fluid/layout/_partials/plugins/mermaid.ejs","hash":"110e45e2d3433178f00f482adc863110f90c46d6","modified":1748000395355},{"_id":"themes/fluid/layout/_partials/plugins/highlight.ejs","hash":"502b99e19e496825df7032ca2b0b1a95ebb2b357","modified":1748000395355},{"_id":"themes/fluid/layout/_partials/post/category-bar.ejs","hash":"551ffae43844925beb099c85a9e6d8d9fcbf8086","modified":1748000395356},{"_id":"themes/fluid/layout/_partials/plugins/moment.ejs","hash":"acc72c3284fe906a4505132c3d9a4720d80e6fcb","modified":1748000395355},{"_id":"themes/fluid/layout/_partials/plugins/typed.ejs","hash":"42850952e8f5858497fe774c2aff87b6563ab01e","modified":1766104424384},{"_id":"themes/fluid/layout/_partials/plugins/nprogress.ejs","hash":"47c1df255aa552ad71ef3e57deca46530a8f2802","modified":1766104424384},{"_id":"themes/fluid/layout/_partials/post/copyright.ejs","hash":"26905d5862b1531ebcc175af15178dabeecc81c8","modified":1748000395357},{"_id":"themes/fluid/layout/_partials/post/meta-bottom.ejs","hash":"f0cb813cd03642c9b68cff8b6669f73a61dd10f8","modified":1748000395357},{"_id":"themes/fluid/layout/_partials/post/meta-top.ejs","hash":"73827074db4e0fc3d52c51a76285df87aa5e5a7f","modified":1748000395357},{"_id":"themes/fluid/layout/_partials/post/sidebar-left.ejs","hash":"db4ecdcc762bb1b1bae5060f0baa6115174779ff","modified":1748000395357},{"_id":"themes/fluid/layout/_partials/post/toc.ejs","hash":"1b1eb4c8e163a5d909e86da76ef778948e0e0b77","modified":1748000395358},{"_id":"themes/fluid/layout/_partials/post/sidebar-right.ejs","hash":"2507cdad08f61cf8c1d9b0ca7f4f1dc8c4e5841b","modified":1748000395358},{"_id":"themes/fluid/source/css/_mixins/base.styl","hash":"046979dbd8cdabd21d89f9c1d8f1bb3f2fd06d6f","modified":1748000395376},{"_id":"themes/fluid/source/css/_functions/base.styl","hash":"171697018fd384fce0834875ca94b91f16564cac","modified":1748000395376},{"_id":"themes/fluid/source/css/_variables/base.styl","hash":"9ea66cf79f1e4356b6b402bc3dc5fb55c9862f1f","modified":1748000395389},{"_id":"themes/fluid/source/css/_pages/pages.styl","hash":"92c062cf55457b6549497244d09ec34e9c0c95c2","modified":1748000395388},{"_id":"themes/fluid/source/css/_pages/_archive/archive.styl","hash":"e3846fb429f6732bd15fde40f7c28b3492d786c8","modified":1748000395377},{"_id":"themes/fluid/source/css/_pages/_base/base.styl","hash":"cd255079553985722ee80fb1833f6507dde52194","modified":1748000395383},{"_id":"themes/fluid/source/css/_pages/_about/about.styl","hash":"8ba5fb6a8ced1de6f7893184bf12f4021fe22595","modified":1748000395377},{"_id":"themes/fluid/source/css/_pages/_base/keyframes.styl","hash":"58a7f8f2baea2d58cf5f7edfc91314ee5d7156ca","modified":1748000395383},{"_id":"themes/fluid/source/css/_pages/_base/inline.styl","hash":"96c3bb95dea4b3d3ecd20b810a674bfcef04870c","modified":1748000395383},{"_id":"themes/fluid/source/css/_pages/_base/print.styl","hash":"571bd018e914bd0f7c5f89df874b5937937e5fa6","modified":1748000395384},{"_id":"themes/fluid/source/css/_pages/_index/index.styl","hash":"bac20c8fb20276b08972df5ecc7a5850a72393f4","modified":1766072964924},{"_id":"themes/fluid/source/css/_pages/_base/color-schema.styl","hash":"66d5b045c0e54001d3c98c5901d72590fe08acc4","modified":1748000395383},{"_id":"themes/fluid/source/css/_pages/_links/links.styl","hash":"d3ef491fd449d89a1b95801dee788a5d9bec4320","modified":1748000395385},{"_id":"themes/fluid/source/css/_pages/_category/category-bar.styl","hash":"f35415bd86b5c26fbc71728048d9e1481263554f","modified":1748000395384},{"_id":"themes/fluid/source/css/_pages/_category/category-list.styl","hash":"d3aeb7bf22d52d7dde59b292090ef8b46943718a","modified":1748000395385},{"_id":"themes/fluid/source/css/_pages/_category/category-chain.styl","hash":"4263f7b930e6b57e13295d17fd3745a9e5c52494","modified":1748000395384},{"_id":"themes/fluid/source/css/_pages/_post/comment.styl","hash":"1fc96d09d52d9502e84e4e2a8d482ea45e8b81ea","modified":1748000395386},{"_id":"themes/fluid/source/css/_pages/_post/highlight.styl","hash":"d73cccb65eaa804910884df17442e34736b3f4fb","modified":1748000395386},{"_id":"themes/fluid/source/css/_pages/_post/post-page.styl","hash":"6a35a450bd0a12f68fd92aac3f88b23475a98d46","modified":1748000395387},{"_id":"themes/fluid/source/css/_pages/_post/post-tag.styl","hash":"31c64c3fae4a0fc4747d8afeb72f7a9667c5326c","modified":1748000395387},{"_id":"themes/fluid/source/css/_pages/_post/markdown.styl","hash":"2d12f23b46d0ce07ae810bc4f5635c490a098fa4","modified":1748000395387},{"_id":"themes/fluid/source/css/_pages/_tag/tags.styl","hash":"29e9b72cfda2f2baf9cf2597fcd7f9e66303a9bd","modified":1748000395388},{"_id":"themes/fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"26d65475b1c52a61115044db8883df6739c3a473","modified":1748000395378},{"_id":"themes/fluid/source/css/_pages/_base/_widget/banner.styl","hash":"80301db38e448e40e88bb34d0128628b0809b243","modified":1748000395378},{"_id":"themes/fluid/source/css/_pages/_base/_widget/board.styl","hash":"1068d71721baeed76bf0176f9b964d36b5764c9f","modified":1748000395378},{"_id":"themes/fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"417a7388b39c0203178b0032e151febd66a0e9f3","modified":1748000395379},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footer.styl","hash":"e6f5921ff9009c1853e7db30c482bc1682433ed9","modified":1748000395379},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"41935973a66c14ab2bea0539d4b1f15c62534fa4","modified":1748000395380},{"_id":"themes/fluid/source/css/_pages/_base/_widget/header.styl","hash":"88c3c2d99a097142a87eeec0c7c65a3789f25117","modified":1748000395380},{"_id":"themes/fluid/source/css/_pages/_base/_widget/modal.styl","hash":"0ca6171ce262339e0e36cfea0978b554d87ae7fc","modified":1748000395380},{"_id":"themes/fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"3ac1eb36e124adef607775aa505386d5680960e2","modified":1748000395379},{"_id":"themes/fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"48799d3148ef6493be0e05897c635124e9b05d03","modified":1748000395381},{"_id":"themes/fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"8fad325e411bc83c8ebdc4115015477eed5f60da","modified":1748000395381},{"_id":"themes/fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"f4ae7cbf2f10f459de7864f8e642553b587df889","modified":1748000395381},{"_id":"themes/fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"04447d3b673be84a1af1dc57933a3c41dd7c0cfe","modified":1748000395381},{"_id":"source/imgs/web-history/TIM.png","hash":"3764af453e357422acd111028d0604c16c24f31e","modified":1752130958000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"e4dbbbb1a2508a72bc04680552d7ebbea0eed0fe","modified":1748000395382},{"_id":"themes/fluid/source/css/_pages/_base/_widget/search.styl","hash":"1f4e678d7219815ab62de1b92ec75e021247f90b","modified":1748000395382},{"_id":"themes/fluid/source/css/_pages/_base/_widget/toc.styl","hash":"5defef321e3e933fe84f3f2ca481c88f55381fb0","modified":1748000395382},{"_id":"source/imgs/web-history/CSS.png","hash":"68722626e90661e58d8d70aea0d4c7ef7f205310","modified":1752130958000},{"_id":"source/imgs/build-blog1/blog1.jpg","hash":"cd119385d9f85524aeb92a1c3cdac16ca712118f","modified":1749313095831},{"_id":"source/imgs/feature-of-fe/tauri.png","hash":"1eccc2041fd297f37242b596c423ad3a0ab00a92","modified":1753803111348},{"_id":"source/imgs/build-blog1/step1.png","hash":"711d482f34bc57def949dca2218da0a1e3f6bc9a","modified":1749313095887},{"_id":"source/imgs/build-blog1/blog2.jpg","hash":"088f470ce2f0c902c5115d1e4891f473a6445d55","modified":1749313095831},{"_id":"themes/fluid/source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1748000395392},{"_id":"source/imgs/build-blog3/environment1.png","hash":"dabc596a066194027aec024f042d060ea00e2fed","modified":1749478196250},{"_id":"source/imgs/closure/closure.png","hash":"f5ffcdaf87cac085f01ad2aedbc05ced0a834b9a","modified":1755178395213},{"_id":"source/imgs/build-blog1/blog4.jpg","hash":"bc8543254d3656f309148392d9145f26ba13d79c","modified":1749313095872},{"_id":"source/imgs/baners/node.png","hash":"179615e8d144bb30aefca1270d517dbf82ea6338","modified":1756205508214},{"_id":"themes/fluid/source/img/wild-fire.jpg","hash":"a032903bb422e1d524a190a19b02b0031dc87b91","modified":1749654949932},{"_id":"source/imgs/feature-of-fe/design.jpg","hash":"2f9ee72f52f923d28c6fa84d307b9aa361d05b30","modified":1753802354727},{"_id":"source/imgs/build-blog3/landscape.png","hash":"004c644178862bb6b1a88f2aec28c2c798a5f297","modified":1749478196262},{"_id":"source/imgs/react-vs-vue/react-vs-vue.png","hash":"11b26c61e83179607579b7cb46f9be895ecc18e7","modified":1754811783954},{"_id":"source/imgs/feature-of-fe/code.jpg","hash":"014831bca5aee59361946f39581694ff202ca432","modified":1753802388536},{"_id":"source/imgs/build-blog1/blog6.jpg","hash":"077be667affcb34f66cba6385aa759c0e37b3a2d","modified":1749313095887},{"_id":"source/imgs/prototype/banner.png","hash":"c6ebbbc76a0cd9f2bd6686920bbc784bceeb75f2","modified":1756133212845},{"_id":"themes/fluid/source/img/drawn.jpg","hash":"a8afab014b63afa5e2c043eb7b50ecba6b03edfb","modified":1749313095940},{"_id":"source/imgs/build-blog1/blog3.jpg","hash":"20f8f6d4a7e06e9f33cbd43d5a45e09a4b477081","modified":1749313095864},{"_id":"source/imgs/build-blogs2/my-sit.png","hash":"cf76b3e7a36c6cf1d27efa4d40f63439f561f3ea","modified":1749313095912},{"_id":"source/imgs/logo3.png","hash":"4a231b2e2619c10f6221916531b3fe616a1d990c","modified":1754793332004},{"_id":"source/imgs/logo.png","hash":"dfe5c04010702e83ca532f263ee05475ad4972b7","modified":1754793331996}],"Category":[{"name":"Vue源码阅读","_id":"cmjbml2hy0005ikup88n32osy"},{"name":"小程序开发","_id":"cmjbml2i1000aikup469q63du"},{"name":"Web开发","_id":"cmjbml2i2000fikup70r54rcz"},{"name":"ES6进阶","_id":"cmjbml2i6000oikup1c2z77l5"},{"name":"搭建博客","_id":"cmjbml2i90012ikup75r7b4et"},{"name":"网络安全","parent":"cmjbml2i2000fikup70r54rcz","_id":"cmjbml2if001tikup46l0dgpx"}],"Data":[],"Page":[{"title":"about","date":"2025-05-23T04:55:03.000Z","_content":"## Hi there 👋 ![](https://komarev.com/ghpvc/?username=jvxiao&color=blue&style=plastic)\n\n<!--\n**jvxiao/jvxiao** is a ✨ _special_ ✨ repository because its `README.md` (this file) appears on your GitHub profile.\n\nHere are some ideas to get you started:\n\n- 🔭 I’m currently working on ...\n- 🌱 I’m currently learning ...\n- 👯 I’m looking to collaborate on ...\n- 🤔 I’m looking for help with ...\n- 💬 Ask me about ...\n- 📫 How to reach me: ... \n- 😄 Pronouns: ...\n- ⚡ Fun fact: ...\n-->\n\nHi, I am Jovin Xiao, as known as jvxiao, a full-time front-end developer. In the past few years, I have mainly used Vue and Node to complete my development work. \n\nIn my spare time, I enjoy learning new things and creating some very interesting projects. If you like my projects, please don't hesitate to give me a star or kindly consider [sponsoring me by afdian](https://afdian.com/a/jvxiao).\n\nFeel free to contact me.\n\n","source":"about/index.md","raw":"---\ntitle: about\ndate: 2025-05-23 12:55:03\n---\n## Hi there 👋 ![](https://komarev.com/ghpvc/?username=jvxiao&color=blue&style=plastic)\n\n<!--\n**jvxiao/jvxiao** is a ✨ _special_ ✨ repository because its `README.md` (this file) appears on your GitHub profile.\n\nHere are some ideas to get you started:\n\n- 🔭 I’m currently working on ...\n- 🌱 I’m currently learning ...\n- 👯 I’m looking to collaborate on ...\n- 🤔 I’m looking for help with ...\n- 💬 Ask me about ...\n- 📫 How to reach me: ... \n- 😄 Pronouns: ...\n- ⚡ Fun fact: ...\n-->\n\nHi, I am Jovin Xiao, as known as jvxiao, a full-time front-end developer. In the past few years, I have mainly used Vue and Node to complete my development work. \n\nIn my spare time, I enjoy learning new things and creating some very interesting projects. If you like my projects, please don't hesitate to give me a star or kindly consider [sponsoring me by afdian](https://afdian.com/a/jvxiao).\n\nFeel free to contact me.\n\n","updated":"2025-06-17T13:54:22.433Z","path":"about/index.html","comments":1,"layout":"page","_id":"cmjbml2hv0001ikup65pfc6bv","content":"<h2 id=\"Hi-there-👋\"><a href=\"#Hi-there-👋\" class=\"headerlink\" title=\"Hi there 👋 \"></a>Hi there 👋 <img src=\"https://komarev.com/ghpvc/?username=jvxiao&color=blue&style=plastic\"></h2><!--\n**jvxiao/jvxiao** is a ✨ _special_ ✨ repository because its `README.md` (this file) appears on your GitHub profile.\n\nHere are some ideas to get you started:\n\n- 🔭 I’m currently working on ...\n- 🌱 I’m currently learning ...\n- 👯 I’m looking to collaborate on ...\n- 🤔 I’m looking for help with ...\n- 💬 Ask me about ...\n- 📫 How to reach me: ... \n- 😄 Pronouns: ...\n- ⚡ Fun fact: ...\n-->\n\n<p>Hi, I am Jovin Xiao, as known as jvxiao, a full-time front-end developer. In the past few years, I have mainly used Vue and Node to complete my development work. </p>\n<p>In my spare time, I enjoy learning new things and creating some very interesting projects. If you like my projects, please don’t hesitate to give me a star or kindly consider <a href=\"https://afdian.com/a/jvxiao\">sponsoring me by afdian</a>.</p>\n<p>Feel free to contact me.</p>\n","excerpt":"","more":"<h2 id=\"Hi-there-👋\"><a href=\"#Hi-there-👋\" class=\"headerlink\" title=\"Hi there 👋 \"></a>Hi there 👋 <img src=\"https://komarev.com/ghpvc/?username=jvxiao&color=blue&style=plastic\"></h2><!--\n**jvxiao/jvxiao** is a ✨ _special_ ✨ repository because its `README.md` (this file) appears on your GitHub profile.\n\nHere are some ideas to get you started:\n\n- 🔭 I’m currently working on ...\n- 🌱 I’m currently learning ...\n- 👯 I’m looking to collaborate on ...\n- 🤔 I’m looking for help with ...\n- 💬 Ask me about ...\n- 📫 How to reach me: ... \n- 😄 Pronouns: ...\n- ⚡ Fun fact: ...\n-->\n\n<p>Hi, I am Jovin Xiao, as known as jvxiao, a full-time front-end developer. In the past few years, I have mainly used Vue and Node to complete my development work. </p>\n<p>In my spare time, I enjoy learning new things and creating some very interesting projects. If you like my projects, please don’t hesitate to give me a star or kindly consider <a href=\"https://afdian.com/a/jvxiao\">sponsoring me by afdian</a>.</p>\n<p>Feel free to contact me.</p>\n"}],"Post":[{"title":"一篇文章搞懂Array,Set和Map异同","date":"2025-05-23T04:40:00.000Z","_content":"\nArray,Set和Map三个作为Javascript中可迭代的集合数据类型，在编程过程中使用的频率也比较高。针对三种数据类型各自的一些特性，本文的内容将从以下几个方面来上述数据类型做一个总结。\n\n-  [**实例的创建**](##实例的创建)\n-  [**数据添加**](##数据添加)\n-  [**数据访问（查找）**](##数据访问（查找）)\n-  [**数据的遍历**](##数据的遍历)\n-  [**类似的功能和一些专有方法**](##类似的功能和一些专有方法)\n-  [**三者之间的转换**](##三者之间的转换)\n-  [**应用场景**](##应用场景)\n\n## 实例的创建\n  Map和Set创建实例的方式是唯一的，只允许通过new调用构造方法来创建一个实例。值得注意的是，Set和Map在调用构造函数的时候，传参都是数组或者可迭代对象，其中Map的传参数组需要时一个键值对数组。当然，传参也是可选的，非必须。\n\n Array相较于前两者，其创建实例的方式要多写，可通过字面方式创建，也可像Map和Set一样通过构造函数来创建。此外使用Array的静态函数Array.from来创建也是非常常见的。例如，通过docuemnt.getElementsByTagName这类方法获取到一个HTMLCollect这样一个类数组，通常会通过Array.from将其装换成一个真正的数组来进行后续的操作。\n\n  ```Javascript\n\n   // 创建map实例\n   let map1 = new Map();\n   let map2 = new Map([['a', 1], ['b', 2]]); //  a=>1, b=>2\n   // 创建set实例\n   let set1 = new Set();\n   let set2 = new Set([1,2])\n\n  // 通过字面量创建数组\n  let arr1 = [1,2,3];\n  // 使用Array静态方法从一个可迭代对象或者类数组中创建数组实例\n  let arr2 = Array.from([4,5]) \n  // 使用Array构造函数\n  let arr3 = new Array([6,7]);\n```\n\n## 数据添加与变更\n\n\n```Javascript\n  // Set的数据操作：添加与删除\n  let set = new Set();\n  set.add(11) // [11]\n  set.add(23) // [11, 23]\n  set.add(11) // [11, 23]\n  set.delete(23) // [11] \n  \n  // Map的数据操作：添加与删除\n  let  map = new Map();\n  map.set('a', 1);   // [a=>1]\n  map.set('b', 2);   // [a=>1, b=>2]\n  map.delete('b');   // [a=>1]\n\n  // Array\n  let arr = [1,2,3]\n  // 在数组末尾添加一个值\n  arr.push(4)       // [1,2,3,4]\n  // 弹出数组末尾的值\n  arr.pop(4)        // [1,2,3]\n  // 在数组头部添加一个值\n  arr.unshift(0)    // [0,1,2,3]\n  // 移除头部的第一个值\n  arr.shift()       // [1,2,3]\n  // 在第二个数（下标1）之后插入一个值‘a’\n  arr.splice(1,0,'a')   // [1,2,'a', 3];\n  // 删除第二个数（下标1）后面1个值，然后插入一个新的值‘b’\n  arr.splice(1,1,'b')   // [1,2,'b',3]\n```\n\n## 数据访问\n  Array和Map都能够访问实例中的特定数据，Array是通过下标，而Map是通过实例方法get, 唯独Set没有方式可以直接访问其中特定数据。其实也不难理解，Set本身不是为了单纯存储数据和访问特殊而生的，因为这些功能Array就可以支持，何必再单出构造一个Set数据结构了。我对此的理解是，Set跟多的是紧紧围绕着数据唯一不重复这一准则来的，它的侧重点是某一数据的有无，而不是数据存在哪里。\n\n  另外，从结构上来说。Set不像Array那样是有序的，所以也无法使用下标来访问，也不像Map那般，每个键对应一个值，所以也无法通过键来访问。故而，Set没有单独访问某一数据的方式。\n\n```Javascript\n  const arr = [1,2,3];\n  const set = new Set(['a', 'b']);\n  const map = new Map([['a', 1], ['b', '2']]);\n  \n  //Array通过下标访问数据\n  console.log(arr[0], arr[2]) // 1, 3\n  //Map使用实例方法get访问数据，参数是键\n  console.log(mpa.get('a))    // 1\n```\n## 数据的遍历\n\n**Set数据的遍历方式**：\n-  keys()   &emsp;&emsp;返回键名迭代器\n-  values() &emsp;返回值迭代器  \n-  entries() &emsp;返回键值迭代器\n-  forEach()\n```Javascript\nconst set = new Set(['a', 'b', 'c']);\n// set每个值对应的key其实也是数据值本身\nconst keyIter = set.keys();\nconsole.log(keyIter.next().value);  // 'a'\nconsole.log(keyIter.next().value);  // 'b'\nconsole.log(keyIter.next().value);  // 'c'\nconsole.log(keyIter.next().value);  // undefined\n\nconst valueIter = set.values();\nfor(let val of valueIter) {\n  console.log(val);                // 'a', 'b', 'c'\n}\n\nconst entriesIter = set.entries();\nfor(let [key, value] of entriesIter) {\n  console(`${key}:${value}`)     // 'a':'a', 'b':'b', 'c':'c'\n}\n\nset.forEach(val => {\n  console.log(val)             // 'a', 'b', 'c'\n})\n```\n</br>\n\n**Map数据的遍历方式**\n-  keys()   &emsp;&emsp;返回键名迭代器\n-  values() &emsp;返回值迭代器  \n-  entries() &emsp;返回键值迭代器\n-  forEach()\n\n```Javascript\nconst map = new Map([['a', 1], ['b', '2']]);\n/**\n* 代码就自己脑补吧，\n* 不能说和Set的方式很像，\n* 只能说真的就是一模一样\n**/\n```\n</br>\n\n**Array数据的遍历方式**\n\nArray遍历数据的方法是最多的，除了下面列举的几个之外，还有some, every,甚至filter, find和findIndex这些方法可以用来遍历数据。使用这些方法需要注意的是其使用的场景，例如map和forEach都可以用来对数组内数据做一些操作，但如果不需要返回值的情况，还是使用forEach方法，而不建议是map，其它方法也是如此。\n\n-  keys()   &emsp;&emsp;返回键名迭代器\n-  values() &emsp;返回值迭代器  \n-  entries() &emsp;返回键值迭代器\n-  map()    &emsp;回调函数，要有返回值\n-  reduce() \n-  forEach()\n-  for...of\n```Javascript\n/**\n* 代码就不写了，偷个懒，不过还是贴心的附上链接\n* https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array\n**/\n```\n\n\n## 类似的功能和一些专有方法\n- **是否包含某个元素**: 数组的includes方法，map和set的has方法，三者的返回值都是布尔值，区别只在于传入的参数。数组和set传入的是值，map传入的是键。\n- **合并两个相同类型的数据**： 数组使用concat方法，合并两个数组值，set使用union方法合并两个集合。map没有专有方法可以用来合并两个map数据，不过可以通过使用new Map([...map1, ...map2])来返回一个合并之后的新map\n- **数据大小**：数组有length属性，map和set有size属性\n- **清空数据**：map和size都可通过clear()方法来清空数据，数组无专有方法，可自己通过修改length值为0或者使用splice方法清空数据。\n\n>关于数组中的includes方法在数组值为一个个对象的时候，这个时候传入的值就只能是对象的引用了。如果作用域内不存在引用的话，判断数组中是否存在某个对象，就只能通过filter, find或者findIndex之类的方法加上数据特征去判断数组中是否存在该对象了。\n\n  \n## 三者之间的转换\n\n\n```Javascript\nconst arr = [1, 3, 4, 4];\nconst arr1 = [['a', 'Kebei']];\nconst map = new Map(['a', 1], ['b', 2]);\nconst set = new Set([1, 5]);\n\n// Array 转 Set\nconst arr2Set = new Set(arr);   // [1, 3, 4];\n// Array 转Map\nconst arr2Map = new Map(arr1);  // {'a' => 'Kebei'}\n\n//Set转Array\nconst set2Arr = Array.from(set);        // [1, 5]\nconst set2Arr2 = [...set];              // [1, 5]\nconst set2Arr3 = set.values()           // [1, 5]\n//Set转Map\nconst set2Map = new Map(set.entries())  // { 1=> 1, 5=>5}\n\n// Map转Array\nconst map2Arr = Array.from(map);     // ['a', 1], ['b', 2]\nconst map2Arr2 = [...map];           // ['a', 1], ['b', 2]\nconst map2Arr3 = map.values()        // ['a', 1], ['b', 2]\n// Map转Set\nconst map2Set = new Set(map.values()) // [1, 2]\n```\n## 应用场景\n</br>\n最常见的一种场景莫过于使用数组与Set之间格式变化进行数据去重\n\n```Javascript\n  const dedup = (arr) => {\n    return [...new Set(arr)]\n  }\n```\n上述方法和之前includes方法也是一样存在无法处理复杂数据类型，对于复杂对象数据，需要根据各自业务场景对重复的数据进行去重策略选择，即在一堆的重复对象中（以id重复为例）保留业务需要的唯一一个数据。\n\n## 总结\n三种数据结构有着各自不同的特性。数组是一个天然的栈，也是一个天然的队列，在三种数据结构中，其实例方法也应用也是最多的，是线性存储中话事人般的存在，也是我们在普通业务场景下的首选。Set数据的唯一性，可以帮助我们在业务场景中快速的进行去重。Map键值对结构的特殊性，以及对键的包容性，能够通过键快速获取到值，也是复杂业务冲常常用的。\n</br>\n\n【资料参考】\n  1. https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array\n  2. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\n  3. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map","source":"_posts/Array-set-map-summary.md","raw":"\n---\ntitle: 一篇文章搞懂Array,Set和Map异同\ndate: 2025-05-23 12:40:00\ntags:\n  - Javascript\n  - Array\n  - Set\n  - Map\n---\n\nArray,Set和Map三个作为Javascript中可迭代的集合数据类型，在编程过程中使用的频率也比较高。针对三种数据类型各自的一些特性，本文的内容将从以下几个方面来上述数据类型做一个总结。\n\n-  [**实例的创建**](##实例的创建)\n-  [**数据添加**](##数据添加)\n-  [**数据访问（查找）**](##数据访问（查找）)\n-  [**数据的遍历**](##数据的遍历)\n-  [**类似的功能和一些专有方法**](##类似的功能和一些专有方法)\n-  [**三者之间的转换**](##三者之间的转换)\n-  [**应用场景**](##应用场景)\n\n## 实例的创建\n  Map和Set创建实例的方式是唯一的，只允许通过new调用构造方法来创建一个实例。值得注意的是，Set和Map在调用构造函数的时候，传参都是数组或者可迭代对象，其中Map的传参数组需要时一个键值对数组。当然，传参也是可选的，非必须。\n\n Array相较于前两者，其创建实例的方式要多写，可通过字面方式创建，也可像Map和Set一样通过构造函数来创建。此外使用Array的静态函数Array.from来创建也是非常常见的。例如，通过docuemnt.getElementsByTagName这类方法获取到一个HTMLCollect这样一个类数组，通常会通过Array.from将其装换成一个真正的数组来进行后续的操作。\n\n  ```Javascript\n\n   // 创建map实例\n   let map1 = new Map();\n   let map2 = new Map([['a', 1], ['b', 2]]); //  a=>1, b=>2\n   // 创建set实例\n   let set1 = new Set();\n   let set2 = new Set([1,2])\n\n  // 通过字面量创建数组\n  let arr1 = [1,2,3];\n  // 使用Array静态方法从一个可迭代对象或者类数组中创建数组实例\n  let arr2 = Array.from([4,5]) \n  // 使用Array构造函数\n  let arr3 = new Array([6,7]);\n```\n\n## 数据添加与变更\n\n\n```Javascript\n  // Set的数据操作：添加与删除\n  let set = new Set();\n  set.add(11) // [11]\n  set.add(23) // [11, 23]\n  set.add(11) // [11, 23]\n  set.delete(23) // [11] \n  \n  // Map的数据操作：添加与删除\n  let  map = new Map();\n  map.set('a', 1);   // [a=>1]\n  map.set('b', 2);   // [a=>1, b=>2]\n  map.delete('b');   // [a=>1]\n\n  // Array\n  let arr = [1,2,3]\n  // 在数组末尾添加一个值\n  arr.push(4)       // [1,2,3,4]\n  // 弹出数组末尾的值\n  arr.pop(4)        // [1,2,3]\n  // 在数组头部添加一个值\n  arr.unshift(0)    // [0,1,2,3]\n  // 移除头部的第一个值\n  arr.shift()       // [1,2,3]\n  // 在第二个数（下标1）之后插入一个值‘a’\n  arr.splice(1,0,'a')   // [1,2,'a', 3];\n  // 删除第二个数（下标1）后面1个值，然后插入一个新的值‘b’\n  arr.splice(1,1,'b')   // [1,2,'b',3]\n```\n\n## 数据访问\n  Array和Map都能够访问实例中的特定数据，Array是通过下标，而Map是通过实例方法get, 唯独Set没有方式可以直接访问其中特定数据。其实也不难理解，Set本身不是为了单纯存储数据和访问特殊而生的，因为这些功能Array就可以支持，何必再单出构造一个Set数据结构了。我对此的理解是，Set跟多的是紧紧围绕着数据唯一不重复这一准则来的，它的侧重点是某一数据的有无，而不是数据存在哪里。\n\n  另外，从结构上来说。Set不像Array那样是有序的，所以也无法使用下标来访问，也不像Map那般，每个键对应一个值，所以也无法通过键来访问。故而，Set没有单独访问某一数据的方式。\n\n```Javascript\n  const arr = [1,2,3];\n  const set = new Set(['a', 'b']);\n  const map = new Map([['a', 1], ['b', '2']]);\n  \n  //Array通过下标访问数据\n  console.log(arr[0], arr[2]) // 1, 3\n  //Map使用实例方法get访问数据，参数是键\n  console.log(mpa.get('a))    // 1\n```\n## 数据的遍历\n\n**Set数据的遍历方式**：\n-  keys()   &emsp;&emsp;返回键名迭代器\n-  values() &emsp;返回值迭代器  \n-  entries() &emsp;返回键值迭代器\n-  forEach()\n```Javascript\nconst set = new Set(['a', 'b', 'c']);\n// set每个值对应的key其实也是数据值本身\nconst keyIter = set.keys();\nconsole.log(keyIter.next().value);  // 'a'\nconsole.log(keyIter.next().value);  // 'b'\nconsole.log(keyIter.next().value);  // 'c'\nconsole.log(keyIter.next().value);  // undefined\n\nconst valueIter = set.values();\nfor(let val of valueIter) {\n  console.log(val);                // 'a', 'b', 'c'\n}\n\nconst entriesIter = set.entries();\nfor(let [key, value] of entriesIter) {\n  console(`${key}:${value}`)     // 'a':'a', 'b':'b', 'c':'c'\n}\n\nset.forEach(val => {\n  console.log(val)             // 'a', 'b', 'c'\n})\n```\n</br>\n\n**Map数据的遍历方式**\n-  keys()   &emsp;&emsp;返回键名迭代器\n-  values() &emsp;返回值迭代器  \n-  entries() &emsp;返回键值迭代器\n-  forEach()\n\n```Javascript\nconst map = new Map([['a', 1], ['b', '2']]);\n/**\n* 代码就自己脑补吧，\n* 不能说和Set的方式很像，\n* 只能说真的就是一模一样\n**/\n```\n</br>\n\n**Array数据的遍历方式**\n\nArray遍历数据的方法是最多的，除了下面列举的几个之外，还有some, every,甚至filter, find和findIndex这些方法可以用来遍历数据。使用这些方法需要注意的是其使用的场景，例如map和forEach都可以用来对数组内数据做一些操作，但如果不需要返回值的情况，还是使用forEach方法，而不建议是map，其它方法也是如此。\n\n-  keys()   &emsp;&emsp;返回键名迭代器\n-  values() &emsp;返回值迭代器  \n-  entries() &emsp;返回键值迭代器\n-  map()    &emsp;回调函数，要有返回值\n-  reduce() \n-  forEach()\n-  for...of\n```Javascript\n/**\n* 代码就不写了，偷个懒，不过还是贴心的附上链接\n* https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array\n**/\n```\n\n\n## 类似的功能和一些专有方法\n- **是否包含某个元素**: 数组的includes方法，map和set的has方法，三者的返回值都是布尔值，区别只在于传入的参数。数组和set传入的是值，map传入的是键。\n- **合并两个相同类型的数据**： 数组使用concat方法，合并两个数组值，set使用union方法合并两个集合。map没有专有方法可以用来合并两个map数据，不过可以通过使用new Map([...map1, ...map2])来返回一个合并之后的新map\n- **数据大小**：数组有length属性，map和set有size属性\n- **清空数据**：map和size都可通过clear()方法来清空数据，数组无专有方法，可自己通过修改length值为0或者使用splice方法清空数据。\n\n>关于数组中的includes方法在数组值为一个个对象的时候，这个时候传入的值就只能是对象的引用了。如果作用域内不存在引用的话，判断数组中是否存在某个对象，就只能通过filter, find或者findIndex之类的方法加上数据特征去判断数组中是否存在该对象了。\n\n  \n## 三者之间的转换\n\n\n```Javascript\nconst arr = [1, 3, 4, 4];\nconst arr1 = [['a', 'Kebei']];\nconst map = new Map(['a', 1], ['b', 2]);\nconst set = new Set([1, 5]);\n\n// Array 转 Set\nconst arr2Set = new Set(arr);   // [1, 3, 4];\n// Array 转Map\nconst arr2Map = new Map(arr1);  // {'a' => 'Kebei'}\n\n//Set转Array\nconst set2Arr = Array.from(set);        // [1, 5]\nconst set2Arr2 = [...set];              // [1, 5]\nconst set2Arr3 = set.values()           // [1, 5]\n//Set转Map\nconst set2Map = new Map(set.entries())  // { 1=> 1, 5=>5}\n\n// Map转Array\nconst map2Arr = Array.from(map);     // ['a', 1], ['b', 2]\nconst map2Arr2 = [...map];           // ['a', 1], ['b', 2]\nconst map2Arr3 = map.values()        // ['a', 1], ['b', 2]\n// Map转Set\nconst map2Set = new Set(map.values()) // [1, 2]\n```\n## 应用场景\n</br>\n最常见的一种场景莫过于使用数组与Set之间格式变化进行数据去重\n\n```Javascript\n  const dedup = (arr) => {\n    return [...new Set(arr)]\n  }\n```\n上述方法和之前includes方法也是一样存在无法处理复杂数据类型，对于复杂对象数据，需要根据各自业务场景对重复的数据进行去重策略选择，即在一堆的重复对象中（以id重复为例）保留业务需要的唯一一个数据。\n\n## 总结\n三种数据结构有着各自不同的特性。数组是一个天然的栈，也是一个天然的队列，在三种数据结构中，其实例方法也应用也是最多的，是线性存储中话事人般的存在，也是我们在普通业务场景下的首选。Set数据的唯一性，可以帮助我们在业务场景中快速的进行去重。Map键值对结构的特殊性，以及对键的包容性，能够通过键快速获取到值，也是复杂业务冲常常用的。\n</br>\n\n【资料参考】\n  1. https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array\n  2. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\n  3. https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map","slug":"Array-set-map-summary","published":1,"updated":"2025-06-07T16:18:15.823Z","comments":1,"layout":"post","photos":[],"_id":"cmjbml2hr0000ikup4du97din","content":"<p>Array,Set和Map三个作为Javascript中可迭代的集合数据类型，在编程过程中使用的频率也比较高。针对三种数据类型各自的一些特性，本文的内容将从以下几个方面来上述数据类型做一个总结。</p>\n<ul>\n<li><a href=\"##%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%88%9B%E5%BB%BA\"><strong>实例的创建</strong></a></li>\n<li><a href=\"##%E6%95%B0%E6%8D%AE%E6%B7%BB%E5%8A%A0\"><strong>数据添加</strong></a></li>\n<li><a href=\"##%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%EF%BC%88%E6%9F%A5%E6%89%BE%EF%BC%89\"><strong>数据访问（查找）</strong></a></li>\n<li><a href=\"##%E6%95%B0%E6%8D%AE%E7%9A%84%E9%81%8D%E5%8E%86\"><strong>数据的遍历</strong></a></li>\n<li><a href=\"##%E7%B1%BB%E4%BC%BC%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E4%B8%80%E4%BA%9B%E4%B8%93%E6%9C%89%E6%96%B9%E6%B3%95\"><strong>类似的功能和一些专有方法</strong></a></li>\n<li><a href=\"##%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2\"><strong>三者之间的转换</strong></a></li>\n<li><a href=\"##%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\"><strong>应用场景</strong></a></li>\n</ul>\n<h2 id=\"实例的创建\"><a href=\"#实例的创建\" class=\"headerlink\" title=\"实例的创建\"></a>实例的创建</h2><p>  Map和Set创建实例的方式是唯一的，只允许通过new调用构造方法来创建一个实例。值得注意的是，Set和Map在调用构造函数的时候，传参都是数组或者可迭代对象，其中Map的传参数组需要时一个键值对数组。当然，传参也是可选的，非必须。</p>\n<p> Array相较于前两者，其创建实例的方式要多写，可通过字面方式创建，也可像Map和Set一样通过构造函数来创建。此外使用Array的静态函数Array.from来创建也是非常常见的。例如，通过docuemnt.getElementsByTagName这类方法获取到一个HTMLCollect这样一个类数组，通常会通过Array.from将其装换成一个真正的数组来进行后续的操作。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><br> <span class=\"hljs-comment\">// 创建map实例</span><br> <span class=\"hljs-keyword\">let</span> map1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();<br> <span class=\"hljs-keyword\">let</span> map2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">1</span>], [<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-number\">2</span>]]); <span class=\"hljs-comment\">//  a=&gt;1, b=&gt;2</span><br> <span class=\"hljs-comment\">// 创建set实例</span><br> <span class=\"hljs-keyword\">let</span> set1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>();<br> <span class=\"hljs-keyword\">let</span> set2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>])<br><br><span class=\"hljs-comment\">// 通过字面量创建数组</span><br><span class=\"hljs-keyword\">let</span> arr1 = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>];<br><span class=\"hljs-comment\">// 使用Array静态方法从一个可迭代对象或者类数组中创建数组实例</span><br><span class=\"hljs-keyword\">let</span> arr2 = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>([<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>]) <br><span class=\"hljs-comment\">// 使用Array构造函数</span><br><span class=\"hljs-keyword\">let</span> arr3 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Array</span>([<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">7</span>]);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"数据添加与变更\"><a href=\"#数据添加与变更\" class=\"headerlink\" title=\"数据添加与变更\"></a>数据添加与变更</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">// Set的数据操作：添加与删除</span><br><span class=\"hljs-keyword\">let</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>();<br>set.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">11</span>) <span class=\"hljs-comment\">// [11]</span><br>set.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">23</span>) <span class=\"hljs-comment\">// [11, 23]</span><br>set.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">11</span>) <span class=\"hljs-comment\">// [11, 23]</span><br>set.<span class=\"hljs-title function_\">delete</span>(<span class=\"hljs-number\">23</span>) <span class=\"hljs-comment\">// [11] </span><br><br><span class=\"hljs-comment\">// Map的数据操作：添加与删除</span><br><span class=\"hljs-keyword\">let</span>  map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();<br>map.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">1</span>);   <span class=\"hljs-comment\">// [a=&gt;1]</span><br>map.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-number\">2</span>);   <span class=\"hljs-comment\">// [a=&gt;1, b=&gt;2]</span><br>map.<span class=\"hljs-title function_\">delete</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>);   <span class=\"hljs-comment\">// [a=&gt;1]</span><br><br><span class=\"hljs-comment\">// Array</span><br><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>]<br><span class=\"hljs-comment\">// 在数组末尾添加一个值</span><br>arr.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-number\">4</span>)       <span class=\"hljs-comment\">// [1,2,3,4]</span><br><span class=\"hljs-comment\">// 弹出数组末尾的值</span><br>arr.<span class=\"hljs-title function_\">pop</span>(<span class=\"hljs-number\">4</span>)        <span class=\"hljs-comment\">// [1,2,3]</span><br><span class=\"hljs-comment\">// 在数组头部添加一个值</span><br>arr.<span class=\"hljs-title function_\">unshift</span>(<span class=\"hljs-number\">0</span>)    <span class=\"hljs-comment\">// [0,1,2,3]</span><br><span class=\"hljs-comment\">// 移除头部的第一个值</span><br>arr.<span class=\"hljs-title function_\">shift</span>()       <span class=\"hljs-comment\">// [1,2,3]</span><br><span class=\"hljs-comment\">// 在第二个数（下标1）之后插入一个值‘a’</span><br>arr.<span class=\"hljs-title function_\">splice</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-string\">&#x27;a&#x27;</span>)   <span class=\"hljs-comment\">// [1,2,&#x27;a&#x27;, 3];</span><br><span class=\"hljs-comment\">// 删除第二个数（下标1）后面1个值，然后插入一个新的值‘b’</span><br>arr.<span class=\"hljs-title function_\">splice</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">&#x27;b&#x27;</span>)   <span class=\"hljs-comment\">// [1,2,&#x27;b&#x27;,3]</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"数据访问\"><a href=\"#数据访问\" class=\"headerlink\" title=\"数据访问\"></a>数据访问</h2><p>  Array和Map都能够访问实例中的特定数据，Array是通过下标，而Map是通过实例方法get, 唯独Set没有方式可以直接访问其中特定数据。其实也不难理解，Set本身不是为了单纯存储数据和访问特殊而生的，因为这些功能Array就可以支持，何必再单出构造一个Set数据结构了。我对此的理解是，Set跟多的是紧紧围绕着数据唯一不重复这一准则来的，它的侧重点是某一数据的有无，而不是数据存在哪里。</p>\n<p>  另外，从结构上来说。Set不像Array那样是有序的，所以也无法使用下标来访问，也不像Map那般，每个键对应一个值，所以也无法通过键来访问。故而，Set没有单独访问某一数据的方式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>];<br><span class=\"hljs-keyword\">const</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>]);<br><span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">1</span>], [<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;2&#x27;</span>]]);<br><br><span class=\"hljs-comment\">//Array通过下标访问数据</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(arr[<span class=\"hljs-number\">0</span>], arr[<span class=\"hljs-number\">2</span>]) <span class=\"hljs-comment\">// 1, 3</span><br><span class=\"hljs-comment\">//Map使用实例方法get访问数据，参数是键</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(mpa.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;a))    // 1</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"数据的遍历\"><a href=\"#数据的遍历\" class=\"headerlink\" title=\"数据的遍历\"></a>数据的遍历</h2><p><strong>Set数据的遍历方式</strong>：</p>\n<ul>\n<li>keys()   &emsp;&emsp;返回键名迭代器</li>\n<li>values() &emsp;返回值迭代器  </li>\n<li>entries() &emsp;返回键值迭代器</li>\n<li>forEach()<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">const</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>]);<br><span class=\"hljs-comment\">// set每个值对应的key其实也是数据值本身</span><br><span class=\"hljs-keyword\">const</span> keyIter = set.<span class=\"hljs-title function_\">keys</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(keyIter.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>);  <span class=\"hljs-comment\">// &#x27;a&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(keyIter.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>);  <span class=\"hljs-comment\">// &#x27;b&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(keyIter.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>);  <span class=\"hljs-comment\">// &#x27;c&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(keyIter.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>);  <span class=\"hljs-comment\">// undefined</span><br><br><span class=\"hljs-keyword\">const</span> valueIter = set.<span class=\"hljs-title function_\">values</span>();<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> val <span class=\"hljs-keyword\">of</span> valueIter) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(val);                <span class=\"hljs-comment\">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span><br>&#125;<br><br><span class=\"hljs-keyword\">const</span> entriesIter = set.<span class=\"hljs-title function_\">entries</span>();<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> [key, value] <span class=\"hljs-keyword\">of</span> entriesIter) &#123;<br>  <span class=\"hljs-title function_\">console</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;key&#125;</span>:<span class=\"hljs-subst\">$&#123;value&#125;</span>`</span>)     <span class=\"hljs-comment\">// &#x27;a&#x27;:&#x27;a&#x27;, &#x27;b&#x27;:&#x27;b&#x27;, &#x27;c&#x27;:&#x27;c&#x27;</span><br>&#125;<br><br>set.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">val</span> =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(val)             <span class=\"hljs-comment\">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n</br></li>\n</ul>\n<p><strong>Map数据的遍历方式</strong></p>\n<ul>\n<li>keys()   &emsp;&emsp;返回键名迭代器</li>\n<li>values() &emsp;返回值迭代器  </li>\n<li>entries() &emsp;返回键值迭代器</li>\n<li>forEach()</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">1</span>], [<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;2&#x27;</span>]]);<br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">* 代码就自己脑补吧，</span><br><span class=\"hljs-comment\">* 不能说和Set的方式很像，</span><br><span class=\"hljs-comment\">* 只能说真的就是一模一样</span><br><span class=\"hljs-comment\">**/</span><br></code></pre></td></tr></table></figure>\n</br>\n\n<p><strong>Array数据的遍历方式</strong></p>\n<p>Array遍历数据的方法是最多的，除了下面列举的几个之外，还有some, every,甚至filter, find和findIndex这些方法可以用来遍历数据。使用这些方法需要注意的是其使用的场景，例如map和forEach都可以用来对数组内数据做一些操作，但如果不需要返回值的情况，还是使用forEach方法，而不建议是map，其它方法也是如此。</p>\n<ul>\n<li>keys()   &emsp;&emsp;返回键名迭代器</li>\n<li>values() &emsp;返回值迭代器  </li>\n<li>entries() &emsp;返回键值迭代器</li>\n<li>map()    &emsp;回调函数，要有返回值</li>\n<li>reduce() </li>\n<li>forEach()</li>\n<li>for…of<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">* 代码就不写了，偷个懒，不过还是贴心的附上链接</span><br><span class=\"hljs-comment\">* https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array</span><br><span class=\"hljs-comment\">**/</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"类似的功能和一些专有方法\"><a href=\"#类似的功能和一些专有方法\" class=\"headerlink\" title=\"类似的功能和一些专有方法\"></a>类似的功能和一些专有方法</h2><ul>\n<li><strong>是否包含某个元素</strong>: 数组的includes方法，map和set的has方法，三者的返回值都是布尔值，区别只在于传入的参数。数组和set传入的是值，map传入的是键。</li>\n<li><strong>合并两个相同类型的数据</strong>： 数组使用concat方法，合并两个数组值，set使用union方法合并两个集合。map没有专有方法可以用来合并两个map数据，不过可以通过使用new Map([…map1, …map2])来返回一个合并之后的新map</li>\n<li><strong>数据大小</strong>：数组有length属性，map和set有size属性</li>\n<li><strong>清空数据</strong>：map和size都可通过clear()方法来清空数据，数组无专有方法，可自己通过修改length值为0或者使用splice方法清空数据。</li>\n</ul>\n<blockquote>\n<p>关于数组中的includes方法在数组值为一个个对象的时候，这个时候传入的值就只能是对象的引用了。如果作用域内不存在引用的话，判断数组中是否存在某个对象，就只能通过filter, find或者findIndex之类的方法加上数据特征去判断数组中是否存在该对象了。</p>\n</blockquote>\n<h2 id=\"三者之间的转换\"><a href=\"#三者之间的转换\" class=\"headerlink\" title=\"三者之间的转换\"></a>三者之间的转换</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">4</span>];<br><span class=\"hljs-keyword\">const</span> arr1 = [[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;Kebei&#x27;</span>]];<br><span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">1</span>], [<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-number\">2</span>]);<br><span class=\"hljs-keyword\">const</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>]);<br><br><span class=\"hljs-comment\">// Array 转 Set</span><br><span class=\"hljs-keyword\">const</span> arr2Set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>(arr);   <span class=\"hljs-comment\">// [1, 3, 4];</span><br><span class=\"hljs-comment\">// Array 转Map</span><br><span class=\"hljs-keyword\">const</span> arr2Map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(arr1);  <span class=\"hljs-comment\">// &#123;&#x27;a&#x27; =&gt; &#x27;Kebei&#x27;&#125;</span><br><br><span class=\"hljs-comment\">//Set转Array</span><br><span class=\"hljs-keyword\">const</span> set2Arr = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(set);        <span class=\"hljs-comment\">// [1, 5]</span><br><span class=\"hljs-keyword\">const</span> set2Arr2 = [...set];              <span class=\"hljs-comment\">// [1, 5]</span><br><span class=\"hljs-keyword\">const</span> set2Arr3 = set.<span class=\"hljs-title function_\">values</span>()           <span class=\"hljs-comment\">// [1, 5]</span><br><span class=\"hljs-comment\">//Set转Map</span><br><span class=\"hljs-keyword\">const</span> set2Map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(set.<span class=\"hljs-title function_\">entries</span>())  <span class=\"hljs-comment\">// &#123; 1=&gt; 1, 5=&gt;5&#125;</span><br><br><span class=\"hljs-comment\">// Map转Array</span><br><span class=\"hljs-keyword\">const</span> map2Arr = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(map);     <span class=\"hljs-comment\">// [&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2]</span><br><span class=\"hljs-keyword\">const</span> map2Arr2 = [...map];           <span class=\"hljs-comment\">// [&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2]</span><br><span class=\"hljs-keyword\">const</span> map2Arr3 = map.<span class=\"hljs-title function_\">values</span>()        <span class=\"hljs-comment\">// [&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2]</span><br><span class=\"hljs-comment\">// Map转Set</span><br><span class=\"hljs-keyword\">const</span> map2Set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>(map.<span class=\"hljs-title function_\">values</span>()) <span class=\"hljs-comment\">// [1, 2]</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2></br>\n最常见的一种场景莫过于使用数组与Set之间格式变化进行数据去重\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">dedup</span> = (<span class=\"hljs-params\">arr</span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">return</span> [...<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>(arr)]<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>上述方法和之前includes方法也是一样存在无法处理复杂数据类型，对于复杂对象数据，需要根据各自业务场景对重复的数据进行去重策略选择，即在一堆的重复对象中（以id重复为例）保留业务需要的唯一一个数据。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>三种数据结构有着各自不同的特性。数组是一个天然的栈，也是一个天然的队列，在三种数据结构中，其实例方法也应用也是最多的，是线性存储中话事人般的存在，也是我们在普通业务场景下的首选。Set数据的唯一性，可以帮助我们在业务场景中快速的进行去重。Map键值对结构的特殊性，以及对键的包容性，能够通过键快速获取到值，也是复杂业务冲常常用的。<br></br></p>\n<p>【资料参考】</p>\n<ol>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map</a></li>\n</ol>\n","excerpt":"","more":"<p>Array,Set和Map三个作为Javascript中可迭代的集合数据类型，在编程过程中使用的频率也比较高。针对三种数据类型各自的一些特性，本文的内容将从以下几个方面来上述数据类型做一个总结。</p>\n<ul>\n<li><a href=\"##%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%88%9B%E5%BB%BA\"><strong>实例的创建</strong></a></li>\n<li><a href=\"##%E6%95%B0%E6%8D%AE%E6%B7%BB%E5%8A%A0\"><strong>数据添加</strong></a></li>\n<li><a href=\"##%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%EF%BC%88%E6%9F%A5%E6%89%BE%EF%BC%89\"><strong>数据访问（查找）</strong></a></li>\n<li><a href=\"##%E6%95%B0%E6%8D%AE%E7%9A%84%E9%81%8D%E5%8E%86\"><strong>数据的遍历</strong></a></li>\n<li><a href=\"##%E7%B1%BB%E4%BC%BC%E7%9A%84%E5%8A%9F%E8%83%BD%E5%92%8C%E4%B8%80%E4%BA%9B%E4%B8%93%E6%9C%89%E6%96%B9%E6%B3%95\"><strong>类似的功能和一些专有方法</strong></a></li>\n<li><a href=\"##%E4%B8%89%E8%80%85%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2\"><strong>三者之间的转换</strong></a></li>\n<li><a href=\"##%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\"><strong>应用场景</strong></a></li>\n</ul>\n<h2 id=\"实例的创建\"><a href=\"#实例的创建\" class=\"headerlink\" title=\"实例的创建\"></a>实例的创建</h2><p>  Map和Set创建实例的方式是唯一的，只允许通过new调用构造方法来创建一个实例。值得注意的是，Set和Map在调用构造函数的时候，传参都是数组或者可迭代对象，其中Map的传参数组需要时一个键值对数组。当然，传参也是可选的，非必须。</p>\n<p> Array相较于前两者，其创建实例的方式要多写，可通过字面方式创建，也可像Map和Set一样通过构造函数来创建。此外使用Array的静态函数Array.from来创建也是非常常见的。例如，通过docuemnt.getElementsByTagName这类方法获取到一个HTMLCollect这样一个类数组，通常会通过Array.from将其装换成一个真正的数组来进行后续的操作。</p>\n  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><br> <span class=\"hljs-comment\">// 创建map实例</span><br> <span class=\"hljs-keyword\">let</span> map1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();<br> <span class=\"hljs-keyword\">let</span> map2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">1</span>], [<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-number\">2</span>]]); <span class=\"hljs-comment\">//  a=&gt;1, b=&gt;2</span><br> <span class=\"hljs-comment\">// 创建set实例</span><br> <span class=\"hljs-keyword\">let</span> set1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>();<br> <span class=\"hljs-keyword\">let</span> set2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>])<br><br><span class=\"hljs-comment\">// 通过字面量创建数组</span><br><span class=\"hljs-keyword\">let</span> arr1 = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>];<br><span class=\"hljs-comment\">// 使用Array静态方法从一个可迭代对象或者类数组中创建数组实例</span><br><span class=\"hljs-keyword\">let</span> arr2 = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>([<span class=\"hljs-number\">4</span>,<span class=\"hljs-number\">5</span>]) <br><span class=\"hljs-comment\">// 使用Array构造函数</span><br><span class=\"hljs-keyword\">let</span> arr3 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Array</span>([<span class=\"hljs-number\">6</span>,<span class=\"hljs-number\">7</span>]);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"数据添加与变更\"><a href=\"#数据添加与变更\" class=\"headerlink\" title=\"数据添加与变更\"></a>数据添加与变更</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">// Set的数据操作：添加与删除</span><br><span class=\"hljs-keyword\">let</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>();<br>set.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">11</span>) <span class=\"hljs-comment\">// [11]</span><br>set.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">23</span>) <span class=\"hljs-comment\">// [11, 23]</span><br>set.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">11</span>) <span class=\"hljs-comment\">// [11, 23]</span><br>set.<span class=\"hljs-title function_\">delete</span>(<span class=\"hljs-number\">23</span>) <span class=\"hljs-comment\">// [11] </span><br><br><span class=\"hljs-comment\">// Map的数据操作：添加与删除</span><br><span class=\"hljs-keyword\">let</span>  map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();<br>map.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">1</span>);   <span class=\"hljs-comment\">// [a=&gt;1]</span><br>map.<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-number\">2</span>);   <span class=\"hljs-comment\">// [a=&gt;1, b=&gt;2]</span><br>map.<span class=\"hljs-title function_\">delete</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>);   <span class=\"hljs-comment\">// [a=&gt;1]</span><br><br><span class=\"hljs-comment\">// Array</span><br><span class=\"hljs-keyword\">let</span> arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>]<br><span class=\"hljs-comment\">// 在数组末尾添加一个值</span><br>arr.<span class=\"hljs-title function_\">push</span>(<span class=\"hljs-number\">4</span>)       <span class=\"hljs-comment\">// [1,2,3,4]</span><br><span class=\"hljs-comment\">// 弹出数组末尾的值</span><br>arr.<span class=\"hljs-title function_\">pop</span>(<span class=\"hljs-number\">4</span>)        <span class=\"hljs-comment\">// [1,2,3]</span><br><span class=\"hljs-comment\">// 在数组头部添加一个值</span><br>arr.<span class=\"hljs-title function_\">unshift</span>(<span class=\"hljs-number\">0</span>)    <span class=\"hljs-comment\">// [0,1,2,3]</span><br><span class=\"hljs-comment\">// 移除头部的第一个值</span><br>arr.<span class=\"hljs-title function_\">shift</span>()       <span class=\"hljs-comment\">// [1,2,3]</span><br><span class=\"hljs-comment\">// 在第二个数（下标1）之后插入一个值‘a’</span><br>arr.<span class=\"hljs-title function_\">splice</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">0</span>,<span class=\"hljs-string\">&#x27;a&#x27;</span>)   <span class=\"hljs-comment\">// [1,2,&#x27;a&#x27;, 3];</span><br><span class=\"hljs-comment\">// 删除第二个数（下标1）后面1个值，然后插入一个新的值‘b’</span><br>arr.<span class=\"hljs-title function_\">splice</span>(<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">1</span>,<span class=\"hljs-string\">&#x27;b&#x27;</span>)   <span class=\"hljs-comment\">// [1,2,&#x27;b&#x27;,3]</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"数据访问\"><a href=\"#数据访问\" class=\"headerlink\" title=\"数据访问\"></a>数据访问</h2><p>  Array和Map都能够访问实例中的特定数据，Array是通过下标，而Map是通过实例方法get, 唯独Set没有方式可以直接访问其中特定数据。其实也不难理解，Set本身不是为了单纯存储数据和访问特殊而生的，因为这些功能Array就可以支持，何必再单出构造一个Set数据结构了。我对此的理解是，Set跟多的是紧紧围绕着数据唯一不重复这一准则来的，它的侧重点是某一数据的有无，而不是数据存在哪里。</p>\n<p>  另外，从结构上来说。Set不像Array那样是有序的，所以也无法使用下标来访问，也不像Map那般，每个键对应一个值，所以也无法通过键来访问。故而，Set没有单独访问某一数据的方式。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>];<br><span class=\"hljs-keyword\">const</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>]);<br><span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">1</span>], [<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;2&#x27;</span>]]);<br><br><span class=\"hljs-comment\">//Array通过下标访问数据</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(arr[<span class=\"hljs-number\">0</span>], arr[<span class=\"hljs-number\">2</span>]) <span class=\"hljs-comment\">// 1, 3</span><br><span class=\"hljs-comment\">//Map使用实例方法get访问数据，参数是键</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(mpa.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;a))    // 1</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"数据的遍历\"><a href=\"#数据的遍历\" class=\"headerlink\" title=\"数据的遍历\"></a>数据的遍历</h2><p><strong>Set数据的遍历方式</strong>：</p>\n<ul>\n<li>keys()   &emsp;&emsp;返回键名迭代器</li>\n<li>values() &emsp;返回值迭代器  </li>\n<li>entries() &emsp;返回键值迭代器</li>\n<li>forEach()<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">const</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>]);<br><span class=\"hljs-comment\">// set每个值对应的key其实也是数据值本身</span><br><span class=\"hljs-keyword\">const</span> keyIter = set.<span class=\"hljs-title function_\">keys</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(keyIter.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>);  <span class=\"hljs-comment\">// &#x27;a&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(keyIter.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>);  <span class=\"hljs-comment\">// &#x27;b&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(keyIter.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>);  <span class=\"hljs-comment\">// &#x27;c&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(keyIter.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>);  <span class=\"hljs-comment\">// undefined</span><br><br><span class=\"hljs-keyword\">const</span> valueIter = set.<span class=\"hljs-title function_\">values</span>();<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> val <span class=\"hljs-keyword\">of</span> valueIter) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(val);                <span class=\"hljs-comment\">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span><br>&#125;<br><br><span class=\"hljs-keyword\">const</span> entriesIter = set.<span class=\"hljs-title function_\">entries</span>();<br><span class=\"hljs-keyword\">for</span>(<span class=\"hljs-keyword\">let</span> [key, value] <span class=\"hljs-keyword\">of</span> entriesIter) &#123;<br>  <span class=\"hljs-title function_\">console</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;key&#125;</span>:<span class=\"hljs-subst\">$&#123;value&#125;</span>`</span>)     <span class=\"hljs-comment\">// &#x27;a&#x27;:&#x27;a&#x27;, &#x27;b&#x27;:&#x27;b&#x27;, &#x27;c&#x27;:&#x27;c&#x27;</span><br>&#125;<br><br>set.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">val</span> =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(val)             <span class=\"hljs-comment\">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure>\n</br></li>\n</ul>\n<p><strong>Map数据的遍历方式</strong></p>\n<ul>\n<li>keys()   &emsp;&emsp;返回键名迭代器</li>\n<li>values() &emsp;返回值迭代器  </li>\n<li>entries() &emsp;返回键值迭代器</li>\n<li>forEach()</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">1</span>], [<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;2&#x27;</span>]]);<br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">* 代码就自己脑补吧，</span><br><span class=\"hljs-comment\">* 不能说和Set的方式很像，</span><br><span class=\"hljs-comment\">* 只能说真的就是一模一样</span><br><span class=\"hljs-comment\">**/</span><br></code></pre></td></tr></table></figure>\n</br>\n\n<p><strong>Array数据的遍历方式</strong></p>\n<p>Array遍历数据的方法是最多的，除了下面列举的几个之外，还有some, every,甚至filter, find和findIndex这些方法可以用来遍历数据。使用这些方法需要注意的是其使用的场景，例如map和forEach都可以用来对数组内数据做一些操作，但如果不需要返回值的情况，还是使用forEach方法，而不建议是map，其它方法也是如此。</p>\n<ul>\n<li>keys()   &emsp;&emsp;返回键名迭代器</li>\n<li>values() &emsp;返回值迭代器  </li>\n<li>entries() &emsp;返回键值迭代器</li>\n<li>map()    &emsp;回调函数，要有返回值</li>\n<li>reduce() </li>\n<li>forEach()</li>\n<li>for…of<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">* 代码就不写了，偷个懒，不过还是贴心的附上链接</span><br><span class=\"hljs-comment\">* https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array</span><br><span class=\"hljs-comment\">**/</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"类似的功能和一些专有方法\"><a href=\"#类似的功能和一些专有方法\" class=\"headerlink\" title=\"类似的功能和一些专有方法\"></a>类似的功能和一些专有方法</h2><ul>\n<li><strong>是否包含某个元素</strong>: 数组的includes方法，map和set的has方法，三者的返回值都是布尔值，区别只在于传入的参数。数组和set传入的是值，map传入的是键。</li>\n<li><strong>合并两个相同类型的数据</strong>： 数组使用concat方法，合并两个数组值，set使用union方法合并两个集合。map没有专有方法可以用来合并两个map数据，不过可以通过使用new Map([…map1, …map2])来返回一个合并之后的新map</li>\n<li><strong>数据大小</strong>：数组有length属性，map和set有size属性</li>\n<li><strong>清空数据</strong>：map和size都可通过clear()方法来清空数据，数组无专有方法，可自己通过修改length值为0或者使用splice方法清空数据。</li>\n</ul>\n<blockquote>\n<p>关于数组中的includes方法在数组值为一个个对象的时候，这个时候传入的值就只能是对象的引用了。如果作用域内不存在引用的话，判断数组中是否存在某个对象，就只能通过filter, find或者findIndex之类的方法加上数据特征去判断数组中是否存在该对象了。</p>\n</blockquote>\n<h2 id=\"三者之间的转换\"><a href=\"#三者之间的转换\" class=\"headerlink\" title=\"三者之间的转换\"></a>三者之间的转换</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">4</span>];<br><span class=\"hljs-keyword\">const</span> arr1 = [[<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;Kebei&#x27;</span>]];<br><span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">1</span>], [<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-number\">2</span>]);<br><span class=\"hljs-keyword\">const</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>]);<br><br><span class=\"hljs-comment\">// Array 转 Set</span><br><span class=\"hljs-keyword\">const</span> arr2Set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>(arr);   <span class=\"hljs-comment\">// [1, 3, 4];</span><br><span class=\"hljs-comment\">// Array 转Map</span><br><span class=\"hljs-keyword\">const</span> arr2Map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(arr1);  <span class=\"hljs-comment\">// &#123;&#x27;a&#x27; =&gt; &#x27;Kebei&#x27;&#125;</span><br><br><span class=\"hljs-comment\">//Set转Array</span><br><span class=\"hljs-keyword\">const</span> set2Arr = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(set);        <span class=\"hljs-comment\">// [1, 5]</span><br><span class=\"hljs-keyword\">const</span> set2Arr2 = [...set];              <span class=\"hljs-comment\">// [1, 5]</span><br><span class=\"hljs-keyword\">const</span> set2Arr3 = set.<span class=\"hljs-title function_\">values</span>()           <span class=\"hljs-comment\">// [1, 5]</span><br><span class=\"hljs-comment\">//Set转Map</span><br><span class=\"hljs-keyword\">const</span> set2Map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(set.<span class=\"hljs-title function_\">entries</span>())  <span class=\"hljs-comment\">// &#123; 1=&gt; 1, 5=&gt;5&#125;</span><br><br><span class=\"hljs-comment\">// Map转Array</span><br><span class=\"hljs-keyword\">const</span> map2Arr = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(map);     <span class=\"hljs-comment\">// [&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2]</span><br><span class=\"hljs-keyword\">const</span> map2Arr2 = [...map];           <span class=\"hljs-comment\">// [&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2]</span><br><span class=\"hljs-keyword\">const</span> map2Arr3 = map.<span class=\"hljs-title function_\">values</span>()        <span class=\"hljs-comment\">// [&#x27;a&#x27;, 1], [&#x27;b&#x27;, 2]</span><br><span class=\"hljs-comment\">// Map转Set</span><br><span class=\"hljs-keyword\">const</span> map2Set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>(map.<span class=\"hljs-title function_\">values</span>()) <span class=\"hljs-comment\">// [1, 2]</span><br></code></pre></td></tr></table></figure>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2></br>\n最常见的一种场景莫过于使用数组与Set之间格式变化进行数据去重\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">dedup</span> = (<span class=\"hljs-params\">arr</span>) =&gt; &#123;<br>  <span class=\"hljs-keyword\">return</span> [...<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>(arr)]<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>上述方法和之前includes方法也是一样存在无法处理复杂数据类型，对于复杂对象数据，需要根据各自业务场景对重复的数据进行去重策略选择，即在一堆的重复对象中（以id重复为例）保留业务需要的唯一一个数据。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>三种数据结构有着各自不同的特性。数组是一个天然的栈，也是一个天然的队列，在三种数据结构中，其实例方法也应用也是最多的，是线性存储中话事人般的存在，也是我们在普通业务场景下的首选。Set数据的唯一性，可以帮助我们在业务场景中快速的进行去重。Map键值对结构的特殊性，以及对键的包容性，能够通过键快速获取到值，也是复杂业务冲常常用的。<br></br></p>\n<p>【资料参考】</p>\n<ol>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map\">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map</a></li>\n</ol>\n"},{"title":"Vue依赖收集和触发，看这些关键源码","date":"2025-05-23T04:40:00.000Z","_content":"\n从Vue开始较大范围在前端应用开始，关于Vue一些基础知识的讨论和面试问题就在开发圈子里基本上就跟前几年的股票和基金一样，楼下摆摊卖酱香饼的阿姨都能说上几句那种。找过前端开发工作或者正在找开发工作的前端都知道，面试官基本上都有那么几个常问的问题，而网上呢也有那么一套可以用来背诵的“八股文”，自己懂多少没有关系，应付面试官还是够的，可以算是屡试不爽吧。\n\n背诵面试八股文无可厚非的，可以说是每一个找工作的人都干过和必须干的事情，因为我们都要工作，都要恰饭。只有恰上饭，才能去谈些伟大的理想。背“八股文”本是一种捷径，尤其是本身对一门技术不是特别了解的开发者，就是那种刚刚能使用它那种。\n\n在众多关于Vue的面试“八股文”中，今天讲的是其中最常问的一个--Vue中的依赖收集。本文也将从代码层面，讲清楚关于依赖收集的几个问题。\n-  收集的依赖是什么？（what）\n-  怎么收集的依赖？  （how）\n-  什么时候收集？     (when)\n\n至于为什么要收集依赖(why)，现在就可以先告诉答案。**收集依赖，其核心作用是在数据发生变化的时候可以做出相应的动作，比如刷新视图**，为了执行这一动作，我们就得知道是谁在什么时候发生了变化，所以我们要收集依赖。\n\n\n下面我们结合代码，尽可能通俗的讲解关于上述的三个问题：\n\n\n\n在搞清楚依赖收集之前，先把源码中几个概念性的东西说明一下，建议下载[Vue3源码](https://github.com/vuejs/core)进行对照着看：\n-  **Dep**: 本质上是一个Map实例，同时在map实例上绑定一个celanup函数和一个computed属性。\n- **ReactiveEffect**: 相当于2.x版本中的Watcher类, 里头有一个deps数组，用来存dep, 每个实例里面都有一个track_id用来标识唯一性。\n\n- **effect函数**： 里头实例化一个ReactiveEffect对象，同时绑定一些options, 返回值是一个runner,实际上是对ReactiveEffect对象行为的一种业务封装。\n\n下面以一行简单的代码开始关于依赖收集的探索。\n```Javascript\nconst num = ref(1);\n```\n```Javascript\n// packages/reactivity/src/ref.ts\nexport function ref<T>(value: T): Ref<UnwrapRef<T>>\nexport function ref<T = any>(): Ref<T | undefined>\nexport function ref(value?: unknown) {\n  return createRef(value, false)\n}\n```\nref函数主要是对createRef做了一个函数包装，主要内容看到createRef函数。\n\n```Javascript\n// packages/reactivity/src/ref.ts\nfunction createRef(rawValue: unknown, shallow: boolean) {\n  if (isRef(rawValue)) {\n    return rawValue\n  }\n  return new RefImpl(rawValue, shallow)\n}\n```\ncreateRef函数在这里对原始数据rawValue做了一个判断，如果数据本身就是响应式数据了，就直接返回它本身，如果不是，就返回一个实例化的RefImpl对象。\n\n\n```Javascript\n// packages/reactivity/src/ref.ts\nclass RefImpl<T> {\n  private _value: T\n  private _rawValue: T\n\n  public dep?: Dep = undefined\n  public readonly __v_isRef = true\n\n  constructor(\n    value: T,\n    public readonly __v_isShallow: boolean,\n  ) {\n    this._rawValue = __v_isShallow ? value : toRaw(value)\n    this._value = __v_isShallow ? value : toReactive(value)\n  }\n\n  get value() {\n    trackRefValue(this)\n    return this._value\n  }\n\n  set value(newVal) {\n    const useDirectValue =\n      this.__v_isShallow || isShallow(newVal) || isReadonly(newVal)\n    newVal = useDirectValue ? newVal : toRaw(newVal)\n    if (hasChanged(newVal, this._rawValue)) {\n      this._rawValue = newVal\n      this._value = useDirectValue ? newVal : toReactive(newVal)\n      triggerRefValue(this, DirtyLevels.Dirty, newVal)\n    }\n  }\n}\n```\n重点来了，RefImple类里头，才是真正包含了从原始数据变成响应式数据，以及收集依赖的逻辑。在一个refImpl实例中，里面有一个dep对象，初始值是undefined， 这个dep会这trackRefValue函数执行的过程中被赋值。\n\n下面代码从17-21(get value())行，就是依赖收集的过程：当一个ref型响应式数据通过.value访问时，会触发RefImpl实例中的getter。它会首先执行一个trackValue函数，然后再返回_value值，所以接下来重点看关注trackValue函数，所以**依赖是在数据被访问的时候触发的**。\n\n```Javascript\n// packages/reactivity/src/ref.ts\nexport function trackRefValue(ref: RefBase<any>) {\n  if (shouldTrack && activeEffect) {\n    ref = toRaw(ref)\n    trackEffect(\n      activeEffect,\n      (ref.dep ??= createDep(\n        () => (ref.dep = undefined),\n        ref instanceof ComputedRefImpl ? ref : undefined,\n      )),\n      __DEV__\n        ? {\n            target: ref,\n            type: TrackOpTypes.GET,\n            key: 'value',\n          }\n        : void 0,\n    )\n  }\n}u\n```\n\ntrackRefValue函数中有两个变量，shouldTrack和activeEffect，暂时我们不去理会它们，只要知道shouldTrack是一个布尔值，activeEffect是一个RectiveEffect实例。\n\n在shouldTrack值为true且activeEffect有值的情况下，首先会将ref转成原始值，然后再执行trackEffect函数。\n\n在执行trackEffect函数的中，第一个是activeEffect, 在任意时刻它在全局是具有唯一性的；第二个是ref.dep, 其中给ref.dep的赋值函数createDep返回一个Dep实例，前面说过的，本质是个map; 第三个函数是个对象，是关于开发环境下debug的一些配置。\n\n在这里，我们可以看到，之前说个的ref实例中原来是undefined的ref.dep赋值，就在此处。\n\n```Javascript\n// packages/reactivity/src/effect.ts\nexport function trackEffect(\n  effect: ReactiveEffect,\n  dep: Dep,\n  debuggerEventExtraInfo?: DebuggerEventExtraInfo,\n) {\n  if (dep.get(effect) !== effect._trackId) {\n    dep.set(effect, effect._trackId)\n    const oldDep = effect.deps[effect._depsLength]\n    if (oldDep !== dep) {\n      if (oldDep) {\n        cleanupDepEffect(oldDep, effect)\n      }\n      effect.deps[effect._depsLength++] = dep\n    } else {\n      effect._depsLength++\n    }\n    if (__DEV__) {\n      effect.onTrack?.(extend({ effect }, debuggerEventExtraInfo!))\n    }\n  }\n}\n```\ntrackEffect函数绝对是依赖收集重头戏中的重头戏。\n\n首先上来就是一个判断，dep, 也就是ref中的dep，本质是个map，判断里面是否存在对应的effect, 如果没有，就执行接下来的操作。\n\ndep将effect也就是activeEffect作为键，其_trackId作为值添加到dep，**所以我们说的收集的依赖指的就是effect对象**。同时我们得到了一个关于**dep和effect之间的第一关系，即一个dep可以对应多个effect**。\n\n接着，将effects实例中deps数组中最后一个值取出来与当前的dep值进行比对，看是否是同一个值如果不是同一个值，而且oldDep是有值的，那么就执行cleanupDepEffect操作。如果oldDep为空值，就跳过这一步，直接往effect.deps中添加dep。因此，我们在这里得到了关于dep和effect第二个结论，**一个effect可以对应多个dep**。\n\n代码还有一部分，接着往下看，在oldDep不等于当前dep的时候，直接对effec_depsLength进行加操作，也就是说，effect.deps值没有变，但是_depsLength值却超出了deps数组边界的情况，这也就是为什么上面要判断oldDep是否存在的原因。\n\n\n由上面上面两个结论我们可以得出，一个dep中可以对应多个effect, 一个effect也可以对应多个dep, 因此dep和effect的关系是多对多的关系。\n\n### 总结\n\n-  收集的依赖是什么？（what）\n  > 我们常说的收集的依赖是effect对象\n\n-  怎么收集的依赖？  （how）\n > 判断当前数据dep中有没有activeEffct, 没有就加进去。把大象关进冰箱里要几步！！！\n-  什么时候收集？     (when)\n> 在数据被访问时，触发getter，进行依赖收集\n","source":"_posts/Dependencies-collecting-of-vue3.md","raw":"---\ntitle: Vue依赖收集和触发，看这些关键源码\ndate: 2025-05-23 12:40:00\ncategory: Vue源码阅读\ntags:\n  - Vue\n  - 源码阅读\n  - 依赖收集\n---\n\n从Vue开始较大范围在前端应用开始，关于Vue一些基础知识的讨论和面试问题就在开发圈子里基本上就跟前几年的股票和基金一样，楼下摆摊卖酱香饼的阿姨都能说上几句那种。找过前端开发工作或者正在找开发工作的前端都知道，面试官基本上都有那么几个常问的问题，而网上呢也有那么一套可以用来背诵的“八股文”，自己懂多少没有关系，应付面试官还是够的，可以算是屡试不爽吧。\n\n背诵面试八股文无可厚非的，可以说是每一个找工作的人都干过和必须干的事情，因为我们都要工作，都要恰饭。只有恰上饭，才能去谈些伟大的理想。背“八股文”本是一种捷径，尤其是本身对一门技术不是特别了解的开发者，就是那种刚刚能使用它那种。\n\n在众多关于Vue的面试“八股文”中，今天讲的是其中最常问的一个--Vue中的依赖收集。本文也将从代码层面，讲清楚关于依赖收集的几个问题。\n-  收集的依赖是什么？（what）\n-  怎么收集的依赖？  （how）\n-  什么时候收集？     (when)\n\n至于为什么要收集依赖(why)，现在就可以先告诉答案。**收集依赖，其核心作用是在数据发生变化的时候可以做出相应的动作，比如刷新视图**，为了执行这一动作，我们就得知道是谁在什么时候发生了变化，所以我们要收集依赖。\n\n\n下面我们结合代码，尽可能通俗的讲解关于上述的三个问题：\n\n\n\n在搞清楚依赖收集之前，先把源码中几个概念性的东西说明一下，建议下载[Vue3源码](https://github.com/vuejs/core)进行对照着看：\n-  **Dep**: 本质上是一个Map实例，同时在map实例上绑定一个celanup函数和一个computed属性。\n- **ReactiveEffect**: 相当于2.x版本中的Watcher类, 里头有一个deps数组，用来存dep, 每个实例里面都有一个track_id用来标识唯一性。\n\n- **effect函数**： 里头实例化一个ReactiveEffect对象，同时绑定一些options, 返回值是一个runner,实际上是对ReactiveEffect对象行为的一种业务封装。\n\n下面以一行简单的代码开始关于依赖收集的探索。\n```Javascript\nconst num = ref(1);\n```\n```Javascript\n// packages/reactivity/src/ref.ts\nexport function ref<T>(value: T): Ref<UnwrapRef<T>>\nexport function ref<T = any>(): Ref<T | undefined>\nexport function ref(value?: unknown) {\n  return createRef(value, false)\n}\n```\nref函数主要是对createRef做了一个函数包装，主要内容看到createRef函数。\n\n```Javascript\n// packages/reactivity/src/ref.ts\nfunction createRef(rawValue: unknown, shallow: boolean) {\n  if (isRef(rawValue)) {\n    return rawValue\n  }\n  return new RefImpl(rawValue, shallow)\n}\n```\ncreateRef函数在这里对原始数据rawValue做了一个判断，如果数据本身就是响应式数据了，就直接返回它本身，如果不是，就返回一个实例化的RefImpl对象。\n\n\n```Javascript\n// packages/reactivity/src/ref.ts\nclass RefImpl<T> {\n  private _value: T\n  private _rawValue: T\n\n  public dep?: Dep = undefined\n  public readonly __v_isRef = true\n\n  constructor(\n    value: T,\n    public readonly __v_isShallow: boolean,\n  ) {\n    this._rawValue = __v_isShallow ? value : toRaw(value)\n    this._value = __v_isShallow ? value : toReactive(value)\n  }\n\n  get value() {\n    trackRefValue(this)\n    return this._value\n  }\n\n  set value(newVal) {\n    const useDirectValue =\n      this.__v_isShallow || isShallow(newVal) || isReadonly(newVal)\n    newVal = useDirectValue ? newVal : toRaw(newVal)\n    if (hasChanged(newVal, this._rawValue)) {\n      this._rawValue = newVal\n      this._value = useDirectValue ? newVal : toReactive(newVal)\n      triggerRefValue(this, DirtyLevels.Dirty, newVal)\n    }\n  }\n}\n```\n重点来了，RefImple类里头，才是真正包含了从原始数据变成响应式数据，以及收集依赖的逻辑。在一个refImpl实例中，里面有一个dep对象，初始值是undefined， 这个dep会这trackRefValue函数执行的过程中被赋值。\n\n下面代码从17-21(get value())行，就是依赖收集的过程：当一个ref型响应式数据通过.value访问时，会触发RefImpl实例中的getter。它会首先执行一个trackValue函数，然后再返回_value值，所以接下来重点看关注trackValue函数，所以**依赖是在数据被访问的时候触发的**。\n\n```Javascript\n// packages/reactivity/src/ref.ts\nexport function trackRefValue(ref: RefBase<any>) {\n  if (shouldTrack && activeEffect) {\n    ref = toRaw(ref)\n    trackEffect(\n      activeEffect,\n      (ref.dep ??= createDep(\n        () => (ref.dep = undefined),\n        ref instanceof ComputedRefImpl ? ref : undefined,\n      )),\n      __DEV__\n        ? {\n            target: ref,\n            type: TrackOpTypes.GET,\n            key: 'value',\n          }\n        : void 0,\n    )\n  }\n}u\n```\n\ntrackRefValue函数中有两个变量，shouldTrack和activeEffect，暂时我们不去理会它们，只要知道shouldTrack是一个布尔值，activeEffect是一个RectiveEffect实例。\n\n在shouldTrack值为true且activeEffect有值的情况下，首先会将ref转成原始值，然后再执行trackEffect函数。\n\n在执行trackEffect函数的中，第一个是activeEffect, 在任意时刻它在全局是具有唯一性的；第二个是ref.dep, 其中给ref.dep的赋值函数createDep返回一个Dep实例，前面说过的，本质是个map; 第三个函数是个对象，是关于开发环境下debug的一些配置。\n\n在这里，我们可以看到，之前说个的ref实例中原来是undefined的ref.dep赋值，就在此处。\n\n```Javascript\n// packages/reactivity/src/effect.ts\nexport function trackEffect(\n  effect: ReactiveEffect,\n  dep: Dep,\n  debuggerEventExtraInfo?: DebuggerEventExtraInfo,\n) {\n  if (dep.get(effect) !== effect._trackId) {\n    dep.set(effect, effect._trackId)\n    const oldDep = effect.deps[effect._depsLength]\n    if (oldDep !== dep) {\n      if (oldDep) {\n        cleanupDepEffect(oldDep, effect)\n      }\n      effect.deps[effect._depsLength++] = dep\n    } else {\n      effect._depsLength++\n    }\n    if (__DEV__) {\n      effect.onTrack?.(extend({ effect }, debuggerEventExtraInfo!))\n    }\n  }\n}\n```\ntrackEffect函数绝对是依赖收集重头戏中的重头戏。\n\n首先上来就是一个判断，dep, 也就是ref中的dep，本质是个map，判断里面是否存在对应的effect, 如果没有，就执行接下来的操作。\n\ndep将effect也就是activeEffect作为键，其_trackId作为值添加到dep，**所以我们说的收集的依赖指的就是effect对象**。同时我们得到了一个关于**dep和effect之间的第一关系，即一个dep可以对应多个effect**。\n\n接着，将effects实例中deps数组中最后一个值取出来与当前的dep值进行比对，看是否是同一个值如果不是同一个值，而且oldDep是有值的，那么就执行cleanupDepEffect操作。如果oldDep为空值，就跳过这一步，直接往effect.deps中添加dep。因此，我们在这里得到了关于dep和effect第二个结论，**一个effect可以对应多个dep**。\n\n代码还有一部分，接着往下看，在oldDep不等于当前dep的时候，直接对effec_depsLength进行加操作，也就是说，effect.deps值没有变，但是_depsLength值却超出了deps数组边界的情况，这也就是为什么上面要判断oldDep是否存在的原因。\n\n\n由上面上面两个结论我们可以得出，一个dep中可以对应多个effect, 一个effect也可以对应多个dep, 因此dep和effect的关系是多对多的关系。\n\n### 总结\n\n-  收集的依赖是什么？（what）\n  > 我们常说的收集的依赖是effect对象\n\n-  怎么收集的依赖？  （how）\n > 判断当前数据dep中有没有activeEffct, 没有就加进去。把大象关进冰箱里要几步！！！\n-  什么时候收集？     (when)\n> 在数据被访问时，触发getter，进行依赖收集\n","slug":"Dependencies-collecting-of-vue3","published":1,"updated":"2025-06-21T14:15:44.943Z","comments":1,"layout":"post","photos":[],"_id":"cmjbml2hv0002ikupdcai5v7e","content":"<p>从Vue开始较大范围在前端应用开始，关于Vue一些基础知识的讨论和面试问题就在开发圈子里基本上就跟前几年的股票和基金一样，楼下摆摊卖酱香饼的阿姨都能说上几句那种。找过前端开发工作或者正在找开发工作的前端都知道，面试官基本上都有那么几个常问的问题，而网上呢也有那么一套可以用来背诵的“八股文”，自己懂多少没有关系，应付面试官还是够的，可以算是屡试不爽吧。</p>\n<p>背诵面试八股文无可厚非的，可以说是每一个找工作的人都干过和必须干的事情，因为我们都要工作，都要恰饭。只有恰上饭，才能去谈些伟大的理想。背“八股文”本是一种捷径，尤其是本身对一门技术不是特别了解的开发者，就是那种刚刚能使用它那种。</p>\n<p>在众多关于Vue的面试“八股文”中，今天讲的是其中最常问的一个–Vue中的依赖收集。本文也将从代码层面，讲清楚关于依赖收集的几个问题。</p>\n<ul>\n<li>收集的依赖是什么？（what）</li>\n<li>怎么收集的依赖？  （how）</li>\n<li>什么时候收集？     (when)</li>\n</ul>\n<p>至于为什么要收集依赖(why)，现在就可以先告诉答案。<strong>收集依赖，其核心作用是在数据发生变化的时候可以做出相应的动作，比如刷新视图</strong>，为了执行这一动作，我们就得知道是谁在什么时候发生了变化，所以我们要收集依赖。</p>\n<p>下面我们结合代码，尽可能通俗的讲解关于上述的三个问题：</p>\n<p>在搞清楚依赖收集之前，先把源码中几个概念性的东西说明一下，建议下载<a href=\"https://github.com/vuejs/core\">Vue3源码</a>进行对照着看：</p>\n<ul>\n<li><p><strong>Dep</strong>: 本质上是一个Map实例，同时在map实例上绑定一个celanup函数和一个computed属性。</p>\n</li>\n<li><p><strong>ReactiveEffect</strong>: 相当于2.x版本中的Watcher类, 里头有一个deps数组，用来存dep, 每个实例里面都有一个track_id用来标识唯一性。</p>\n</li>\n<li><p><strong>effect函数</strong>： 里头实例化一个ReactiveEffect对象，同时绑定一些options, 返回值是一个runner,实际上是对ReactiveEffect对象行为的一种业务封装。</p>\n</li>\n</ul>\n<p>下面以一行简单的代码开始关于依赖收集的探索。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">const</span> num = <span class=\"hljs-title function_\">ref</span>(<span class=\"hljs-number\">1</span>);<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">// packages/reactivity/src/ref.ts</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> ref&lt;T&gt;(<span class=\"hljs-attr\">value</span>: T): <span class=\"hljs-title class_\">Ref</span>&lt;<span class=\"hljs-title class_\">UnwrapRef</span>&lt;T&gt;&gt;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> ref&lt;T = any&gt;(): <span class=\"hljs-title class_\">Ref</span>&lt;T | <span class=\"hljs-literal\">undefined</span>&gt;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">ref</span>(<span class=\"hljs-params\">value?: unknown</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">createRef</span>(value, <span class=\"hljs-literal\">false</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>ref函数主要是对createRef做了一个函数包装，主要内容看到createRef函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">// packages/reactivity/src/ref.ts</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createRef</span>(<span class=\"hljs-params\">rawValue: unknown, shallow: boolean</span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_\">isRef</span>(rawValue)) &#123;<br>    <span class=\"hljs-keyword\">return</span> rawValue<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RefImpl</span>(rawValue, shallow)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>createRef函数在这里对原始数据rawValue做了一个判断，如果数据本身就是响应式数据了，就直接返回它本身，如果不是，就返回一个实例化的RefImpl对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">// packages/reactivity/src/ref.ts</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RefImpl</span>&lt;T&gt; &#123;<br>  private <span class=\"hljs-attr\">_value</span>: T<br>  private <span class=\"hljs-attr\">_rawValue</span>: T<br><br>  public dep?: <span class=\"hljs-title class_\">Dep</span> = <span class=\"hljs-literal\">undefined</span><br>  public readonly __v_isRef = <span class=\"hljs-literal\">true</span><br><br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span><br><span class=\"hljs-params\">    value: T,</span><br><span class=\"hljs-params\">    public readonly __v_isShallow: boolean,</span><br><span class=\"hljs-params\">  </span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_rawValue</span> = __v_isShallow ? value : <span class=\"hljs-title function_\">toRaw</span>(value)<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_value</span> = __v_isShallow ? value : <span class=\"hljs-title function_\">toReactive</span>(value)<br>  &#125;<br><br>  <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title function_\">value</span>() &#123;<br>    <span class=\"hljs-title function_\">trackRefValue</span>(<span class=\"hljs-variable language_\">this</span>)<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_value</span><br>  &#125;<br><br>  <span class=\"hljs-keyword\">set</span> <span class=\"hljs-title function_\">value</span>(<span class=\"hljs-params\">newVal</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> useDirectValue =<br>      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">__v_isShallow</span> || <span class=\"hljs-title function_\">isShallow</span>(newVal) || <span class=\"hljs-title function_\">isReadonly</span>(newVal)<br>    newVal = useDirectValue ? newVal : <span class=\"hljs-title function_\">toRaw</span>(newVal)<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_\">hasChanged</span>(newVal, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_rawValue</span>)) &#123;<br>      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_rawValue</span> = newVal<br>      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_value</span> = useDirectValue ? newVal : <span class=\"hljs-title function_\">toReactive</span>(newVal)<br>      <span class=\"hljs-title function_\">triggerRefValue</span>(<span class=\"hljs-variable language_\">this</span>, <span class=\"hljs-title class_\">DirtyLevels</span>.<span class=\"hljs-property\">Dirty</span>, newVal)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>重点来了，RefImple类里头，才是真正包含了从原始数据变成响应式数据，以及收集依赖的逻辑。在一个refImpl实例中，里面有一个dep对象，初始值是undefined， 这个dep会这trackRefValue函数执行的过程中被赋值。</p>\n<p>下面代码从17-21(get value())行，就是依赖收集的过程：当一个ref型响应式数据通过.value访问时，会触发RefImpl实例中的getter。它会首先执行一个trackValue函数，然后再返回_value值，所以接下来重点看关注trackValue函数，所以<strong>依赖是在数据被访问的时候触发的</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">// packages/reactivity/src/ref.ts</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">trackRefValue</span>(<span class=\"hljs-params\">ref: RefBase&lt;any&gt;</span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (shouldTrack &amp;&amp; activeEffect) &#123;<br>    ref = <span class=\"hljs-title function_\">toRaw</span>(ref)<br>    <span class=\"hljs-title function_\">trackEffect</span>(<br>      activeEffect,<br>      (ref.<span class=\"hljs-property\">dep</span> ??= <span class=\"hljs-title function_\">createDep</span>(<br>        <span class=\"hljs-function\">() =&gt;</span> (ref.<span class=\"hljs-property\">dep</span> = <span class=\"hljs-literal\">undefined</span>),<br>        ref <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">ComputedRefImpl</span> ? ref : <span class=\"hljs-literal\">undefined</span>,<br>      )),<br>      __DEV__<br>        ? &#123;<br>            <span class=\"hljs-attr\">target</span>: ref,<br>            <span class=\"hljs-attr\">type</span>: <span class=\"hljs-title class_\">TrackOpTypes</span>.<span class=\"hljs-property\">GET</span>,<br>            <span class=\"hljs-attr\">key</span>: <span class=\"hljs-string\">&#x27;value&#x27;</span>,<br>          &#125;<br>        : <span class=\"hljs-keyword\">void</span> <span class=\"hljs-number\">0</span>,<br>    )<br>  &#125;<br>&#125;u<br></code></pre></td></tr></table></figure>\n\n<p>trackRefValue函数中有两个变量，shouldTrack和activeEffect，暂时我们不去理会它们，只要知道shouldTrack是一个布尔值，activeEffect是一个RectiveEffect实例。</p>\n<p>在shouldTrack值为true且activeEffect有值的情况下，首先会将ref转成原始值，然后再执行trackEffect函数。</p>\n<p>在执行trackEffect函数的中，第一个是activeEffect, 在任意时刻它在全局是具有唯一性的；第二个是ref.dep, 其中给ref.dep的赋值函数createDep返回一个Dep实例，前面说过的，本质是个map; 第三个函数是个对象，是关于开发环境下debug的一些配置。</p>\n<p>在这里，我们可以看到，之前说个的ref实例中原来是undefined的ref.dep赋值，就在此处。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">// packages/reactivity/src/effect.ts</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">trackEffect</span>(<span class=\"hljs-params\"></span><br><span class=\"hljs-params\">  effect: ReactiveEffect,</span><br><span class=\"hljs-params\">  dep: Dep,</span><br><span class=\"hljs-params\">  debuggerEventExtraInfo?: DebuggerEventExtraInfo,</span><br><span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (dep.<span class=\"hljs-title function_\">get</span>(effect) !== effect.<span class=\"hljs-property\">_trackId</span>) &#123;<br>    dep.<span class=\"hljs-title function_\">set</span>(effect, effect.<span class=\"hljs-property\">_trackId</span>)<br>    <span class=\"hljs-keyword\">const</span> oldDep = effect.<span class=\"hljs-property\">deps</span>[effect.<span class=\"hljs-property\">_depsLength</span>]<br>    <span class=\"hljs-keyword\">if</span> (oldDep !== dep) &#123;<br>      <span class=\"hljs-keyword\">if</span> (oldDep) &#123;<br>        <span class=\"hljs-title function_\">cleanupDepEffect</span>(oldDep, effect)<br>      &#125;<br>      effect.<span class=\"hljs-property\">deps</span>[effect.<span class=\"hljs-property\">_depsLength</span>++] = dep<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      effect.<span class=\"hljs-property\">_depsLength</span>++<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (__DEV__) &#123;<br>      effect.<span class=\"hljs-property\">onTrack</span>?.(<span class=\"hljs-title function_\">extend</span>(&#123; effect &#125;, debuggerEventExtraInfo!))<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>trackEffect函数绝对是依赖收集重头戏中的重头戏。</p>\n<p>首先上来就是一个判断，dep, 也就是ref中的dep，本质是个map，判断里面是否存在对应的effect, 如果没有，就执行接下来的操作。</p>\n<p>dep将effect也就是activeEffect作为键，其_trackId作为值添加到dep，<strong>所以我们说的收集的依赖指的就是effect对象</strong>。同时我们得到了一个关于<strong>dep和effect之间的第一关系，即一个dep可以对应多个effect</strong>。</p>\n<p>接着，将effects实例中deps数组中最后一个值取出来与当前的dep值进行比对，看是否是同一个值如果不是同一个值，而且oldDep是有值的，那么就执行cleanupDepEffect操作。如果oldDep为空值，就跳过这一步，直接往effect.deps中添加dep。因此，我们在这里得到了关于dep和effect第二个结论，<strong>一个effect可以对应多个dep</strong>。</p>\n<p>代码还有一部分，接着往下看，在oldDep不等于当前dep的时候，直接对effec_depsLength进行加操作，也就是说，effect.deps值没有变，但是_depsLength值却超出了deps数组边界的情况，这也就是为什么上面要判断oldDep是否存在的原因。</p>\n<p>由上面上面两个结论我们可以得出，一个dep中可以对应多个effect, 一个effect也可以对应多个dep, 因此dep和effect的关系是多对多的关系。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><p>收集的依赖是什么？（what）</p>\n<blockquote>\n<p>我们常说的收集的依赖是effect对象</p>\n</blockquote>\n</li>\n<li><p>怎么收集的依赖？  （how）</p>\n<blockquote>\n<p>判断当前数据dep中有没有activeEffct, 没有就加进去。把大象关进冰箱里要几步！！！</p>\n</blockquote>\n</li>\n<li><p>什么时候收集？     (when)</p>\n<blockquote>\n<p>在数据被访问时，触发getter，进行依赖收集</p>\n</blockquote>\n</li>\n</ul>\n","excerpt":"","more":"<p>从Vue开始较大范围在前端应用开始，关于Vue一些基础知识的讨论和面试问题就在开发圈子里基本上就跟前几年的股票和基金一样，楼下摆摊卖酱香饼的阿姨都能说上几句那种。找过前端开发工作或者正在找开发工作的前端都知道，面试官基本上都有那么几个常问的问题，而网上呢也有那么一套可以用来背诵的“八股文”，自己懂多少没有关系，应付面试官还是够的，可以算是屡试不爽吧。</p>\n<p>背诵面试八股文无可厚非的，可以说是每一个找工作的人都干过和必须干的事情，因为我们都要工作，都要恰饭。只有恰上饭，才能去谈些伟大的理想。背“八股文”本是一种捷径，尤其是本身对一门技术不是特别了解的开发者，就是那种刚刚能使用它那种。</p>\n<p>在众多关于Vue的面试“八股文”中，今天讲的是其中最常问的一个–Vue中的依赖收集。本文也将从代码层面，讲清楚关于依赖收集的几个问题。</p>\n<ul>\n<li>收集的依赖是什么？（what）</li>\n<li>怎么收集的依赖？  （how）</li>\n<li>什么时候收集？     (when)</li>\n</ul>\n<p>至于为什么要收集依赖(why)，现在就可以先告诉答案。<strong>收集依赖，其核心作用是在数据发生变化的时候可以做出相应的动作，比如刷新视图</strong>，为了执行这一动作，我们就得知道是谁在什么时候发生了变化，所以我们要收集依赖。</p>\n<p>下面我们结合代码，尽可能通俗的讲解关于上述的三个问题：</p>\n<p>在搞清楚依赖收集之前，先把源码中几个概念性的东西说明一下，建议下载<a href=\"https://github.com/vuejs/core\">Vue3源码</a>进行对照着看：</p>\n<ul>\n<li><p><strong>Dep</strong>: 本质上是一个Map实例，同时在map实例上绑定一个celanup函数和一个computed属性。</p>\n</li>\n<li><p><strong>ReactiveEffect</strong>: 相当于2.x版本中的Watcher类, 里头有一个deps数组，用来存dep, 每个实例里面都有一个track_id用来标识唯一性。</p>\n</li>\n<li><p><strong>effect函数</strong>： 里头实例化一个ReactiveEffect对象，同时绑定一些options, 返回值是一个runner,实际上是对ReactiveEffect对象行为的一种业务封装。</p>\n</li>\n</ul>\n<p>下面以一行简单的代码开始关于依赖收集的探索。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-keyword\">const</span> num = <span class=\"hljs-title function_\">ref</span>(<span class=\"hljs-number\">1</span>);<br></code></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">// packages/reactivity/src/ref.ts</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> ref&lt;T&gt;(<span class=\"hljs-attr\">value</span>: T): <span class=\"hljs-title class_\">Ref</span>&lt;<span class=\"hljs-title class_\">UnwrapRef</span>&lt;T&gt;&gt;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> ref&lt;T = any&gt;(): <span class=\"hljs-title class_\">Ref</span>&lt;T | <span class=\"hljs-literal\">undefined</span>&gt;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">ref</span>(<span class=\"hljs-params\">value?: unknown</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_\">createRef</span>(value, <span class=\"hljs-literal\">false</span>)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>ref函数主要是对createRef做了一个函数包装，主要内容看到createRef函数。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">// packages/reactivity/src/ref.ts</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createRef</span>(<span class=\"hljs-params\">rawValue: unknown, shallow: boolean</span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_\">isRef</span>(rawValue)) &#123;<br>    <span class=\"hljs-keyword\">return</span> rawValue<br>  &#125;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RefImpl</span>(rawValue, shallow)<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>createRef函数在这里对原始数据rawValue做了一个判断，如果数据本身就是响应式数据了，就直接返回它本身，如果不是，就返回一个实例化的RefImpl对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">// packages/reactivity/src/ref.ts</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RefImpl</span>&lt;T&gt; &#123;<br>  private <span class=\"hljs-attr\">_value</span>: T<br>  private <span class=\"hljs-attr\">_rawValue</span>: T<br><br>  public dep?: <span class=\"hljs-title class_\">Dep</span> = <span class=\"hljs-literal\">undefined</span><br>  public readonly __v_isRef = <span class=\"hljs-literal\">true</span><br><br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span><br><span class=\"hljs-params\">    value: T,</span><br><span class=\"hljs-params\">    public readonly __v_isShallow: boolean,</span><br><span class=\"hljs-params\">  </span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_rawValue</span> = __v_isShallow ? value : <span class=\"hljs-title function_\">toRaw</span>(value)<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_value</span> = __v_isShallow ? value : <span class=\"hljs-title function_\">toReactive</span>(value)<br>  &#125;<br><br>  <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title function_\">value</span>() &#123;<br>    <span class=\"hljs-title function_\">trackRefValue</span>(<span class=\"hljs-variable language_\">this</span>)<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_value</span><br>  &#125;<br><br>  <span class=\"hljs-keyword\">set</span> <span class=\"hljs-title function_\">value</span>(<span class=\"hljs-params\">newVal</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> useDirectValue =<br>      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">__v_isShallow</span> || <span class=\"hljs-title function_\">isShallow</span>(newVal) || <span class=\"hljs-title function_\">isReadonly</span>(newVal)<br>    newVal = useDirectValue ? newVal : <span class=\"hljs-title function_\">toRaw</span>(newVal)<br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title function_\">hasChanged</span>(newVal, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_rawValue</span>)) &#123;<br>      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_rawValue</span> = newVal<br>      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">_value</span> = useDirectValue ? newVal : <span class=\"hljs-title function_\">toReactive</span>(newVal)<br>      <span class=\"hljs-title function_\">triggerRefValue</span>(<span class=\"hljs-variable language_\">this</span>, <span class=\"hljs-title class_\">DirtyLevels</span>.<span class=\"hljs-property\">Dirty</span>, newVal)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>重点来了，RefImple类里头，才是真正包含了从原始数据变成响应式数据，以及收集依赖的逻辑。在一个refImpl实例中，里面有一个dep对象，初始值是undefined， 这个dep会这trackRefValue函数执行的过程中被赋值。</p>\n<p>下面代码从17-21(get value())行，就是依赖收集的过程：当一个ref型响应式数据通过.value访问时，会触发RefImpl实例中的getter。它会首先执行一个trackValue函数，然后再返回_value值，所以接下来重点看关注trackValue函数，所以<strong>依赖是在数据被访问的时候触发的</strong>。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">// packages/reactivity/src/ref.ts</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">trackRefValue</span>(<span class=\"hljs-params\">ref: RefBase&lt;any&gt;</span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (shouldTrack &amp;&amp; activeEffect) &#123;<br>    ref = <span class=\"hljs-title function_\">toRaw</span>(ref)<br>    <span class=\"hljs-title function_\">trackEffect</span>(<br>      activeEffect,<br>      (ref.<span class=\"hljs-property\">dep</span> ??= <span class=\"hljs-title function_\">createDep</span>(<br>        <span class=\"hljs-function\">() =&gt;</span> (ref.<span class=\"hljs-property\">dep</span> = <span class=\"hljs-literal\">undefined</span>),<br>        ref <span class=\"hljs-keyword\">instanceof</span> <span class=\"hljs-title class_\">ComputedRefImpl</span> ? ref : <span class=\"hljs-literal\">undefined</span>,<br>      )),<br>      __DEV__<br>        ? &#123;<br>            <span class=\"hljs-attr\">target</span>: ref,<br>            <span class=\"hljs-attr\">type</span>: <span class=\"hljs-title class_\">TrackOpTypes</span>.<span class=\"hljs-property\">GET</span>,<br>            <span class=\"hljs-attr\">key</span>: <span class=\"hljs-string\">&#x27;value&#x27;</span>,<br>          &#125;<br>        : <span class=\"hljs-keyword\">void</span> <span class=\"hljs-number\">0</span>,<br>    )<br>  &#125;<br>&#125;u<br></code></pre></td></tr></table></figure>\n\n<p>trackRefValue函数中有两个变量，shouldTrack和activeEffect，暂时我们不去理会它们，只要知道shouldTrack是一个布尔值，activeEffect是一个RectiveEffect实例。</p>\n<p>在shouldTrack值为true且activeEffect有值的情况下，首先会将ref转成原始值，然后再执行trackEffect函数。</p>\n<p>在执行trackEffect函数的中，第一个是activeEffect, 在任意时刻它在全局是具有唯一性的；第二个是ref.dep, 其中给ref.dep的赋值函数createDep返回一个Dep实例，前面说过的，本质是个map; 第三个函数是个对象，是关于开发环境下debug的一些配置。</p>\n<p>在这里，我们可以看到，之前说个的ref实例中原来是undefined的ref.dep赋值，就在此处。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Javascript\"><span class=\"hljs-comment\">// packages/reactivity/src/effect.ts</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">trackEffect</span>(<span class=\"hljs-params\"></span><br><span class=\"hljs-params\">  effect: ReactiveEffect,</span><br><span class=\"hljs-params\">  dep: Dep,</span><br><span class=\"hljs-params\">  debuggerEventExtraInfo?: DebuggerEventExtraInfo,</span><br><span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (dep.<span class=\"hljs-title function_\">get</span>(effect) !== effect.<span class=\"hljs-property\">_trackId</span>) &#123;<br>    dep.<span class=\"hljs-title function_\">set</span>(effect, effect.<span class=\"hljs-property\">_trackId</span>)<br>    <span class=\"hljs-keyword\">const</span> oldDep = effect.<span class=\"hljs-property\">deps</span>[effect.<span class=\"hljs-property\">_depsLength</span>]<br>    <span class=\"hljs-keyword\">if</span> (oldDep !== dep) &#123;<br>      <span class=\"hljs-keyword\">if</span> (oldDep) &#123;<br>        <span class=\"hljs-title function_\">cleanupDepEffect</span>(oldDep, effect)<br>      &#125;<br>      effect.<span class=\"hljs-property\">deps</span>[effect.<span class=\"hljs-property\">_depsLength</span>++] = dep<br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      effect.<span class=\"hljs-property\">_depsLength</span>++<br>    &#125;<br>    <span class=\"hljs-keyword\">if</span> (__DEV__) &#123;<br>      effect.<span class=\"hljs-property\">onTrack</span>?.(<span class=\"hljs-title function_\">extend</span>(&#123; effect &#125;, debuggerEventExtraInfo!))<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>trackEffect函数绝对是依赖收集重头戏中的重头戏。</p>\n<p>首先上来就是一个判断，dep, 也就是ref中的dep，本质是个map，判断里面是否存在对应的effect, 如果没有，就执行接下来的操作。</p>\n<p>dep将effect也就是activeEffect作为键，其_trackId作为值添加到dep，<strong>所以我们说的收集的依赖指的就是effect对象</strong>。同时我们得到了一个关于<strong>dep和effect之间的第一关系，即一个dep可以对应多个effect</strong>。</p>\n<p>接着，将effects实例中deps数组中最后一个值取出来与当前的dep值进行比对，看是否是同一个值如果不是同一个值，而且oldDep是有值的，那么就执行cleanupDepEffect操作。如果oldDep为空值，就跳过这一步，直接往effect.deps中添加dep。因此，我们在这里得到了关于dep和effect第二个结论，<strong>一个effect可以对应多个dep</strong>。</p>\n<p>代码还有一部分，接着往下看，在oldDep不等于当前dep的时候，直接对effec_depsLength进行加操作，也就是说，effect.deps值没有变，但是_depsLength值却超出了deps数组边界的情况，这也就是为什么上面要判断oldDep是否存在的原因。</p>\n<p>由上面上面两个结论我们可以得出，一个dep中可以对应多个effect, 一个effect也可以对应多个dep, 因此dep和effect的关系是多对多的关系。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><ul>\n<li><p>收集的依赖是什么？（what）</p>\n<blockquote>\n<p>我们常说的收集的依赖是effect对象</p>\n</blockquote>\n</li>\n<li><p>怎么收集的依赖？  （how）</p>\n<blockquote>\n<p>判断当前数据dep中有没有activeEffct, 没有就加进去。把大象关进冰箱里要几步！！！</p>\n</blockquote>\n</li>\n<li><p>什么时候收集？     (when)</p>\n<blockquote>\n<p>在数据被访问时，触发getter，进行依赖收集</p>\n</blockquote>\n</li>\n</ul>\n"},{"title":"关于微信云托管对象存储那点事","date":"2025-05-23T04:40:00.000Z","_content":"最近在鼓捣一个关于图像处理相关的小程序，出于快速开发考虑，在后台开发这块，没有选择走传统的后台部署服务。毕竟，购买云服务器，注册购买域名以及备案等一系列操作下来，也够让人心累。\n\n这次选择的是微信开发的平台的云托管，至于为什么走的不是云函数开发，其中就涉及到了开发语言的选择--python, 如果改用javascript重写一下，成本有点高，所以最终方案选择云托管。\n\n在按照云托管的部署流程一通走下来后，everything is fine. But...\n\n离大谱的，接口请求和响应，居然不能超过1M, 而我这程序就是关于图像处理的，动不动图片大小就会超过1M。如果非要限制用户图片大小限制在1M以下，太过影响用户体验。\n\n此外我还想过，在用户端使用图像压缩，但图像太大压缩也会存在超过1M的情况，另外清晰度也会受到影响。\n\n在微信开发社区和各个IT论坛找了一圈下来，其实没有比较好的解决方案，最终都需要经过一个中间对象存储的过程。\n\n也就是先将图片上传到云上，让后将图片对象的id作为接口入参传入，后台需要使用到图片的时候根据图片id下载即可，然后将处理后的图片，又要上传回云上，返回给客户端新的图片的id，客户端可以根据图片id来获取资源。如下图\n\n<!-- ![处理流程](./imgs/微信云对象存储..png) -->\n<div align=\"center\">\n    <img src=\"/imgs/微信云对象存储..png\" width=\"80%\" height=\"20%\" alt=\"处理流程\"/>\n</div>\n\n\n\n对象存储云平台其实很多，例如比较有名的比如七牛，阿里，还有腾讯云自己的。我这里采用了微信云对象存储，具体的使用呢可以参考 [微信云托管对象存储](https://developers.weixin.qq.com/minigame/dev/wxcloudrun/src/guide/storage/manage.html)，相应的开发手册可以参考[对象存储-服务端和其他客户端](https://developers.weixin.qq.com/minigame/dev/wxcloudrun/src/development/storage/service/)\n\n\n为了在后续的开发中更好处理类似的情况，我将微信云托管对象存储做成了一个模块，具体实现情况如下。\n\n首先，需要从自己的小程序或者和云托管平台获取到以下三个重要参数：\n\n- **APPID** ： \"your-wechat-appid\"\n- **SECRET**： \"your-wechat-secret\"\n- **ENV_ID**： \"your-cloud-env-id\"\n\n- ### 文件上传 (获取token-获取元数据-上传COS)\n\n微信开放平台如果第三方调用对应接口的话，都是需要鉴权了，所以首先我们需要获取到token值。\n\n``` Python\ndef _refresh_access_token(self):\n        \"\"\"获取或刷新access_token\"\"\"\n        url = \"https://api.weixin.qq.com/cgi-bin/token\"\n        params = {\n            \"grant_type\": \"client_credential\",\n            \"appid\": self.appid,\n            \"secret\": self.secret\n        }\n        response = requests.get(url, params=params, verify=False).json()\n        if 'access_token' in response:\n            self.access_token = response['access_token']\n            self.token_expires = time.time() + response['expires_in'] - 300  # 提前5分钟刷新\n        else:\n            raise Exception(f\"获取access_token失败: {response}\")\n```\n\n\n文件上传可以分成2步：**1获取上传元数据，2上传文件到COS**。\n\n获取元数据可以理解为向平台发送请求，获取一个用来存放一个文件（存储对象）的一个URL地址, 上传文件到COS可以则可以理解成将资源放到上一步生成的URL地址上，经此，文件才算真正的上传成功了。\n\n``` Python\n    def upload_file(self, local_path, cloud_path):\n        \"\"\"\n        上传本地文件到微信云存储\n        :param local_path: 本地文件路径\n        :param cloud_path: 云端存储路径（如：'images/example.jpg'）\n        :return: 文件ID（用于后续下载）\n        \"\"\"\n        self._ensure_access_token()\n        \n        # 1. 获取上传元数据\n        upload_meta_url = \"https://api.weixin.qq.com/tcb/uploadfile\"\n        params = {\"access_token\": self.access_token}\n        payload = {\"env\": self.env, \"path\": cloud_path}\n        response = requests.post(upload_meta_url, params=params, json=payload,verify=False).json()\n        print(payload, params)\n        if response.get('errcode', 0) != 0:\n            raise Exception(f\"上传元数据获取失败: {response}\")\n        \n        # 2. 上传文件到COS\n        cos_url = response['url']\n       \n        key = cloud_path.split('/')[-1]\n        print(key)\n        files = {\n            \"Signature\":(None,response['authorization']),\n            \"x-cos-meta-fileid\": (None, response['cos_file_id']),\n            \"x-cos-security-token\": (None,response['token']),\n            \"key\": (None, cloud_path),\n            'file':(key, open(local_path, 'rb')),\n        }\n\n        upload_resp = requests.post(cos_url, files=files, verify=False)\n        if upload_resp.status_code != 204:\n            raise Exception(f\"COS上传失败: {upload_resp.text}\", upload_resp)\n       \n        return response['file_id']\n```\n\n\n- ### 文件下载\n\n下载文件相对简单一些，直接调用微信开放平台对外提供的批量下载接口，当然对应的token也是需要的，这部分就不做赘述，代码实现可以参考下方。\n\n``` Python \n\ndef download_file(self, file_id, local_path):\n        \"\"\"\n        从微信云存储下载文件\n        :param file_id: 文件ID（上传时返回的file_id）\n        :param local_path: 本地存储路径\n        \"\"\"\n        self._ensure_access_token()\n        \n        # 1. 获取下载链接\n        download_meta_url = \"https://api.weixin.qq.com/tcb/batchdownloadfile\"\n        params = {\"access_token\": self.access_token}\n        payload = {\n            \"env\": self.env,\n            \"file_list\": [{\"fileid\": file_id, \"max_age\": 7200}]\n        }\n        response = requests.post(download_meta_url, params=params, json=payload, verify=False).json()\n        \n        if response.get('errcode', 0) != 0:\n            raise Exception(f\"下载元数据获取失败: {response}\")\n        \n        file_info = response['file_list'][0]\n        if file_info['status'] != 0:\n            raise Exception(f\"下载错误: {file_info['errmsg']}\")\n        \n        # 2. 下载文件\n        download_resp = requests.get(file_info['download_url'], verify=False)\n        if download_resp.status_code != 200:\n            raise Exception(\"文件下载失败\")\n        \n        with open(local_path, 'wb') as f:\n            f.write(download_resp.content)\n            \n        return True\n```\n\n以上就是微信云托管上对象存储的上传和下载的实现了。为了方便，我们可以将功能在一个类中实现。此外，考虑到token获取接口是有限制的，每天的调用次数是2000次，而每个token的有效时间是2小时，因此可以重复利用已有token。\n\n最终，完整的代码实现如下：\n\n``` Python\n# wx-cloud-storage.py\n# description: 微信云托管对象存储管理模块\nimport requests\nimport time\n\nclass WeChatCloudStorage:\n    def __init__(self, appid, secret, env):\n        self.appid = appid\n        self.secret = secret\n        self.env = env\n        self.access_token = None\n        self.token_expires = 0  # Token过期时间戳\n\n    def _refresh_access_token(self):\n        \"\"\"获取或刷新access_token\"\"\"\n        url = \"https://api.weixin.qq.com/cgi-bin/token\"\n        params = {\n            \"grant_type\": \"client_credential\",\n            \"appid\": self.appid,\n            \"secret\": self.secret\n        }\n        response = requests.get(url, params=params, verify=False).json()\n        if 'access_token' in response:\n            self.access_token = response['access_token']\n            self.token_expires = time.time() + response['expires_in'] - 300  # 提前5分钟刷新\n        else:\n            raise Exception(f\"获取access_token失败: {response}\")\n\n    def _ensure_access_token(self):\n        \"\"\"确保access_token有效\"\"\"\n        if time.time() >= self.token_expires or not self.access_token:\n            self._refresh_access_token()\n\n    def upload_file(self, local_path, cloud_path):\n        \"\"\"\n        上传本地文件到微信云存储\n        :param local_path: 本地文件路径\n        :param cloud_path: 云端存储路径（如：'images/example.jpg'）\n        :return: 文件ID（用于后续下载）\n        \"\"\"\n        self._ensure_access_token()\n        \n        # 1. 获取上传元数据\n        upload_meta_url = \"https://api.weixin.qq.com/tcb/uploadfile\"\n        params = {\"access_token\": self.access_token}\n        payload = {\"env\": self.env, \"path\": cloud_path}\n        response = requests.post(upload_meta_url, params=params, json=payload,verify=False).json()\n        print(payload, params)\n        if response.get('errcode', 0) != 0:\n            raise Exception(f\"上传元数据获取失败: {response}\")\n        \n        # 2. 上传文件到COS\n        cos_url = response['url']\n       \n        key = cloud_path.split('/')[-1]\n        print(key)\n        files = {\n            \"Signature\":(None,response['authorization']),\n            \"x-cos-meta-fileid\": (None, response['cos_file_id']),\n            \"x-cos-security-token\": (None,response['token']),\n            \"key\": (None, cloud_path),\n            'file':(key, open(local_path, 'rb')),\n        }\n\n        upload_resp = requests.post(cos_url, files=files, verify=False)\n        if upload_resp.status_code != 204:\n            raise Exception(f\"COS上传失败: {upload_resp.text}\", upload_resp)\n       \n        return response['file_id']\n\n    def download_file(self, file_id, local_path):\n        \"\"\"\n        从微信云存储下载文件\n        :param file_id: 文件ID（上传时返回的file_id）\n        :param local_path: 本地存储路径\n        \"\"\"\n        self._ensure_access_token()\n        \n        # 1. 获取下载链接\n        download_meta_url = \"https://api.weixin.qq.com/tcb/batchdownloadfile\"\n        params = {\"access_token\": self.access_token}\n        payload = {\n            \"env\": self.env,\n            \"file_list\": [{\"fileid\": file_id, \"max_age\": 7200}]\n        }\n        response = requests.post(download_meta_url, params=params, json=payload, verify=False).json()\n        \n        if response.get('errcode', 0) != 0:\n            raise Exception(f\"下载元数据获取失败: {response}\")\n        \n        file_info = response['file_list'][0]\n        if file_info['status'] != 0:\n            raise Exception(f\"下载错误: {file_info['errmsg']}\")\n        \n        # 2. 下载文件\n        download_resp = requests.get(file_info['download_url'], verify=False)\n        if download_resp.status_code != 200:\n            raise Exception(\"文件下载失败\")\n        \n        with open(local_path, 'wb') as f:\n            f.write(download_resp.content)\n            \n        return True\n\n# 使用示例\nif __name__ == \"__main__\":\n    # 配置信息（需要替换为实际值）\n    APPID = \"your-wechat-appid\"\n    SECRET = \"your-wechat-secret\"\n    ENV_ID = \"your-cloud-env-id\"\n   \n    # 上传示例\n    storage = WeChatCloudStorage(APPID, SECRET, ENV_ID)\n    try:\n        file_id = storage.upload_file(\"../test.png\", \"image/test2.png\")\n        print(f\"文件上传成功，File ID: {file_id}\")\n    except Exception as e:\n        print(f\"上传失败: {e}\")\n    # 下载示例\n    try:\n        storage.download_file(file_id, \"downloaded_image.jpg\")\n        print(\"文件下载成功\")\n    except Exception as e:\n        print(f\"下载失败: {e}\")\n\n\n```\n\n以上就是关于对象存储管理相关的内容了，如果你在开发类似的功能过程中有类似的idea或者遇到一些难搞的坑，欢迎一起讨论。","source":"_posts/Manage-wx-could-service.md","raw":"---\ntitle: 关于微信云托管对象存储那点事\ndate: 2025-05-23 12:40:00\ncategory: 小程序开发\ntags:\n    - 小程序\n    - 微信云\n    - 对象存储\n---\n最近在鼓捣一个关于图像处理相关的小程序，出于快速开发考虑，在后台开发这块，没有选择走传统的后台部署服务。毕竟，购买云服务器，注册购买域名以及备案等一系列操作下来，也够让人心累。\n\n这次选择的是微信开发的平台的云托管，至于为什么走的不是云函数开发，其中就涉及到了开发语言的选择--python, 如果改用javascript重写一下，成本有点高，所以最终方案选择云托管。\n\n在按照云托管的部署流程一通走下来后，everything is fine. But...\n\n离大谱的，接口请求和响应，居然不能超过1M, 而我这程序就是关于图像处理的，动不动图片大小就会超过1M。如果非要限制用户图片大小限制在1M以下，太过影响用户体验。\n\n此外我还想过，在用户端使用图像压缩，但图像太大压缩也会存在超过1M的情况，另外清晰度也会受到影响。\n\n在微信开发社区和各个IT论坛找了一圈下来，其实没有比较好的解决方案，最终都需要经过一个中间对象存储的过程。\n\n也就是先将图片上传到云上，让后将图片对象的id作为接口入参传入，后台需要使用到图片的时候根据图片id下载即可，然后将处理后的图片，又要上传回云上，返回给客户端新的图片的id，客户端可以根据图片id来获取资源。如下图\n\n<!-- ![处理流程](./imgs/微信云对象存储..png) -->\n<div align=\"center\">\n    <img src=\"/imgs/微信云对象存储..png\" width=\"80%\" height=\"20%\" alt=\"处理流程\"/>\n</div>\n\n\n\n对象存储云平台其实很多，例如比较有名的比如七牛，阿里，还有腾讯云自己的。我这里采用了微信云对象存储，具体的使用呢可以参考 [微信云托管对象存储](https://developers.weixin.qq.com/minigame/dev/wxcloudrun/src/guide/storage/manage.html)，相应的开发手册可以参考[对象存储-服务端和其他客户端](https://developers.weixin.qq.com/minigame/dev/wxcloudrun/src/development/storage/service/)\n\n\n为了在后续的开发中更好处理类似的情况，我将微信云托管对象存储做成了一个模块，具体实现情况如下。\n\n首先，需要从自己的小程序或者和云托管平台获取到以下三个重要参数：\n\n- **APPID** ： \"your-wechat-appid\"\n- **SECRET**： \"your-wechat-secret\"\n- **ENV_ID**： \"your-cloud-env-id\"\n\n- ### 文件上传 (获取token-获取元数据-上传COS)\n\n微信开放平台如果第三方调用对应接口的话，都是需要鉴权了，所以首先我们需要获取到token值。\n\n``` Python\ndef _refresh_access_token(self):\n        \"\"\"获取或刷新access_token\"\"\"\n        url = \"https://api.weixin.qq.com/cgi-bin/token\"\n        params = {\n            \"grant_type\": \"client_credential\",\n            \"appid\": self.appid,\n            \"secret\": self.secret\n        }\n        response = requests.get(url, params=params, verify=False).json()\n        if 'access_token' in response:\n            self.access_token = response['access_token']\n            self.token_expires = time.time() + response['expires_in'] - 300  # 提前5分钟刷新\n        else:\n            raise Exception(f\"获取access_token失败: {response}\")\n```\n\n\n文件上传可以分成2步：**1获取上传元数据，2上传文件到COS**。\n\n获取元数据可以理解为向平台发送请求，获取一个用来存放一个文件（存储对象）的一个URL地址, 上传文件到COS可以则可以理解成将资源放到上一步生成的URL地址上，经此，文件才算真正的上传成功了。\n\n``` Python\n    def upload_file(self, local_path, cloud_path):\n        \"\"\"\n        上传本地文件到微信云存储\n        :param local_path: 本地文件路径\n        :param cloud_path: 云端存储路径（如：'images/example.jpg'）\n        :return: 文件ID（用于后续下载）\n        \"\"\"\n        self._ensure_access_token()\n        \n        # 1. 获取上传元数据\n        upload_meta_url = \"https://api.weixin.qq.com/tcb/uploadfile\"\n        params = {\"access_token\": self.access_token}\n        payload = {\"env\": self.env, \"path\": cloud_path}\n        response = requests.post(upload_meta_url, params=params, json=payload,verify=False).json()\n        print(payload, params)\n        if response.get('errcode', 0) != 0:\n            raise Exception(f\"上传元数据获取失败: {response}\")\n        \n        # 2. 上传文件到COS\n        cos_url = response['url']\n       \n        key = cloud_path.split('/')[-1]\n        print(key)\n        files = {\n            \"Signature\":(None,response['authorization']),\n            \"x-cos-meta-fileid\": (None, response['cos_file_id']),\n            \"x-cos-security-token\": (None,response['token']),\n            \"key\": (None, cloud_path),\n            'file':(key, open(local_path, 'rb')),\n        }\n\n        upload_resp = requests.post(cos_url, files=files, verify=False)\n        if upload_resp.status_code != 204:\n            raise Exception(f\"COS上传失败: {upload_resp.text}\", upload_resp)\n       \n        return response['file_id']\n```\n\n\n- ### 文件下载\n\n下载文件相对简单一些，直接调用微信开放平台对外提供的批量下载接口，当然对应的token也是需要的，这部分就不做赘述，代码实现可以参考下方。\n\n``` Python \n\ndef download_file(self, file_id, local_path):\n        \"\"\"\n        从微信云存储下载文件\n        :param file_id: 文件ID（上传时返回的file_id）\n        :param local_path: 本地存储路径\n        \"\"\"\n        self._ensure_access_token()\n        \n        # 1. 获取下载链接\n        download_meta_url = \"https://api.weixin.qq.com/tcb/batchdownloadfile\"\n        params = {\"access_token\": self.access_token}\n        payload = {\n            \"env\": self.env,\n            \"file_list\": [{\"fileid\": file_id, \"max_age\": 7200}]\n        }\n        response = requests.post(download_meta_url, params=params, json=payload, verify=False).json()\n        \n        if response.get('errcode', 0) != 0:\n            raise Exception(f\"下载元数据获取失败: {response}\")\n        \n        file_info = response['file_list'][0]\n        if file_info['status'] != 0:\n            raise Exception(f\"下载错误: {file_info['errmsg']}\")\n        \n        # 2. 下载文件\n        download_resp = requests.get(file_info['download_url'], verify=False)\n        if download_resp.status_code != 200:\n            raise Exception(\"文件下载失败\")\n        \n        with open(local_path, 'wb') as f:\n            f.write(download_resp.content)\n            \n        return True\n```\n\n以上就是微信云托管上对象存储的上传和下载的实现了。为了方便，我们可以将功能在一个类中实现。此外，考虑到token获取接口是有限制的，每天的调用次数是2000次，而每个token的有效时间是2小时，因此可以重复利用已有token。\n\n最终，完整的代码实现如下：\n\n``` Python\n# wx-cloud-storage.py\n# description: 微信云托管对象存储管理模块\nimport requests\nimport time\n\nclass WeChatCloudStorage:\n    def __init__(self, appid, secret, env):\n        self.appid = appid\n        self.secret = secret\n        self.env = env\n        self.access_token = None\n        self.token_expires = 0  # Token过期时间戳\n\n    def _refresh_access_token(self):\n        \"\"\"获取或刷新access_token\"\"\"\n        url = \"https://api.weixin.qq.com/cgi-bin/token\"\n        params = {\n            \"grant_type\": \"client_credential\",\n            \"appid\": self.appid,\n            \"secret\": self.secret\n        }\n        response = requests.get(url, params=params, verify=False).json()\n        if 'access_token' in response:\n            self.access_token = response['access_token']\n            self.token_expires = time.time() + response['expires_in'] - 300  # 提前5分钟刷新\n        else:\n            raise Exception(f\"获取access_token失败: {response}\")\n\n    def _ensure_access_token(self):\n        \"\"\"确保access_token有效\"\"\"\n        if time.time() >= self.token_expires or not self.access_token:\n            self._refresh_access_token()\n\n    def upload_file(self, local_path, cloud_path):\n        \"\"\"\n        上传本地文件到微信云存储\n        :param local_path: 本地文件路径\n        :param cloud_path: 云端存储路径（如：'images/example.jpg'）\n        :return: 文件ID（用于后续下载）\n        \"\"\"\n        self._ensure_access_token()\n        \n        # 1. 获取上传元数据\n        upload_meta_url = \"https://api.weixin.qq.com/tcb/uploadfile\"\n        params = {\"access_token\": self.access_token}\n        payload = {\"env\": self.env, \"path\": cloud_path}\n        response = requests.post(upload_meta_url, params=params, json=payload,verify=False).json()\n        print(payload, params)\n        if response.get('errcode', 0) != 0:\n            raise Exception(f\"上传元数据获取失败: {response}\")\n        \n        # 2. 上传文件到COS\n        cos_url = response['url']\n       \n        key = cloud_path.split('/')[-1]\n        print(key)\n        files = {\n            \"Signature\":(None,response['authorization']),\n            \"x-cos-meta-fileid\": (None, response['cos_file_id']),\n            \"x-cos-security-token\": (None,response['token']),\n            \"key\": (None, cloud_path),\n            'file':(key, open(local_path, 'rb')),\n        }\n\n        upload_resp = requests.post(cos_url, files=files, verify=False)\n        if upload_resp.status_code != 204:\n            raise Exception(f\"COS上传失败: {upload_resp.text}\", upload_resp)\n       \n        return response['file_id']\n\n    def download_file(self, file_id, local_path):\n        \"\"\"\n        从微信云存储下载文件\n        :param file_id: 文件ID（上传时返回的file_id）\n        :param local_path: 本地存储路径\n        \"\"\"\n        self._ensure_access_token()\n        \n        # 1. 获取下载链接\n        download_meta_url = \"https://api.weixin.qq.com/tcb/batchdownloadfile\"\n        params = {\"access_token\": self.access_token}\n        payload = {\n            \"env\": self.env,\n            \"file_list\": [{\"fileid\": file_id, \"max_age\": 7200}]\n        }\n        response = requests.post(download_meta_url, params=params, json=payload, verify=False).json()\n        \n        if response.get('errcode', 0) != 0:\n            raise Exception(f\"下载元数据获取失败: {response}\")\n        \n        file_info = response['file_list'][0]\n        if file_info['status'] != 0:\n            raise Exception(f\"下载错误: {file_info['errmsg']}\")\n        \n        # 2. 下载文件\n        download_resp = requests.get(file_info['download_url'], verify=False)\n        if download_resp.status_code != 200:\n            raise Exception(\"文件下载失败\")\n        \n        with open(local_path, 'wb') as f:\n            f.write(download_resp.content)\n            \n        return True\n\n# 使用示例\nif __name__ == \"__main__\":\n    # 配置信息（需要替换为实际值）\n    APPID = \"your-wechat-appid\"\n    SECRET = \"your-wechat-secret\"\n    ENV_ID = \"your-cloud-env-id\"\n   \n    # 上传示例\n    storage = WeChatCloudStorage(APPID, SECRET, ENV_ID)\n    try:\n        file_id = storage.upload_file(\"../test.png\", \"image/test2.png\")\n        print(f\"文件上传成功，File ID: {file_id}\")\n    except Exception as e:\n        print(f\"上传失败: {e}\")\n    # 下载示例\n    try:\n        storage.download_file(file_id, \"downloaded_image.jpg\")\n        print(\"文件下载成功\")\n    except Exception as e:\n        print(f\"下载失败: {e}\")\n\n\n```\n\n以上就是关于对象存储管理相关的内容了，如果你在开发类似的功能过程中有类似的idea或者遇到一些难搞的坑，欢迎一起讨论。","slug":"Manage-wx-could-service","published":1,"updated":"2025-06-21T14:16:44.677Z","comments":1,"layout":"post","photos":[],"_id":"cmjbml2hy0004ikupg0cw8qei","content":"<p>最近在鼓捣一个关于图像处理相关的小程序，出于快速开发考虑，在后台开发这块，没有选择走传统的后台部署服务。毕竟，购买云服务器，注册购买域名以及备案等一系列操作下来，也够让人心累。</p>\n<p>这次选择的是微信开发的平台的云托管，至于为什么走的不是云函数开发，其中就涉及到了开发语言的选择–python, 如果改用javascript重写一下，成本有点高，所以最终方案选择云托管。</p>\n<p>在按照云托管的部署流程一通走下来后，everything is fine. But…</p>\n<p>离大谱的，接口请求和响应，居然不能超过1M, 而我这程序就是关于图像处理的，动不动图片大小就会超过1M。如果非要限制用户图片大小限制在1M以下，太过影响用户体验。</p>\n<p>此外我还想过，在用户端使用图像压缩，但图像太大压缩也会存在超过1M的情况，另外清晰度也会受到影响。</p>\n<p>在微信开发社区和各个IT论坛找了一圈下来，其实没有比较好的解决方案，最终都需要经过一个中间对象存储的过程。</p>\n<p>也就是先将图片上传到云上，让后将图片对象的id作为接口入参传入，后台需要使用到图片的时候根据图片id下载即可，然后将处理后的图片，又要上传回云上，返回给客户端新的图片的id，客户端可以根据图片id来获取资源。如下图</p>\n<!-- ![处理流程](./imgs/微信云对象存储..png) -->\n<div align=\"center\">\n    <img src=\"/imgs/微信云对象存储..png\" width=\"80%\" height=\"20%\" alt=\"处理流程\"/>\n</div>\n\n\n\n<p>对象存储云平台其实很多，例如比较有名的比如七牛，阿里，还有腾讯云自己的。我这里采用了微信云对象存储，具体的使用呢可以参考 <a href=\"https://developers.weixin.qq.com/minigame/dev/wxcloudrun/src/guide/storage/manage.html\">微信云托管对象存储</a>，相应的开发手册可以参考<a href=\"https://developers.weixin.qq.com/minigame/dev/wxcloudrun/src/development/storage/service/\">对象存储-服务端和其他客户端</a></p>\n<p>为了在后续的开发中更好处理类似的情况，我将微信云托管对象存储做成了一个模块，具体实现情况如下。</p>\n<p>首先，需要从自己的小程序或者和云托管平台获取到以下三个重要参数：</p>\n<ul>\n<li><p><strong>APPID</strong> ： “your-wechat-appid”</p>\n</li>\n<li><p><strong>SECRET</strong>： “your-wechat-secret”</p>\n</li>\n<li><p><strong>ENV_ID</strong>： “your-cloud-env-id”</p>\n</li>\n<li><h3 id=\"文件上传-获取token-获取元数据-上传COS\"><a href=\"#文件上传-获取token-获取元数据-上传COS\" class=\"headerlink\" title=\"文件上传 (获取token-获取元数据-上传COS)\"></a>文件上传 (获取token-获取元数据-上传COS)</h3></li>\n</ul>\n<p>微信开放平台如果第三方调用对应接口的话，都是需要鉴权了，所以首先我们需要获取到token值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_refresh_access_token</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;获取或刷新access_token&quot;&quot;&quot;</span><br>        url = <span class=\"hljs-string\">&quot;https://api.weixin.qq.com/cgi-bin/token&quot;</span><br>        params = &#123;<br>            <span class=\"hljs-string\">&quot;grant_type&quot;</span>: <span class=\"hljs-string\">&quot;client_credential&quot;</span>,<br>            <span class=\"hljs-string\">&quot;appid&quot;</span>: <span class=\"hljs-variable language_\">self</span>.appid,<br>            <span class=\"hljs-string\">&quot;secret&quot;</span>: <span class=\"hljs-variable language_\">self</span>.secret<br>        &#125;<br>        response = requests.get(url, params=params, verify=<span class=\"hljs-literal\">False</span>).json()<br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-string\">&#x27;access_token&#x27;</span> <span class=\"hljs-keyword\">in</span> response:<br>            <span class=\"hljs-variable language_\">self</span>.access_token = response[<span class=\"hljs-string\">&#x27;access_token&#x27;</span>]<br>            <span class=\"hljs-variable language_\">self</span>.token_expires = time.time() + response[<span class=\"hljs-string\">&#x27;expires_in&#x27;</span>] - <span class=\"hljs-number\">300</span>  <span class=\"hljs-comment\"># 提前5分钟刷新</span><br>        <span class=\"hljs-keyword\">else</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;获取access_token失败: <span class=\"hljs-subst\">&#123;response&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n\n<p>文件上传可以分成2步：<strong>1获取上传元数据，2上传文件到COS</strong>。</p>\n<p>获取元数据可以理解为向平台发送请求，获取一个用来存放一个文件（存储对象）的一个URL地址, 上传文件到COS可以则可以理解成将资源放到上一步生成的URL地址上，经此，文件才算真正的上传成功了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">upload_file</span>(<span class=\"hljs-params\">self, local_path, cloud_path</span>):<br>    <span class=\"hljs-string\">&quot;&quot;&quot;</span><br><span class=\"hljs-string\">    上传本地文件到微信云存储</span><br><span class=\"hljs-string\">    :param local_path: 本地文件路径</span><br><span class=\"hljs-string\">    :param cloud_path: 云端存储路径（如：&#x27;images/example.jpg&#x27;）</span><br><span class=\"hljs-string\">    :return: 文件ID（用于后续下载）</span><br><span class=\"hljs-string\">    &quot;&quot;&quot;</span><br>    <span class=\"hljs-variable language_\">self</span>._ensure_access_token()<br>    <br>    <span class=\"hljs-comment\"># 1. 获取上传元数据</span><br>    upload_meta_url = <span class=\"hljs-string\">&quot;https://api.weixin.qq.com/tcb/uploadfile&quot;</span><br>    params = &#123;<span class=\"hljs-string\">&quot;access_token&quot;</span>: <span class=\"hljs-variable language_\">self</span>.access_token&#125;<br>    payload = &#123;<span class=\"hljs-string\">&quot;env&quot;</span>: <span class=\"hljs-variable language_\">self</span>.env, <span class=\"hljs-string\">&quot;path&quot;</span>: cloud_path&#125;<br>    response = requests.post(upload_meta_url, params=params, json=payload,verify=<span class=\"hljs-literal\">False</span>).json()<br>    <span class=\"hljs-built_in\">print</span>(payload, params)<br>    <span class=\"hljs-keyword\">if</span> response.get(<span class=\"hljs-string\">&#x27;errcode&#x27;</span>, <span class=\"hljs-number\">0</span>) != <span class=\"hljs-number\">0</span>:<br>        <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;上传元数据获取失败: <span class=\"hljs-subst\">&#123;response&#125;</span>&quot;</span>)<br>    <br>    <span class=\"hljs-comment\"># 2. 上传文件到COS</span><br>    cos_url = response[<span class=\"hljs-string\">&#x27;url&#x27;</span>]<br>   <br>    key = cloud_path.split(<span class=\"hljs-string\">&#x27;/&#x27;</span>)[-<span class=\"hljs-number\">1</span>]<br>    <span class=\"hljs-built_in\">print</span>(key)<br>    files = &#123;<br>        <span class=\"hljs-string\">&quot;Signature&quot;</span>:(<span class=\"hljs-literal\">None</span>,response[<span class=\"hljs-string\">&#x27;authorization&#x27;</span>]),<br>        <span class=\"hljs-string\">&quot;x-cos-meta-fileid&quot;</span>: (<span class=\"hljs-literal\">None</span>, response[<span class=\"hljs-string\">&#x27;cos_file_id&#x27;</span>]),<br>        <span class=\"hljs-string\">&quot;x-cos-security-token&quot;</span>: (<span class=\"hljs-literal\">None</span>,response[<span class=\"hljs-string\">&#x27;token&#x27;</span>]),<br>        <span class=\"hljs-string\">&quot;key&quot;</span>: (<span class=\"hljs-literal\">None</span>, cloud_path),<br>        <span class=\"hljs-string\">&#x27;file&#x27;</span>:(key, <span class=\"hljs-built_in\">open</span>(local_path, <span class=\"hljs-string\">&#x27;rb&#x27;</span>)),<br>    &#125;<br><br>    upload_resp = requests.post(cos_url, files=files, verify=<span class=\"hljs-literal\">False</span>)<br>    <span class=\"hljs-keyword\">if</span> upload_resp.status_code != <span class=\"hljs-number\">204</span>:<br>        <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;COS上传失败: <span class=\"hljs-subst\">&#123;upload_resp.text&#125;</span>&quot;</span>, upload_resp)<br>   <br>    <span class=\"hljs-keyword\">return</span> response[<span class=\"hljs-string\">&#x27;file_id&#x27;</span>]<br></code></pre></td></tr></table></figure>\n\n\n<ul>\n<li><h3 id=\"文件下载\"><a href=\"#文件下载\" class=\"headerlink\" title=\"文件下载\"></a>文件下载</h3></li>\n</ul>\n<p>下载文件相对简单一些，直接调用微信开放平台对外提供的批量下载接口，当然对应的token也是需要的，这部分就不做赘述，代码实现可以参考下方。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Python\"><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">download_file</span>(<span class=\"hljs-params\">self, file_id, local_path</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;</span><br><span class=\"hljs-string\">        从微信云存储下载文件</span><br><span class=\"hljs-string\">        :param file_id: 文件ID（上传时返回的file_id）</span><br><span class=\"hljs-string\">        :param local_path: 本地存储路径</span><br><span class=\"hljs-string\">        &quot;&quot;&quot;</span><br>        <span class=\"hljs-variable language_\">self</span>._ensure_access_token()<br>        <br>        <span class=\"hljs-comment\"># 1. 获取下载链接</span><br>        download_meta_url = <span class=\"hljs-string\">&quot;https://api.weixin.qq.com/tcb/batchdownloadfile&quot;</span><br>        params = &#123;<span class=\"hljs-string\">&quot;access_token&quot;</span>: <span class=\"hljs-variable language_\">self</span>.access_token&#125;<br>        payload = &#123;<br>            <span class=\"hljs-string\">&quot;env&quot;</span>: <span class=\"hljs-variable language_\">self</span>.env,<br>            <span class=\"hljs-string\">&quot;file_list&quot;</span>: [&#123;<span class=\"hljs-string\">&quot;fileid&quot;</span>: file_id, <span class=\"hljs-string\">&quot;max_age&quot;</span>: <span class=\"hljs-number\">7200</span>&#125;]<br>        &#125;<br>        response = requests.post(download_meta_url, params=params, json=payload, verify=<span class=\"hljs-literal\">False</span>).json()<br>        <br>        <span class=\"hljs-keyword\">if</span> response.get(<span class=\"hljs-string\">&#x27;errcode&#x27;</span>, <span class=\"hljs-number\">0</span>) != <span class=\"hljs-number\">0</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;下载元数据获取失败: <span class=\"hljs-subst\">&#123;response&#125;</span>&quot;</span>)<br>        <br>        file_info = response[<span class=\"hljs-string\">&#x27;file_list&#x27;</span>][<span class=\"hljs-number\">0</span>]<br>        <span class=\"hljs-keyword\">if</span> file_info[<span class=\"hljs-string\">&#x27;status&#x27;</span>] != <span class=\"hljs-number\">0</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;下载错误: <span class=\"hljs-subst\">&#123;file_info[<span class=\"hljs-string\">&#x27;errmsg&#x27;</span>]&#125;</span>&quot;</span>)<br>        <br>        <span class=\"hljs-comment\"># 2. 下载文件</span><br>        download_resp = requests.get(file_info[<span class=\"hljs-string\">&#x27;download_url&#x27;</span>], verify=<span class=\"hljs-literal\">False</span>)<br>        <span class=\"hljs-keyword\">if</span> download_resp.status_code != <span class=\"hljs-number\">200</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">&quot;文件下载失败&quot;</span>)<br>        <br>        <span class=\"hljs-keyword\">with</span> <span class=\"hljs-built_in\">open</span>(local_path, <span class=\"hljs-string\">&#x27;wb&#x27;</span>) <span class=\"hljs-keyword\">as</span> f:<br>            f.write(download_resp.content)<br>            <br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span><br></code></pre></td></tr></table></figure>\n\n<p>以上就是微信云托管上对象存储的上传和下载的实现了。为了方便，我们可以将功能在一个类中实现。此外，考虑到token获取接口是有限制的，每天的调用次数是2000次，而每个token的有效时间是2小时，因此可以重复利用已有token。</p>\n<p>最终，完整的代码实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Python\"><span class=\"hljs-comment\"># wx-cloud-storage.py</span><br><span class=\"hljs-comment\"># description: 微信云托管对象存储管理模块</span><br><span class=\"hljs-keyword\">import</span> requests<br><span class=\"hljs-keyword\">import</span> time<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">WeChatCloudStorage</span>:<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, appid, secret, env</span>):<br>        <span class=\"hljs-variable language_\">self</span>.appid = appid<br>        <span class=\"hljs-variable language_\">self</span>.secret = secret<br>        <span class=\"hljs-variable language_\">self</span>.env = env<br>        <span class=\"hljs-variable language_\">self</span>.access_token = <span class=\"hljs-literal\">None</span><br>        <span class=\"hljs-variable language_\">self</span>.token_expires = <span class=\"hljs-number\">0</span>  <span class=\"hljs-comment\"># Token过期时间戳</span><br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_refresh_access_token</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;获取或刷新access_token&quot;&quot;&quot;</span><br>        url = <span class=\"hljs-string\">&quot;https://api.weixin.qq.com/cgi-bin/token&quot;</span><br>        params = &#123;<br>            <span class=\"hljs-string\">&quot;grant_type&quot;</span>: <span class=\"hljs-string\">&quot;client_credential&quot;</span>,<br>            <span class=\"hljs-string\">&quot;appid&quot;</span>: <span class=\"hljs-variable language_\">self</span>.appid,<br>            <span class=\"hljs-string\">&quot;secret&quot;</span>: <span class=\"hljs-variable language_\">self</span>.secret<br>        &#125;<br>        response = requests.get(url, params=params, verify=<span class=\"hljs-literal\">False</span>).json()<br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-string\">&#x27;access_token&#x27;</span> <span class=\"hljs-keyword\">in</span> response:<br>            <span class=\"hljs-variable language_\">self</span>.access_token = response[<span class=\"hljs-string\">&#x27;access_token&#x27;</span>]<br>            <span class=\"hljs-variable language_\">self</span>.token_expires = time.time() + response[<span class=\"hljs-string\">&#x27;expires_in&#x27;</span>] - <span class=\"hljs-number\">300</span>  <span class=\"hljs-comment\"># 提前5分钟刷新</span><br>        <span class=\"hljs-keyword\">else</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;获取access_token失败: <span class=\"hljs-subst\">&#123;response&#125;</span>&quot;</span>)<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_ensure_access_token</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;确保access_token有效&quot;&quot;&quot;</span><br>        <span class=\"hljs-keyword\">if</span> time.time() &gt;= <span class=\"hljs-variable language_\">self</span>.token_expires <span class=\"hljs-keyword\">or</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-variable language_\">self</span>.access_token:<br>            <span class=\"hljs-variable language_\">self</span>._refresh_access_token()<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">upload_file</span>(<span class=\"hljs-params\">self, local_path, cloud_path</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;</span><br><span class=\"hljs-string\">        上传本地文件到微信云存储</span><br><span class=\"hljs-string\">        :param local_path: 本地文件路径</span><br><span class=\"hljs-string\">        :param cloud_path: 云端存储路径（如：&#x27;images/example.jpg&#x27;）</span><br><span class=\"hljs-string\">        :return: 文件ID（用于后续下载）</span><br><span class=\"hljs-string\">        &quot;&quot;&quot;</span><br>        <span class=\"hljs-variable language_\">self</span>._ensure_access_token()<br>        <br>        <span class=\"hljs-comment\"># 1. 获取上传元数据</span><br>        upload_meta_url = <span class=\"hljs-string\">&quot;https://api.weixin.qq.com/tcb/uploadfile&quot;</span><br>        params = &#123;<span class=\"hljs-string\">&quot;access_token&quot;</span>: <span class=\"hljs-variable language_\">self</span>.access_token&#125;<br>        payload = &#123;<span class=\"hljs-string\">&quot;env&quot;</span>: <span class=\"hljs-variable language_\">self</span>.env, <span class=\"hljs-string\">&quot;path&quot;</span>: cloud_path&#125;<br>        response = requests.post(upload_meta_url, params=params, json=payload,verify=<span class=\"hljs-literal\">False</span>).json()<br>        <span class=\"hljs-built_in\">print</span>(payload, params)<br>        <span class=\"hljs-keyword\">if</span> response.get(<span class=\"hljs-string\">&#x27;errcode&#x27;</span>, <span class=\"hljs-number\">0</span>) != <span class=\"hljs-number\">0</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;上传元数据获取失败: <span class=\"hljs-subst\">&#123;response&#125;</span>&quot;</span>)<br>        <br>        <span class=\"hljs-comment\"># 2. 上传文件到COS</span><br>        cos_url = response[<span class=\"hljs-string\">&#x27;url&#x27;</span>]<br>       <br>        key = cloud_path.split(<span class=\"hljs-string\">&#x27;/&#x27;</span>)[-<span class=\"hljs-number\">1</span>]<br>        <span class=\"hljs-built_in\">print</span>(key)<br>        files = &#123;<br>            <span class=\"hljs-string\">&quot;Signature&quot;</span>:(<span class=\"hljs-literal\">None</span>,response[<span class=\"hljs-string\">&#x27;authorization&#x27;</span>]),<br>            <span class=\"hljs-string\">&quot;x-cos-meta-fileid&quot;</span>: (<span class=\"hljs-literal\">None</span>, response[<span class=\"hljs-string\">&#x27;cos_file_id&#x27;</span>]),<br>            <span class=\"hljs-string\">&quot;x-cos-security-token&quot;</span>: (<span class=\"hljs-literal\">None</span>,response[<span class=\"hljs-string\">&#x27;token&#x27;</span>]),<br>            <span class=\"hljs-string\">&quot;key&quot;</span>: (<span class=\"hljs-literal\">None</span>, cloud_path),<br>            <span class=\"hljs-string\">&#x27;file&#x27;</span>:(key, <span class=\"hljs-built_in\">open</span>(local_path, <span class=\"hljs-string\">&#x27;rb&#x27;</span>)),<br>        &#125;<br><br>        upload_resp = requests.post(cos_url, files=files, verify=<span class=\"hljs-literal\">False</span>)<br>        <span class=\"hljs-keyword\">if</span> upload_resp.status_code != <span class=\"hljs-number\">204</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;COS上传失败: <span class=\"hljs-subst\">&#123;upload_resp.text&#125;</span>&quot;</span>, upload_resp)<br>       <br>        <span class=\"hljs-keyword\">return</span> response[<span class=\"hljs-string\">&#x27;file_id&#x27;</span>]<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">download_file</span>(<span class=\"hljs-params\">self, file_id, local_path</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;</span><br><span class=\"hljs-string\">        从微信云存储下载文件</span><br><span class=\"hljs-string\">        :param file_id: 文件ID（上传时返回的file_id）</span><br><span class=\"hljs-string\">        :param local_path: 本地存储路径</span><br><span class=\"hljs-string\">        &quot;&quot;&quot;</span><br>        <span class=\"hljs-variable language_\">self</span>._ensure_access_token()<br>        <br>        <span class=\"hljs-comment\"># 1. 获取下载链接</span><br>        download_meta_url = <span class=\"hljs-string\">&quot;https://api.weixin.qq.com/tcb/batchdownloadfile&quot;</span><br>        params = &#123;<span class=\"hljs-string\">&quot;access_token&quot;</span>: <span class=\"hljs-variable language_\">self</span>.access_token&#125;<br>        payload = &#123;<br>            <span class=\"hljs-string\">&quot;env&quot;</span>: <span class=\"hljs-variable language_\">self</span>.env,<br>            <span class=\"hljs-string\">&quot;file_list&quot;</span>: [&#123;<span class=\"hljs-string\">&quot;fileid&quot;</span>: file_id, <span class=\"hljs-string\">&quot;max_age&quot;</span>: <span class=\"hljs-number\">7200</span>&#125;]<br>        &#125;<br>        response = requests.post(download_meta_url, params=params, json=payload, verify=<span class=\"hljs-literal\">False</span>).json()<br>        <br>        <span class=\"hljs-keyword\">if</span> response.get(<span class=\"hljs-string\">&#x27;errcode&#x27;</span>, <span class=\"hljs-number\">0</span>) != <span class=\"hljs-number\">0</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;下载元数据获取失败: <span class=\"hljs-subst\">&#123;response&#125;</span>&quot;</span>)<br>        <br>        file_info = response[<span class=\"hljs-string\">&#x27;file_list&#x27;</span>][<span class=\"hljs-number\">0</span>]<br>        <span class=\"hljs-keyword\">if</span> file_info[<span class=\"hljs-string\">&#x27;status&#x27;</span>] != <span class=\"hljs-number\">0</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;下载错误: <span class=\"hljs-subst\">&#123;file_info[<span class=\"hljs-string\">&#x27;errmsg&#x27;</span>]&#125;</span>&quot;</span>)<br>        <br>        <span class=\"hljs-comment\"># 2. 下载文件</span><br>        download_resp = requests.get(file_info[<span class=\"hljs-string\">&#x27;download_url&#x27;</span>], verify=<span class=\"hljs-literal\">False</span>)<br>        <span class=\"hljs-keyword\">if</span> download_resp.status_code != <span class=\"hljs-number\">200</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">&quot;文件下载失败&quot;</span>)<br>        <br>        <span class=\"hljs-keyword\">with</span> <span class=\"hljs-built_in\">open</span>(local_path, <span class=\"hljs-string\">&#x27;wb&#x27;</span>) <span class=\"hljs-keyword\">as</span> f:<br>            f.write(download_resp.content)<br>            <br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span><br><br><span class=\"hljs-comment\"># 使用示例</span><br><span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:<br>    <span class=\"hljs-comment\"># 配置信息（需要替换为实际值）</span><br>    APPID = <span class=\"hljs-string\">&quot;your-wechat-appid&quot;</span><br>    SECRET = <span class=\"hljs-string\">&quot;your-wechat-secret&quot;</span><br>    ENV_ID = <span class=\"hljs-string\">&quot;your-cloud-env-id&quot;</span><br>   <br>    <span class=\"hljs-comment\"># 上传示例</span><br>    storage = WeChatCloudStorage(APPID, SECRET, ENV_ID)<br>    <span class=\"hljs-keyword\">try</span>:<br>        file_id = storage.upload_file(<span class=\"hljs-string\">&quot;../test.png&quot;</span>, <span class=\"hljs-string\">&quot;image/test2.png&quot;</span>)<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;文件上传成功，File ID: <span class=\"hljs-subst\">&#123;file_id&#125;</span>&quot;</span>)<br>    <span class=\"hljs-keyword\">except</span> Exception <span class=\"hljs-keyword\">as</span> e:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;上传失败: <span class=\"hljs-subst\">&#123;e&#125;</span>&quot;</span>)<br>    <span class=\"hljs-comment\"># 下载示例</span><br>    <span class=\"hljs-keyword\">try</span>:<br>        storage.download_file(file_id, <span class=\"hljs-string\">&quot;downloaded_image.jpg&quot;</span>)<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;文件下载成功&quot;</span>)<br>    <span class=\"hljs-keyword\">except</span> Exception <span class=\"hljs-keyword\">as</span> e:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;下载失败: <span class=\"hljs-subst\">&#123;e&#125;</span>&quot;</span>)<br><br><br></code></pre></td></tr></table></figure>\n\n<p>以上就是关于对象存储管理相关的内容了，如果你在开发类似的功能过程中有类似的idea或者遇到一些难搞的坑，欢迎一起讨论。</p>\n","excerpt":"","more":"<p>最近在鼓捣一个关于图像处理相关的小程序，出于快速开发考虑，在后台开发这块，没有选择走传统的后台部署服务。毕竟，购买云服务器，注册购买域名以及备案等一系列操作下来，也够让人心累。</p>\n<p>这次选择的是微信开发的平台的云托管，至于为什么走的不是云函数开发，其中就涉及到了开发语言的选择–python, 如果改用javascript重写一下，成本有点高，所以最终方案选择云托管。</p>\n<p>在按照云托管的部署流程一通走下来后，everything is fine. But…</p>\n<p>离大谱的，接口请求和响应，居然不能超过1M, 而我这程序就是关于图像处理的，动不动图片大小就会超过1M。如果非要限制用户图片大小限制在1M以下，太过影响用户体验。</p>\n<p>此外我还想过，在用户端使用图像压缩，但图像太大压缩也会存在超过1M的情况，另外清晰度也会受到影响。</p>\n<p>在微信开发社区和各个IT论坛找了一圈下来，其实没有比较好的解决方案，最终都需要经过一个中间对象存储的过程。</p>\n<p>也就是先将图片上传到云上，让后将图片对象的id作为接口入参传入，后台需要使用到图片的时候根据图片id下载即可，然后将处理后的图片，又要上传回云上，返回给客户端新的图片的id，客户端可以根据图片id来获取资源。如下图</p>\n<!-- ![处理流程](./imgs/微信云对象存储..png) -->\n<div align=\"center\">\n    <img src=\"/imgs/微信云对象存储..png\" width=\"80%\" height=\"20%\" alt=\"处理流程\"/>\n</div>\n\n\n\n<p>对象存储云平台其实很多，例如比较有名的比如七牛，阿里，还有腾讯云自己的。我这里采用了微信云对象存储，具体的使用呢可以参考 <a href=\"https://developers.weixin.qq.com/minigame/dev/wxcloudrun/src/guide/storage/manage.html\">微信云托管对象存储</a>，相应的开发手册可以参考<a href=\"https://developers.weixin.qq.com/minigame/dev/wxcloudrun/src/development/storage/service/\">对象存储-服务端和其他客户端</a></p>\n<p>为了在后续的开发中更好处理类似的情况，我将微信云托管对象存储做成了一个模块，具体实现情况如下。</p>\n<p>首先，需要从自己的小程序或者和云托管平台获取到以下三个重要参数：</p>\n<ul>\n<li><p><strong>APPID</strong> ： “your-wechat-appid”</p>\n</li>\n<li><p><strong>SECRET</strong>： “your-wechat-secret”</p>\n</li>\n<li><p><strong>ENV_ID</strong>： “your-cloud-env-id”</p>\n</li>\n<li><h3 id=\"文件上传-获取token-获取元数据-上传COS\"><a href=\"#文件上传-获取token-获取元数据-上传COS\" class=\"headerlink\" title=\"文件上传 (获取token-获取元数据-上传COS)\"></a>文件上传 (获取token-获取元数据-上传COS)</h3></li>\n</ul>\n<p>微信开放平台如果第三方调用对应接口的话，都是需要鉴权了，所以首先我们需要获取到token值。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_refresh_access_token</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;获取或刷新access_token&quot;&quot;&quot;</span><br>        url = <span class=\"hljs-string\">&quot;https://api.weixin.qq.com/cgi-bin/token&quot;</span><br>        params = &#123;<br>            <span class=\"hljs-string\">&quot;grant_type&quot;</span>: <span class=\"hljs-string\">&quot;client_credential&quot;</span>,<br>            <span class=\"hljs-string\">&quot;appid&quot;</span>: <span class=\"hljs-variable language_\">self</span>.appid,<br>            <span class=\"hljs-string\">&quot;secret&quot;</span>: <span class=\"hljs-variable language_\">self</span>.secret<br>        &#125;<br>        response = requests.get(url, params=params, verify=<span class=\"hljs-literal\">False</span>).json()<br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-string\">&#x27;access_token&#x27;</span> <span class=\"hljs-keyword\">in</span> response:<br>            <span class=\"hljs-variable language_\">self</span>.access_token = response[<span class=\"hljs-string\">&#x27;access_token&#x27;</span>]<br>            <span class=\"hljs-variable language_\">self</span>.token_expires = time.time() + response[<span class=\"hljs-string\">&#x27;expires_in&#x27;</span>] - <span class=\"hljs-number\">300</span>  <span class=\"hljs-comment\"># 提前5分钟刷新</span><br>        <span class=\"hljs-keyword\">else</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;获取access_token失败: <span class=\"hljs-subst\">&#123;response&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure>\n\n\n<p>文件上传可以分成2步：<strong>1获取上传元数据，2上传文件到COS</strong>。</p>\n<p>获取元数据可以理解为向平台发送请求，获取一个用来存放一个文件（存储对象）的一个URL地址, 上传文件到COS可以则可以理解成将资源放到上一步生成的URL地址上，经此，文件才算真正的上传成功了。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">upload_file</span>(<span class=\"hljs-params\">self, local_path, cloud_path</span>):<br>    <span class=\"hljs-string\">&quot;&quot;&quot;</span><br><span class=\"hljs-string\">    上传本地文件到微信云存储</span><br><span class=\"hljs-string\">    :param local_path: 本地文件路径</span><br><span class=\"hljs-string\">    :param cloud_path: 云端存储路径（如：&#x27;images/example.jpg&#x27;）</span><br><span class=\"hljs-string\">    :return: 文件ID（用于后续下载）</span><br><span class=\"hljs-string\">    &quot;&quot;&quot;</span><br>    <span class=\"hljs-variable language_\">self</span>._ensure_access_token()<br>    <br>    <span class=\"hljs-comment\"># 1. 获取上传元数据</span><br>    upload_meta_url = <span class=\"hljs-string\">&quot;https://api.weixin.qq.com/tcb/uploadfile&quot;</span><br>    params = &#123;<span class=\"hljs-string\">&quot;access_token&quot;</span>: <span class=\"hljs-variable language_\">self</span>.access_token&#125;<br>    payload = &#123;<span class=\"hljs-string\">&quot;env&quot;</span>: <span class=\"hljs-variable language_\">self</span>.env, <span class=\"hljs-string\">&quot;path&quot;</span>: cloud_path&#125;<br>    response = requests.post(upload_meta_url, params=params, json=payload,verify=<span class=\"hljs-literal\">False</span>).json()<br>    <span class=\"hljs-built_in\">print</span>(payload, params)<br>    <span class=\"hljs-keyword\">if</span> response.get(<span class=\"hljs-string\">&#x27;errcode&#x27;</span>, <span class=\"hljs-number\">0</span>) != <span class=\"hljs-number\">0</span>:<br>        <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;上传元数据获取失败: <span class=\"hljs-subst\">&#123;response&#125;</span>&quot;</span>)<br>    <br>    <span class=\"hljs-comment\"># 2. 上传文件到COS</span><br>    cos_url = response[<span class=\"hljs-string\">&#x27;url&#x27;</span>]<br>   <br>    key = cloud_path.split(<span class=\"hljs-string\">&#x27;/&#x27;</span>)[-<span class=\"hljs-number\">1</span>]<br>    <span class=\"hljs-built_in\">print</span>(key)<br>    files = &#123;<br>        <span class=\"hljs-string\">&quot;Signature&quot;</span>:(<span class=\"hljs-literal\">None</span>,response[<span class=\"hljs-string\">&#x27;authorization&#x27;</span>]),<br>        <span class=\"hljs-string\">&quot;x-cos-meta-fileid&quot;</span>: (<span class=\"hljs-literal\">None</span>, response[<span class=\"hljs-string\">&#x27;cos_file_id&#x27;</span>]),<br>        <span class=\"hljs-string\">&quot;x-cos-security-token&quot;</span>: (<span class=\"hljs-literal\">None</span>,response[<span class=\"hljs-string\">&#x27;token&#x27;</span>]),<br>        <span class=\"hljs-string\">&quot;key&quot;</span>: (<span class=\"hljs-literal\">None</span>, cloud_path),<br>        <span class=\"hljs-string\">&#x27;file&#x27;</span>:(key, <span class=\"hljs-built_in\">open</span>(local_path, <span class=\"hljs-string\">&#x27;rb&#x27;</span>)),<br>    &#125;<br><br>    upload_resp = requests.post(cos_url, files=files, verify=<span class=\"hljs-literal\">False</span>)<br>    <span class=\"hljs-keyword\">if</span> upload_resp.status_code != <span class=\"hljs-number\">204</span>:<br>        <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;COS上传失败: <span class=\"hljs-subst\">&#123;upload_resp.text&#125;</span>&quot;</span>, upload_resp)<br>   <br>    <span class=\"hljs-keyword\">return</span> response[<span class=\"hljs-string\">&#x27;file_id&#x27;</span>]<br></code></pre></td></tr></table></figure>\n\n\n<ul>\n<li><h3 id=\"文件下载\"><a href=\"#文件下载\" class=\"headerlink\" title=\"文件下载\"></a>文件下载</h3></li>\n</ul>\n<p>下载文件相对简单一些，直接调用微信开放平台对外提供的批量下载接口，当然对应的token也是需要的，这部分就不做赘述，代码实现可以参考下方。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Python\"><br><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">download_file</span>(<span class=\"hljs-params\">self, file_id, local_path</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;</span><br><span class=\"hljs-string\">        从微信云存储下载文件</span><br><span class=\"hljs-string\">        :param file_id: 文件ID（上传时返回的file_id）</span><br><span class=\"hljs-string\">        :param local_path: 本地存储路径</span><br><span class=\"hljs-string\">        &quot;&quot;&quot;</span><br>        <span class=\"hljs-variable language_\">self</span>._ensure_access_token()<br>        <br>        <span class=\"hljs-comment\"># 1. 获取下载链接</span><br>        download_meta_url = <span class=\"hljs-string\">&quot;https://api.weixin.qq.com/tcb/batchdownloadfile&quot;</span><br>        params = &#123;<span class=\"hljs-string\">&quot;access_token&quot;</span>: <span class=\"hljs-variable language_\">self</span>.access_token&#125;<br>        payload = &#123;<br>            <span class=\"hljs-string\">&quot;env&quot;</span>: <span class=\"hljs-variable language_\">self</span>.env,<br>            <span class=\"hljs-string\">&quot;file_list&quot;</span>: [&#123;<span class=\"hljs-string\">&quot;fileid&quot;</span>: file_id, <span class=\"hljs-string\">&quot;max_age&quot;</span>: <span class=\"hljs-number\">7200</span>&#125;]<br>        &#125;<br>        response = requests.post(download_meta_url, params=params, json=payload, verify=<span class=\"hljs-literal\">False</span>).json()<br>        <br>        <span class=\"hljs-keyword\">if</span> response.get(<span class=\"hljs-string\">&#x27;errcode&#x27;</span>, <span class=\"hljs-number\">0</span>) != <span class=\"hljs-number\">0</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;下载元数据获取失败: <span class=\"hljs-subst\">&#123;response&#125;</span>&quot;</span>)<br>        <br>        file_info = response[<span class=\"hljs-string\">&#x27;file_list&#x27;</span>][<span class=\"hljs-number\">0</span>]<br>        <span class=\"hljs-keyword\">if</span> file_info[<span class=\"hljs-string\">&#x27;status&#x27;</span>] != <span class=\"hljs-number\">0</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;下载错误: <span class=\"hljs-subst\">&#123;file_info[<span class=\"hljs-string\">&#x27;errmsg&#x27;</span>]&#125;</span>&quot;</span>)<br>        <br>        <span class=\"hljs-comment\"># 2. 下载文件</span><br>        download_resp = requests.get(file_info[<span class=\"hljs-string\">&#x27;download_url&#x27;</span>], verify=<span class=\"hljs-literal\">False</span>)<br>        <span class=\"hljs-keyword\">if</span> download_resp.status_code != <span class=\"hljs-number\">200</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">&quot;文件下载失败&quot;</span>)<br>        <br>        <span class=\"hljs-keyword\">with</span> <span class=\"hljs-built_in\">open</span>(local_path, <span class=\"hljs-string\">&#x27;wb&#x27;</span>) <span class=\"hljs-keyword\">as</span> f:<br>            f.write(download_resp.content)<br>            <br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span><br></code></pre></td></tr></table></figure>\n\n<p>以上就是微信云托管上对象存储的上传和下载的实现了。为了方便，我们可以将功能在一个类中实现。此外，考虑到token获取接口是有限制的，每天的调用次数是2000次，而每个token的有效时间是2小时，因此可以重复利用已有token。</p>\n<p>最终，完整的代码实现如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs Python\"><span class=\"hljs-comment\"># wx-cloud-storage.py</span><br><span class=\"hljs-comment\"># description: 微信云托管对象存储管理模块</span><br><span class=\"hljs-keyword\">import</span> requests<br><span class=\"hljs-keyword\">import</span> time<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">WeChatCloudStorage</span>:<br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, appid, secret, env</span>):<br>        <span class=\"hljs-variable language_\">self</span>.appid = appid<br>        <span class=\"hljs-variable language_\">self</span>.secret = secret<br>        <span class=\"hljs-variable language_\">self</span>.env = env<br>        <span class=\"hljs-variable language_\">self</span>.access_token = <span class=\"hljs-literal\">None</span><br>        <span class=\"hljs-variable language_\">self</span>.token_expires = <span class=\"hljs-number\">0</span>  <span class=\"hljs-comment\"># Token过期时间戳</span><br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_refresh_access_token</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;获取或刷新access_token&quot;&quot;&quot;</span><br>        url = <span class=\"hljs-string\">&quot;https://api.weixin.qq.com/cgi-bin/token&quot;</span><br>        params = &#123;<br>            <span class=\"hljs-string\">&quot;grant_type&quot;</span>: <span class=\"hljs-string\">&quot;client_credential&quot;</span>,<br>            <span class=\"hljs-string\">&quot;appid&quot;</span>: <span class=\"hljs-variable language_\">self</span>.appid,<br>            <span class=\"hljs-string\">&quot;secret&quot;</span>: <span class=\"hljs-variable language_\">self</span>.secret<br>        &#125;<br>        response = requests.get(url, params=params, verify=<span class=\"hljs-literal\">False</span>).json()<br>        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-string\">&#x27;access_token&#x27;</span> <span class=\"hljs-keyword\">in</span> response:<br>            <span class=\"hljs-variable language_\">self</span>.access_token = response[<span class=\"hljs-string\">&#x27;access_token&#x27;</span>]<br>            <span class=\"hljs-variable language_\">self</span>.token_expires = time.time() + response[<span class=\"hljs-string\">&#x27;expires_in&#x27;</span>] - <span class=\"hljs-number\">300</span>  <span class=\"hljs-comment\"># 提前5分钟刷新</span><br>        <span class=\"hljs-keyword\">else</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;获取access_token失败: <span class=\"hljs-subst\">&#123;response&#125;</span>&quot;</span>)<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">_ensure_access_token</span>(<span class=\"hljs-params\">self</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;确保access_token有效&quot;&quot;&quot;</span><br>        <span class=\"hljs-keyword\">if</span> time.time() &gt;= <span class=\"hljs-variable language_\">self</span>.token_expires <span class=\"hljs-keyword\">or</span> <span class=\"hljs-keyword\">not</span> <span class=\"hljs-variable language_\">self</span>.access_token:<br>            <span class=\"hljs-variable language_\">self</span>._refresh_access_token()<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">upload_file</span>(<span class=\"hljs-params\">self, local_path, cloud_path</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;</span><br><span class=\"hljs-string\">        上传本地文件到微信云存储</span><br><span class=\"hljs-string\">        :param local_path: 本地文件路径</span><br><span class=\"hljs-string\">        :param cloud_path: 云端存储路径（如：&#x27;images/example.jpg&#x27;）</span><br><span class=\"hljs-string\">        :return: 文件ID（用于后续下载）</span><br><span class=\"hljs-string\">        &quot;&quot;&quot;</span><br>        <span class=\"hljs-variable language_\">self</span>._ensure_access_token()<br>        <br>        <span class=\"hljs-comment\"># 1. 获取上传元数据</span><br>        upload_meta_url = <span class=\"hljs-string\">&quot;https://api.weixin.qq.com/tcb/uploadfile&quot;</span><br>        params = &#123;<span class=\"hljs-string\">&quot;access_token&quot;</span>: <span class=\"hljs-variable language_\">self</span>.access_token&#125;<br>        payload = &#123;<span class=\"hljs-string\">&quot;env&quot;</span>: <span class=\"hljs-variable language_\">self</span>.env, <span class=\"hljs-string\">&quot;path&quot;</span>: cloud_path&#125;<br>        response = requests.post(upload_meta_url, params=params, json=payload,verify=<span class=\"hljs-literal\">False</span>).json()<br>        <span class=\"hljs-built_in\">print</span>(payload, params)<br>        <span class=\"hljs-keyword\">if</span> response.get(<span class=\"hljs-string\">&#x27;errcode&#x27;</span>, <span class=\"hljs-number\">0</span>) != <span class=\"hljs-number\">0</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;上传元数据获取失败: <span class=\"hljs-subst\">&#123;response&#125;</span>&quot;</span>)<br>        <br>        <span class=\"hljs-comment\"># 2. 上传文件到COS</span><br>        cos_url = response[<span class=\"hljs-string\">&#x27;url&#x27;</span>]<br>       <br>        key = cloud_path.split(<span class=\"hljs-string\">&#x27;/&#x27;</span>)[-<span class=\"hljs-number\">1</span>]<br>        <span class=\"hljs-built_in\">print</span>(key)<br>        files = &#123;<br>            <span class=\"hljs-string\">&quot;Signature&quot;</span>:(<span class=\"hljs-literal\">None</span>,response[<span class=\"hljs-string\">&#x27;authorization&#x27;</span>]),<br>            <span class=\"hljs-string\">&quot;x-cos-meta-fileid&quot;</span>: (<span class=\"hljs-literal\">None</span>, response[<span class=\"hljs-string\">&#x27;cos_file_id&#x27;</span>]),<br>            <span class=\"hljs-string\">&quot;x-cos-security-token&quot;</span>: (<span class=\"hljs-literal\">None</span>,response[<span class=\"hljs-string\">&#x27;token&#x27;</span>]),<br>            <span class=\"hljs-string\">&quot;key&quot;</span>: (<span class=\"hljs-literal\">None</span>, cloud_path),<br>            <span class=\"hljs-string\">&#x27;file&#x27;</span>:(key, <span class=\"hljs-built_in\">open</span>(local_path, <span class=\"hljs-string\">&#x27;rb&#x27;</span>)),<br>        &#125;<br><br>        upload_resp = requests.post(cos_url, files=files, verify=<span class=\"hljs-literal\">False</span>)<br>        <span class=\"hljs-keyword\">if</span> upload_resp.status_code != <span class=\"hljs-number\">204</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;COS上传失败: <span class=\"hljs-subst\">&#123;upload_resp.text&#125;</span>&quot;</span>, upload_resp)<br>       <br>        <span class=\"hljs-keyword\">return</span> response[<span class=\"hljs-string\">&#x27;file_id&#x27;</span>]<br><br>    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">download_file</span>(<span class=\"hljs-params\">self, file_id, local_path</span>):<br>        <span class=\"hljs-string\">&quot;&quot;&quot;</span><br><span class=\"hljs-string\">        从微信云存储下载文件</span><br><span class=\"hljs-string\">        :param file_id: 文件ID（上传时返回的file_id）</span><br><span class=\"hljs-string\">        :param local_path: 本地存储路径</span><br><span class=\"hljs-string\">        &quot;&quot;&quot;</span><br>        <span class=\"hljs-variable language_\">self</span>._ensure_access_token()<br>        <br>        <span class=\"hljs-comment\"># 1. 获取下载链接</span><br>        download_meta_url = <span class=\"hljs-string\">&quot;https://api.weixin.qq.com/tcb/batchdownloadfile&quot;</span><br>        params = &#123;<span class=\"hljs-string\">&quot;access_token&quot;</span>: <span class=\"hljs-variable language_\">self</span>.access_token&#125;<br>        payload = &#123;<br>            <span class=\"hljs-string\">&quot;env&quot;</span>: <span class=\"hljs-variable language_\">self</span>.env,<br>            <span class=\"hljs-string\">&quot;file_list&quot;</span>: [&#123;<span class=\"hljs-string\">&quot;fileid&quot;</span>: file_id, <span class=\"hljs-string\">&quot;max_age&quot;</span>: <span class=\"hljs-number\">7200</span>&#125;]<br>        &#125;<br>        response = requests.post(download_meta_url, params=params, json=payload, verify=<span class=\"hljs-literal\">False</span>).json()<br>        <br>        <span class=\"hljs-keyword\">if</span> response.get(<span class=\"hljs-string\">&#x27;errcode&#x27;</span>, <span class=\"hljs-number\">0</span>) != <span class=\"hljs-number\">0</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;下载元数据获取失败: <span class=\"hljs-subst\">&#123;response&#125;</span>&quot;</span>)<br>        <br>        file_info = response[<span class=\"hljs-string\">&#x27;file_list&#x27;</span>][<span class=\"hljs-number\">0</span>]<br>        <span class=\"hljs-keyword\">if</span> file_info[<span class=\"hljs-string\">&#x27;status&#x27;</span>] != <span class=\"hljs-number\">0</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">f&quot;下载错误: <span class=\"hljs-subst\">&#123;file_info[<span class=\"hljs-string\">&#x27;errmsg&#x27;</span>]&#125;</span>&quot;</span>)<br>        <br>        <span class=\"hljs-comment\"># 2. 下载文件</span><br>        download_resp = requests.get(file_info[<span class=\"hljs-string\">&#x27;download_url&#x27;</span>], verify=<span class=\"hljs-literal\">False</span>)<br>        <span class=\"hljs-keyword\">if</span> download_resp.status_code != <span class=\"hljs-number\">200</span>:<br>            <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">&quot;文件下载失败&quot;</span>)<br>        <br>        <span class=\"hljs-keyword\">with</span> <span class=\"hljs-built_in\">open</span>(local_path, <span class=\"hljs-string\">&#x27;wb&#x27;</span>) <span class=\"hljs-keyword\">as</span> f:<br>            f.write(download_resp.content)<br>            <br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span><br><br><span class=\"hljs-comment\"># 使用示例</span><br><span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:<br>    <span class=\"hljs-comment\"># 配置信息（需要替换为实际值）</span><br>    APPID = <span class=\"hljs-string\">&quot;your-wechat-appid&quot;</span><br>    SECRET = <span class=\"hljs-string\">&quot;your-wechat-secret&quot;</span><br>    ENV_ID = <span class=\"hljs-string\">&quot;your-cloud-env-id&quot;</span><br>   <br>    <span class=\"hljs-comment\"># 上传示例</span><br>    storage = WeChatCloudStorage(APPID, SECRET, ENV_ID)<br>    <span class=\"hljs-keyword\">try</span>:<br>        file_id = storage.upload_file(<span class=\"hljs-string\">&quot;../test.png&quot;</span>, <span class=\"hljs-string\">&quot;image/test2.png&quot;</span>)<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;文件上传成功，File ID: <span class=\"hljs-subst\">&#123;file_id&#125;</span>&quot;</span>)<br>    <span class=\"hljs-keyword\">except</span> Exception <span class=\"hljs-keyword\">as</span> e:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;上传失败: <span class=\"hljs-subst\">&#123;e&#125;</span>&quot;</span>)<br>    <span class=\"hljs-comment\"># 下载示例</span><br>    <span class=\"hljs-keyword\">try</span>:<br>        storage.download_file(file_id, <span class=\"hljs-string\">&quot;downloaded_image.jpg&quot;</span>)<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;文件下载成功&quot;</span>)<br>    <span class=\"hljs-keyword\">except</span> Exception <span class=\"hljs-keyword\">as</span> e:<br>        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;下载失败: <span class=\"hljs-subst\">&#123;e&#125;</span>&quot;</span>)<br><br><br></code></pre></td></tr></table></figure>\n\n<p>以上就是关于对象存储管理相关的内容了，如果你在开发类似的功能过程中有类似的idea或者遇到一些难搞的坑，欢迎一起讨论。</p>\n"},{"title":"糟糕，Vite proxy error ECONNREFUSED","date":"2025-05-23T04:40:00.000Z","_content":" \n\n最近正在开发一款应用，前端框架是vite+vue, 后台服务也是使用的node+express组合，当一切工作都在顺利进行的时候，不出意外，意外出现了。\n\n当我尝试使用axios直连本地服务地址的时候，丝滑得如同德芙一样。然而每次请求地址都需要拼写全链接--即host+port+service-path，这是一件很愚蠢的事情。\n\n为了让事情变得简单一些，减少重复工作，我和聪明的各位一样决定使用vite的代理。\n\n因为web的地址9000，本地启动的后台服务地址是8080，所以我最初的配置如下：\n\n``` javascript\nexport default defineConfig({\n  # ...   其它配置\n  server: {\n    host: '0.0.0.0',\n    port: 9000,\n    proxy: {\n      '/api': {\n        target: 'http://localhost:8080/',\n        changeOrigin: true,\n      }\n    }\n  }\n})\n\n```\n\n然后它却对我说 `Vite proxy error ECONNREFUSED`\n\n那么多大风大浪都过去了，居然在这小阴沟里翻了船，忍不了！\n\n## 排查方向\n因为涉及到vite server配置，其本质就是http-server以及http-agent的问题,  于是从从下面几个方向做了一一排查\n\n- **Vite的服务器配置**\n\n- **端口占用或防火墙设置**\n\n- **浏览器或系统代理设置**\n\n- ​**Hosts文件配置问题或DNS解析问题**\n\n\n## 测试验证\n- 首先vite服务配置问题是最先被排除的，因为该项目配置已经经历了时间的考验，在很多项目中都有使用\n\n- 然后通过 `netstat -ano | find 9000` 检查并未发现端口被占用的情况\n\n- 至于代理，确实是开了--科学上网使用。然而在关闭之后，似乎没有起作用，所以问题不在这里。\n\n- 那么还剩最后一条，当我检查我本地的hosts文件时，纳尼，localhost没有配置指向本地的环回地址127.0.0.1，难道是这里出问题了吗。\n\n  为了验证这个想法，我将配置中的target做了以下修改:\n\n  ~~target: 'http://localhost:8080/'~~ </br>\n    target: 'http://127.0.0.1:8080/'\n\n  果然，生效了，看来之前的猜测是对的。\n\n</br>\n\n所以目前至少有两种方法可以解决该问题：\n\n  - **在vite配置中将localhost替换成127.0.0.1**\n  - **在hosts文件中添加localhost的地址**\n\n当然，第二种方式显然是更合理的，几乎是种一劳永逸的方法，在日后不同项目的开发中，总是难免还会存在使用localhost的情况。因此，建议在hosts文件中配置它。\n\n## 总结\n在这个问题中呢，其实也牵扯出更多的关于http server 和 http client相关的知识。不论是server的创建还是client的连接，正确的ip和端口是需要保证的。\n\n当遇到类似的情况时，不妨从底层思考在复杂的封装工具和配置的背后，它的本质是什么，以及正常使用时需要哪些因子的参与。","source":"_posts/Vite-server-error.md","raw":"---\ntitle: 糟糕，Vite proxy error ECONNREFUSED\ndate: 2025-05-23 12:40:00\ncategory: Web开发\ntags:\n  - Vite\n  - Proxy\n  - error\n--- \n\n最近正在开发一款应用，前端框架是vite+vue, 后台服务也是使用的node+express组合，当一切工作都在顺利进行的时候，不出意外，意外出现了。\n\n当我尝试使用axios直连本地服务地址的时候，丝滑得如同德芙一样。然而每次请求地址都需要拼写全链接--即host+port+service-path，这是一件很愚蠢的事情。\n\n为了让事情变得简单一些，减少重复工作，我和聪明的各位一样决定使用vite的代理。\n\n因为web的地址9000，本地启动的后台服务地址是8080，所以我最初的配置如下：\n\n``` javascript\nexport default defineConfig({\n  # ...   其它配置\n  server: {\n    host: '0.0.0.0',\n    port: 9000,\n    proxy: {\n      '/api': {\n        target: 'http://localhost:8080/',\n        changeOrigin: true,\n      }\n    }\n  }\n})\n\n```\n\n然后它却对我说 `Vite proxy error ECONNREFUSED`\n\n那么多大风大浪都过去了，居然在这小阴沟里翻了船，忍不了！\n\n## 排查方向\n因为涉及到vite server配置，其本质就是http-server以及http-agent的问题,  于是从从下面几个方向做了一一排查\n\n- **Vite的服务器配置**\n\n- **端口占用或防火墙设置**\n\n- **浏览器或系统代理设置**\n\n- ​**Hosts文件配置问题或DNS解析问题**\n\n\n## 测试验证\n- 首先vite服务配置问题是最先被排除的，因为该项目配置已经经历了时间的考验，在很多项目中都有使用\n\n- 然后通过 `netstat -ano | find 9000` 检查并未发现端口被占用的情况\n\n- 至于代理，确实是开了--科学上网使用。然而在关闭之后，似乎没有起作用，所以问题不在这里。\n\n- 那么还剩最后一条，当我检查我本地的hosts文件时，纳尼，localhost没有配置指向本地的环回地址127.0.0.1，难道是这里出问题了吗。\n\n  为了验证这个想法，我将配置中的target做了以下修改:\n\n  ~~target: 'http://localhost:8080/'~~ </br>\n    target: 'http://127.0.0.1:8080/'\n\n  果然，生效了，看来之前的猜测是对的。\n\n</br>\n\n所以目前至少有两种方法可以解决该问题：\n\n  - **在vite配置中将localhost替换成127.0.0.1**\n  - **在hosts文件中添加localhost的地址**\n\n当然，第二种方式显然是更合理的，几乎是种一劳永逸的方法，在日后不同项目的开发中，总是难免还会存在使用localhost的情况。因此，建议在hosts文件中配置它。\n\n## 总结\n在这个问题中呢，其实也牵扯出更多的关于http server 和 http client相关的知识。不论是server的创建还是client的连接，正确的ip和端口是需要保证的。\n\n当遇到类似的情况时，不妨从底层思考在复杂的封装工具和配置的背后，它的本质是什么，以及正常使用时需要哪些因子的参与。","slug":"Vite-server-error","published":1,"updated":"2025-06-21T14:16:56.740Z","comments":1,"layout":"post","photos":[],"_id":"cmjbml2hz0006ikup2m470vsb","content":"<p>最近正在开发一款应用，前端框架是vite+vue, 后台服务也是使用的node+express组合，当一切工作都在顺利进行的时候，不出意外，意外出现了。</p>\n<p>当我尝试使用axios直连本地服务地址的时候，丝滑得如同德芙一样。然而每次请求地址都需要拼写全链接–即host+port+service-path，这是一件很愚蠢的事情。</p>\n<p>为了让事情变得简单一些，减少重复工作，我和聪明的各位一样决定使用vite的代理。</p>\n<p>因为web的地址9000，本地启动的后台服务地址是8080，所以我最初的配置如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title function_\">defineConfig</span>(&#123;<br>  # ...   其它配置<br>  <span class=\"hljs-attr\">server</span>: &#123;<br>    <span class=\"hljs-attr\">host</span>: <span class=\"hljs-string\">&#x27;0.0.0.0&#x27;</span>,<br>    <span class=\"hljs-attr\">port</span>: <span class=\"hljs-number\">9000</span>,<br>    <span class=\"hljs-attr\">proxy</span>: &#123;<br>      <span class=\"hljs-string\">&#x27;/api&#x27;</span>: &#123;<br>        <span class=\"hljs-attr\">target</span>: <span class=\"hljs-string\">&#x27;http://localhost:8080/&#x27;</span>,<br>        <span class=\"hljs-attr\">changeOrigin</span>: <span class=\"hljs-literal\">true</span>,<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;)<br><br></code></pre></td></tr></table></figure>\n\n<p>然后它却对我说 <code>Vite proxy error ECONNREFUSED</code></p>\n<p>那么多大风大浪都过去了，居然在这小阴沟里翻了船，忍不了！</p>\n<h2 id=\"排查方向\"><a href=\"#排查方向\" class=\"headerlink\" title=\"排查方向\"></a>排查方向</h2><p>因为涉及到vite server配置，其本质就是http-server以及http-agent的问题,  于是从从下面几个方向做了一一排查</p>\n<ul>\n<li><p><strong>Vite的服务器配置</strong></p>\n</li>\n<li><p><strong>端口占用或防火墙设置</strong></p>\n</li>\n<li><p><strong>浏览器或系统代理设置</strong></p>\n</li>\n<li><p>​<strong>Hosts文件配置问题或DNS解析问题</strong></p>\n</li>\n</ul>\n<h2 id=\"测试验证\"><a href=\"#测试验证\" class=\"headerlink\" title=\"测试验证\"></a>测试验证</h2><ul>\n<li><p>首先vite服务配置问题是最先被排除的，因为该项目配置已经经历了时间的考验，在很多项目中都有使用</p>\n</li>\n<li><p>然后通过 <code>netstat -ano | find 9000</code> 检查并未发现端口被占用的情况</p>\n</li>\n<li><p>至于代理，确实是开了–科学上网使用。然而在关闭之后，似乎没有起作用，所以问题不在这里。</p>\n</li>\n<li><p>那么还剩最后一条，当我检查我本地的hosts文件时，纳尼，localhost没有配置指向本地的环回地址127.0.0.1，难道是这里出问题了吗。</p>\n<p>为了验证这个想法，我将配置中的target做了以下修改:</p>\n<p><del>target: ‘<a href=\"http://localhost:8080/\">http://localhost:8080/</a>‘</del> </br><br>  target: ‘<a href=\"http://127.0.0.1:8080/\">http://127.0.0.1:8080/</a>‘</p>\n<p>果然，生效了，看来之前的猜测是对的。</p>\n</li>\n</ul>\n</br>\n\n<p>所以目前至少有两种方法可以解决该问题：</p>\n<ul>\n<li><strong>在vite配置中将localhost替换成127.0.0.1</strong></li>\n<li><strong>在hosts文件中添加localhost的地址</strong></li>\n</ul>\n<p>当然，第二种方式显然是更合理的，几乎是种一劳永逸的方法，在日后不同项目的开发中，总是难免还会存在使用localhost的情况。因此，建议在hosts文件中配置它。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>在这个问题中呢，其实也牵扯出更多的关于http server 和 http client相关的知识。不论是server的创建还是client的连接，正确的ip和端口是需要保证的。</p>\n<p>当遇到类似的情况时，不妨从底层思考在复杂的封装工具和配置的背后，它的本质是什么，以及正常使用时需要哪些因子的参与。</p>\n","excerpt":"","more":"<p>最近正在开发一款应用，前端框架是vite+vue, 后台服务也是使用的node+express组合，当一切工作都在顺利进行的时候，不出意外，意外出现了。</p>\n<p>当我尝试使用axios直连本地服务地址的时候，丝滑得如同德芙一样。然而每次请求地址都需要拼写全链接–即host+port+service-path，这是一件很愚蠢的事情。</p>\n<p>为了让事情变得简单一些，减少重复工作，我和聪明的各位一样决定使用vite的代理。</p>\n<p>因为web的地址9000，本地启动的后台服务地址是8080，所以我最初的配置如下：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title function_\">defineConfig</span>(&#123;<br>  # ...   其它配置<br>  <span class=\"hljs-attr\">server</span>: &#123;<br>    <span class=\"hljs-attr\">host</span>: <span class=\"hljs-string\">&#x27;0.0.0.0&#x27;</span>,<br>    <span class=\"hljs-attr\">port</span>: <span class=\"hljs-number\">9000</span>,<br>    <span class=\"hljs-attr\">proxy</span>: &#123;<br>      <span class=\"hljs-string\">&#x27;/api&#x27;</span>: &#123;<br>        <span class=\"hljs-attr\">target</span>: <span class=\"hljs-string\">&#x27;http://localhost:8080/&#x27;</span>,<br>        <span class=\"hljs-attr\">changeOrigin</span>: <span class=\"hljs-literal\">true</span>,<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;)<br><br></code></pre></td></tr></table></figure>\n\n<p>然后它却对我说 <code>Vite proxy error ECONNREFUSED</code></p>\n<p>那么多大风大浪都过去了，居然在这小阴沟里翻了船，忍不了！</p>\n<h2 id=\"排查方向\"><a href=\"#排查方向\" class=\"headerlink\" title=\"排查方向\"></a>排查方向</h2><p>因为涉及到vite server配置，其本质就是http-server以及http-agent的问题,  于是从从下面几个方向做了一一排查</p>\n<ul>\n<li><p><strong>Vite的服务器配置</strong></p>\n</li>\n<li><p><strong>端口占用或防火墙设置</strong></p>\n</li>\n<li><p><strong>浏览器或系统代理设置</strong></p>\n</li>\n<li><p>​<strong>Hosts文件配置问题或DNS解析问题</strong></p>\n</li>\n</ul>\n<h2 id=\"测试验证\"><a href=\"#测试验证\" class=\"headerlink\" title=\"测试验证\"></a>测试验证</h2><ul>\n<li><p>首先vite服务配置问题是最先被排除的，因为该项目配置已经经历了时间的考验，在很多项目中都有使用</p>\n</li>\n<li><p>然后通过 <code>netstat -ano | find 9000</code> 检查并未发现端口被占用的情况</p>\n</li>\n<li><p>至于代理，确实是开了–科学上网使用。然而在关闭之后，似乎没有起作用，所以问题不在这里。</p>\n</li>\n<li><p>那么还剩最后一条，当我检查我本地的hosts文件时，纳尼，localhost没有配置指向本地的环回地址127.0.0.1，难道是这里出问题了吗。</p>\n<p>为了验证这个想法，我将配置中的target做了以下修改:</p>\n<p><del>target: ‘<a href=\"http://localhost:8080/\">http://localhost:8080/</a>‘</del> </br><br>  target: ‘<a href=\"http://127.0.0.1:8080/\">http://127.0.0.1:8080/</a>‘</p>\n<p>果然，生效了，看来之前的猜测是对的。</p>\n</li>\n</ul>\n</br>\n\n<p>所以目前至少有两种方法可以解决该问题：</p>\n<ul>\n<li><strong>在vite配置中将localhost替换成127.0.0.1</strong></li>\n<li><strong>在hosts文件中添加localhost的地址</strong></li>\n</ul>\n<p>当然，第二种方式显然是更合理的，几乎是种一劳永逸的方法，在日后不同项目的开发中，总是难免还会存在使用localhost的情况。因此，建议在hosts文件中配置它。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>在这个问题中呢，其实也牵扯出更多的关于http server 和 http client相关的知识。不论是server的创建还是client的连接，正确的ip和端口是需要保证的。</p>\n<p>当遇到类似的情况时，不妨从底层思考在复杂的封装工具和配置的背后，它的本质是什么，以及正常使用时需要哪些因子的参与。</p>\n"},{"title":"Javascript中两种不同的继承方式对比","date":"2025-05-23T04:40:00.000Z","targs":["Javascript","继承"],"_content":"\n# Dog.prototype = new Animal() 和 Dog.prototype.proto = Animal.prototype的两种继承方式的区别\n\n\n## 1. Dog.prototype = new Animal()\n\n### 语法和机制\n- **​目的**：通过创建 Animal 的实例来继承其原型链。\n- ​**底层逻辑**：将 Dog.prototype 替换为一个新的 Animal 实例。\n- **​原型链结构**：\n\n```javascript\nDog.prototype → Animal 实例 → Animal.prototype → Object.prototype → null\n```\n\n因此，Dog 的实例通过原型链可以访问 Animal 实例的属性和 Animal.prototype 的方法。\n\n### ​特点\n\n- **​调用父类构造函数**： 会执行 Animal() 构造函数，初始化父类属性（如 this.name)\n- **继承实例属性**：Dog.prototype 会包含 Animal 实例的属性（如 name），即使这些属性是实例级别的。\n\n- **覆盖原有原型**：替换 Dog.prototype 后，原先定义在 Dog.prototype 上的方法会被丢失，需重新添加。\n​- **constructor 问题**：Dog.prototype.constructor 会指向 Animal，需手动修正：\n``` javascript\n  Dog.prototype.constructor = Dog;\n```\n​示例\n``` javascript\n  function Animal() { this.name = \"Animal\"; }\n  Animal.prototype.eat = function() { console.log(\"Eat\"); };\n\n  function Dog() {}\n  Dog.prototype = new Animal(); // 继承\n  Dog.prototype.constructor = Dog; // 修复 constructor\n\n  const dog = new Dog();\n  console.log(dog.name); // \"Animal\"（继承自 Animal 实例）\n  dog.eat();           // \"Eat\"（继承自 Animal.prototype）\n```\n\n## ​2. Dog.prototype.proto = Animal.prototype\n\n### ​语法和机制\n\n- ​目的：直接让 Dog.prototype 的 proto 属性（即 __proto__）指向 Animal.prototype。\n\n- ​底层逻辑：修改 Dog.prototype 的原型链。\n\n​-  原型链结构：\n```javascript\n  Dog.prototype → Animal.prototype → Object.prototype → null\n```\n\n因此，Dog 的实例直接通过原型链访问 Animal.prototype 的方法，但不会继承 Animal 实例的属性。\n### ​特点\n\n- **​不调用父类构造函数**：不会执行 Animal()，避免副作用（如初始化逻辑）。\n\n​- **仅继承原型方法**：Dog 的实例只能访问 Animal.prototype 的方法，无法获取 Animal 实例的属性（如 name）。\n\n- **​保留原有原型**：不会覆盖 Dog.prototype 上已定义的方法。\n\n- **​非标准操作**：直接修改 proto（或 __proto__）是非标准的，可能影响性能，推荐用 Object.setPrototypeOf()：\n```javascript\nObject.setPrototypeOf(Dog.prototype, Animal.prototype);\n```\n​示例\n```javascript\nfunction Animal() { this.name = \"Animal\"; }\nAnimal.prototype.eat = function() { console.log(\"Eat\"); };\n\nfunction Dog() {}\nDog.prototype.proto = Animal.prototype; // 直接修改 proto\n\nconst dog = new Dog();\nconsole.log(dog.name); // undefined（未继承 Animal 实例属性）\ndog.eat();           // \"Eat\"（继承自 Animal.prototype）\n\n```\n\n### ​关键区别总结\n\n### ​**关键区别总结**\n\n| ​**特性**                | `Dog.prototype = new Animal()`                          | `Dog.prototype.__proto__ = Animal.prototype`         |\n|-------------------------|--------------------------------------------------------|-----------------------------------------------------|\n| ​**调用父类构造函数**     | ✅ 是（执行 `Animal()`，初始化父类实例属性）            | ❌ 否（直接链接原型，不调用构造函数）                 |\n| ​**继承实例属性**         | ✅ 是（继承 `Animal` 实例的属性，如 `this.name`）       | ❌ 否（仅继承原型方法，不包含实例属性）               |\n| ​**覆盖原型对象**         | ✅ 是（完全替换 `Dog.prototype` 为新实例）             | ❌ 否（仅修改原型的 `__proto__`，保留原有属性和方法） |\n| ​**constructor修正**    | ✅ 需手动修复（`Dog.prototype.constructor = Dog`）     | ✅ 通常无需修复（原型链未改变构造函数引用）           |\n| ​**兼容性**               | ⚠️ 传统写法，但可能引发副作用（如多余属性继承）       | ⚠️ 非标准操作（直接修改 `__proto__` 可能影响性能）   |\n| ​**推荐程度**             | ❌ 不推荐（问题多，已过时）                             | ⚠️ 慎用（可用 `Object.setPrototypeOf()` 替代）         |\n| ​**原型链结构**           | `Dog.prototype → Animal 实例 → Animal.prototype`         | `Dog.prototype → Animal.prototype → Object.prototype`   |\n| ​**是否继承父类方法**     | ✅ 是（通过 `Animal.prototype`）                       | ✅ 是（直接链接到 `Animal.prototype`）                |\n| ​**是否继承父类实例方法** | ❌ 否（仅继承原型方法，实例属性不会被继承）             | ❌ 否（同上）                                        |\n| ​**典型用途**             | 早期原型链继承（已不推荐）                            | 理论原型链扩展（极少使用，多用 `Object.create()`）   |\n| ​**替代方案**             | `Object.create(Animal.prototype)` + 手动初始化属性     | `Object.setPrototypeOf(Dog.prototype, Animal.prototype)` |\n| ​**ES6 推荐写法**         | `class Dog extends Animal {}`                           | `class Dog extends Animal {}`                         |\n\n### 补充说明\n- ​**Dog.prototype = new Animal() 的问题**：\n\n  - 强制调用父类构造函数，可能导致不必要的初始化逻辑（如 Animal 的 this.name）。\n  - 会将父类实例的属性（如 name）提升为 Dog.prototype 的属性，导致所有子类实例共享这些属性（可能引发意外行为）。\n\n- ​**Dog.prototype.__proto__ = Animal.prototype 的问题**：\n\n  - ​非标准操作：虽然浏览器支持，但 __proto__ 是内部属性，直接修改可能导致性能下降或兼容性问题。\n  - ​无法继承父类构造函数：子类实例仍需通过 new Dog() 创建，不会自动调用父类构造函数。\n\n\n### ​现代替代方案：\n\n​**Object.create()**：\n```javascript\nDog.prototype = Object.create(Animal.prototype);\nDog.prototype.constructor = Dog;\n```\n直接继承 Animal.prototype，不调用父类构造函数，更安全高效。\n\n​ES6 class 语法：\n```javascript\nclass Dog extends Animal {}\n```\n自动处理原型链和构造函数继承，代码更简洁清晰。","source":"_posts/Differences-between-two-kinds-inherit-approches.md","raw":"\n---\ntitle: Javascript中两种不同的继承方式对比\ndate: 2025-05-23 12:40:00\ncategory: Web开发\ntargs:\n  - Javascript\n  - 继承\n---\n\n# Dog.prototype = new Animal() 和 Dog.prototype.proto = Animal.prototype的两种继承方式的区别\n\n\n## 1. Dog.prototype = new Animal()\n\n### 语法和机制\n- **​目的**：通过创建 Animal 的实例来继承其原型链。\n- ​**底层逻辑**：将 Dog.prototype 替换为一个新的 Animal 实例。\n- **​原型链结构**：\n\n```javascript\nDog.prototype → Animal 实例 → Animal.prototype → Object.prototype → null\n```\n\n因此，Dog 的实例通过原型链可以访问 Animal 实例的属性和 Animal.prototype 的方法。\n\n### ​特点\n\n- **​调用父类构造函数**： 会执行 Animal() 构造函数，初始化父类属性（如 this.name)\n- **继承实例属性**：Dog.prototype 会包含 Animal 实例的属性（如 name），即使这些属性是实例级别的。\n\n- **覆盖原有原型**：替换 Dog.prototype 后，原先定义在 Dog.prototype 上的方法会被丢失，需重新添加。\n​- **constructor 问题**：Dog.prototype.constructor 会指向 Animal，需手动修正：\n``` javascript\n  Dog.prototype.constructor = Dog;\n```\n​示例\n``` javascript\n  function Animal() { this.name = \"Animal\"; }\n  Animal.prototype.eat = function() { console.log(\"Eat\"); };\n\n  function Dog() {}\n  Dog.prototype = new Animal(); // 继承\n  Dog.prototype.constructor = Dog; // 修复 constructor\n\n  const dog = new Dog();\n  console.log(dog.name); // \"Animal\"（继承自 Animal 实例）\n  dog.eat();           // \"Eat\"（继承自 Animal.prototype）\n```\n\n## ​2. Dog.prototype.proto = Animal.prototype\n\n### ​语法和机制\n\n- ​目的：直接让 Dog.prototype 的 proto 属性（即 __proto__）指向 Animal.prototype。\n\n- ​底层逻辑：修改 Dog.prototype 的原型链。\n\n​-  原型链结构：\n```javascript\n  Dog.prototype → Animal.prototype → Object.prototype → null\n```\n\n因此，Dog 的实例直接通过原型链访问 Animal.prototype 的方法，但不会继承 Animal 实例的属性。\n### ​特点\n\n- **​不调用父类构造函数**：不会执行 Animal()，避免副作用（如初始化逻辑）。\n\n​- **仅继承原型方法**：Dog 的实例只能访问 Animal.prototype 的方法，无法获取 Animal 实例的属性（如 name）。\n\n- **​保留原有原型**：不会覆盖 Dog.prototype 上已定义的方法。\n\n- **​非标准操作**：直接修改 proto（或 __proto__）是非标准的，可能影响性能，推荐用 Object.setPrototypeOf()：\n```javascript\nObject.setPrototypeOf(Dog.prototype, Animal.prototype);\n```\n​示例\n```javascript\nfunction Animal() { this.name = \"Animal\"; }\nAnimal.prototype.eat = function() { console.log(\"Eat\"); };\n\nfunction Dog() {}\nDog.prototype.proto = Animal.prototype; // 直接修改 proto\n\nconst dog = new Dog();\nconsole.log(dog.name); // undefined（未继承 Animal 实例属性）\ndog.eat();           // \"Eat\"（继承自 Animal.prototype）\n\n```\n\n### ​关键区别总结\n\n### ​**关键区别总结**\n\n| ​**特性**                | `Dog.prototype = new Animal()`                          | `Dog.prototype.__proto__ = Animal.prototype`         |\n|-------------------------|--------------------------------------------------------|-----------------------------------------------------|\n| ​**调用父类构造函数**     | ✅ 是（执行 `Animal()`，初始化父类实例属性）            | ❌ 否（直接链接原型，不调用构造函数）                 |\n| ​**继承实例属性**         | ✅ 是（继承 `Animal` 实例的属性，如 `this.name`）       | ❌ 否（仅继承原型方法，不包含实例属性）               |\n| ​**覆盖原型对象**         | ✅ 是（完全替换 `Dog.prototype` 为新实例）             | ❌ 否（仅修改原型的 `__proto__`，保留原有属性和方法） |\n| ​**constructor修正**    | ✅ 需手动修复（`Dog.prototype.constructor = Dog`）     | ✅ 通常无需修复（原型链未改变构造函数引用）           |\n| ​**兼容性**               | ⚠️ 传统写法，但可能引发副作用（如多余属性继承）       | ⚠️ 非标准操作（直接修改 `__proto__` 可能影响性能）   |\n| ​**推荐程度**             | ❌ 不推荐（问题多，已过时）                             | ⚠️ 慎用（可用 `Object.setPrototypeOf()` 替代）         |\n| ​**原型链结构**           | `Dog.prototype → Animal 实例 → Animal.prototype`         | `Dog.prototype → Animal.prototype → Object.prototype`   |\n| ​**是否继承父类方法**     | ✅ 是（通过 `Animal.prototype`）                       | ✅ 是（直接链接到 `Animal.prototype`）                |\n| ​**是否继承父类实例方法** | ❌ 否（仅继承原型方法，实例属性不会被继承）             | ❌ 否（同上）                                        |\n| ​**典型用途**             | 早期原型链继承（已不推荐）                            | 理论原型链扩展（极少使用，多用 `Object.create()`）   |\n| ​**替代方案**             | `Object.create(Animal.prototype)` + 手动初始化属性     | `Object.setPrototypeOf(Dog.prototype, Animal.prototype)` |\n| ​**ES6 推荐写法**         | `class Dog extends Animal {}`                           | `class Dog extends Animal {}`                         |\n\n### 补充说明\n- ​**Dog.prototype = new Animal() 的问题**：\n\n  - 强制调用父类构造函数，可能导致不必要的初始化逻辑（如 Animal 的 this.name）。\n  - 会将父类实例的属性（如 name）提升为 Dog.prototype 的属性，导致所有子类实例共享这些属性（可能引发意外行为）。\n\n- ​**Dog.prototype.__proto__ = Animal.prototype 的问题**：\n\n  - ​非标准操作：虽然浏览器支持，但 __proto__ 是内部属性，直接修改可能导致性能下降或兼容性问题。\n  - ​无法继承父类构造函数：子类实例仍需通过 new Dog() 创建，不会自动调用父类构造函数。\n\n\n### ​现代替代方案：\n\n​**Object.create()**：\n```javascript\nDog.prototype = Object.create(Animal.prototype);\nDog.prototype.constructor = Dog;\n```\n直接继承 Animal.prototype，不调用父类构造函数，更安全高效。\n\n​ES6 class 语法：\n```javascript\nclass Dog extends Animal {}\n```\n自动处理原型链和构造函数继承，代码更简洁清晰。","slug":"Differences-between-two-kinds-inherit-approches","published":1,"updated":"2025-06-21T14:16:14.913Z","comments":1,"layout":"post","photos":[],"_id":"cmjbml2hz0007ikupbp9ja8sk","content":"<h1 id=\"Dog-prototype-new-Animal-和-Dog-prototype-proto-Animal-prototype的两种继承方式的区别\"><a href=\"#Dog-prototype-new-Animal-和-Dog-prototype-proto-Animal-prototype的两种继承方式的区别\" class=\"headerlink\" title=\"Dog.prototype &#x3D; new Animal() 和 Dog.prototype.proto &#x3D; Animal.prototype的两种继承方式的区别\"></a>Dog.prototype &#x3D; new Animal() 和 Dog.prototype.proto &#x3D; Animal.prototype的两种继承方式的区别</h1><h2 id=\"1-Dog-prototype-new-Animal\"><a href=\"#1-Dog-prototype-new-Animal\" class=\"headerlink\" title=\"1. Dog.prototype &#x3D; new Animal()\"></a>1. Dog.prototype &#x3D; new Animal()</h2><h3 id=\"语法和机制\"><a href=\"#语法和机制\" class=\"headerlink\" title=\"语法和机制\"></a>语法和机制</h3><ul>\n<li><strong>​目的</strong>：通过创建 Animal 的实例来继承其原型链。</li>\n<li>​<strong>底层逻辑</strong>：将 Dog.prototype 替换为一个新的 Animal 实例。</li>\n<li><strong>​原型链结构</strong>：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> → <span class=\"hljs-title class_\">Animal</span> 实例 → <span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> → <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> → <span class=\"hljs-literal\">null</span><br></code></pre></td></tr></table></figure>\n\n<p>因此，Dog 的实例通过原型链可以访问 Animal 实例的属性和 Animal.prototype 的方法。</p>\n<h3 id=\"​特点\"><a href=\"#​特点\" class=\"headerlink\" title=\"​特点\"></a>​特点</h3><ul>\n<li><p><strong>​调用父类构造函数</strong>： 会执行 Animal() 构造函数，初始化父类属性（如 this.name)</p>\n</li>\n<li><p><strong>继承实例属性</strong>：Dog.prototype 会包含 Animal 实例的属性（如 name），即使这些属性是实例级别的。</p>\n</li>\n<li><p><strong>覆盖原有原型</strong>：替换 Dog.prototype 后，原先定义在 Dog.prototype 上的方法会被丢失，需重新添加。<br>​- <strong>constructor 问题</strong>：Dog.prototype.constructor 会指向 Animal，需手动修正：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">constructor</span> = <span class=\"hljs-title class_\">Dog</span>;<br></code></pre></td></tr></table></figure>\n<p>​示例</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Animal</span>(<span class=\"hljs-params\"></span>) &#123; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = <span class=\"hljs-string\">&quot;Animal&quot;</span>; &#125;<br><span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">eat</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;Eat&quot;</span>); &#125;;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Dog</span>(<span class=\"hljs-params\"></span>) &#123;&#125;<br><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Animal</span>(); <span class=\"hljs-comment\">// 继承</span><br><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">constructor</span> = <span class=\"hljs-title class_\">Dog</span>; <span class=\"hljs-comment\">// 修复 constructor</span><br><br><span class=\"hljs-keyword\">const</span> dog = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Dog</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(dog.<span class=\"hljs-property\">name</span>); <span class=\"hljs-comment\">// &quot;Animal&quot;（继承自 Animal 实例）</span><br>dog.<span class=\"hljs-title function_\">eat</span>();           <span class=\"hljs-comment\">// &quot;Eat&quot;（继承自 Animal.prototype）</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"​2-Dog-prototype-proto-Animal-prototype\"><a href=\"#​2-Dog-prototype-proto-Animal-prototype\" class=\"headerlink\" title=\"​2. Dog.prototype.proto &#x3D; Animal.prototype\"></a>​2. Dog.prototype.proto &#x3D; Animal.prototype</h2><h3 id=\"​语法和机制\"><a href=\"#​语法和机制\" class=\"headerlink\" title=\"​语法和机制\"></a>​语法和机制</h3><ul>\n<li><p>​目的：直接让 Dog.prototype 的 proto 属性（即 __proto__）指向 Animal.prototype。</p>\n</li>\n<li><p>​底层逻辑：修改 Dog.prototype 的原型链。</p>\n</li>\n</ul>\n<p>​-  原型链结构：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> → <span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> → <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> → <span class=\"hljs-literal\">null</span><br></code></pre></td></tr></table></figure>\n\n<p>因此，Dog 的实例直接通过原型链访问 Animal.prototype 的方法，但不会继承 Animal 实例的属性。</p>\n<h3 id=\"​特点-1\"><a href=\"#​特点-1\" class=\"headerlink\" title=\"​特点\"></a>​特点</h3><ul>\n<li><strong>​不调用父类构造函数</strong>：不会执行 Animal()，避免副作用（如初始化逻辑）。</li>\n</ul>\n<p>​- <strong>仅继承原型方法</strong>：Dog 的实例只能访问 Animal.prototype 的方法，无法获取 Animal 实例的属性（如 name）。</p>\n<ul>\n<li><p><strong>​保留原有原型</strong>：不会覆盖 Dog.prototype 上已定义的方法。</p>\n</li>\n<li><p><strong>​非标准操作</strong>：直接修改 proto（或 __proto__）是非标准的，可能影响性能，推荐用 Object.setPrototypeOf()：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">setPrototypeOf</span>(<span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>, <span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);<br></code></pre></td></tr></table></figure>\n<p>​示例</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Animal</span>(<span class=\"hljs-params\"></span>) &#123; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = <span class=\"hljs-string\">&quot;Animal&quot;</span>; &#125;<br><span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">eat</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;Eat&quot;</span>); &#125;;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Dog</span>(<span class=\"hljs-params\"></span>) &#123;&#125;<br><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">proto</span> = <span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>; <span class=\"hljs-comment\">// 直接修改 proto</span><br><br><span class=\"hljs-keyword\">const</span> dog = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Dog</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(dog.<span class=\"hljs-property\">name</span>); <span class=\"hljs-comment\">// undefined（未继承 Animal 实例属性）</span><br>dog.<span class=\"hljs-title function_\">eat</span>();           <span class=\"hljs-comment\">// &quot;Eat&quot;（继承自 Animal.prototype）</span><br><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"​关键区别总结\"><a href=\"#​关键区别总结\" class=\"headerlink\" title=\"​关键区别总结\"></a>​关键区别总结</h3><h3 id=\"​关键区别总结-1\"><a href=\"#​关键区别总结-1\" class=\"headerlink\" title=\"​关键区别总结\"></a>​<strong>关键区别总结</strong></h3><table>\n<thead>\n<tr>\n<th>​<strong>特性</strong></th>\n<th><code>Dog.prototype = new Animal()</code></th>\n<th><code>Dog.prototype.__proto__ = Animal.prototype</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>​<strong>调用父类构造函数</strong></td>\n<td>✅ 是（执行 <code>Animal()</code>，初始化父类实例属性）</td>\n<td>❌ 否（直接链接原型，不调用构造函数）</td>\n</tr>\n<tr>\n<td>​<strong>继承实例属性</strong></td>\n<td>✅ 是（继承 <code>Animal</code> 实例的属性，如 <code>this.name</code>）</td>\n<td>❌ 否（仅继承原型方法，不包含实例属性）</td>\n</tr>\n<tr>\n<td>​<strong>覆盖原型对象</strong></td>\n<td>✅ 是（完全替换 <code>Dog.prototype</code> 为新实例）</td>\n<td>❌ 否（仅修改原型的 <code>__proto__</code>，保留原有属性和方法）</td>\n</tr>\n<tr>\n<td>​<strong>constructor修正</strong></td>\n<td>✅ 需手动修复（<code>Dog.prototype.constructor = Dog</code>）</td>\n<td>✅ 通常无需修复（原型链未改变构造函数引用）</td>\n</tr>\n<tr>\n<td>​<strong>兼容性</strong></td>\n<td>⚠️ 传统写法，但可能引发副作用（如多余属性继承）</td>\n<td>⚠️ 非标准操作（直接修改 <code>__proto__</code> 可能影响性能）</td>\n</tr>\n<tr>\n<td>​<strong>推荐程度</strong></td>\n<td>❌ 不推荐（问题多，已过时）</td>\n<td>⚠️ 慎用（可用 <code>Object.setPrototypeOf()</code> 替代）</td>\n</tr>\n<tr>\n<td>​<strong>原型链结构</strong></td>\n<td><code>Dog.prototype → Animal 实例 → Animal.prototype</code></td>\n<td><code>Dog.prototype → Animal.prototype → Object.prototype</code></td>\n</tr>\n<tr>\n<td>​<strong>是否继承父类方法</strong></td>\n<td>✅ 是（通过 <code>Animal.prototype</code>）</td>\n<td>✅ 是（直接链接到 <code>Animal.prototype</code>）</td>\n</tr>\n<tr>\n<td>​<strong>是否继承父类实例方法</strong></td>\n<td>❌ 否（仅继承原型方法，实例属性不会被继承）</td>\n<td>❌ 否（同上）</td>\n</tr>\n<tr>\n<td>​<strong>典型用途</strong></td>\n<td>早期原型链继承（已不推荐）</td>\n<td>理论原型链扩展（极少使用，多用 <code>Object.create()</code>）</td>\n</tr>\n<tr>\n<td>​<strong>替代方案</strong></td>\n<td><code>Object.create(Animal.prototype)</code> + 手动初始化属性</td>\n<td><code>Object.setPrototypeOf(Dog.prototype, Animal.prototype)</code></td>\n</tr>\n<tr>\n<td>​<strong>ES6 推荐写法</strong></td>\n<td><code>class Dog extends Animal &#123;&#125;</code></td>\n<td><code>class Dog extends Animal &#123;&#125;</code></td>\n</tr>\n</tbody></table>\n<h3 id=\"补充说明\"><a href=\"#补充说明\" class=\"headerlink\" title=\"补充说明\"></a>补充说明</h3><ul>\n<li><p>​<strong>Dog.prototype &#x3D; new Animal() 的问题</strong>：</p>\n<ul>\n<li>强制调用父类构造函数，可能导致不必要的初始化逻辑（如 Animal 的 this.name）。</li>\n<li>会将父类实例的属性（如 name）提升为 Dog.prototype 的属性，导致所有子类实例共享这些属性（可能引发意外行为）。</li>\n</ul>\n</li>\n<li><p>​<strong>Dog.prototype.<strong>proto</strong> &#x3D; Animal.prototype 的问题</strong>：</p>\n<ul>\n<li>​非标准操作：虽然浏览器支持，但 <strong>proto</strong> 是内部属性，直接修改可能导致性能下降或兼容性问题。</li>\n<li>​无法继承父类构造函数：子类实例仍需通过 new Dog() 创建，不会自动调用父类构造函数。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"​现代替代方案：\"><a href=\"#​现代替代方案：\" class=\"headerlink\" title=\"​现代替代方案：\"></a>​现代替代方案：</h3><p>​**Object.create()**：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(<span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);<br><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">constructor</span> = <span class=\"hljs-title class_\">Dog</span>;<br></code></pre></td></tr></table></figure>\n<p>直接继承 Animal.prototype，不调用父类构造函数，更安全高效。</p>\n<p>​ES6 class 语法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Dog</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Animal</span> &#123;&#125;<br></code></pre></td></tr></table></figure>\n<p>自动处理原型链和构造函数继承，代码更简洁清晰。</p>\n","excerpt":"","more":"<h1 id=\"Dog-prototype-new-Animal-和-Dog-prototype-proto-Animal-prototype的两种继承方式的区别\"><a href=\"#Dog-prototype-new-Animal-和-Dog-prototype-proto-Animal-prototype的两种继承方式的区别\" class=\"headerlink\" title=\"Dog.prototype &#x3D; new Animal() 和 Dog.prototype.proto &#x3D; Animal.prototype的两种继承方式的区别\"></a>Dog.prototype &#x3D; new Animal() 和 Dog.prototype.proto &#x3D; Animal.prototype的两种继承方式的区别</h1><h2 id=\"1-Dog-prototype-new-Animal\"><a href=\"#1-Dog-prototype-new-Animal\" class=\"headerlink\" title=\"1. Dog.prototype &#x3D; new Animal()\"></a>1. Dog.prototype &#x3D; new Animal()</h2><h3 id=\"语法和机制\"><a href=\"#语法和机制\" class=\"headerlink\" title=\"语法和机制\"></a>语法和机制</h3><ul>\n<li><strong>​目的</strong>：通过创建 Animal 的实例来继承其原型链。</li>\n<li>​<strong>底层逻辑</strong>：将 Dog.prototype 替换为一个新的 Animal 实例。</li>\n<li><strong>​原型链结构</strong>：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> → <span class=\"hljs-title class_\">Animal</span> 实例 → <span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> → <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> → <span class=\"hljs-literal\">null</span><br></code></pre></td></tr></table></figure>\n\n<p>因此，Dog 的实例通过原型链可以访问 Animal 实例的属性和 Animal.prototype 的方法。</p>\n<h3 id=\"​特点\"><a href=\"#​特点\" class=\"headerlink\" title=\"​特点\"></a>​特点</h3><ul>\n<li><p><strong>​调用父类构造函数</strong>： 会执行 Animal() 构造函数，初始化父类属性（如 this.name)</p>\n</li>\n<li><p><strong>继承实例属性</strong>：Dog.prototype 会包含 Animal 实例的属性（如 name），即使这些属性是实例级别的。</p>\n</li>\n<li><p><strong>覆盖原有原型</strong>：替换 Dog.prototype 后，原先定义在 Dog.prototype 上的方法会被丢失，需重新添加。<br>​- <strong>constructor 问题</strong>：Dog.prototype.constructor 会指向 Animal，需手动修正：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">constructor</span> = <span class=\"hljs-title class_\">Dog</span>;<br></code></pre></td></tr></table></figure>\n<p>​示例</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Animal</span>(<span class=\"hljs-params\"></span>) &#123; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = <span class=\"hljs-string\">&quot;Animal&quot;</span>; &#125;<br><span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">eat</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;Eat&quot;</span>); &#125;;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Dog</span>(<span class=\"hljs-params\"></span>) &#123;&#125;<br><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Animal</span>(); <span class=\"hljs-comment\">// 继承</span><br><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">constructor</span> = <span class=\"hljs-title class_\">Dog</span>; <span class=\"hljs-comment\">// 修复 constructor</span><br><br><span class=\"hljs-keyword\">const</span> dog = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Dog</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(dog.<span class=\"hljs-property\">name</span>); <span class=\"hljs-comment\">// &quot;Animal&quot;（继承自 Animal 实例）</span><br>dog.<span class=\"hljs-title function_\">eat</span>();           <span class=\"hljs-comment\">// &quot;Eat&quot;（继承自 Animal.prototype）</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"​2-Dog-prototype-proto-Animal-prototype\"><a href=\"#​2-Dog-prototype-proto-Animal-prototype\" class=\"headerlink\" title=\"​2. Dog.prototype.proto &#x3D; Animal.prototype\"></a>​2. Dog.prototype.proto &#x3D; Animal.prototype</h2><h3 id=\"​语法和机制\"><a href=\"#​语法和机制\" class=\"headerlink\" title=\"​语法和机制\"></a>​语法和机制</h3><ul>\n<li><p>​目的：直接让 Dog.prototype 的 proto 属性（即 __proto__）指向 Animal.prototype。</p>\n</li>\n<li><p>​底层逻辑：修改 Dog.prototype 的原型链。</p>\n</li>\n</ul>\n<p>​-  原型链结构：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> → <span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> → <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> → <span class=\"hljs-literal\">null</span><br></code></pre></td></tr></table></figure>\n\n<p>因此，Dog 的实例直接通过原型链访问 Animal.prototype 的方法，但不会继承 Animal 实例的属性。</p>\n<h3 id=\"​特点-1\"><a href=\"#​特点-1\" class=\"headerlink\" title=\"​特点\"></a>​特点</h3><ul>\n<li><strong>​不调用父类构造函数</strong>：不会执行 Animal()，避免副作用（如初始化逻辑）。</li>\n</ul>\n<p>​- <strong>仅继承原型方法</strong>：Dog 的实例只能访问 Animal.prototype 的方法，无法获取 Animal 实例的属性（如 name）。</p>\n<ul>\n<li><p><strong>​保留原有原型</strong>：不会覆盖 Dog.prototype 上已定义的方法。</p>\n</li>\n<li><p><strong>​非标准操作</strong>：直接修改 proto（或 __proto__）是非标准的，可能影响性能，推荐用 Object.setPrototypeOf()：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">setPrototypeOf</span>(<span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>, <span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);<br></code></pre></td></tr></table></figure>\n<p>​示例</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Animal</span>(<span class=\"hljs-params\"></span>) &#123; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = <span class=\"hljs-string\">&quot;Animal&quot;</span>; &#125;<br><span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">eat</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;Eat&quot;</span>); &#125;;<br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Dog</span>(<span class=\"hljs-params\"></span>) &#123;&#125;<br><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">proto</span> = <span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>; <span class=\"hljs-comment\">// 直接修改 proto</span><br><br><span class=\"hljs-keyword\">const</span> dog = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Dog</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(dog.<span class=\"hljs-property\">name</span>); <span class=\"hljs-comment\">// undefined（未继承 Animal 实例属性）</span><br>dog.<span class=\"hljs-title function_\">eat</span>();           <span class=\"hljs-comment\">// &quot;Eat&quot;（继承自 Animal.prototype）</span><br><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"​关键区别总结\"><a href=\"#​关键区别总结\" class=\"headerlink\" title=\"​关键区别总结\"></a>​关键区别总结</h3><h3 id=\"​关键区别总结-1\"><a href=\"#​关键区别总结-1\" class=\"headerlink\" title=\"​关键区别总结\"></a>​<strong>关键区别总结</strong></h3><table>\n<thead>\n<tr>\n<th>​<strong>特性</strong></th>\n<th><code>Dog.prototype = new Animal()</code></th>\n<th><code>Dog.prototype.__proto__ = Animal.prototype</code></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>​<strong>调用父类构造函数</strong></td>\n<td>✅ 是（执行 <code>Animal()</code>，初始化父类实例属性）</td>\n<td>❌ 否（直接链接原型，不调用构造函数）</td>\n</tr>\n<tr>\n<td>​<strong>继承实例属性</strong></td>\n<td>✅ 是（继承 <code>Animal</code> 实例的属性，如 <code>this.name</code>）</td>\n<td>❌ 否（仅继承原型方法，不包含实例属性）</td>\n</tr>\n<tr>\n<td>​<strong>覆盖原型对象</strong></td>\n<td>✅ 是（完全替换 <code>Dog.prototype</code> 为新实例）</td>\n<td>❌ 否（仅修改原型的 <code>__proto__</code>，保留原有属性和方法）</td>\n</tr>\n<tr>\n<td>​<strong>constructor修正</strong></td>\n<td>✅ 需手动修复（<code>Dog.prototype.constructor = Dog</code>）</td>\n<td>✅ 通常无需修复（原型链未改变构造函数引用）</td>\n</tr>\n<tr>\n<td>​<strong>兼容性</strong></td>\n<td>⚠️ 传统写法，但可能引发副作用（如多余属性继承）</td>\n<td>⚠️ 非标准操作（直接修改 <code>__proto__</code> 可能影响性能）</td>\n</tr>\n<tr>\n<td>​<strong>推荐程度</strong></td>\n<td>❌ 不推荐（问题多，已过时）</td>\n<td>⚠️ 慎用（可用 <code>Object.setPrototypeOf()</code> 替代）</td>\n</tr>\n<tr>\n<td>​<strong>原型链结构</strong></td>\n<td><code>Dog.prototype → Animal 实例 → Animal.prototype</code></td>\n<td><code>Dog.prototype → Animal.prototype → Object.prototype</code></td>\n</tr>\n<tr>\n<td>​<strong>是否继承父类方法</strong></td>\n<td>✅ 是（通过 <code>Animal.prototype</code>）</td>\n<td>✅ 是（直接链接到 <code>Animal.prototype</code>）</td>\n</tr>\n<tr>\n<td>​<strong>是否继承父类实例方法</strong></td>\n<td>❌ 否（仅继承原型方法，实例属性不会被继承）</td>\n<td>❌ 否（同上）</td>\n</tr>\n<tr>\n<td>​<strong>典型用途</strong></td>\n<td>早期原型链继承（已不推荐）</td>\n<td>理论原型链扩展（极少使用，多用 <code>Object.create()</code>）</td>\n</tr>\n<tr>\n<td>​<strong>替代方案</strong></td>\n<td><code>Object.create(Animal.prototype)</code> + 手动初始化属性</td>\n<td><code>Object.setPrototypeOf(Dog.prototype, Animal.prototype)</code></td>\n</tr>\n<tr>\n<td>​<strong>ES6 推荐写法</strong></td>\n<td><code>class Dog extends Animal &#123;&#125;</code></td>\n<td><code>class Dog extends Animal &#123;&#125;</code></td>\n</tr>\n</tbody></table>\n<h3 id=\"补充说明\"><a href=\"#补充说明\" class=\"headerlink\" title=\"补充说明\"></a>补充说明</h3><ul>\n<li><p>​<strong>Dog.prototype &#x3D; new Animal() 的问题</strong>：</p>\n<ul>\n<li>强制调用父类构造函数，可能导致不必要的初始化逻辑（如 Animal 的 this.name）。</li>\n<li>会将父类实例的属性（如 name）提升为 Dog.prototype 的属性，导致所有子类实例共享这些属性（可能引发意外行为）。</li>\n</ul>\n</li>\n<li><p>​<strong>Dog.prototype.<strong>proto</strong> &#x3D; Animal.prototype 的问题</strong>：</p>\n<ul>\n<li>​非标准操作：虽然浏览器支持，但 <strong>proto</strong> 是内部属性，直接修改可能导致性能下降或兼容性问题。</li>\n<li>​无法继承父类构造函数：子类实例仍需通过 new Dog() 创建，不会自动调用父类构造函数。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"​现代替代方案：\"><a href=\"#​现代替代方案：\" class=\"headerlink\" title=\"​现代替代方案：\"></a>​现代替代方案：</h3><p>​**Object.create()**：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(<span class=\"hljs-title class_\">Animal</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);<br><span class=\"hljs-title class_\">Dog</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">constructor</span> = <span class=\"hljs-title class_\">Dog</span>;<br></code></pre></td></tr></table></figure>\n<p>直接继承 Animal.prototype，不调用父类构造函数，更安全高效。</p>\n<p>​ES6 class 语法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Dog</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Animal</span> &#123;&#125;<br></code></pre></td></tr></table></figure>\n<p>自动处理原型链和构造函数继承，代码更简洁清晰。</p>\n"},{"title":"打破软件“收费”羞愧感，勇敢要钱","date":"2025-09-21T14:31:47.000Z","banner_img":"/imgs/baners/cash.jpg","index_img":"/imgs/baners/cash.jpg","_content":"\n每个开发者大概都有个小梦想——做一款属于自己的软件，被很多人用，要是还能赚点钱就更好了。可现实是，不少好想法哪怕做成了产品，最后也难免中途夭折。原因五花八门，运营恰恰是很多开发者的短板；更现实的是“收益”问题——纯靠“爱发电”的项目能走多远，其实谁也说不准。\n\n我的小程序《豆豆证照工坊》上线半个多月后，我也遇上了这个难题。\n\n上周微信团队发消息说，我的云环境欠费了。一开始我以为这东西是免费的，后来才搞明白：小程序上线前，云环境对开发者是免费的；可一旦正式上线，就得开始付费了。\n\n登录后台一看，好家伙——两周的瑞幸咖啡钱直接没了，还没算那个每月19.9元的“穷鬼套餐”（基础版）。这哪儿是“爱发电”啊，分明是拿我的咖啡钱在发电。这下我不得不认真想了：软件得有收益，至少得能覆盖基础支出吧？\n\n纠结这事儿的时候，心里其实挺矛盾的。一方面，总希望自己花时间琢磨出来的产品，能被更多人喜欢、用上，还能帮到大家；可另一方面，“得靠收益支撑软件运行”的现实又摆在哪儿——每一次接口调用、图片处理、数据存储，都在消耗资源，总有人得为这些买单。\n\n纠结了好一阵，最后还是选了“要钱不要脸”——开始考虑收费。\n\n不过以前不管是学习还是生活里，遇到过不少简单的线上工具，非要注册、开会员才能用，我对这种收费模式一直很不感冒。所以“付费会员”这条路，我肯定不碰。毕竟“屠龙者终成恶龙”的事儿，不如一开始就别做。\n\n之前写文的评论区里，有网友提议可以在小程序里加赞赏功能，这个想法倒是点醒了我。这感觉像极了以前街头卖艺——“有钱的捧个钱场，没钱的捧个人场”，只不过现在这叫“开源精神”吧。\n\n接入赞赏的方式倒简单：用户点一下赞赏按钮，会弹出赞赏二维码，要么长按保存，要么截图存到手机里，再用微信扫一下就行。可问题是，小程序里没法直接长按识别赞赏码，整套流程一下就变繁琐了；更麻烦的是，还得下载图片、退出小程序去扫码——操作一中断，靠这种“收费”方式赚钱，概率实在太低了。\n\n既然赞赏太鸡肋，想稳定有笔收益，自然就得考虑加广告了。为了“吃相”好看点，直接在操作页面插广告的方式肯定排除——得保住用户用的时候的好体验。\n\n现在选的是激励广告：用户要是做一些耗资源多的操作（比如复杂的图片处理），就得看一次广告，相当于付了这次操作的“费”；除此之外的基础操作，全是免费的。这样既不影响大多数人的使用，也能勉强覆盖云服务的支出，算是目前最平衡的办法了。\n\n可即便选了激励广告，我心里其实还是没底——到底能不能真的覆盖掉每月的运营支出，谁也说不准。毕竟在国内，“免费使用软件”早就成了大家的默认习惯，不管是看几十秒广告，还是掏哪怕一块钱，只要沾了“付费”的边，都像在无形中“冒犯”用户——说不定人家眉头一皱，随手就把小程序关了，下次再也不会打开。\n\n这种担忧不是没道理。我自己刷手机时，要是遇到必须看广告才能用的功能，也会忍不住吐槽两句，有时候干脆换个工具。可即便知道可能会流失用户，我还是不想退回到“完全免费”的老路上去。\n\n倒不是我贪心，想靠这小程序赚多少钱，而是我始终觉得，一款真正成熟、能长久走下去的软件，不该只有“设计”和“开发”这两个环节。“盈利”其实是补上最后一块关键拼图——只有形成“设计-开发-盈利”的完整闭环，软件才不用一直靠我的“咖啡钱”贴补，才不用担心里程碑式的“欠费通知”，才能真的稳定地活下去，继续给需要的人解决证照处理的麻烦。\n\n哪怕最后每个月只赚一块钱，和“完全免费”比起来，也是天差地别的。那一块钱不是收益，更像一个小小的“认可信号”——说明有人觉得这个工具有用，愿意为它消耗的资源、为我花在上面的时间买单。这份认可，比单纯的“用户量”更让我踏实，也更能支撑我继续优化功能、解决bug，把它做得更顺手。\n\n我也知道，这种“想打破免费惯性”的想法，可能有点理想化，甚至会被人说“矫情”。但还是想试试——毕竟做《豆豆证照工坊》的初衷，从来不是“做个一次性的玩具”，而是希望它能真的帮到大家，并且能一直帮下去。如果这点小小的“收益闭环”，能让这个初衷实现，那就已经足够了。\n","source":"_posts/about-software-charges.md","raw":"---\ntitle: 打破软件“收费”羞愧感，勇敢要钱\ndate: 2025-09-21 22:31:47\ntags: 小程序\nbanner_img: /imgs/baners/cash.jpg\nindex_img: /imgs/baners/cash.jpg\n---\n\n每个开发者大概都有个小梦想——做一款属于自己的软件，被很多人用，要是还能赚点钱就更好了。可现实是，不少好想法哪怕做成了产品，最后也难免中途夭折。原因五花八门，运营恰恰是很多开发者的短板；更现实的是“收益”问题——纯靠“爱发电”的项目能走多远，其实谁也说不准。\n\n我的小程序《豆豆证照工坊》上线半个多月后，我也遇上了这个难题。\n\n上周微信团队发消息说，我的云环境欠费了。一开始我以为这东西是免费的，后来才搞明白：小程序上线前，云环境对开发者是免费的；可一旦正式上线，就得开始付费了。\n\n登录后台一看，好家伙——两周的瑞幸咖啡钱直接没了，还没算那个每月19.9元的“穷鬼套餐”（基础版）。这哪儿是“爱发电”啊，分明是拿我的咖啡钱在发电。这下我不得不认真想了：软件得有收益，至少得能覆盖基础支出吧？\n\n纠结这事儿的时候，心里其实挺矛盾的。一方面，总希望自己花时间琢磨出来的产品，能被更多人喜欢、用上，还能帮到大家；可另一方面，“得靠收益支撑软件运行”的现实又摆在哪儿——每一次接口调用、图片处理、数据存储，都在消耗资源，总有人得为这些买单。\n\n纠结了好一阵，最后还是选了“要钱不要脸”——开始考虑收费。\n\n不过以前不管是学习还是生活里，遇到过不少简单的线上工具，非要注册、开会员才能用，我对这种收费模式一直很不感冒。所以“付费会员”这条路，我肯定不碰。毕竟“屠龙者终成恶龙”的事儿，不如一开始就别做。\n\n之前写文的评论区里，有网友提议可以在小程序里加赞赏功能，这个想法倒是点醒了我。这感觉像极了以前街头卖艺——“有钱的捧个钱场，没钱的捧个人场”，只不过现在这叫“开源精神”吧。\n\n接入赞赏的方式倒简单：用户点一下赞赏按钮，会弹出赞赏二维码，要么长按保存，要么截图存到手机里，再用微信扫一下就行。可问题是，小程序里没法直接长按识别赞赏码，整套流程一下就变繁琐了；更麻烦的是，还得下载图片、退出小程序去扫码——操作一中断，靠这种“收费”方式赚钱，概率实在太低了。\n\n既然赞赏太鸡肋，想稳定有笔收益，自然就得考虑加广告了。为了“吃相”好看点，直接在操作页面插广告的方式肯定排除——得保住用户用的时候的好体验。\n\n现在选的是激励广告：用户要是做一些耗资源多的操作（比如复杂的图片处理），就得看一次广告，相当于付了这次操作的“费”；除此之外的基础操作，全是免费的。这样既不影响大多数人的使用，也能勉强覆盖云服务的支出，算是目前最平衡的办法了。\n\n可即便选了激励广告，我心里其实还是没底——到底能不能真的覆盖掉每月的运营支出，谁也说不准。毕竟在国内，“免费使用软件”早就成了大家的默认习惯，不管是看几十秒广告，还是掏哪怕一块钱，只要沾了“付费”的边，都像在无形中“冒犯”用户——说不定人家眉头一皱，随手就把小程序关了，下次再也不会打开。\n\n这种担忧不是没道理。我自己刷手机时，要是遇到必须看广告才能用的功能，也会忍不住吐槽两句，有时候干脆换个工具。可即便知道可能会流失用户，我还是不想退回到“完全免费”的老路上去。\n\n倒不是我贪心，想靠这小程序赚多少钱，而是我始终觉得，一款真正成熟、能长久走下去的软件，不该只有“设计”和“开发”这两个环节。“盈利”其实是补上最后一块关键拼图——只有形成“设计-开发-盈利”的完整闭环，软件才不用一直靠我的“咖啡钱”贴补，才不用担心里程碑式的“欠费通知”，才能真的稳定地活下去，继续给需要的人解决证照处理的麻烦。\n\n哪怕最后每个月只赚一块钱，和“完全免费”比起来，也是天差地别的。那一块钱不是收益，更像一个小小的“认可信号”——说明有人觉得这个工具有用，愿意为它消耗的资源、为我花在上面的时间买单。这份认可，比单纯的“用户量”更让我踏实，也更能支撑我继续优化功能、解决bug，把它做得更顺手。\n\n我也知道，这种“想打破免费惯性”的想法，可能有点理想化，甚至会被人说“矫情”。但还是想试试——毕竟做《豆豆证照工坊》的初衷，从来不是“做个一次性的玩具”，而是希望它能真的帮到大家，并且能一直帮下去。如果这点小小的“收益闭环”，能让这个初衷实现，那就已经足够了。\n","slug":"about-software-charges","published":1,"updated":"2025-10-28T13:46:26.985Z","comments":1,"layout":"post","photos":[],"_id":"cmjbml2i00009ikup4ji7ambw","content":"<p>每个开发者大概都有个小梦想——做一款属于自己的软件，被很多人用，要是还能赚点钱就更好了。可现实是，不少好想法哪怕做成了产品，最后也难免中途夭折。原因五花八门，运营恰恰是很多开发者的短板；更现实的是“收益”问题——纯靠“爱发电”的项目能走多远，其实谁也说不准。</p>\n<p>我的小程序《豆豆证照工坊》上线半个多月后，我也遇上了这个难题。</p>\n<p>上周微信团队发消息说，我的云环境欠费了。一开始我以为这东西是免费的，后来才搞明白：小程序上线前，云环境对开发者是免费的；可一旦正式上线，就得开始付费了。</p>\n<p>登录后台一看，好家伙——两周的瑞幸咖啡钱直接没了，还没算那个每月19.9元的“穷鬼套餐”（基础版）。这哪儿是“爱发电”啊，分明是拿我的咖啡钱在发电。这下我不得不认真想了：软件得有收益，至少得能覆盖基础支出吧？</p>\n<p>纠结这事儿的时候，心里其实挺矛盾的。一方面，总希望自己花时间琢磨出来的产品，能被更多人喜欢、用上，还能帮到大家；可另一方面，“得靠收益支撑软件运行”的现实又摆在哪儿——每一次接口调用、图片处理、数据存储，都在消耗资源，总有人得为这些买单。</p>\n<p>纠结了好一阵，最后还是选了“要钱不要脸”——开始考虑收费。</p>\n<p>不过以前不管是学习还是生活里，遇到过不少简单的线上工具，非要注册、开会员才能用，我对这种收费模式一直很不感冒。所以“付费会员”这条路，我肯定不碰。毕竟“屠龙者终成恶龙”的事儿，不如一开始就别做。</p>\n<p>之前写文的评论区里，有网友提议可以在小程序里加赞赏功能，这个想法倒是点醒了我。这感觉像极了以前街头卖艺——“有钱的捧个钱场，没钱的捧个人场”，只不过现在这叫“开源精神”吧。</p>\n<p>接入赞赏的方式倒简单：用户点一下赞赏按钮，会弹出赞赏二维码，要么长按保存，要么截图存到手机里，再用微信扫一下就行。可问题是，小程序里没法直接长按识别赞赏码，整套流程一下就变繁琐了；更麻烦的是，还得下载图片、退出小程序去扫码——操作一中断，靠这种“收费”方式赚钱，概率实在太低了。</p>\n<p>既然赞赏太鸡肋，想稳定有笔收益，自然就得考虑加广告了。为了“吃相”好看点，直接在操作页面插广告的方式肯定排除——得保住用户用的时候的好体验。</p>\n<p>现在选的是激励广告：用户要是做一些耗资源多的操作（比如复杂的图片处理），就得看一次广告，相当于付了这次操作的“费”；除此之外的基础操作，全是免费的。这样既不影响大多数人的使用，也能勉强覆盖云服务的支出，算是目前最平衡的办法了。</p>\n<p>可即便选了激励广告，我心里其实还是没底——到底能不能真的覆盖掉每月的运营支出，谁也说不准。毕竟在国内，“免费使用软件”早就成了大家的默认习惯，不管是看几十秒广告，还是掏哪怕一块钱，只要沾了“付费”的边，都像在无形中“冒犯”用户——说不定人家眉头一皱，随手就把小程序关了，下次再也不会打开。</p>\n<p>这种担忧不是没道理。我自己刷手机时，要是遇到必须看广告才能用的功能，也会忍不住吐槽两句，有时候干脆换个工具。可即便知道可能会流失用户，我还是不想退回到“完全免费”的老路上去。</p>\n<p>倒不是我贪心，想靠这小程序赚多少钱，而是我始终觉得，一款真正成熟、能长久走下去的软件，不该只有“设计”和“开发”这两个环节。“盈利”其实是补上最后一块关键拼图——只有形成“设计-开发-盈利”的完整闭环，软件才不用一直靠我的“咖啡钱”贴补，才不用担心里程碑式的“欠费通知”，才能真的稳定地活下去，继续给需要的人解决证照处理的麻烦。</p>\n<p>哪怕最后每个月只赚一块钱，和“完全免费”比起来，也是天差地别的。那一块钱不是收益，更像一个小小的“认可信号”——说明有人觉得这个工具有用，愿意为它消耗的资源、为我花在上面的时间买单。这份认可，比单纯的“用户量”更让我踏实，也更能支撑我继续优化功能、解决bug，把它做得更顺手。</p>\n<p>我也知道，这种“想打破免费惯性”的想法，可能有点理想化，甚至会被人说“矫情”。但还是想试试——毕竟做《豆豆证照工坊》的初衷，从来不是“做个一次性的玩具”，而是希望它能真的帮到大家，并且能一直帮下去。如果这点小小的“收益闭环”，能让这个初衷实现，那就已经足够了。</p>\n","excerpt":"","more":"<p>每个开发者大概都有个小梦想——做一款属于自己的软件，被很多人用，要是还能赚点钱就更好了。可现实是，不少好想法哪怕做成了产品，最后也难免中途夭折。原因五花八门，运营恰恰是很多开发者的短板；更现实的是“收益”问题——纯靠“爱发电”的项目能走多远，其实谁也说不准。</p>\n<p>我的小程序《豆豆证照工坊》上线半个多月后，我也遇上了这个难题。</p>\n<p>上周微信团队发消息说，我的云环境欠费了。一开始我以为这东西是免费的，后来才搞明白：小程序上线前，云环境对开发者是免费的；可一旦正式上线，就得开始付费了。</p>\n<p>登录后台一看，好家伙——两周的瑞幸咖啡钱直接没了，还没算那个每月19.9元的“穷鬼套餐”（基础版）。这哪儿是“爱发电”啊，分明是拿我的咖啡钱在发电。这下我不得不认真想了：软件得有收益，至少得能覆盖基础支出吧？</p>\n<p>纠结这事儿的时候，心里其实挺矛盾的。一方面，总希望自己花时间琢磨出来的产品，能被更多人喜欢、用上，还能帮到大家；可另一方面，“得靠收益支撑软件运行”的现实又摆在哪儿——每一次接口调用、图片处理、数据存储，都在消耗资源，总有人得为这些买单。</p>\n<p>纠结了好一阵，最后还是选了“要钱不要脸”——开始考虑收费。</p>\n<p>不过以前不管是学习还是生活里，遇到过不少简单的线上工具，非要注册、开会员才能用，我对这种收费模式一直很不感冒。所以“付费会员”这条路，我肯定不碰。毕竟“屠龙者终成恶龙”的事儿，不如一开始就别做。</p>\n<p>之前写文的评论区里，有网友提议可以在小程序里加赞赏功能，这个想法倒是点醒了我。这感觉像极了以前街头卖艺——“有钱的捧个钱场，没钱的捧个人场”，只不过现在这叫“开源精神”吧。</p>\n<p>接入赞赏的方式倒简单：用户点一下赞赏按钮，会弹出赞赏二维码，要么长按保存，要么截图存到手机里，再用微信扫一下就行。可问题是，小程序里没法直接长按识别赞赏码，整套流程一下就变繁琐了；更麻烦的是，还得下载图片、退出小程序去扫码——操作一中断，靠这种“收费”方式赚钱，概率实在太低了。</p>\n<p>既然赞赏太鸡肋，想稳定有笔收益，自然就得考虑加广告了。为了“吃相”好看点，直接在操作页面插广告的方式肯定排除——得保住用户用的时候的好体验。</p>\n<p>现在选的是激励广告：用户要是做一些耗资源多的操作（比如复杂的图片处理），就得看一次广告，相当于付了这次操作的“费”；除此之外的基础操作，全是免费的。这样既不影响大多数人的使用，也能勉强覆盖云服务的支出，算是目前最平衡的办法了。</p>\n<p>可即便选了激励广告，我心里其实还是没底——到底能不能真的覆盖掉每月的运营支出，谁也说不准。毕竟在国内，“免费使用软件”早就成了大家的默认习惯，不管是看几十秒广告，还是掏哪怕一块钱，只要沾了“付费”的边，都像在无形中“冒犯”用户——说不定人家眉头一皱，随手就把小程序关了，下次再也不会打开。</p>\n<p>这种担忧不是没道理。我自己刷手机时，要是遇到必须看广告才能用的功能，也会忍不住吐槽两句，有时候干脆换个工具。可即便知道可能会流失用户，我还是不想退回到“完全免费”的老路上去。</p>\n<p>倒不是我贪心，想靠这小程序赚多少钱，而是我始终觉得，一款真正成熟、能长久走下去的软件，不该只有“设计”和“开发”这两个环节。“盈利”其实是补上最后一块关键拼图——只有形成“设计-开发-盈利”的完整闭环，软件才不用一直靠我的“咖啡钱”贴补，才不用担心里程碑式的“欠费通知”，才能真的稳定地活下去，继续给需要的人解决证照处理的麻烦。</p>\n<p>哪怕最后每个月只赚一块钱，和“完全免费”比起来，也是天差地别的。那一块钱不是收益，更像一个小小的“认可信号”——说明有人觉得这个工具有用，愿意为它消耗的资源、为我花在上面的时间买单。这份认可，比单纯的“用户量”更让我踏实，也更能支撑我继续优化功能、解决bug，把它做得更顺手。</p>\n<p>我也知道，这种“想打破免费惯性”的想法，可能有点理想化，甚至会被人说“矫情”。但还是想试试——毕竟做《豆豆证照工坊》的初衷，从来不是“做个一次性的玩具”，而是希望它能真的帮到大家，并且能一直帮下去。如果这点小小的“收益闭环”，能让这个初衷实现，那就已经足够了。</p>\n"},{"title":"Javascript高频面试点--ES6 数组(Array)新特性","date":"2025-12-06T04:29:11.000Z","_content":"\n数组是 JavaScript 处理数据的核心结构，ES6（ECMAScript 2015）对数组的扩展，解决了传统操作的繁琐问题，让数据处理更高效。下面我们来结合实例，梳理 ES6 数组的核心扩展特性与用法。\n\n## 一、语法层面的突破：扩展运算符\n\n\n扩展运算符（`...`）是 ES6 中最具代表性的语法糖之一，它将数组或类数组对象展开为独立的元素，彻底改变了数组拷贝、合并、参数传递等常见操作的实现方式。\n\n### 1. 数组拷贝\n\n传统拷贝数组需借助`slice()`或`concat()`，ES6 中使用扩展运算符更为简洁直观，且支持深拷贝一维数组：\n\n\n\n```javascript\n// 浅拷贝一维数组\n\nconst arr1 = [1, 2, 3];\n\nconst arr2 = [...arr1]; // [1, 2, 3]\n\narr2[0] = 100;\n\nconsole.log(arr1); // [1, 2, 3]（原数组不受影响）\n\n// 对比ES5写法\n\nconst arr3 = arr1.slice();\n\nconst arr4 = [].concat(arr1);\n```\n\n### 2. 数组合并\n\n无需再依赖`concat()`的链式调用，扩展运算符可直接合并多个数组，且支持在任意位置插入元素：\n\n\n\n```javascript\nconst arrA = [1, 2];\n\nconst arrB = [3, 4];\n\nconst arrC = [0, ...arrA, 2.5, ...arrB, 5]; // [0, 1, 2, 2.5, 3, 4, 5]\n```\n\n### 3. 函数参数传递\n\n解决了`apply()`传递数组参数的繁琐问题，直接将数组元素作为独立参数传入函数：\n\n\n\n```javascript\nconst numbers = [10, 20, 30];\n\n// ES6写法\n\nMath.max(...numbers); // 30\n\n// ES5写法\n\nMath.max.apply(null, numbers); // 30\n```\n\n### 4. 解构赋值结合\n\n扩展运算符可与解构赋值配合，便捷提取数组部分元素：\n\n\n\n```javascript\nconst [first, second, ...rest] = [1, 2, 3, 4, 5];\n\nconsole.log(first); // 1\n\nconsole.log(second); // 2\n\nconsole.log(rest); // [3, 4, 5]（剩余元素组成新数组）\n```\n\n## 二、数组构造函数的增强：Array.from () 与 Array.of ()\n\nES6 为`Array`构造函数新增了两个静态方法，分别解决了 “类数组对象转数组” 和 “创建固定长度数组” 的经典问题。\n\n#### 1. Array.from ()：类数组对象与可迭代对象转数组\n\n类数组对象（如 DOM 集合、`arguments`）和可迭代对象（如 Set、Map），在 ES6 前需通过`Array.prototype.slice.call()`转换为数组，`Array.from()`提供了统一、直观的解决方案，还支持映射函数参数：\n\n\n\n```javascript\n// 转换类数组对象（DOM集合）\n\nconst lis = document.querySelectorAll('li');\n\nconst liArray = Array.from(lis); // 转为数组，可使用数组方法\n\n// 转换arguments对象\n\nfunction sum() {\n\t return Array.from(arguments).reduce((a, b) => a + b, 0);\n}\n\nsum(1, 2, 3); // 6\n\n// 带映射函数（类似map()）\n\nconst str = 'hello';\n\nArray.from(str, char => char.toUpperCase()); // ['H', 'E', 'L', 'L', 'O']\n\n// 转换Set对象\n\nconst set = new Set([1, 2, 2, 3]);\n\nArray.from(set); // [1, 2, 3]（自动去重）\n```\n\n#### 2. Array.of ()：统一数组创建行为\n\n传统`Array`构造函数存在行为不一致问题：当传入单个数字时，创建的是指定长度的空数组，而非包含该数字的数组。`Array.of()`修复了这一缺陷，无论传入多少参数，均创建包含这些参数的数组：\n\n\n\n```javascript\n// ES6 Array.of()\n\nArray.of(5); // [5]\n\nArray.of(1, 2, 3); // [1, 2, 3]\n\nArray.of(); // []（无参数返回空数组）\n\n// ES5 Array构造函数（对比）\n\nArray(5); // [empty × 5]（长度为5的空数组）\n\nArray(1, 2, 3); // [1, 2, 3]（多参数正常）\n```\n\n## 三、数组实例方法的升级：查找、遍历与修改\n\nES6 新增了多个数组实例方法，覆盖了查找、遍历、填充、扁平化等高频场景，让数据处理逻辑更简洁。\n\n### 1. 查找类方法：find () 与 findIndex ()\n\n传统查找数组元素依赖`indexOf()`，但它仅支持查找原始值，且无法处理 “满足特定条件的元素”。`find()`和`findIndex()`弥补了这一不足，支持传入回调函数，返回第一个满足条件的元素或其索引：\n\n\n\n```javascript\nconst users = [\n  { id: 1, name: '张三', age: 20 },\n  { id: 2, name: '李四', age: 25 },\n  { id: 3, name: '王五', age: 30 }\n];\n\n// find()：返回第一个满足条件的元素\n\nconst targetUser = users.find(user => user.age > 22);\n\nconsole.log(targetUser); // { id: 2, name: '李四', age: 25 }\n\n// findIndex()：返回第一个满足条件的元素索引\n\nconst targetIndex = users.findIndex(user => user.name === '王五');\n\nconsole.log(targetIndex); // 2\n\n// 支持查找NaN（indexOf()无法做到）\n\nconst numbers = [1, NaN, 3];\n\nnumbers.find(n => Object.is(n, NaN)); // NaN\n\nnumbers.findIndex(n => Object.is(n, NaN)); // 1\n```\n\n### 2. 包含判断：includes ()\n\n`indexOf()`判断元素是否存在时，需通过返回值是否为`-1`判断，语义不够清晰。`includes()`直接返回布尔值，且支持判断`NaN`，使用更直观：\n\n\n\n```javascript\nconst fruits = ['苹果', '香蕉', '橙子'];\n\nfruits.includes('香蕉'); // true\n\nfruits.includes('葡萄'); // false\n\n// 支持NaN判断\n\n[1, 2, NaN].includes(NaN); // true\n\n[1, 2, NaN].indexOf(NaN); // -1（对比）\n```\n\n### 3. 迭代器方法：entries ()、keys ()、values ()\n\nES6 为数组新增了三个迭代器方法，支持通过`for...of`循环遍历数组的键、值或键值对，替代了传统的`for`循环或`forEach()`：\n\n\n\n```javascript\nconst arr = ['a', 'b', 'c'];\n\n// keys()：遍历索引\n\nfor (const key of arr.keys()) {\n\n&#x20; console.log(key); // 0, 1, 2\n\n}\n\n// values()：遍历值（ES2017正式标准化）\n\nfor (const value of arr.values()) {\n\n console.log(value); // 'a', 'b', 'c'\n\n}\n\n// entries()：遍历键值对（返回数组\\[key, value]）\n\nfor (const [key, value] of arr.entries()) {\n\nconsole.log(`${key}: ${value}`); // 0: a, 1: b, 2: c\n\n}\n```\n\n#### 4. 填充与复制：fill () 与 copyWithin ()\n\n`fill()`用于将数组指定范围的元素替换为固定值，`copyWithin()`则将数组内部的元素复制到另一位置，均支持修改原数组（也可通过浅拷贝避免）：\n\n\n\n```javascript\n\n// fill(value, start?, end?)：填充数组\n\nconst arr1 = [1, 2, 3, 4, 5];\n\narr1.fill(0); // [0, 0, 0, 0, 0]（填充整个数组）\n\narr1.fill(9, 1, 3); // [0, 9, 9, 0, 0]（从索引1到3前填充9）\n\n// copyWithin(target, start?, end?)：复制内部元素\n\nconst arr2 = [1, 2, 3, 4, 5];\n\narr2.copyWithin(0, 3); // [4, 5, 3, 4, 5]（将索引3及以后的元素复制到索引0开始的位置）\n\narr2.copyWithin(1, 0, 2); // [4, 4, 5, 4, 5]（将索引0-2前的元素复制到索引1开始的位置）\n```\n\n### 5. 扁平化处理：flat  与 flatMap \n\n多维数组扁平化是常见需求，ES6 前需递归实现，`flat()`和`flatMap()`提供了原生支持：\n\n\n\n```javascript\n// flat(depth?)：扁平化数组，depth默认1（可传Infinity扁平化所有层级）\n\nconst nestedArr = [1, [2, [3, [4]]]];\n\nnestedArr.flat(); // [1, 2, [3, [4]]]（扁平化1层）\n\nnestedArr.flat(2); // [1, 2, 3, [4]]（扁平化2层）\n\nnestedArr.flat(Infinity); // [1, 2, 3, 4]（扁平化所有层级）\n\n// flatMap()：先执行map()，再执行flat(1)（效率更高）\n\nconst arr = [1, 2, 3];\n\n// 等价于 arr.map(x => [x * 2]).flat()\n\narr.flatMap(x => [x * 2]); // \\[2, 4, 6]\n\n// 处理嵌套数组场景\n\nconst lists = [\n ['a', 'b'],\n ['c', 'd'],\n ['e']\n];\n\nlists.flatMap(list => list.map(item => item.toUpperCase())); // \\['A', 'B', 'C', 'D', 'E']\n```\n\n## 四、空位处理的规范化\n\nES5 中数组空位（如`[1, , 3]`）的行为不一致（`forEach()`、`map()`跳过空位，`join()`视为空字符串）。ES6 明确规定：数组空位应被视为`undefined`，新增方法（如`find()`、`includes()`）均按`undefined`处理，避免了歧义：\n\n\n\n```javascript\nconst arr = [1, , 3];\n\n// ES6方法：将空位视为undefined\n\narr.includes(undefined); // true\n\narr.find(x => x === undefined); // undefined（找到空位）\n\narr.flat(); // [1, undefined, 3]（扁平化不忽略空位）\n\n// ES5方法（对比）\n\narr.map(x => x || 0); // [1, 0, 3]（map()跳过空位，返回原位置）\n\narr.join('-'); // \"1--3\"（join()将空位视为空字符串）\n```\n\nES6中数组的拓展用简洁语法和实用方法，解决了传统操作的痛点，减少代码量、提升可读性。掌握这些特性，能帮助我们更高效地处理项目中的数据。\n\n最关键的是，面试频率很高啊，哈哈!","source":"_posts/array-in-es6.md","raw":"---\ntitle: Javascript高频面试点--ES6 数组(Array)新特性\ndate: 2025-12-06 12:29:11\ntags: JavaScript进阶, ES6进阶\ncategory: ES6进阶\n---\n\n数组是 JavaScript 处理数据的核心结构，ES6（ECMAScript 2015）对数组的扩展，解决了传统操作的繁琐问题，让数据处理更高效。下面我们来结合实例，梳理 ES6 数组的核心扩展特性与用法。\n\n## 一、语法层面的突破：扩展运算符\n\n\n扩展运算符（`...`）是 ES6 中最具代表性的语法糖之一，它将数组或类数组对象展开为独立的元素，彻底改变了数组拷贝、合并、参数传递等常见操作的实现方式。\n\n### 1. 数组拷贝\n\n传统拷贝数组需借助`slice()`或`concat()`，ES6 中使用扩展运算符更为简洁直观，且支持深拷贝一维数组：\n\n\n\n```javascript\n// 浅拷贝一维数组\n\nconst arr1 = [1, 2, 3];\n\nconst arr2 = [...arr1]; // [1, 2, 3]\n\narr2[0] = 100;\n\nconsole.log(arr1); // [1, 2, 3]（原数组不受影响）\n\n// 对比ES5写法\n\nconst arr3 = arr1.slice();\n\nconst arr4 = [].concat(arr1);\n```\n\n### 2. 数组合并\n\n无需再依赖`concat()`的链式调用，扩展运算符可直接合并多个数组，且支持在任意位置插入元素：\n\n\n\n```javascript\nconst arrA = [1, 2];\n\nconst arrB = [3, 4];\n\nconst arrC = [0, ...arrA, 2.5, ...arrB, 5]; // [0, 1, 2, 2.5, 3, 4, 5]\n```\n\n### 3. 函数参数传递\n\n解决了`apply()`传递数组参数的繁琐问题，直接将数组元素作为独立参数传入函数：\n\n\n\n```javascript\nconst numbers = [10, 20, 30];\n\n// ES6写法\n\nMath.max(...numbers); // 30\n\n// ES5写法\n\nMath.max.apply(null, numbers); // 30\n```\n\n### 4. 解构赋值结合\n\n扩展运算符可与解构赋值配合，便捷提取数组部分元素：\n\n\n\n```javascript\nconst [first, second, ...rest] = [1, 2, 3, 4, 5];\n\nconsole.log(first); // 1\n\nconsole.log(second); // 2\n\nconsole.log(rest); // [3, 4, 5]（剩余元素组成新数组）\n```\n\n## 二、数组构造函数的增强：Array.from () 与 Array.of ()\n\nES6 为`Array`构造函数新增了两个静态方法，分别解决了 “类数组对象转数组” 和 “创建固定长度数组” 的经典问题。\n\n#### 1. Array.from ()：类数组对象与可迭代对象转数组\n\n类数组对象（如 DOM 集合、`arguments`）和可迭代对象（如 Set、Map），在 ES6 前需通过`Array.prototype.slice.call()`转换为数组，`Array.from()`提供了统一、直观的解决方案，还支持映射函数参数：\n\n\n\n```javascript\n// 转换类数组对象（DOM集合）\n\nconst lis = document.querySelectorAll('li');\n\nconst liArray = Array.from(lis); // 转为数组，可使用数组方法\n\n// 转换arguments对象\n\nfunction sum() {\n\t return Array.from(arguments).reduce((a, b) => a + b, 0);\n}\n\nsum(1, 2, 3); // 6\n\n// 带映射函数（类似map()）\n\nconst str = 'hello';\n\nArray.from(str, char => char.toUpperCase()); // ['H', 'E', 'L', 'L', 'O']\n\n// 转换Set对象\n\nconst set = new Set([1, 2, 2, 3]);\n\nArray.from(set); // [1, 2, 3]（自动去重）\n```\n\n#### 2. Array.of ()：统一数组创建行为\n\n传统`Array`构造函数存在行为不一致问题：当传入单个数字时，创建的是指定长度的空数组，而非包含该数字的数组。`Array.of()`修复了这一缺陷，无论传入多少参数，均创建包含这些参数的数组：\n\n\n\n```javascript\n// ES6 Array.of()\n\nArray.of(5); // [5]\n\nArray.of(1, 2, 3); // [1, 2, 3]\n\nArray.of(); // []（无参数返回空数组）\n\n// ES5 Array构造函数（对比）\n\nArray(5); // [empty × 5]（长度为5的空数组）\n\nArray(1, 2, 3); // [1, 2, 3]（多参数正常）\n```\n\n## 三、数组实例方法的升级：查找、遍历与修改\n\nES6 新增了多个数组实例方法，覆盖了查找、遍历、填充、扁平化等高频场景，让数据处理逻辑更简洁。\n\n### 1. 查找类方法：find () 与 findIndex ()\n\n传统查找数组元素依赖`indexOf()`，但它仅支持查找原始值，且无法处理 “满足特定条件的元素”。`find()`和`findIndex()`弥补了这一不足，支持传入回调函数，返回第一个满足条件的元素或其索引：\n\n\n\n```javascript\nconst users = [\n  { id: 1, name: '张三', age: 20 },\n  { id: 2, name: '李四', age: 25 },\n  { id: 3, name: '王五', age: 30 }\n];\n\n// find()：返回第一个满足条件的元素\n\nconst targetUser = users.find(user => user.age > 22);\n\nconsole.log(targetUser); // { id: 2, name: '李四', age: 25 }\n\n// findIndex()：返回第一个满足条件的元素索引\n\nconst targetIndex = users.findIndex(user => user.name === '王五');\n\nconsole.log(targetIndex); // 2\n\n// 支持查找NaN（indexOf()无法做到）\n\nconst numbers = [1, NaN, 3];\n\nnumbers.find(n => Object.is(n, NaN)); // NaN\n\nnumbers.findIndex(n => Object.is(n, NaN)); // 1\n```\n\n### 2. 包含判断：includes ()\n\n`indexOf()`判断元素是否存在时，需通过返回值是否为`-1`判断，语义不够清晰。`includes()`直接返回布尔值，且支持判断`NaN`，使用更直观：\n\n\n\n```javascript\nconst fruits = ['苹果', '香蕉', '橙子'];\n\nfruits.includes('香蕉'); // true\n\nfruits.includes('葡萄'); // false\n\n// 支持NaN判断\n\n[1, 2, NaN].includes(NaN); // true\n\n[1, 2, NaN].indexOf(NaN); // -1（对比）\n```\n\n### 3. 迭代器方法：entries ()、keys ()、values ()\n\nES6 为数组新增了三个迭代器方法，支持通过`for...of`循环遍历数组的键、值或键值对，替代了传统的`for`循环或`forEach()`：\n\n\n\n```javascript\nconst arr = ['a', 'b', 'c'];\n\n// keys()：遍历索引\n\nfor (const key of arr.keys()) {\n\n&#x20; console.log(key); // 0, 1, 2\n\n}\n\n// values()：遍历值（ES2017正式标准化）\n\nfor (const value of arr.values()) {\n\n console.log(value); // 'a', 'b', 'c'\n\n}\n\n// entries()：遍历键值对（返回数组\\[key, value]）\n\nfor (const [key, value] of arr.entries()) {\n\nconsole.log(`${key}: ${value}`); // 0: a, 1: b, 2: c\n\n}\n```\n\n#### 4. 填充与复制：fill () 与 copyWithin ()\n\n`fill()`用于将数组指定范围的元素替换为固定值，`copyWithin()`则将数组内部的元素复制到另一位置，均支持修改原数组（也可通过浅拷贝避免）：\n\n\n\n```javascript\n\n// fill(value, start?, end?)：填充数组\n\nconst arr1 = [1, 2, 3, 4, 5];\n\narr1.fill(0); // [0, 0, 0, 0, 0]（填充整个数组）\n\narr1.fill(9, 1, 3); // [0, 9, 9, 0, 0]（从索引1到3前填充9）\n\n// copyWithin(target, start?, end?)：复制内部元素\n\nconst arr2 = [1, 2, 3, 4, 5];\n\narr2.copyWithin(0, 3); // [4, 5, 3, 4, 5]（将索引3及以后的元素复制到索引0开始的位置）\n\narr2.copyWithin(1, 0, 2); // [4, 4, 5, 4, 5]（将索引0-2前的元素复制到索引1开始的位置）\n```\n\n### 5. 扁平化处理：flat  与 flatMap \n\n多维数组扁平化是常见需求，ES6 前需递归实现，`flat()`和`flatMap()`提供了原生支持：\n\n\n\n```javascript\n// flat(depth?)：扁平化数组，depth默认1（可传Infinity扁平化所有层级）\n\nconst nestedArr = [1, [2, [3, [4]]]];\n\nnestedArr.flat(); // [1, 2, [3, [4]]]（扁平化1层）\n\nnestedArr.flat(2); // [1, 2, 3, [4]]（扁平化2层）\n\nnestedArr.flat(Infinity); // [1, 2, 3, 4]（扁平化所有层级）\n\n// flatMap()：先执行map()，再执行flat(1)（效率更高）\n\nconst arr = [1, 2, 3];\n\n// 等价于 arr.map(x => [x * 2]).flat()\n\narr.flatMap(x => [x * 2]); // \\[2, 4, 6]\n\n// 处理嵌套数组场景\n\nconst lists = [\n ['a', 'b'],\n ['c', 'd'],\n ['e']\n];\n\nlists.flatMap(list => list.map(item => item.toUpperCase())); // \\['A', 'B', 'C', 'D', 'E']\n```\n\n## 四、空位处理的规范化\n\nES5 中数组空位（如`[1, , 3]`）的行为不一致（`forEach()`、`map()`跳过空位，`join()`视为空字符串）。ES6 明确规定：数组空位应被视为`undefined`，新增方法（如`find()`、`includes()`）均按`undefined`处理，避免了歧义：\n\n\n\n```javascript\nconst arr = [1, , 3];\n\n// ES6方法：将空位视为undefined\n\narr.includes(undefined); // true\n\narr.find(x => x === undefined); // undefined（找到空位）\n\narr.flat(); // [1, undefined, 3]（扁平化不忽略空位）\n\n// ES5方法（对比）\n\narr.map(x => x || 0); // [1, 0, 3]（map()跳过空位，返回原位置）\n\narr.join('-'); // \"1--3\"（join()将空位视为空字符串）\n```\n\nES6中数组的拓展用简洁语法和实用方法，解决了传统操作的痛点，减少代码量、提升可读性。掌握这些特性，能帮助我们更高效地处理项目中的数据。\n\n最关键的是，面试频率很高啊，哈哈!","slug":"array-in-es6","published":1,"updated":"2025-12-06T04:47:41.765Z","comments":1,"layout":"post","photos":[],"_id":"cmjbml2i1000bikupap4zb25k","content":"<p>数组是 JavaScript 处理数据的核心结构，ES6（ECMAScript 2015）对数组的扩展，解决了传统操作的繁琐问题，让数据处理更高效。下面我们来结合实例，梳理 ES6 数组的核心扩展特性与用法。</p>\n<h2 id=\"一、语法层面的突破：扩展运算符\"><a href=\"#一、语法层面的突破：扩展运算符\" class=\"headerlink\" title=\"一、语法层面的突破：扩展运算符\"></a>一、语法层面的突破：扩展运算符</h2><p>扩展运算符（<code>...</code>）是 ES6 中最具代表性的语法糖之一，它将数组或类数组对象展开为独立的元素，彻底改变了数组拷贝、合并、参数传递等常见操作的实现方式。</p>\n<h3 id=\"1-数组拷贝\"><a href=\"#1-数组拷贝\" class=\"headerlink\" title=\"1. 数组拷贝\"></a>1. 数组拷贝</h3><p>传统拷贝数组需借助<code>slice()</code>或<code>concat()</code>，ES6 中使用扩展运算符更为简洁直观，且支持深拷贝一维数组：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 浅拷贝一维数组</span><br><br><span class=\"hljs-keyword\">const</span> arr1 = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];<br><br><span class=\"hljs-keyword\">const</span> arr2 = [...arr1]; <span class=\"hljs-comment\">// [1, 2, 3]</span><br><br>arr2[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">100</span>;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(arr1); <span class=\"hljs-comment\">// [1, 2, 3]（原数组不受影响）</span><br><br><span class=\"hljs-comment\">// 对比ES5写法</span><br><br><span class=\"hljs-keyword\">const</span> arr3 = arr1.<span class=\"hljs-title function_\">slice</span>();<br><br><span class=\"hljs-keyword\">const</span> arr4 = [].<span class=\"hljs-title function_\">concat</span>(arr1);<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-数组合并\"><a href=\"#2-数组合并\" class=\"headerlink\" title=\"2. 数组合并\"></a>2. 数组合并</h3><p>无需再依赖<code>concat()</code>的链式调用，扩展运算符可直接合并多个数组，且支持在任意位置插入元素：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> arrA = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>];<br><br><span class=\"hljs-keyword\">const</span> arrB = [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>];<br><br><span class=\"hljs-keyword\">const</span> arrC = [<span class=\"hljs-number\">0</span>, ...arrA, <span class=\"hljs-number\">2.5</span>, ...arrB, <span class=\"hljs-number\">5</span>]; <span class=\"hljs-comment\">// [0, 1, 2, 2.5, 3, 4, 5]</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-函数参数传递\"><a href=\"#3-函数参数传递\" class=\"headerlink\" title=\"3. 函数参数传递\"></a>3. 函数参数传递</h3><p>解决了<code>apply()</code>传递数组参数的繁琐问题，直接将数组元素作为独立参数传入函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> numbers = [<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">30</span>];<br><br><span class=\"hljs-comment\">// ES6写法</span><br><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">max</span>(...numbers); <span class=\"hljs-comment\">// 30</span><br><br><span class=\"hljs-comment\">// ES5写法</span><br><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">max</span>.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-literal\">null</span>, numbers); <span class=\"hljs-comment\">// 30</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"4-解构赋值结合\"><a href=\"#4-解构赋值结合\" class=\"headerlink\" title=\"4. 解构赋值结合\"></a>4. 解构赋值结合</h3><p>扩展运算符可与解构赋值配合，便捷提取数组部分元素：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> [first, second, ...rest] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>];<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(first); <span class=\"hljs-comment\">// 1</span><br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(second); <span class=\"hljs-comment\">// 2</span><br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rest); <span class=\"hljs-comment\">// [3, 4, 5]（剩余元素组成新数组）</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"二、数组构造函数的增强：Array-from-与-Array-of\"><a href=\"#二、数组构造函数的增强：Array-from-与-Array-of\" class=\"headerlink\" title=\"二、数组构造函数的增强：Array.from () 与 Array.of ()\"></a>二、数组构造函数的增强：Array.from () 与 Array.of ()</h2><p>ES6 为<code>Array</code>构造函数新增了两个静态方法，分别解决了 “类数组对象转数组” 和 “创建固定长度数组” 的经典问题。</p>\n<h4 id=\"1-Array-from-：类数组对象与可迭代对象转数组\"><a href=\"#1-Array-from-：类数组对象与可迭代对象转数组\" class=\"headerlink\" title=\"1. Array.from ()：类数组对象与可迭代对象转数组\"></a>1. Array.from ()：类数组对象与可迭代对象转数组</h4><p>类数组对象（如 DOM 集合、<code>arguments</code>）和可迭代对象（如 Set、Map），在 ES6 前需通过<code>Array.prototype.slice.call()</code>转换为数组，<code>Array.from()</code>提供了统一、直观的解决方案，还支持映射函数参数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 转换类数组对象（DOM集合）</span><br><br><span class=\"hljs-keyword\">const</span> lis = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelectorAll</span>(<span class=\"hljs-string\">&#x27;li&#x27;</span>);<br><br><span class=\"hljs-keyword\">const</span> liArray = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(lis); <span class=\"hljs-comment\">// 转为数组，可使用数组方法</span><br><br><span class=\"hljs-comment\">// 转换arguments对象</span><br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-params\"></span>) &#123;<br>\t <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(<span class=\"hljs-variable language_\">arguments</span>).<span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =&gt;</span> a + b, <span class=\"hljs-number\">0</span>);<br>&#125;<br><br><span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// 6</span><br><br><span class=\"hljs-comment\">// 带映射函数（类似map()）</span><br><br><span class=\"hljs-keyword\">const</span> str = <span class=\"hljs-string\">&#x27;hello&#x27;</span>;<br><br><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(str, <span class=\"hljs-function\"><span class=\"hljs-params\">char</span> =&gt;</span> char.<span class=\"hljs-title function_\">toUpperCase</span>()); <span class=\"hljs-comment\">// [&#x27;H&#x27;, &#x27;E&#x27;, &#x27;L&#x27;, &#x27;L&#x27;, &#x27;O&#x27;]</span><br><br><span class=\"hljs-comment\">// 转换Set对象</span><br><br><span class=\"hljs-keyword\">const</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]);<br><br><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(set); <span class=\"hljs-comment\">// [1, 2, 3]（自动去重）</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-Array-of-：统一数组创建行为\"><a href=\"#2-Array-of-：统一数组创建行为\" class=\"headerlink\" title=\"2. Array.of ()：统一数组创建行为\"></a>2. Array.of ()：统一数组创建行为</h4><p>传统<code>Array</code>构造函数存在行为不一致问题：当传入单个数字时，创建的是指定长度的空数组，而非包含该数字的数组。<code>Array.of()</code>修复了这一缺陷，无论传入多少参数，均创建包含这些参数的数组：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// ES6 Array.of()</span><br><br><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">of</span>(<span class=\"hljs-number\">5</span>); <span class=\"hljs-comment\">// [5]</span><br><br><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">of</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// [1, 2, 3]</span><br><br><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">of</span>(); <span class=\"hljs-comment\">// []（无参数返回空数组）</span><br><br><span class=\"hljs-comment\">// ES5 Array构造函数（对比）</span><br><br><span class=\"hljs-title class_\">Array</span>(<span class=\"hljs-number\">5</span>); <span class=\"hljs-comment\">// [empty × 5]（长度为5的空数组）</span><br><br><span class=\"hljs-title class_\">Array</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// [1, 2, 3]（多参数正常）</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"三、数组实例方法的升级：查找、遍历与修改\"><a href=\"#三、数组实例方法的升级：查找、遍历与修改\" class=\"headerlink\" title=\"三、数组实例方法的升级：查找、遍历与修改\"></a>三、数组实例方法的升级：查找、遍历与修改</h2><p>ES6 新增了多个数组实例方法，覆盖了查找、遍历、填充、扁平化等高频场景，让数据处理逻辑更简洁。</p>\n<h3 id=\"1-查找类方法：find-与-findIndex\"><a href=\"#1-查找类方法：find-与-findIndex\" class=\"headerlink\" title=\"1. 查找类方法：find () 与 findIndex ()\"></a>1. 查找类方法：find () 与 findIndex ()</h3><p>传统查找数组元素依赖<code>indexOf()</code>，但它仅支持查找原始值，且无法处理 “满足特定条件的元素”。<code>find()</code>和<code>findIndex()</code>弥补了这一不足，支持传入回调函数，返回第一个满足条件的元素或其索引：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> users = [<br>  &#123; <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;张三&#x27;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">20</span> &#125;,<br>  &#123; <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;李四&#x27;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">25</span> &#125;,<br>  &#123; <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;王五&#x27;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">30</span> &#125;<br>];<br><br><span class=\"hljs-comment\">// find()：返回第一个满足条件的元素</span><br><br><span class=\"hljs-keyword\">const</span> targetUser = users.<span class=\"hljs-title function_\">find</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">user</span> =&gt;</span> user.<span class=\"hljs-property\">age</span> &gt; <span class=\"hljs-number\">22</span>);<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(targetUser); <span class=\"hljs-comment\">// &#123; id: 2, name: &#x27;李四&#x27;, age: 25 &#125;</span><br><br><span class=\"hljs-comment\">// findIndex()：返回第一个满足条件的元素索引</span><br><br><span class=\"hljs-keyword\">const</span> targetIndex = users.<span class=\"hljs-title function_\">findIndex</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">user</span> =&gt;</span> user.<span class=\"hljs-property\">name</span> === <span class=\"hljs-string\">&#x27;王五&#x27;</span>);<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(targetIndex); <span class=\"hljs-comment\">// 2</span><br><br><span class=\"hljs-comment\">// 支持查找NaN（indexOf()无法做到）</span><br><br><span class=\"hljs-keyword\">const</span> numbers = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-title class_\">NaN</span>, <span class=\"hljs-number\">3</span>];<br><br>numbers.<span class=\"hljs-title function_\">find</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">n</span> =&gt;</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">is</span>(n, <span class=\"hljs-title class_\">NaN</span>)); <span class=\"hljs-comment\">// NaN</span><br><br>numbers.<span class=\"hljs-title function_\">findIndex</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">n</span> =&gt;</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">is</span>(n, <span class=\"hljs-title class_\">NaN</span>)); <span class=\"hljs-comment\">// 1</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-包含判断：includes\"><a href=\"#2-包含判断：includes\" class=\"headerlink\" title=\"2. 包含判断：includes ()\"></a>2. 包含判断：includes ()</h3><p><code>indexOf()</code>判断元素是否存在时，需通过返回值是否为<code>-1</code>判断，语义不够清晰。<code>includes()</code>直接返回布尔值，且支持判断<code>NaN</code>，使用更直观：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> fruits = [<span class=\"hljs-string\">&#x27;苹果&#x27;</span>, <span class=\"hljs-string\">&#x27;香蕉&#x27;</span>, <span class=\"hljs-string\">&#x27;橙子&#x27;</span>];<br><br>fruits.<span class=\"hljs-title function_\">includes</span>(<span class=\"hljs-string\">&#x27;香蕉&#x27;</span>); <span class=\"hljs-comment\">// true</span><br><br>fruits.<span class=\"hljs-title function_\">includes</span>(<span class=\"hljs-string\">&#x27;葡萄&#x27;</span>); <span class=\"hljs-comment\">// false</span><br><br><span class=\"hljs-comment\">// 支持NaN判断</span><br><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-title class_\">NaN</span>].<span class=\"hljs-title function_\">includes</span>(<span class=\"hljs-title class_\">NaN</span>); <span class=\"hljs-comment\">// true</span><br><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-title class_\">NaN</span>].<span class=\"hljs-title function_\">indexOf</span>(<span class=\"hljs-title class_\">NaN</span>); <span class=\"hljs-comment\">// -1（对比）</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-迭代器方法：entries-、keys-、values\"><a href=\"#3-迭代器方法：entries-、keys-、values\" class=\"headerlink\" title=\"3. 迭代器方法：entries ()、keys ()、values ()\"></a>3. 迭代器方法：entries ()、keys ()、values ()</h3><p>ES6 为数组新增了三个迭代器方法，支持通过<code>for...of</code>循环遍历数组的键、值或键值对，替代了传统的<code>for</code>循环或<code>forEach()</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>];<br><br><span class=\"hljs-comment\">// keys()：遍历索引</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> key <span class=\"hljs-keyword\">of</span> arr.<span class=\"hljs-title function_\">keys</span>()) &#123;<br><br>&amp;#x20; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(key); <span class=\"hljs-comment\">// 0, 1, 2</span><br><br>&#125;<br><br><span class=\"hljs-comment\">// values()：遍历值（ES2017正式标准化）</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> value <span class=\"hljs-keyword\">of</span> arr.<span class=\"hljs-title function_\">values</span>()) &#123;<br><br> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value); <span class=\"hljs-comment\">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span><br><br>&#125;<br><br><span class=\"hljs-comment\">// entries()：遍历键值对（返回数组\\[key, value]）</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> [key, value] <span class=\"hljs-keyword\">of</span> arr.<span class=\"hljs-title function_\">entries</span>()) &#123;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;key&#125;</span>: <span class=\"hljs-subst\">$&#123;value&#125;</span>`</span>); <span class=\"hljs-comment\">// 0: a, 1: b, 2: c</span><br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-填充与复制：fill-与-copyWithin\"><a href=\"#4-填充与复制：fill-与-copyWithin\" class=\"headerlink\" title=\"4. 填充与复制：fill () 与 copyWithin ()\"></a>4. 填充与复制：fill () 与 copyWithin ()</h4><p><code>fill()</code>用于将数组指定范围的元素替换为固定值，<code>copyWithin()</code>则将数组内部的元素复制到另一位置，均支持修改原数组（也可通过浅拷贝避免）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><br><span class=\"hljs-comment\">// fill(value, start?, end?)：填充数组</span><br><br><span class=\"hljs-keyword\">const</span> arr1 = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>];<br><br>arr1.<span class=\"hljs-title function_\">fill</span>(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// [0, 0, 0, 0, 0]（填充整个数组）</span><br><br>arr1.<span class=\"hljs-title function_\">fill</span>(<span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// [0, 9, 9, 0, 0]（从索引1到3前填充9）</span><br><br><span class=\"hljs-comment\">// copyWithin(target, start?, end?)：复制内部元素</span><br><br><span class=\"hljs-keyword\">const</span> arr2 = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>];<br><br>arr2.<span class=\"hljs-title function_\">copyWithin</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// [4, 5, 3, 4, 5]（将索引3及以后的元素复制到索引0开始的位置）</span><br><br>arr2.<span class=\"hljs-title function_\">copyWithin</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// [4, 4, 5, 4, 5]（将索引0-2前的元素复制到索引1开始的位置）</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"5-扁平化处理：flat-与-flatMap\"><a href=\"#5-扁平化处理：flat-与-flatMap\" class=\"headerlink\" title=\"5. 扁平化处理：flat  与 flatMap\"></a>5. 扁平化处理：flat  与 flatMap</h3><p>多维数组扁平化是常见需求，ES6 前需递归实现，<code>flat()</code>和<code>flatMap()</code>提供了原生支持：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// flat(depth?)：扁平化数组，depth默认1（可传Infinity扁平化所有层级）</span><br><br><span class=\"hljs-keyword\">const</span> nestedArr = [<span class=\"hljs-number\">1</span>, [<span class=\"hljs-number\">2</span>, [<span class=\"hljs-number\">3</span>, [<span class=\"hljs-number\">4</span>]]]];<br><br>nestedArr.<span class=\"hljs-title function_\">flat</span>(); <span class=\"hljs-comment\">// [1, 2, [3, [4]]]（扁平化1层）</span><br><br>nestedArr.<span class=\"hljs-title function_\">flat</span>(<span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// [1, 2, 3, [4]]（扁平化2层）</span><br><br>nestedArr.<span class=\"hljs-title function_\">flat</span>(<span class=\"hljs-title class_\">Infinity</span>); <span class=\"hljs-comment\">// [1, 2, 3, 4]（扁平化所有层级）</span><br><br><span class=\"hljs-comment\">// flatMap()：先执行map()，再执行flat(1)（效率更高）</span><br><br><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];<br><br><span class=\"hljs-comment\">// 等价于 arr.map(x =&gt; [x * 2]).flat()</span><br><br>arr.<span class=\"hljs-title function_\">flatMap</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> [x * <span class=\"hljs-number\">2</span>]); <span class=\"hljs-comment\">// \\[2, 4, 6]</span><br><br><span class=\"hljs-comment\">// 处理嵌套数组场景</span><br><br><span class=\"hljs-keyword\">const</span> lists = [<br> [<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>],<br> [<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-string\">&#x27;d&#x27;</span>],<br> [<span class=\"hljs-string\">&#x27;e&#x27;</span>]<br>];<br><br>lists.<span class=\"hljs-title function_\">flatMap</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">list</span> =&gt;</span> list.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item.<span class=\"hljs-title function_\">toUpperCase</span>())); <span class=\"hljs-comment\">// \\[&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;]</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"四、空位处理的规范化\"><a href=\"#四、空位处理的规范化\" class=\"headerlink\" title=\"四、空位处理的规范化\"></a>四、空位处理的规范化</h2><p>ES5 中数组空位（如<code>[1, , 3]</code>）的行为不一致（<code>forEach()</code>、<code>map()</code>跳过空位，<code>join()</code>视为空字符串）。ES6 明确规定：数组空位应被视为<code>undefined</code>，新增方法（如<code>find()</code>、<code>includes()</code>）均按<code>undefined</code>处理，避免了歧义：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-number\">1</span>, , <span class=\"hljs-number\">3</span>];<br><br><span class=\"hljs-comment\">// ES6方法：将空位视为undefined</span><br><br>arr.<span class=\"hljs-title function_\">includes</span>(<span class=\"hljs-literal\">undefined</span>); <span class=\"hljs-comment\">// true</span><br><br>arr.<span class=\"hljs-title function_\">find</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x === <span class=\"hljs-literal\">undefined</span>); <span class=\"hljs-comment\">// undefined（找到空位）</span><br><br>arr.<span class=\"hljs-title function_\">flat</span>(); <span class=\"hljs-comment\">// [1, undefined, 3]（扁平化不忽略空位）</span><br><br><span class=\"hljs-comment\">// ES5方法（对比）</span><br><br>arr.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x || <span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// [1, 0, 3]（map()跳过空位，返回原位置）</span><br><br>arr.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;-&#x27;</span>); <span class=\"hljs-comment\">// &quot;1--3&quot;（join()将空位视为空字符串）</span><br></code></pre></td></tr></table></figure>\n\n<p>ES6中数组的拓展用简洁语法和实用方法，解决了传统操作的痛点，减少代码量、提升可读性。掌握这些特性，能帮助我们更高效地处理项目中的数据。</p>\n<p>最关键的是，面试频率很高啊，哈哈!</p>\n","excerpt":"","more":"<p>数组是 JavaScript 处理数据的核心结构，ES6（ECMAScript 2015）对数组的扩展，解决了传统操作的繁琐问题，让数据处理更高效。下面我们来结合实例，梳理 ES6 数组的核心扩展特性与用法。</p>\n<h2 id=\"一、语法层面的突破：扩展运算符\"><a href=\"#一、语法层面的突破：扩展运算符\" class=\"headerlink\" title=\"一、语法层面的突破：扩展运算符\"></a>一、语法层面的突破：扩展运算符</h2><p>扩展运算符（<code>...</code>）是 ES6 中最具代表性的语法糖之一，它将数组或类数组对象展开为独立的元素，彻底改变了数组拷贝、合并、参数传递等常见操作的实现方式。</p>\n<h3 id=\"1-数组拷贝\"><a href=\"#1-数组拷贝\" class=\"headerlink\" title=\"1. 数组拷贝\"></a>1. 数组拷贝</h3><p>传统拷贝数组需借助<code>slice()</code>或<code>concat()</code>，ES6 中使用扩展运算符更为简洁直观，且支持深拷贝一维数组：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 浅拷贝一维数组</span><br><br><span class=\"hljs-keyword\">const</span> arr1 = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];<br><br><span class=\"hljs-keyword\">const</span> arr2 = [...arr1]; <span class=\"hljs-comment\">// [1, 2, 3]</span><br><br>arr2[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">100</span>;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(arr1); <span class=\"hljs-comment\">// [1, 2, 3]（原数组不受影响）</span><br><br><span class=\"hljs-comment\">// 对比ES5写法</span><br><br><span class=\"hljs-keyword\">const</span> arr3 = arr1.<span class=\"hljs-title function_\">slice</span>();<br><br><span class=\"hljs-keyword\">const</span> arr4 = [].<span class=\"hljs-title function_\">concat</span>(arr1);<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-数组合并\"><a href=\"#2-数组合并\" class=\"headerlink\" title=\"2. 数组合并\"></a>2. 数组合并</h3><p>无需再依赖<code>concat()</code>的链式调用，扩展运算符可直接合并多个数组，且支持在任意位置插入元素：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> arrA = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>];<br><br><span class=\"hljs-keyword\">const</span> arrB = [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>];<br><br><span class=\"hljs-keyword\">const</span> arrC = [<span class=\"hljs-number\">0</span>, ...arrA, <span class=\"hljs-number\">2.5</span>, ...arrB, <span class=\"hljs-number\">5</span>]; <span class=\"hljs-comment\">// [0, 1, 2, 2.5, 3, 4, 5]</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-函数参数传递\"><a href=\"#3-函数参数传递\" class=\"headerlink\" title=\"3. 函数参数传递\"></a>3. 函数参数传递</h3><p>解决了<code>apply()</code>传递数组参数的繁琐问题，直接将数组元素作为独立参数传入函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> numbers = [<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">30</span>];<br><br><span class=\"hljs-comment\">// ES6写法</span><br><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">max</span>(...numbers); <span class=\"hljs-comment\">// 30</span><br><br><span class=\"hljs-comment\">// ES5写法</span><br><br><span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">max</span>.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-literal\">null</span>, numbers); <span class=\"hljs-comment\">// 30</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"4-解构赋值结合\"><a href=\"#4-解构赋值结合\" class=\"headerlink\" title=\"4. 解构赋值结合\"></a>4. 解构赋值结合</h3><p>扩展运算符可与解构赋值配合，便捷提取数组部分元素：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> [first, second, ...rest] = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>];<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(first); <span class=\"hljs-comment\">// 1</span><br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(second); <span class=\"hljs-comment\">// 2</span><br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(rest); <span class=\"hljs-comment\">// [3, 4, 5]（剩余元素组成新数组）</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"二、数组构造函数的增强：Array-from-与-Array-of\"><a href=\"#二、数组构造函数的增强：Array-from-与-Array-of\" class=\"headerlink\" title=\"二、数组构造函数的增强：Array.from () 与 Array.of ()\"></a>二、数组构造函数的增强：Array.from () 与 Array.of ()</h2><p>ES6 为<code>Array</code>构造函数新增了两个静态方法，分别解决了 “类数组对象转数组” 和 “创建固定长度数组” 的经典问题。</p>\n<h4 id=\"1-Array-from-：类数组对象与可迭代对象转数组\"><a href=\"#1-Array-from-：类数组对象与可迭代对象转数组\" class=\"headerlink\" title=\"1. Array.from ()：类数组对象与可迭代对象转数组\"></a>1. Array.from ()：类数组对象与可迭代对象转数组</h4><p>类数组对象（如 DOM 集合、<code>arguments</code>）和可迭代对象（如 Set、Map），在 ES6 前需通过<code>Array.prototype.slice.call()</code>转换为数组，<code>Array.from()</code>提供了统一、直观的解决方案，还支持映射函数参数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 转换类数组对象（DOM集合）</span><br><br><span class=\"hljs-keyword\">const</span> lis = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelectorAll</span>(<span class=\"hljs-string\">&#x27;li&#x27;</span>);<br><br><span class=\"hljs-keyword\">const</span> liArray = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(lis); <span class=\"hljs-comment\">// 转为数组，可使用数组方法</span><br><br><span class=\"hljs-comment\">// 转换arguments对象</span><br><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-params\"></span>) &#123;<br>\t <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(<span class=\"hljs-variable language_\">arguments</span>).<span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">a, b</span>) =&gt;</span> a + b, <span class=\"hljs-number\">0</span>);<br>&#125;<br><br><span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// 6</span><br><br><span class=\"hljs-comment\">// 带映射函数（类似map()）</span><br><br><span class=\"hljs-keyword\">const</span> str = <span class=\"hljs-string\">&#x27;hello&#x27;</span>;<br><br><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(str, <span class=\"hljs-function\"><span class=\"hljs-params\">char</span> =&gt;</span> char.<span class=\"hljs-title function_\">toUpperCase</span>()); <span class=\"hljs-comment\">// [&#x27;H&#x27;, &#x27;E&#x27;, &#x27;L&#x27;, &#x27;L&#x27;, &#x27;O&#x27;]</span><br><br><span class=\"hljs-comment\">// 转换Set对象</span><br><br><span class=\"hljs-keyword\">const</span> set = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]);<br><br><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(set); <span class=\"hljs-comment\">// [1, 2, 3]（自动去重）</span><br></code></pre></td></tr></table></figure>\n\n<h4 id=\"2-Array-of-：统一数组创建行为\"><a href=\"#2-Array-of-：统一数组创建行为\" class=\"headerlink\" title=\"2. Array.of ()：统一数组创建行为\"></a>2. Array.of ()：统一数组创建行为</h4><p>传统<code>Array</code>构造函数存在行为不一致问题：当传入单个数字时，创建的是指定长度的空数组，而非包含该数字的数组。<code>Array.of()</code>修复了这一缺陷，无论传入多少参数，均创建包含这些参数的数组：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// ES6 Array.of()</span><br><br><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">of</span>(<span class=\"hljs-number\">5</span>); <span class=\"hljs-comment\">// [5]</span><br><br><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">of</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// [1, 2, 3]</span><br><br><span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">of</span>(); <span class=\"hljs-comment\">// []（无参数返回空数组）</span><br><br><span class=\"hljs-comment\">// ES5 Array构造函数（对比）</span><br><br><span class=\"hljs-title class_\">Array</span>(<span class=\"hljs-number\">5</span>); <span class=\"hljs-comment\">// [empty × 5]（长度为5的空数组）</span><br><br><span class=\"hljs-title class_\">Array</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// [1, 2, 3]（多参数正常）</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"三、数组实例方法的升级：查找、遍历与修改\"><a href=\"#三、数组实例方法的升级：查找、遍历与修改\" class=\"headerlink\" title=\"三、数组实例方法的升级：查找、遍历与修改\"></a>三、数组实例方法的升级：查找、遍历与修改</h2><p>ES6 新增了多个数组实例方法，覆盖了查找、遍历、填充、扁平化等高频场景，让数据处理逻辑更简洁。</p>\n<h3 id=\"1-查找类方法：find-与-findIndex\"><a href=\"#1-查找类方法：find-与-findIndex\" class=\"headerlink\" title=\"1. 查找类方法：find () 与 findIndex ()\"></a>1. 查找类方法：find () 与 findIndex ()</h3><p>传统查找数组元素依赖<code>indexOf()</code>，但它仅支持查找原始值，且无法处理 “满足特定条件的元素”。<code>find()</code>和<code>findIndex()</code>弥补了这一不足，支持传入回调函数，返回第一个满足条件的元素或其索引：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> users = [<br>  &#123; <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;张三&#x27;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">20</span> &#125;,<br>  &#123; <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;李四&#x27;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">25</span> &#125;,<br>  &#123; <span class=\"hljs-attr\">id</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&#x27;王五&#x27;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">30</span> &#125;<br>];<br><br><span class=\"hljs-comment\">// find()：返回第一个满足条件的元素</span><br><br><span class=\"hljs-keyword\">const</span> targetUser = users.<span class=\"hljs-title function_\">find</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">user</span> =&gt;</span> user.<span class=\"hljs-property\">age</span> &gt; <span class=\"hljs-number\">22</span>);<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(targetUser); <span class=\"hljs-comment\">// &#123; id: 2, name: &#x27;李四&#x27;, age: 25 &#125;</span><br><br><span class=\"hljs-comment\">// findIndex()：返回第一个满足条件的元素索引</span><br><br><span class=\"hljs-keyword\">const</span> targetIndex = users.<span class=\"hljs-title function_\">findIndex</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">user</span> =&gt;</span> user.<span class=\"hljs-property\">name</span> === <span class=\"hljs-string\">&#x27;王五&#x27;</span>);<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(targetIndex); <span class=\"hljs-comment\">// 2</span><br><br><span class=\"hljs-comment\">// 支持查找NaN（indexOf()无法做到）</span><br><br><span class=\"hljs-keyword\">const</span> numbers = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-title class_\">NaN</span>, <span class=\"hljs-number\">3</span>];<br><br>numbers.<span class=\"hljs-title function_\">find</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">n</span> =&gt;</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">is</span>(n, <span class=\"hljs-title class_\">NaN</span>)); <span class=\"hljs-comment\">// NaN</span><br><br>numbers.<span class=\"hljs-title function_\">findIndex</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">n</span> =&gt;</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">is</span>(n, <span class=\"hljs-title class_\">NaN</span>)); <span class=\"hljs-comment\">// 1</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-包含判断：includes\"><a href=\"#2-包含判断：includes\" class=\"headerlink\" title=\"2. 包含判断：includes ()\"></a>2. 包含判断：includes ()</h3><p><code>indexOf()</code>判断元素是否存在时，需通过返回值是否为<code>-1</code>判断，语义不够清晰。<code>includes()</code>直接返回布尔值，且支持判断<code>NaN</code>，使用更直观：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> fruits = [<span class=\"hljs-string\">&#x27;苹果&#x27;</span>, <span class=\"hljs-string\">&#x27;香蕉&#x27;</span>, <span class=\"hljs-string\">&#x27;橙子&#x27;</span>];<br><br>fruits.<span class=\"hljs-title function_\">includes</span>(<span class=\"hljs-string\">&#x27;香蕉&#x27;</span>); <span class=\"hljs-comment\">// true</span><br><br>fruits.<span class=\"hljs-title function_\">includes</span>(<span class=\"hljs-string\">&#x27;葡萄&#x27;</span>); <span class=\"hljs-comment\">// false</span><br><br><span class=\"hljs-comment\">// 支持NaN判断</span><br><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-title class_\">NaN</span>].<span class=\"hljs-title function_\">includes</span>(<span class=\"hljs-title class_\">NaN</span>); <span class=\"hljs-comment\">// true</span><br><br>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-title class_\">NaN</span>].<span class=\"hljs-title function_\">indexOf</span>(<span class=\"hljs-title class_\">NaN</span>); <span class=\"hljs-comment\">// -1（对比）</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-迭代器方法：entries-、keys-、values\"><a href=\"#3-迭代器方法：entries-、keys-、values\" class=\"headerlink\" title=\"3. 迭代器方法：entries ()、keys ()、values ()\"></a>3. 迭代器方法：entries ()、keys ()、values ()</h3><p>ES6 为数组新增了三个迭代器方法，支持通过<code>for...of</code>循环遍历数组的键、值或键值对，替代了传统的<code>for</code>循环或<code>forEach()</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>];<br><br><span class=\"hljs-comment\">// keys()：遍历索引</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> key <span class=\"hljs-keyword\">of</span> arr.<span class=\"hljs-title function_\">keys</span>()) &#123;<br><br>&amp;#x20; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(key); <span class=\"hljs-comment\">// 0, 1, 2</span><br><br>&#125;<br><br><span class=\"hljs-comment\">// values()：遍历值（ES2017正式标准化）</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> value <span class=\"hljs-keyword\">of</span> arr.<span class=\"hljs-title function_\">values</span>()) &#123;<br><br> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(value); <span class=\"hljs-comment\">// &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;</span><br><br>&#125;<br><br><span class=\"hljs-comment\">// entries()：遍历键值对（返回数组\\[key, value]）</span><br><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> [key, value] <span class=\"hljs-keyword\">of</span> arr.<span class=\"hljs-title function_\">entries</span>()) &#123;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;key&#125;</span>: <span class=\"hljs-subst\">$&#123;value&#125;</span>`</span>); <span class=\"hljs-comment\">// 0: a, 1: b, 2: c</span><br><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"4-填充与复制：fill-与-copyWithin\"><a href=\"#4-填充与复制：fill-与-copyWithin\" class=\"headerlink\" title=\"4. 填充与复制：fill () 与 copyWithin ()\"></a>4. 填充与复制：fill () 与 copyWithin ()</h4><p><code>fill()</code>用于将数组指定范围的元素替换为固定值，<code>copyWithin()</code>则将数组内部的元素复制到另一位置，均支持修改原数组（也可通过浅拷贝避免）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><br><span class=\"hljs-comment\">// fill(value, start?, end?)：填充数组</span><br><br><span class=\"hljs-keyword\">const</span> arr1 = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>];<br><br>arr1.<span class=\"hljs-title function_\">fill</span>(<span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// [0, 0, 0, 0, 0]（填充整个数组）</span><br><br>arr1.<span class=\"hljs-title function_\">fill</span>(<span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// [0, 9, 9, 0, 0]（从索引1到3前填充9）</span><br><br><span class=\"hljs-comment\">// copyWithin(target, start?, end?)：复制内部元素</span><br><br><span class=\"hljs-keyword\">const</span> arr2 = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>];<br><br>arr2.<span class=\"hljs-title function_\">copyWithin</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// [4, 5, 3, 4, 5]（将索引3及以后的元素复制到索引0开始的位置）</span><br><br>arr2.<span class=\"hljs-title function_\">copyWithin</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// [4, 4, 5, 4, 5]（将索引0-2前的元素复制到索引1开始的位置）</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"5-扁平化处理：flat-与-flatMap\"><a href=\"#5-扁平化处理：flat-与-flatMap\" class=\"headerlink\" title=\"5. 扁平化处理：flat  与 flatMap\"></a>5. 扁平化处理：flat  与 flatMap</h3><p>多维数组扁平化是常见需求，ES6 前需递归实现，<code>flat()</code>和<code>flatMap()</code>提供了原生支持：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// flat(depth?)：扁平化数组，depth默认1（可传Infinity扁平化所有层级）</span><br><br><span class=\"hljs-keyword\">const</span> nestedArr = [<span class=\"hljs-number\">1</span>, [<span class=\"hljs-number\">2</span>, [<span class=\"hljs-number\">3</span>, [<span class=\"hljs-number\">4</span>]]]];<br><br>nestedArr.<span class=\"hljs-title function_\">flat</span>(); <span class=\"hljs-comment\">// [1, 2, [3, [4]]]（扁平化1层）</span><br><br>nestedArr.<span class=\"hljs-title function_\">flat</span>(<span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// [1, 2, 3, [4]]（扁平化2层）</span><br><br>nestedArr.<span class=\"hljs-title function_\">flat</span>(<span class=\"hljs-title class_\">Infinity</span>); <span class=\"hljs-comment\">// [1, 2, 3, 4]（扁平化所有层级）</span><br><br><span class=\"hljs-comment\">// flatMap()：先执行map()，再执行flat(1)（效率更高）</span><br><br><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>];<br><br><span class=\"hljs-comment\">// 等价于 arr.map(x =&gt; [x * 2]).flat()</span><br><br>arr.<span class=\"hljs-title function_\">flatMap</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> [x * <span class=\"hljs-number\">2</span>]); <span class=\"hljs-comment\">// \\[2, 4, 6]</span><br><br><span class=\"hljs-comment\">// 处理嵌套数组场景</span><br><br><span class=\"hljs-keyword\">const</span> lists = [<br> [<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>],<br> [<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-string\">&#x27;d&#x27;</span>],<br> [<span class=\"hljs-string\">&#x27;e&#x27;</span>]<br>];<br><br>lists.<span class=\"hljs-title function_\">flatMap</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">list</span> =&gt;</span> list.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">item</span> =&gt;</span> item.<span class=\"hljs-title function_\">toUpperCase</span>())); <span class=\"hljs-comment\">// \\[&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;]</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"四、空位处理的规范化\"><a href=\"#四、空位处理的规范化\" class=\"headerlink\" title=\"四、空位处理的规范化\"></a>四、空位处理的规范化</h2><p>ES5 中数组空位（如<code>[1, , 3]</code>）的行为不一致（<code>forEach()</code>、<code>map()</code>跳过空位，<code>join()</code>视为空字符串）。ES6 明确规定：数组空位应被视为<code>undefined</code>，新增方法（如<code>find()</code>、<code>includes()</code>）均按<code>undefined</code>处理，避免了歧义：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-number\">1</span>, , <span class=\"hljs-number\">3</span>];<br><br><span class=\"hljs-comment\">// ES6方法：将空位视为undefined</span><br><br>arr.<span class=\"hljs-title function_\">includes</span>(<span class=\"hljs-literal\">undefined</span>); <span class=\"hljs-comment\">// true</span><br><br>arr.<span class=\"hljs-title function_\">find</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x === <span class=\"hljs-literal\">undefined</span>); <span class=\"hljs-comment\">// undefined（找到空位）</span><br><br>arr.<span class=\"hljs-title function_\">flat</span>(); <span class=\"hljs-comment\">// [1, undefined, 3]（扁平化不忽略空位）</span><br><br><span class=\"hljs-comment\">// ES5方法（对比）</span><br><br>arr.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> x || <span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// [1, 0, 3]（map()跳过空位，返回原位置）</span><br><br>arr.<span class=\"hljs-title function_\">join</span>(<span class=\"hljs-string\">&#x27;-&#x27;</span>); <span class=\"hljs-comment\">// &quot;1--3&quot;（join()将空位视为空字符串）</span><br></code></pre></td></tr></table></figure>\n\n<p>ES6中数组的拓展用简洁语法和实用方法，解决了传统操作的痛点，减少代码量、提升可读性。掌握这些特性，能帮助我们更高效地处理项目中的数据。</p>\n<p>最关键的是，面试频率很高啊，哈哈!</p>\n"},{"title":"Vue中双向绑定是什么？它工作原理是什么？万字长文，一次讲透彻！","date":"2025-12-06T04:36:46.000Z","_content":"\n大家好，我是jvxiao。\n\n这是[Vue从入门到精通](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU2MjU3MzI0MA==&action=getalbum&album_id=4276738695946223617#wechat_redirect)系列文章的第2篇，今天我们来讲一讲Vue中一个非常核心的概念--`双向绑定`\n\n本文将从概念本质、底层原理出发，结合完整实现逻辑，带大家全面拆解Vue双向绑定的核心机制。\n\n## 一、核心概念：从单向绑定到双向联动\n要理解双向绑定，首先要明确其与单向绑定的关联与区别——双向绑定是单向绑定的延伸与闭环，而MVVM架构则为这种闭环提供了理论支撑。\n\n###  单向绑定的基础逻辑\n单向绑定指**数据模型（Model）到视图（View）的单向同步**：当开发者通过代码修改Model中的数据时，框架会自动更新对应的View展示，无需手动操作DOM。这种模式的核心价值是“数据驱动视图”，让开发者专注于数据逻辑而非DOM操作，但它存在一个明显局限：用户对View的交互（如表单输入、按钮点击）无法自动同步回Model，需要手动编写事件处理函数来完成数据更新。\n\n### 2. 双向绑定的本质闭环\n双向绑定在单向绑定的基础上，补充了“View到Model的反向同步”：\n- 数据→视图：Model数据变化时，View自动更新；\n- 视图→数据：用户操作View（如输入框输入、下拉框选择）时，Model数据自动同步。\n\n最典型的应用场景是表单交互：当用户在输入框中输入内容时，对应的Model数据会实时更新；当代码修改Model数据时，输入框的显示内容也会同步变化。这种“无需手动干预”的双向同步，正是双向绑定的核心魅力。\n\n### 3. MVVM架构：双向绑定的结构支撑\nVue的双向绑定并非孤立功能，而是基于MVVM（Model-View-ViewModel）架构设计的，三层结构各司其职、协同工作：\n- **Model（数据层）**：存储应用的核心数据与业务逻辑，是应用的“数据源”，例如Vue组件中的`data`选项；\n- **View（视图层）**：应用的可视化展示部分，由HTML、CSS构成，是用户直接交互的界面；\n- **ViewModel（业务逻辑层）**：Vue框架的核心封装，充当Model与View之间的“桥梁”。它既监听Model的变化以更新View，又监听View的交互以更新Model，实现了两层之间的解耦与联动。\n\nViewModel的存在让Model与View完全分离，开发者无需关心“数据如何同步到视图”“视图交互如何更新数据”，只需专注于数据逻辑与界面设计，这也是Vue开发效率高的关键原因之一。\n\n## 二、底层原理：四大核心模块的协同运作\n双向绑定的实现依赖ViewModel的核心能力，而ViewModel的功能又由四个关键模块共同支撑：**监听器（Observer）**、**解析器（Compiler）**、**依赖管理器（Dep）**、**订阅者（Watcher）**。这四个模块形成闭环，完成“数据劫持-模板解析-依赖收集-更新通知”的全流程。\n\n### 1. 监听器（Observer）：数据的“哨兵”\nObserver的核心职责是**对Model中的数据进行响应式劫持**，实时监听数据的变化。其实现逻辑如下：\n- 遍历`data`中的所有属性（包括嵌套对象），通过`Object.defineProperty`（Vue2）或`Proxy`（Vue3）重写属性的`getter`和`setter`方法；\n- 当数据被读取时（如视图渲染时访问数据），触发`getter`方法，用于后续的依赖收集；\n- 当数据被修改时（如用户输入更新数据），触发`setter`方法，向依赖管理器发送更新通知。\n\nVue2中使用`Object.defineProperty`存在一定局限（无法监听数组索引变化、对象新增属性），而Vue3改用`Proxy`，不仅解决了这些问题，还能直接监听整个对象，实现更全面、高效的响应式劫持。\n\n### 2. 解析器（Compiler）：视图的“翻译官”\nCompiler的核心职责是**解析View中的模板指令，建立View与Model的关联**，其工作流程如下：\n- 遍历DOM树，扫描所有元素节点和文本节点，识别出包含Vue指令（如`v-model`、`{{}}`插值表达式）的节点；\n- 对插值文本（如`{{message}}`），从Model中获取对应数据，替换文本内容并初始化视图；\n- 对指令节点（如`<input v-model=\"message\">`），解析指令绑定的数据属性，同时绑定视图交互事件（如`input`事件）；\n- 为每个绑定的数据属性创建对应的订阅者（Watcher），指定数据变化时的视图更新函数。\n\nCompiler的存在让模板中的动态绑定与Model数据建立了精准关联，为双向绑定提供了“视图层面的入口”。\n\n### 3. 依赖管理器（Dep）：数据与订阅者的“中介”\nDep的核心职责是**管理某个数据属性对应的所有订阅者（Watcher）**，充当“数据-订阅者”的桥梁。其核心逻辑如下：\n- 每个数据属性在被响应式劫持时，会创建一个专属的Dep实例；\n- 当数据被读取（触发`getter`）时，Dep会将当前的Watcher实例添加到自身的依赖列表中（依赖收集）；\n- 当数据被修改（触发`setter`）时，Dep会遍历依赖列表，通知所有Watcher执行更新操作（更新通知）。\n\n由于同一个数据属性可能在视图中多次使用（如`message`在多个插值文本中出现），一个Dep实例可能管理多个Watcher，确保数据变化时所有关联视图都能同步更新。\n\n### 4. 订阅者（Watcher）：数据与视图的“连接器”\nWatcher是连接Model与View的核心载体，其核心职责是**接收Dep的更新通知，执行视图更新函数**。其工作流程如下：\n- 当Compiler解析模板时，会为每个动态绑定的数据属性创建一个Watcher实例，同时指定对应的视图更新函数（如替换插值文本、修改元素value值）；\n- Watcher创建时，会主动读取对应的Model数据，触发数据的`getter`方法，从而让自身被添加到该数据的Dep依赖列表中；\n- 当数据变化时，Dep会调用Watcher的`update`方法，执行预设的更新函数，完成视图的同步更新。\n\n### 5. 双向联动的完整闭环\n结合四大模块，Vue双向绑定的完整流程可拆解为两步：\n\n#### （1）数据→视图：Model驱动View更新\n1. 开发者通过代码修改Model中的数据（如`this.message = \"新内容\"`）；\n2. 数据的`setter`方法被触发，调用对应Dep实例的`notify`方法；\n3. Dep遍历依赖列表，通知所有关联的Watcher执行`update`方法；\n4. Watcher调用预设的更新函数，修改DOM元素内容或属性，View同步更新。\n\n#### （2）视图→数据：View驱动Model更新\n1. 用户操作View（如在输入框中输入内容），触发原生事件（如`input`事件）；\n2. Compiler解析`v-model`指令时已绑定该事件，事件回调函数会修改对应的Model数据；\n3. 数据的`setter`方法被触发，重复“数据→视图”的流程，确保所有关联视图同步更新。\n\n## 三、完整实现：基于Vue2思路的双向绑定落地\n结合上述原理，我们基于Vue2的`Object.defineProperty`实现一个完整的双向绑定案例，覆盖“响应式劫持-模板编译-依赖收集-双向同步”全流程。\n\n### 1. 核心类与工具函数定义\n#### （1）Vue构造函数：初始化入口\n负责整合响应式处理、数据代理、模板编译三大核心逻辑：\n```javascript\nclass Vue {\n  constructor(options) {\n    this.$options = options; // 存储配置项（el、data等）\n    this.$data = typeof options.data === 'function' ? options.data() : options.data; // 处理data（支持函数或对象）\n    \n    // 1. 对data执行响应式处理\n    observe(this.$data);\n    // 2. 代理data属性到Vue实例（支持this.message而非this.$data.message）\n    proxy(this, this.$data);\n    // 3. 编译模板\n    new Compile(options.el, this);\n  }\n}\n\n// 数据代理：将$data的属性代理到Vue实例\nfunction proxy(vm, data) {\n  Object.keys(data).forEach(key => {\n    Object.defineProperty(vm, key, {\n      get() {\n        return data[key];\n      },\n      set(newVal) {\n        data[key] = newVal;\n      }\n    });\n  });\n}\n```\n\n#### （2）Observer：响应式劫持实现\n遍历数据属性，重写`getter`和`setter`：\n```javascript\n// 入口函数：判断数据类型，非对象直接返回\nfunction observe(obj) {\n  if (typeof obj !== 'object' || obj === null) {\n    return;\n  }\n  new Observer(obj);\n}\n\nclass Observer {\n  constructor(value) {\n    this.value = value;\n    // 遍历对象属性（仅处理对象，数组需额外处理，此处简化）\n    this.walk(value);\n  }\n  \n  walk(obj) {\n    Object.keys(obj).forEach(key => {\n      defineReactive(obj, key, obj[key]);\n    });\n  }\n}\n\n// 核心：重写属性的getter和setter，关联Dep\nfunction defineReactive(obj, key, val) {\n  // 递归处理嵌套对象\n  observe(val);\n  // 为当前属性创建Dep实例\n  const dep = new Dep();\n  \n  Object.defineProperty(obj, key, {\n    get() {\n      // 依赖收集：Dep.target为当前Watcher实例\n      if (Dep.target) {\n        dep.addDep(Dep.target);\n      }\n      return val;\n    },\n    set(newVal) {\n      // 数据未变化则不触发更新\n      if (newVal === val) return;\n      val = newVal;\n      // 新值可能是对象，需递归响应式处理\n      observe(newVal);\n      // 通知所有Watcher更新\n      dep.notify();\n    }\n  });\n}\n```\n\n#### （3）Dep：依赖管理器\n管理Watcher实例，负责依赖收集与更新通知：\n```javascript\nclass Dep {\n  constructor() {\n    this.deps = []; // 存储当前数据的所有Watcher\n  }\n  \n  // 添加Watcher到依赖列表\n  addDep(watcher) {\n    this.deps.push(watcher);\n  }\n  \n  // 通知所有Watcher执行更新\n  notify() {\n    this.deps.forEach(watcher => watcher.update());\n  }\n}\n\n// 静态属性：存储当前活跃的Watcher（全局唯一，避免多Watcher冲突）\nDep.target = null;\n```\n\n#### （4）Watcher：订阅者实现\n连接Dep与视图更新函数：\n```javascript\nclass Watcher {\n  constructor(vm, key, updaterFn) {\n    this.vm = vm; // Vue实例\n    this.key = key; // 绑定的数据属性名\n    this.updaterFn = updaterFn; // 视图更新函数\n    \n    // 依赖收集关键步骤：将当前Watcher设为活跃状态\n    Dep.target = this;\n    // 读取数据，触发getter，完成依赖收集\n    this.vm[this.key];\n    // 重置活跃Watcher，避免重复收集\n    Dep.target = null;\n  }\n  \n  // 接收Dep通知，执行更新函数\n  update() {\n    const newValue = this.vm[this.key];\n    this.updaterFn(newValue);\n  }\n}\n```\n\n#### （5）Compile：模板解析实现\n解析DOM中的指令和插值，建立数据与视图的关联：\n```javascript\nclass Compile {\n  constructor(el, vm) {\n    this.$vm = vm; // Vue实例\n    this.$el = document.querySelector(el); // 挂载点DOM元素\n    \n    if (this.$el) {\n      this.compile(this.$el); // 开始编译\n    }\n  }\n  \n  // 递归遍历DOM树，解析所有节点\n  compile(el) {\n    const childNodes = el.childNodes;\n    Array.from(childNodes).forEach(node => {\n      // 1. 解析元素节点（处理v-model等指令）\n      if (this.isElementNode(node)) {\n        this.compileElement(node);\n      }\n      // 2. 解析文本节点（处理{{}}插值）\n      else if (this.isTextNode(node) && this.isInterpolation(node)) {\n        this.compileText(node);\n      }\n      \n      // 递归处理子节点（支持嵌套模板）\n      if (node.childNodes && node.childNodes.length > 0) {\n        this.compile(node);\n      }\n    });\n  }\n  \n  // 判断是否为元素节点（nodeType=1）\n  isElementNode(node) {\n    return node.nodeType === 1;\n  }\n  \n  // 判断是否为文本节点（nodeType=3）\n  isTextNode(node) {\n    return node.nodeType === 3;\n  }\n  \n  // 判断是否为插值文本（匹配{{xxx}}）\n  isInterpolation(node) {\n    return /\\{\\{(.*)\\}\\}/.test(node.textContent);\n  }\n  \n  // 解析元素节点：处理v-model指令\n  compileElement(node) {\n    const attributes = node.attributes;\n    Array.from(attributes).forEach(attr => {\n      // 提取指令名（如v-model）和绑定的属性名（如message）\n      const attrName = attr.name;\n      if (this.isDirective(attrName)) {\n        const directiveName = attrName.slice(2); // 去掉\"v-\"\n        const key = attr.value; // 绑定的数据属性名\n        \n        // 处理v-model指令（双向绑定核心）\n        if (directiveName === 'model') {\n          this.modelUpdater(node, key);\n        }\n      }\n    });\n  }\n  \n  // 判断是否为Vue指令（以v-开头）\n  isDirective(attrName) {\n    return attrName.startsWith('v-');\n  }\n  \n  // 解析插值文本：替换{{xxx}}为实际数据\n  compileText(node) {\n    // 提取{{}}中的属性名（如message）\n    const key = RegExp.$1.trim();\n    // 初始化视图：将文本替换为data中的数据\n    this.textUpdater(node, this.$vm[key]);\n    // 创建Watcher：数据变化时更新文本\n    new Watcher(this.$vm, key, (newValue) => {\n      this.textUpdater(node, newValue);\n    });\n  }\n  \n  // 文本更新函数：修改文本节点内容\n  textUpdater(node, value) {\n    node.textContent = value || '';\n  }\n  \n  // v-model指令处理：实现双向绑定\n  modelUpdater(node, key) {\n    // 初始化视图：将输入框value设为data中的数据\n    node.value = this.$vm[key] || '';\n    // 数据→视图：创建Watcher，数据变化时更新输入框value\n    new Watcher(this.$vm, key, (newValue) => {\n      node.value = newValue || '';\n    });\n    // 视图→数据：监听输入事件，更新data中的数据\n    node.addEventListener('input', (e) => {\n      this.$vm[key] = e.target.value;\n    });\n  }\n}\n```\n\n### 2. 测试使用示例\n```html\n<!-- HTML结构 -->\n<div id=\"app\">\n  <p>{{message}}</p>\n  <input type=\"text\" v-model=\"message\">\n</div>\n\n<!-- JavaScript -->\n<script>\nnew Vue({\n  el: '#app',\n  data() {\n    return {\n      message: 'Hello Vue双向绑定!'\n    };\n  }\n});\n</script>\n```\n\n运行效果：\n- 输入框输入内容时，`p`标签中的文本会实时同步（视图→数据→视图）；\n- 代码中修改`vm.message`时，输入框和`p`标签会同时更新（数据→视图）。\n\n## 四、总结\nVue双向绑定的本质，是**MVVM架构下“响应式劫持+发布-订阅模式”的协同作用**：\n- 响应式劫持（Observer）让数据具备“感知变化”的能力；\n- 模板编译（Compiler）让视图具备“关联数据”的能力；\n- 依赖管理（Dep）与订阅者（Watcher）让数据与视图的联动具备“精准高效”的特性。\n\n作为Vue框架中的核心内容，双向绑定机制不仅是面试中经常考察的内容，同时掌握其本质与工作原理对解读Vue源码也能够打下一个坚实的基础。\n\n**【往期精彩】**\n\n- [Vue进阶系列第1篇：说说对Vue的理解，Vue是什么，有什么作用?](https://mp.weixin.qq.com/s/I-hOIMdmxws1sukiAicg4w)\n- [JavaScript ES6中的生成器(Decorator)是什么？有哪些应用场景？](https://mp.weixin.qq.com/s/c7IwODBilcxSyozJvjjHRw)\n\n- [说说JavaScript中ES6 module(模块化)的诞生背景、核心语法及应用场景](https://mp.weixin.qq.com/s/pe4fywIh7WdigHuwRiqDlQ)\n- [一文说透ES6 Proxy: 从本质到应用场景](https://mp.weixin.qq.com/s/lYqBgS0GJgQMX5PAW_snnQ)\n- [JavaScript ES6中的生成器(Generator)是什么？有哪些应用场景？一文全说透](https://mp.weixin.qq.com/s/PtFtlNUH-UcLYU5h-xKiQw)\n\n- [一文搞懂 JavaScript 里 var、let、const 的区别\n](https://mp.weixin.qq.com/s/lqn_51NNxx50YgvWkxCtEg)\n","source":"_posts/bidirection-data-binding.md","raw":"---\ntitle: Vue中双向绑定是什么？它工作原理是什么？万字长文，一次讲透彻！\ndate: 2025-12-06 12:36:46\ntags: JavaScript进阶, ES6进阶\ncategory: ES6进阶\n---\n\n大家好，我是jvxiao。\n\n这是[Vue从入门到精通](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU2MjU3MzI0MA==&action=getalbum&album_id=4276738695946223617#wechat_redirect)系列文章的第2篇，今天我们来讲一讲Vue中一个非常核心的概念--`双向绑定`\n\n本文将从概念本质、底层原理出发，结合完整实现逻辑，带大家全面拆解Vue双向绑定的核心机制。\n\n## 一、核心概念：从单向绑定到双向联动\n要理解双向绑定，首先要明确其与单向绑定的关联与区别——双向绑定是单向绑定的延伸与闭环，而MVVM架构则为这种闭环提供了理论支撑。\n\n###  单向绑定的基础逻辑\n单向绑定指**数据模型（Model）到视图（View）的单向同步**：当开发者通过代码修改Model中的数据时，框架会自动更新对应的View展示，无需手动操作DOM。这种模式的核心价值是“数据驱动视图”，让开发者专注于数据逻辑而非DOM操作，但它存在一个明显局限：用户对View的交互（如表单输入、按钮点击）无法自动同步回Model，需要手动编写事件处理函数来完成数据更新。\n\n### 2. 双向绑定的本质闭环\n双向绑定在单向绑定的基础上，补充了“View到Model的反向同步”：\n- 数据→视图：Model数据变化时，View自动更新；\n- 视图→数据：用户操作View（如输入框输入、下拉框选择）时，Model数据自动同步。\n\n最典型的应用场景是表单交互：当用户在输入框中输入内容时，对应的Model数据会实时更新；当代码修改Model数据时，输入框的显示内容也会同步变化。这种“无需手动干预”的双向同步，正是双向绑定的核心魅力。\n\n### 3. MVVM架构：双向绑定的结构支撑\nVue的双向绑定并非孤立功能，而是基于MVVM（Model-View-ViewModel）架构设计的，三层结构各司其职、协同工作：\n- **Model（数据层）**：存储应用的核心数据与业务逻辑，是应用的“数据源”，例如Vue组件中的`data`选项；\n- **View（视图层）**：应用的可视化展示部分，由HTML、CSS构成，是用户直接交互的界面；\n- **ViewModel（业务逻辑层）**：Vue框架的核心封装，充当Model与View之间的“桥梁”。它既监听Model的变化以更新View，又监听View的交互以更新Model，实现了两层之间的解耦与联动。\n\nViewModel的存在让Model与View完全分离，开发者无需关心“数据如何同步到视图”“视图交互如何更新数据”，只需专注于数据逻辑与界面设计，这也是Vue开发效率高的关键原因之一。\n\n## 二、底层原理：四大核心模块的协同运作\n双向绑定的实现依赖ViewModel的核心能力，而ViewModel的功能又由四个关键模块共同支撑：**监听器（Observer）**、**解析器（Compiler）**、**依赖管理器（Dep）**、**订阅者（Watcher）**。这四个模块形成闭环，完成“数据劫持-模板解析-依赖收集-更新通知”的全流程。\n\n### 1. 监听器（Observer）：数据的“哨兵”\nObserver的核心职责是**对Model中的数据进行响应式劫持**，实时监听数据的变化。其实现逻辑如下：\n- 遍历`data`中的所有属性（包括嵌套对象），通过`Object.defineProperty`（Vue2）或`Proxy`（Vue3）重写属性的`getter`和`setter`方法；\n- 当数据被读取时（如视图渲染时访问数据），触发`getter`方法，用于后续的依赖收集；\n- 当数据被修改时（如用户输入更新数据），触发`setter`方法，向依赖管理器发送更新通知。\n\nVue2中使用`Object.defineProperty`存在一定局限（无法监听数组索引变化、对象新增属性），而Vue3改用`Proxy`，不仅解决了这些问题，还能直接监听整个对象，实现更全面、高效的响应式劫持。\n\n### 2. 解析器（Compiler）：视图的“翻译官”\nCompiler的核心职责是**解析View中的模板指令，建立View与Model的关联**，其工作流程如下：\n- 遍历DOM树，扫描所有元素节点和文本节点，识别出包含Vue指令（如`v-model`、`{{}}`插值表达式）的节点；\n- 对插值文本（如`{{message}}`），从Model中获取对应数据，替换文本内容并初始化视图；\n- 对指令节点（如`<input v-model=\"message\">`），解析指令绑定的数据属性，同时绑定视图交互事件（如`input`事件）；\n- 为每个绑定的数据属性创建对应的订阅者（Watcher），指定数据变化时的视图更新函数。\n\nCompiler的存在让模板中的动态绑定与Model数据建立了精准关联，为双向绑定提供了“视图层面的入口”。\n\n### 3. 依赖管理器（Dep）：数据与订阅者的“中介”\nDep的核心职责是**管理某个数据属性对应的所有订阅者（Watcher）**，充当“数据-订阅者”的桥梁。其核心逻辑如下：\n- 每个数据属性在被响应式劫持时，会创建一个专属的Dep实例；\n- 当数据被读取（触发`getter`）时，Dep会将当前的Watcher实例添加到自身的依赖列表中（依赖收集）；\n- 当数据被修改（触发`setter`）时，Dep会遍历依赖列表，通知所有Watcher执行更新操作（更新通知）。\n\n由于同一个数据属性可能在视图中多次使用（如`message`在多个插值文本中出现），一个Dep实例可能管理多个Watcher，确保数据变化时所有关联视图都能同步更新。\n\n### 4. 订阅者（Watcher）：数据与视图的“连接器”\nWatcher是连接Model与View的核心载体，其核心职责是**接收Dep的更新通知，执行视图更新函数**。其工作流程如下：\n- 当Compiler解析模板时，会为每个动态绑定的数据属性创建一个Watcher实例，同时指定对应的视图更新函数（如替换插值文本、修改元素value值）；\n- Watcher创建时，会主动读取对应的Model数据，触发数据的`getter`方法，从而让自身被添加到该数据的Dep依赖列表中；\n- 当数据变化时，Dep会调用Watcher的`update`方法，执行预设的更新函数，完成视图的同步更新。\n\n### 5. 双向联动的完整闭环\n结合四大模块，Vue双向绑定的完整流程可拆解为两步：\n\n#### （1）数据→视图：Model驱动View更新\n1. 开发者通过代码修改Model中的数据（如`this.message = \"新内容\"`）；\n2. 数据的`setter`方法被触发，调用对应Dep实例的`notify`方法；\n3. Dep遍历依赖列表，通知所有关联的Watcher执行`update`方法；\n4. Watcher调用预设的更新函数，修改DOM元素内容或属性，View同步更新。\n\n#### （2）视图→数据：View驱动Model更新\n1. 用户操作View（如在输入框中输入内容），触发原生事件（如`input`事件）；\n2. Compiler解析`v-model`指令时已绑定该事件，事件回调函数会修改对应的Model数据；\n3. 数据的`setter`方法被触发，重复“数据→视图”的流程，确保所有关联视图同步更新。\n\n## 三、完整实现：基于Vue2思路的双向绑定落地\n结合上述原理，我们基于Vue2的`Object.defineProperty`实现一个完整的双向绑定案例，覆盖“响应式劫持-模板编译-依赖收集-双向同步”全流程。\n\n### 1. 核心类与工具函数定义\n#### （1）Vue构造函数：初始化入口\n负责整合响应式处理、数据代理、模板编译三大核心逻辑：\n```javascript\nclass Vue {\n  constructor(options) {\n    this.$options = options; // 存储配置项（el、data等）\n    this.$data = typeof options.data === 'function' ? options.data() : options.data; // 处理data（支持函数或对象）\n    \n    // 1. 对data执行响应式处理\n    observe(this.$data);\n    // 2. 代理data属性到Vue实例（支持this.message而非this.$data.message）\n    proxy(this, this.$data);\n    // 3. 编译模板\n    new Compile(options.el, this);\n  }\n}\n\n// 数据代理：将$data的属性代理到Vue实例\nfunction proxy(vm, data) {\n  Object.keys(data).forEach(key => {\n    Object.defineProperty(vm, key, {\n      get() {\n        return data[key];\n      },\n      set(newVal) {\n        data[key] = newVal;\n      }\n    });\n  });\n}\n```\n\n#### （2）Observer：响应式劫持实现\n遍历数据属性，重写`getter`和`setter`：\n```javascript\n// 入口函数：判断数据类型，非对象直接返回\nfunction observe(obj) {\n  if (typeof obj !== 'object' || obj === null) {\n    return;\n  }\n  new Observer(obj);\n}\n\nclass Observer {\n  constructor(value) {\n    this.value = value;\n    // 遍历对象属性（仅处理对象，数组需额外处理，此处简化）\n    this.walk(value);\n  }\n  \n  walk(obj) {\n    Object.keys(obj).forEach(key => {\n      defineReactive(obj, key, obj[key]);\n    });\n  }\n}\n\n// 核心：重写属性的getter和setter，关联Dep\nfunction defineReactive(obj, key, val) {\n  // 递归处理嵌套对象\n  observe(val);\n  // 为当前属性创建Dep实例\n  const dep = new Dep();\n  \n  Object.defineProperty(obj, key, {\n    get() {\n      // 依赖收集：Dep.target为当前Watcher实例\n      if (Dep.target) {\n        dep.addDep(Dep.target);\n      }\n      return val;\n    },\n    set(newVal) {\n      // 数据未变化则不触发更新\n      if (newVal === val) return;\n      val = newVal;\n      // 新值可能是对象，需递归响应式处理\n      observe(newVal);\n      // 通知所有Watcher更新\n      dep.notify();\n    }\n  });\n}\n```\n\n#### （3）Dep：依赖管理器\n管理Watcher实例，负责依赖收集与更新通知：\n```javascript\nclass Dep {\n  constructor() {\n    this.deps = []; // 存储当前数据的所有Watcher\n  }\n  \n  // 添加Watcher到依赖列表\n  addDep(watcher) {\n    this.deps.push(watcher);\n  }\n  \n  // 通知所有Watcher执行更新\n  notify() {\n    this.deps.forEach(watcher => watcher.update());\n  }\n}\n\n// 静态属性：存储当前活跃的Watcher（全局唯一，避免多Watcher冲突）\nDep.target = null;\n```\n\n#### （4）Watcher：订阅者实现\n连接Dep与视图更新函数：\n```javascript\nclass Watcher {\n  constructor(vm, key, updaterFn) {\n    this.vm = vm; // Vue实例\n    this.key = key; // 绑定的数据属性名\n    this.updaterFn = updaterFn; // 视图更新函数\n    \n    // 依赖收集关键步骤：将当前Watcher设为活跃状态\n    Dep.target = this;\n    // 读取数据，触发getter，完成依赖收集\n    this.vm[this.key];\n    // 重置活跃Watcher，避免重复收集\n    Dep.target = null;\n  }\n  \n  // 接收Dep通知，执行更新函数\n  update() {\n    const newValue = this.vm[this.key];\n    this.updaterFn(newValue);\n  }\n}\n```\n\n#### （5）Compile：模板解析实现\n解析DOM中的指令和插值，建立数据与视图的关联：\n```javascript\nclass Compile {\n  constructor(el, vm) {\n    this.$vm = vm; // Vue实例\n    this.$el = document.querySelector(el); // 挂载点DOM元素\n    \n    if (this.$el) {\n      this.compile(this.$el); // 开始编译\n    }\n  }\n  \n  // 递归遍历DOM树，解析所有节点\n  compile(el) {\n    const childNodes = el.childNodes;\n    Array.from(childNodes).forEach(node => {\n      // 1. 解析元素节点（处理v-model等指令）\n      if (this.isElementNode(node)) {\n        this.compileElement(node);\n      }\n      // 2. 解析文本节点（处理{{}}插值）\n      else if (this.isTextNode(node) && this.isInterpolation(node)) {\n        this.compileText(node);\n      }\n      \n      // 递归处理子节点（支持嵌套模板）\n      if (node.childNodes && node.childNodes.length > 0) {\n        this.compile(node);\n      }\n    });\n  }\n  \n  // 判断是否为元素节点（nodeType=1）\n  isElementNode(node) {\n    return node.nodeType === 1;\n  }\n  \n  // 判断是否为文本节点（nodeType=3）\n  isTextNode(node) {\n    return node.nodeType === 3;\n  }\n  \n  // 判断是否为插值文本（匹配{{xxx}}）\n  isInterpolation(node) {\n    return /\\{\\{(.*)\\}\\}/.test(node.textContent);\n  }\n  \n  // 解析元素节点：处理v-model指令\n  compileElement(node) {\n    const attributes = node.attributes;\n    Array.from(attributes).forEach(attr => {\n      // 提取指令名（如v-model）和绑定的属性名（如message）\n      const attrName = attr.name;\n      if (this.isDirective(attrName)) {\n        const directiveName = attrName.slice(2); // 去掉\"v-\"\n        const key = attr.value; // 绑定的数据属性名\n        \n        // 处理v-model指令（双向绑定核心）\n        if (directiveName === 'model') {\n          this.modelUpdater(node, key);\n        }\n      }\n    });\n  }\n  \n  // 判断是否为Vue指令（以v-开头）\n  isDirective(attrName) {\n    return attrName.startsWith('v-');\n  }\n  \n  // 解析插值文本：替换{{xxx}}为实际数据\n  compileText(node) {\n    // 提取{{}}中的属性名（如message）\n    const key = RegExp.$1.trim();\n    // 初始化视图：将文本替换为data中的数据\n    this.textUpdater(node, this.$vm[key]);\n    // 创建Watcher：数据变化时更新文本\n    new Watcher(this.$vm, key, (newValue) => {\n      this.textUpdater(node, newValue);\n    });\n  }\n  \n  // 文本更新函数：修改文本节点内容\n  textUpdater(node, value) {\n    node.textContent = value || '';\n  }\n  \n  // v-model指令处理：实现双向绑定\n  modelUpdater(node, key) {\n    // 初始化视图：将输入框value设为data中的数据\n    node.value = this.$vm[key] || '';\n    // 数据→视图：创建Watcher，数据变化时更新输入框value\n    new Watcher(this.$vm, key, (newValue) => {\n      node.value = newValue || '';\n    });\n    // 视图→数据：监听输入事件，更新data中的数据\n    node.addEventListener('input', (e) => {\n      this.$vm[key] = e.target.value;\n    });\n  }\n}\n```\n\n### 2. 测试使用示例\n```html\n<!-- HTML结构 -->\n<div id=\"app\">\n  <p>{{message}}</p>\n  <input type=\"text\" v-model=\"message\">\n</div>\n\n<!-- JavaScript -->\n<script>\nnew Vue({\n  el: '#app',\n  data() {\n    return {\n      message: 'Hello Vue双向绑定!'\n    };\n  }\n});\n</script>\n```\n\n运行效果：\n- 输入框输入内容时，`p`标签中的文本会实时同步（视图→数据→视图）；\n- 代码中修改`vm.message`时，输入框和`p`标签会同时更新（数据→视图）。\n\n## 四、总结\nVue双向绑定的本质，是**MVVM架构下“响应式劫持+发布-订阅模式”的协同作用**：\n- 响应式劫持（Observer）让数据具备“感知变化”的能力；\n- 模板编译（Compiler）让视图具备“关联数据”的能力；\n- 依赖管理（Dep）与订阅者（Watcher）让数据与视图的联动具备“精准高效”的特性。\n\n作为Vue框架中的核心内容，双向绑定机制不仅是面试中经常考察的内容，同时掌握其本质与工作原理对解读Vue源码也能够打下一个坚实的基础。\n\n**【往期精彩】**\n\n- [Vue进阶系列第1篇：说说对Vue的理解，Vue是什么，有什么作用?](https://mp.weixin.qq.com/s/I-hOIMdmxws1sukiAicg4w)\n- [JavaScript ES6中的生成器(Decorator)是什么？有哪些应用场景？](https://mp.weixin.qq.com/s/c7IwODBilcxSyozJvjjHRw)\n\n- [说说JavaScript中ES6 module(模块化)的诞生背景、核心语法及应用场景](https://mp.weixin.qq.com/s/pe4fywIh7WdigHuwRiqDlQ)\n- [一文说透ES6 Proxy: 从本质到应用场景](https://mp.weixin.qq.com/s/lYqBgS0GJgQMX5PAW_snnQ)\n- [JavaScript ES6中的生成器(Generator)是什么？有哪些应用场景？一文全说透](https://mp.weixin.qq.com/s/PtFtlNUH-UcLYU5h-xKiQw)\n\n- [一文搞懂 JavaScript 里 var、let、const 的区别\n](https://mp.weixin.qq.com/s/lqn_51NNxx50YgvWkxCtEg)\n","slug":"bidirection-data-binding","published":1,"updated":"2025-12-06T04:47:41.769Z","comments":1,"layout":"post","photos":[],"_id":"cmjbml2i2000dikupelwgcm3g","content":"<p>大家好，我是jvxiao。</p>\n<p>这是<a href=\"https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU2MjU3MzI0MA==&action=getalbum&album_id=4276738695946223617#wechat_redirect\">Vue从入门到精通</a>系列文章的第2篇，今天我们来讲一讲Vue中一个非常核心的概念–<code>双向绑定</code></p>\n<p>本文将从概念本质、底层原理出发，结合完整实现逻辑，带大家全面拆解Vue双向绑定的核心机制。</p>\n<h2 id=\"一、核心概念：从单向绑定到双向联动\"><a href=\"#一、核心概念：从单向绑定到双向联动\" class=\"headerlink\" title=\"一、核心概念：从单向绑定到双向联动\"></a>一、核心概念：从单向绑定到双向联动</h2><p>要理解双向绑定，首先要明确其与单向绑定的关联与区别——双向绑定是单向绑定的延伸与闭环，而MVVM架构则为这种闭环提供了理论支撑。</p>\n<h3 id=\"单向绑定的基础逻辑\"><a href=\"#单向绑定的基础逻辑\" class=\"headerlink\" title=\"单向绑定的基础逻辑\"></a>单向绑定的基础逻辑</h3><p>单向绑定指<strong>数据模型（Model）到视图（View）的单向同步</strong>：当开发者通过代码修改Model中的数据时，框架会自动更新对应的View展示，无需手动操作DOM。这种模式的核心价值是“数据驱动视图”，让开发者专注于数据逻辑而非DOM操作，但它存在一个明显局限：用户对View的交互（如表单输入、按钮点击）无法自动同步回Model，需要手动编写事件处理函数来完成数据更新。</p>\n<h3 id=\"2-双向绑定的本质闭环\"><a href=\"#2-双向绑定的本质闭环\" class=\"headerlink\" title=\"2. 双向绑定的本质闭环\"></a>2. 双向绑定的本质闭环</h3><p>双向绑定在单向绑定的基础上，补充了“View到Model的反向同步”：</p>\n<ul>\n<li>数据→视图：Model数据变化时，View自动更新；</li>\n<li>视图→数据：用户操作View（如输入框输入、下拉框选择）时，Model数据自动同步。</li>\n</ul>\n<p>最典型的应用场景是表单交互：当用户在输入框中输入内容时，对应的Model数据会实时更新；当代码修改Model数据时，输入框的显示内容也会同步变化。这种“无需手动干预”的双向同步，正是双向绑定的核心魅力。</p>\n<h3 id=\"3-MVVM架构：双向绑定的结构支撑\"><a href=\"#3-MVVM架构：双向绑定的结构支撑\" class=\"headerlink\" title=\"3. MVVM架构：双向绑定的结构支撑\"></a>3. MVVM架构：双向绑定的结构支撑</h3><p>Vue的双向绑定并非孤立功能，而是基于MVVM（Model-View-ViewModel）架构设计的，三层结构各司其职、协同工作：</p>\n<ul>\n<li><strong>Model（数据层）</strong>：存储应用的核心数据与业务逻辑，是应用的“数据源”，例如Vue组件中的<code>data</code>选项；</li>\n<li><strong>View（视图层）</strong>：应用的可视化展示部分，由HTML、CSS构成，是用户直接交互的界面；</li>\n<li><strong>ViewModel（业务逻辑层）</strong>：Vue框架的核心封装，充当Model与View之间的“桥梁”。它既监听Model的变化以更新View，又监听View的交互以更新Model，实现了两层之间的解耦与联动。</li>\n</ul>\n<p>ViewModel的存在让Model与View完全分离，开发者无需关心“数据如何同步到视图”“视图交互如何更新数据”，只需专注于数据逻辑与界面设计，这也是Vue开发效率高的关键原因之一。</p>\n<h2 id=\"二、底层原理：四大核心模块的协同运作\"><a href=\"#二、底层原理：四大核心模块的协同运作\" class=\"headerlink\" title=\"二、底层原理：四大核心模块的协同运作\"></a>二、底层原理：四大核心模块的协同运作</h2><p>双向绑定的实现依赖ViewModel的核心能力，而ViewModel的功能又由四个关键模块共同支撑：<strong>监听器（Observer）</strong>、<strong>解析器（Compiler）</strong>、<strong>依赖管理器（Dep）</strong>、<strong>订阅者（Watcher）</strong>。这四个模块形成闭环，完成“数据劫持-模板解析-依赖收集-更新通知”的全流程。</p>\n<h3 id=\"1-监听器（Observer）：数据的“哨兵”\"><a href=\"#1-监听器（Observer）：数据的“哨兵”\" class=\"headerlink\" title=\"1. 监听器（Observer）：数据的“哨兵”\"></a>1. 监听器（Observer）：数据的“哨兵”</h3><p>Observer的核心职责是<strong>对Model中的数据进行响应式劫持</strong>，实时监听数据的变化。其实现逻辑如下：</p>\n<ul>\n<li>遍历<code>data</code>中的所有属性（包括嵌套对象），通过<code>Object.defineProperty</code>（Vue2）或<code>Proxy</code>（Vue3）重写属性的<code>getter</code>和<code>setter</code>方法；</li>\n<li>当数据被读取时（如视图渲染时访问数据），触发<code>getter</code>方法，用于后续的依赖收集；</li>\n<li>当数据被修改时（如用户输入更新数据），触发<code>setter</code>方法，向依赖管理器发送更新通知。</li>\n</ul>\n<p>Vue2中使用<code>Object.defineProperty</code>存在一定局限（无法监听数组索引变化、对象新增属性），而Vue3改用<code>Proxy</code>，不仅解决了这些问题，还能直接监听整个对象，实现更全面、高效的响应式劫持。</p>\n<h3 id=\"2-解析器（Compiler）：视图的“翻译官”\"><a href=\"#2-解析器（Compiler）：视图的“翻译官”\" class=\"headerlink\" title=\"2. 解析器（Compiler）：视图的“翻译官”\"></a>2. 解析器（Compiler）：视图的“翻译官”</h3><p>Compiler的核心职责是<strong>解析View中的模板指令，建立View与Model的关联</strong>，其工作流程如下：</p>\n<ul>\n<li>遍历DOM树，扫描所有元素节点和文本节点，识别出包含Vue指令（如<code>v-model</code>、<code>&#123;&#123;&#125;&#125;</code>插值表达式）的节点；</li>\n<li>对插值文本（如<code>&#123;&#123;message&#125;&#125;</code>），从Model中获取对应数据，替换文本内容并初始化视图；</li>\n<li>对指令节点（如<code>&lt;input v-model=&quot;message&quot;&gt;</code>），解析指令绑定的数据属性，同时绑定视图交互事件（如<code>input</code>事件）；</li>\n<li>为每个绑定的数据属性创建对应的订阅者（Watcher），指定数据变化时的视图更新函数。</li>\n</ul>\n<p>Compiler的存在让模板中的动态绑定与Model数据建立了精准关联，为双向绑定提供了“视图层面的入口”。</p>\n<h3 id=\"3-依赖管理器（Dep）：数据与订阅者的“中介”\"><a href=\"#3-依赖管理器（Dep）：数据与订阅者的“中介”\" class=\"headerlink\" title=\"3. 依赖管理器（Dep）：数据与订阅者的“中介”\"></a>3. 依赖管理器（Dep）：数据与订阅者的“中介”</h3><p>Dep的核心职责是<strong>管理某个数据属性对应的所有订阅者（Watcher）</strong>，充当“数据-订阅者”的桥梁。其核心逻辑如下：</p>\n<ul>\n<li>每个数据属性在被响应式劫持时，会创建一个专属的Dep实例；</li>\n<li>当数据被读取（触发<code>getter</code>）时，Dep会将当前的Watcher实例添加到自身的依赖列表中（依赖收集）；</li>\n<li>当数据被修改（触发<code>setter</code>）时，Dep会遍历依赖列表，通知所有Watcher执行更新操作（更新通知）。</li>\n</ul>\n<p>由于同一个数据属性可能在视图中多次使用（如<code>message</code>在多个插值文本中出现），一个Dep实例可能管理多个Watcher，确保数据变化时所有关联视图都能同步更新。</p>\n<h3 id=\"4-订阅者（Watcher）：数据与视图的“连接器”\"><a href=\"#4-订阅者（Watcher）：数据与视图的“连接器”\" class=\"headerlink\" title=\"4. 订阅者（Watcher）：数据与视图的“连接器”\"></a>4. 订阅者（Watcher）：数据与视图的“连接器”</h3><p>Watcher是连接Model与View的核心载体，其核心职责是<strong>接收Dep的更新通知，执行视图更新函数</strong>。其工作流程如下：</p>\n<ul>\n<li>当Compiler解析模板时，会为每个动态绑定的数据属性创建一个Watcher实例，同时指定对应的视图更新函数（如替换插值文本、修改元素value值）；</li>\n<li>Watcher创建时，会主动读取对应的Model数据，触发数据的<code>getter</code>方法，从而让自身被添加到该数据的Dep依赖列表中；</li>\n<li>当数据变化时，Dep会调用Watcher的<code>update</code>方法，执行预设的更新函数，完成视图的同步更新。</li>\n</ul>\n<h3 id=\"5-双向联动的完整闭环\"><a href=\"#5-双向联动的完整闭环\" class=\"headerlink\" title=\"5. 双向联动的完整闭环\"></a>5. 双向联动的完整闭环</h3><p>结合四大模块，Vue双向绑定的完整流程可拆解为两步：</p>\n<h4 id=\"（1）数据→视图：Model驱动View更新\"><a href=\"#（1）数据→视图：Model驱动View更新\" class=\"headerlink\" title=\"（1）数据→视图：Model驱动View更新\"></a>（1）数据→视图：Model驱动View更新</h4><ol>\n<li>开发者通过代码修改Model中的数据（如<code>this.message = &quot;新内容&quot;</code>）；</li>\n<li>数据的<code>setter</code>方法被触发，调用对应Dep实例的<code>notify</code>方法；</li>\n<li>Dep遍历依赖列表，通知所有关联的Watcher执行<code>update</code>方法；</li>\n<li>Watcher调用预设的更新函数，修改DOM元素内容或属性，View同步更新。</li>\n</ol>\n<h4 id=\"（2）视图→数据：View驱动Model更新\"><a href=\"#（2）视图→数据：View驱动Model更新\" class=\"headerlink\" title=\"（2）视图→数据：View驱动Model更新\"></a>（2）视图→数据：View驱动Model更新</h4><ol>\n<li>用户操作View（如在输入框中输入内容），触发原生事件（如<code>input</code>事件）；</li>\n<li>Compiler解析<code>v-model</code>指令时已绑定该事件，事件回调函数会修改对应的Model数据；</li>\n<li>数据的<code>setter</code>方法被触发，重复“数据→视图”的流程，确保所有关联视图同步更新。</li>\n</ol>\n<h2 id=\"三、完整实现：基于Vue2思路的双向绑定落地\"><a href=\"#三、完整实现：基于Vue2思路的双向绑定落地\" class=\"headerlink\" title=\"三、完整实现：基于Vue2思路的双向绑定落地\"></a>三、完整实现：基于Vue2思路的双向绑定落地</h2><p>结合上述原理，我们基于Vue2的<code>Object.defineProperty</code>实现一个完整的双向绑定案例，覆盖“响应式劫持-模板编译-依赖收集-双向同步”全流程。</p>\n<h3 id=\"1-核心类与工具函数定义\"><a href=\"#1-核心类与工具函数定义\" class=\"headerlink\" title=\"1. 核心类与工具函数定义\"></a>1. 核心类与工具函数定义</h3><h4 id=\"（1）Vue构造函数：初始化入口\"><a href=\"#（1）Vue构造函数：初始化入口\" class=\"headerlink\" title=\"（1）Vue构造函数：初始化入口\"></a>（1）Vue构造函数：初始化入口</h4><p>负责整合响应式处理、数据代理、模板编译三大核心逻辑：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Vue</span> &#123;<br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">options</span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$options</span> = options; <span class=\"hljs-comment\">// 存储配置项（el、data等）</span><br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$data</span> = <span class=\"hljs-keyword\">typeof</span> options.<span class=\"hljs-property\">data</span> === <span class=\"hljs-string\">&#x27;function&#x27;</span> ? options.<span class=\"hljs-title function_\">data</span>() : options.<span class=\"hljs-property\">data</span>; <span class=\"hljs-comment\">// 处理data（支持函数或对象）</span><br>    <br>    <span class=\"hljs-comment\">// 1. 对data执行响应式处理</span><br>    <span class=\"hljs-title function_\">observe</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$data</span>);<br>    <span class=\"hljs-comment\">// 2. 代理data属性到Vue实例（支持this.message而非this.$data.message）</span><br>    <span class=\"hljs-title function_\">proxy</span>(<span class=\"hljs-variable language_\">this</span>, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$data</span>);<br>    <span class=\"hljs-comment\">// 3. 编译模板</span><br>    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Compile</span>(options.<span class=\"hljs-property\">el</span>, <span class=\"hljs-variable language_\">this</span>);<br>  &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 数据代理：将$data的属性代理到Vue实例</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">proxy</span>(<span class=\"hljs-params\">vm, data</span>) &#123;<br>  <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(data).<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">key</span> =&gt;</span> &#123;<br>    <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">defineProperty</span>(vm, key, &#123;<br>      <span class=\"hljs-title function_\">get</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> data[key];<br>      &#125;,<br>      <span class=\"hljs-title function_\">set</span>(<span class=\"hljs-params\">newVal</span>) &#123;<br>        data[key] = newVal;<br>      &#125;<br>    &#125;);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"（2）Observer：响应式劫持实现\"><a href=\"#（2）Observer：响应式劫持实现\" class=\"headerlink\" title=\"（2）Observer：响应式劫持实现\"></a>（2）Observer：响应式劫持实现</h4><p>遍历数据属性，重写<code>getter</code>和<code>setter</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 入口函数：判断数据类型，非对象直接返回</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">observe</span>(<span class=\"hljs-params\">obj</span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> obj !== <span class=\"hljs-string\">&#x27;object&#x27;</span> || obj === <span class=\"hljs-literal\">null</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Observer</span>(obj);<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Observer</span> &#123;<br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">value</span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span> = value;<br>    <span class=\"hljs-comment\">// 遍历对象属性（仅处理对象，数组需额外处理，此处简化）</span><br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">walk</span>(value);<br>  &#125;<br>  <br>  <span class=\"hljs-title function_\">walk</span>(<span class=\"hljs-params\">obj</span>) &#123;<br>    <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(obj).<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">key</span> =&gt;</span> &#123;<br>      <span class=\"hljs-title function_\">defineReactive</span>(obj, key, obj[key]);<br>    &#125;);<br>  &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 核心：重写属性的getter和setter，关联Dep</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">defineReactive</span>(<span class=\"hljs-params\">obj, key, val</span>) &#123;<br>  <span class=\"hljs-comment\">// 递归处理嵌套对象</span><br>  <span class=\"hljs-title function_\">observe</span>(val);<br>  <span class=\"hljs-comment\">// 为当前属性创建Dep实例</span><br>  <span class=\"hljs-keyword\">const</span> dep = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Dep</span>();<br>  <br>  <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">defineProperty</span>(obj, key, &#123;<br>    <span class=\"hljs-title function_\">get</span>(<span class=\"hljs-params\"></span>) &#123;<br>      <span class=\"hljs-comment\">// 依赖收集：Dep.target为当前Watcher实例</span><br>      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title class_\">Dep</span>.<span class=\"hljs-property\">target</span>) &#123;<br>        dep.<span class=\"hljs-title function_\">addDep</span>(<span class=\"hljs-title class_\">Dep</span>.<span class=\"hljs-property\">target</span>);<br>      &#125;<br>      <span class=\"hljs-keyword\">return</span> val;<br>    &#125;,<br>    <span class=\"hljs-title function_\">set</span>(<span class=\"hljs-params\">newVal</span>) &#123;<br>      <span class=\"hljs-comment\">// 数据未变化则不触发更新</span><br>      <span class=\"hljs-keyword\">if</span> (newVal === val) <span class=\"hljs-keyword\">return</span>;<br>      val = newVal;<br>      <span class=\"hljs-comment\">// 新值可能是对象，需递归响应式处理</span><br>      <span class=\"hljs-title function_\">observe</span>(newVal);<br>      <span class=\"hljs-comment\">// 通知所有Watcher更新</span><br>      dep.<span class=\"hljs-title function_\">notify</span>();<br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"（3）Dep：依赖管理器\"><a href=\"#（3）Dep：依赖管理器\" class=\"headerlink\" title=\"（3）Dep：依赖管理器\"></a>（3）Dep：依赖管理器</h4><p>管理Watcher实例，负责依赖收集与更新通知：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Dep</span> &#123;<br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">deps</span> = []; <span class=\"hljs-comment\">// 存储当前数据的所有Watcher</span><br>  &#125;<br>  <br>  <span class=\"hljs-comment\">// 添加Watcher到依赖列表</span><br>  <span class=\"hljs-title function_\">addDep</span>(<span class=\"hljs-params\">watcher</span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">deps</span>.<span class=\"hljs-title function_\">push</span>(watcher);<br>  &#125;<br>  <br>  <span class=\"hljs-comment\">// 通知所有Watcher执行更新</span><br>  <span class=\"hljs-title function_\">notify</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">deps</span>.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">watcher</span> =&gt;</span> watcher.<span class=\"hljs-title function_\">update</span>());<br>  &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 静态属性：存储当前活跃的Watcher（全局唯一，避免多Watcher冲突）</span><br><span class=\"hljs-title class_\">Dep</span>.<span class=\"hljs-property\">target</span> = <span class=\"hljs-literal\">null</span>;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"（4）Watcher：订阅者实现\"><a href=\"#（4）Watcher：订阅者实现\" class=\"headerlink\" title=\"（4）Watcher：订阅者实现\"></a>（4）Watcher：订阅者实现</h4><p>连接Dep与视图更新函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Watcher</span> &#123;<br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">vm, key, updaterFn</span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">vm</span> = vm; <span class=\"hljs-comment\">// Vue实例</span><br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">key</span> = key; <span class=\"hljs-comment\">// 绑定的数据属性名</span><br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">updaterFn</span> = updaterFn; <span class=\"hljs-comment\">// 视图更新函数</span><br>    <br>    <span class=\"hljs-comment\">// 依赖收集关键步骤：将当前Watcher设为活跃状态</span><br>    <span class=\"hljs-title class_\">Dep</span>.<span class=\"hljs-property\">target</span> = <span class=\"hljs-variable language_\">this</span>;<br>    <span class=\"hljs-comment\">// 读取数据，触发getter，完成依赖收集</span><br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">vm</span>[<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">key</span>];<br>    <span class=\"hljs-comment\">// 重置活跃Watcher，避免重复收集</span><br>    <span class=\"hljs-title class_\">Dep</span>.<span class=\"hljs-property\">target</span> = <span class=\"hljs-literal\">null</span>;<br>  &#125;<br>  <br>  <span class=\"hljs-comment\">// 接收Dep通知，执行更新函数</span><br>  <span class=\"hljs-title function_\">update</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> newValue = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">vm</span>[<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">key</span>];<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">updaterFn</span>(newValue);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"（5）Compile：模板解析实现\"><a href=\"#（5）Compile：模板解析实现\" class=\"headerlink\" title=\"（5）Compile：模板解析实现\"></a>（5）Compile：模板解析实现</h4><p>解析DOM中的指令和插值，建立数据与视图的关联：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Compile</span> &#123;<br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">el, vm</span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$vm</span> = vm; <span class=\"hljs-comment\">// Vue实例</span><br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$el</span> = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(el); <span class=\"hljs-comment\">// 挂载点DOM元素</span><br>    <br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$el</span>) &#123;<br>      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">compile</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$el</span>); <span class=\"hljs-comment\">// 开始编译</span><br>    &#125;<br>  &#125;<br>  <br>  <span class=\"hljs-comment\">// 递归遍历DOM树，解析所有节点</span><br>  <span class=\"hljs-title function_\">compile</span>(<span class=\"hljs-params\">el</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> childNodes = el.<span class=\"hljs-property\">childNodes</span>;<br>    <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(childNodes).<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">node</span> =&gt;</span> &#123;<br>      <span class=\"hljs-comment\">// 1. 解析元素节点（处理v-model等指令）</span><br>      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">isElementNode</span>(node)) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">compileElement</span>(node);<br>      &#125;<br>      <span class=\"hljs-comment\">// 2. 解析文本节点（处理&#123;&#123;&#125;&#125;插值）</span><br>      <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">isTextNode</span>(node) &amp;&amp; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">isInterpolation</span>(node)) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">compileText</span>(node);<br>      &#125;<br>      <br>      <span class=\"hljs-comment\">// 递归处理子节点（支持嵌套模板）</span><br>      <span class=\"hljs-keyword\">if</span> (node.<span class=\"hljs-property\">childNodes</span> &amp;&amp; node.<span class=\"hljs-property\">childNodes</span>.<span class=\"hljs-property\">length</span> &gt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">compile</span>(node);<br>      &#125;<br>    &#125;);<br>  &#125;<br>  <br>  <span class=\"hljs-comment\">// 判断是否为元素节点（nodeType=1）</span><br>  <span class=\"hljs-title function_\">isElementNode</span>(<span class=\"hljs-params\">node</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> node.<span class=\"hljs-property\">nodeType</span> === <span class=\"hljs-number\">1</span>;<br>  &#125;<br>  <br>  <span class=\"hljs-comment\">// 判断是否为文本节点（nodeType=3）</span><br>  <span class=\"hljs-title function_\">isTextNode</span>(<span class=\"hljs-params\">node</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> node.<span class=\"hljs-property\">nodeType</span> === <span class=\"hljs-number\">3</span>;<br>  &#125;<br>  <br>  <span class=\"hljs-comment\">// 判断是否为插值文本（匹配&#123;&#123;xxx&#125;&#125;）</span><br>  <span class=\"hljs-title function_\">isInterpolation</span>(<span class=\"hljs-params\">node</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-regexp\">/\\&#123;\\&#123;(.*)\\&#125;\\&#125;/</span>.<span class=\"hljs-title function_\">test</span>(node.<span class=\"hljs-property\">textContent</span>);<br>  &#125;<br>  <br>  <span class=\"hljs-comment\">// 解析元素节点：处理v-model指令</span><br>  <span class=\"hljs-title function_\">compileElement</span>(<span class=\"hljs-params\">node</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> attributes = node.<span class=\"hljs-property\">attributes</span>;<br>    <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(attributes).<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">attr</span> =&gt;</span> &#123;<br>      <span class=\"hljs-comment\">// 提取指令名（如v-model）和绑定的属性名（如message）</span><br>      <span class=\"hljs-keyword\">const</span> attrName = attr.<span class=\"hljs-property\">name</span>;<br>      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">isDirective</span>(attrName)) &#123;<br>        <span class=\"hljs-keyword\">const</span> directiveName = attrName.<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// 去掉&quot;v-&quot;</span><br>        <span class=\"hljs-keyword\">const</span> key = attr.<span class=\"hljs-property\">value</span>; <span class=\"hljs-comment\">// 绑定的数据属性名</span><br>        <br>        <span class=\"hljs-comment\">// 处理v-model指令（双向绑定核心）</span><br>        <span class=\"hljs-keyword\">if</span> (directiveName === <span class=\"hljs-string\">&#x27;model&#x27;</span>) &#123;<br>          <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">modelUpdater</span>(node, key);<br>        &#125;<br>      &#125;<br>    &#125;);<br>  &#125;<br>  <br>  <span class=\"hljs-comment\">// 判断是否为Vue指令（以v-开头）</span><br>  <span class=\"hljs-title function_\">isDirective</span>(<span class=\"hljs-params\">attrName</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> attrName.<span class=\"hljs-title function_\">startsWith</span>(<span class=\"hljs-string\">&#x27;v-&#x27;</span>);<br>  &#125;<br>  <br>  <span class=\"hljs-comment\">// 解析插值文本：替换&#123;&#123;xxx&#125;&#125;为实际数据</span><br>  <span class=\"hljs-title function_\">compileText</span>(<span class=\"hljs-params\">node</span>) &#123;<br>    <span class=\"hljs-comment\">// 提取&#123;&#123;&#125;&#125;中的属性名（如message）</span><br>    <span class=\"hljs-keyword\">const</span> key = <span class=\"hljs-title class_\">RegExp</span>.<span class=\"hljs-property\">$1</span>.<span class=\"hljs-title function_\">trim</span>();<br>    <span class=\"hljs-comment\">// 初始化视图：将文本替换为data中的数据</span><br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">textUpdater</span>(node, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$vm</span>[key]);<br>    <span class=\"hljs-comment\">// 创建Watcher：数据变化时更新文本</span><br>    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Watcher</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$vm</span>, key, <span class=\"hljs-function\">(<span class=\"hljs-params\">newValue</span>) =&gt;</span> &#123;<br>      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">textUpdater</span>(node, newValue);<br>    &#125;);<br>  &#125;<br>  <br>  <span class=\"hljs-comment\">// 文本更新函数：修改文本节点内容</span><br>  <span class=\"hljs-title function_\">textUpdater</span>(<span class=\"hljs-params\">node, value</span>) &#123;<br>    node.<span class=\"hljs-property\">textContent</span> = value || <span class=\"hljs-string\">&#x27;&#x27;</span>;<br>  &#125;<br>  <br>  <span class=\"hljs-comment\">// v-model指令处理：实现双向绑定</span><br>  <span class=\"hljs-title function_\">modelUpdater</span>(<span class=\"hljs-params\">node, key</span>) &#123;<br>    <span class=\"hljs-comment\">// 初始化视图：将输入框value设为data中的数据</span><br>    node.<span class=\"hljs-property\">value</span> = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$vm</span>[key] || <span class=\"hljs-string\">&#x27;&#x27;</span>;<br>    <span class=\"hljs-comment\">// 数据→视图：创建Watcher，数据变化时更新输入框value</span><br>    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Watcher</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$vm</span>, key, <span class=\"hljs-function\">(<span class=\"hljs-params\">newValue</span>) =&gt;</span> &#123;<br>      node.<span class=\"hljs-property\">value</span> = newValue || <span class=\"hljs-string\">&#x27;&#x27;</span>;<br>    &#125;);<br>    <span class=\"hljs-comment\">// 视图→数据：监听输入事件，更新data中的数据</span><br>    node.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;input&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">e</span>) =&gt;</span> &#123;<br>      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$vm</span>[key] = e.<span class=\"hljs-property\">target</span>.<span class=\"hljs-property\">value</span>;<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-测试使用示例\"><a href=\"#2-测试使用示例\" class=\"headerlink\" title=\"2. 测试使用示例\"></a>2. 测试使用示例</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- HTML结构 --&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;app&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">&quot;message&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br><span class=\"hljs-comment\">&lt;!-- JavaScript --&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\"></span><br><span class=\"language-javascript\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Vue</span>(&#123;</span><br><span class=\"language-javascript\">  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">&#x27;#app&#x27;</span>,</span><br><span class=\"language-javascript\">  <span class=\"hljs-title function_\">data</span>(<span class=\"hljs-params\"></span>) &#123;</span><br><span class=\"language-javascript\">    <span class=\"hljs-keyword\">return</span> &#123;</span><br><span class=\"language-javascript\">      <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">&#x27;Hello Vue双向绑定!&#x27;</span></span><br><span class=\"language-javascript\">    &#125;;</span><br><span class=\"language-javascript\">  &#125;</span><br><span class=\"language-javascript\">&#125;);</span><br><span class=\"language-javascript\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>运行效果：</p>\n<ul>\n<li>输入框输入内容时，<code>p</code>标签中的文本会实时同步（视图→数据→视图）；</li>\n<li>代码中修改<code>vm.message</code>时，输入框和<code>p</code>标签会同时更新（数据→视图）。</li>\n</ul>\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h2><p>Vue双向绑定的本质，是<strong>MVVM架构下“响应式劫持+发布-订阅模式”的协同作用</strong>：</p>\n<ul>\n<li>响应式劫持（Observer）让数据具备“感知变化”的能力；</li>\n<li>模板编译（Compiler）让视图具备“关联数据”的能力；</li>\n<li>依赖管理（Dep）与订阅者（Watcher）让数据与视图的联动具备“精准高效”的特性。</li>\n</ul>\n<p>作为Vue框架中的核心内容，双向绑定机制不仅是面试中经常考察的内容，同时掌握其本质与工作原理对解读Vue源码也能够打下一个坚实的基础。</p>\n<p><strong>【往期精彩】</strong></p>\n<ul>\n<li><p><a href=\"https://mp.weixin.qq.com/s/I-hOIMdmxws1sukiAicg4w\">Vue进阶系列第1篇：说说对Vue的理解，Vue是什么，有什么作用?</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/c7IwODBilcxSyozJvjjHRw\">JavaScript ES6中的生成器(Decorator)是什么？有哪些应用场景？</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/pe4fywIh7WdigHuwRiqDlQ\">说说JavaScript中ES6 module(模块化)的诞生背景、核心语法及应用场景</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/lYqBgS0GJgQMX5PAW_snnQ\">一文说透ES6 Proxy: 从本质到应用场景</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/PtFtlNUH-UcLYU5h-xKiQw\">JavaScript ES6中的生成器(Generator)是什么？有哪些应用场景？一文全说透</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/lqn_51NNxx50YgvWkxCtEg\">一文搞懂 JavaScript 里 var、let、const 的区别\n</a></p>\n</li>\n</ul>\n","excerpt":"","more":"<p>大家好，我是jvxiao。</p>\n<p>这是<a href=\"https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU2MjU3MzI0MA==&action=getalbum&album_id=4276738695946223617#wechat_redirect\">Vue从入门到精通</a>系列文章的第2篇，今天我们来讲一讲Vue中一个非常核心的概念–<code>双向绑定</code></p>\n<p>本文将从概念本质、底层原理出发，结合完整实现逻辑，带大家全面拆解Vue双向绑定的核心机制。</p>\n<h2 id=\"一、核心概念：从单向绑定到双向联动\"><a href=\"#一、核心概念：从单向绑定到双向联动\" class=\"headerlink\" title=\"一、核心概念：从单向绑定到双向联动\"></a>一、核心概念：从单向绑定到双向联动</h2><p>要理解双向绑定，首先要明确其与单向绑定的关联与区别——双向绑定是单向绑定的延伸与闭环，而MVVM架构则为这种闭环提供了理论支撑。</p>\n<h3 id=\"单向绑定的基础逻辑\"><a href=\"#单向绑定的基础逻辑\" class=\"headerlink\" title=\"单向绑定的基础逻辑\"></a>单向绑定的基础逻辑</h3><p>单向绑定指<strong>数据模型（Model）到视图（View）的单向同步</strong>：当开发者通过代码修改Model中的数据时，框架会自动更新对应的View展示，无需手动操作DOM。这种模式的核心价值是“数据驱动视图”，让开发者专注于数据逻辑而非DOM操作，但它存在一个明显局限：用户对View的交互（如表单输入、按钮点击）无法自动同步回Model，需要手动编写事件处理函数来完成数据更新。</p>\n<h3 id=\"2-双向绑定的本质闭环\"><a href=\"#2-双向绑定的本质闭环\" class=\"headerlink\" title=\"2. 双向绑定的本质闭环\"></a>2. 双向绑定的本质闭环</h3><p>双向绑定在单向绑定的基础上，补充了“View到Model的反向同步”：</p>\n<ul>\n<li>数据→视图：Model数据变化时，View自动更新；</li>\n<li>视图→数据：用户操作View（如输入框输入、下拉框选择）时，Model数据自动同步。</li>\n</ul>\n<p>最典型的应用场景是表单交互：当用户在输入框中输入内容时，对应的Model数据会实时更新；当代码修改Model数据时，输入框的显示内容也会同步变化。这种“无需手动干预”的双向同步，正是双向绑定的核心魅力。</p>\n<h3 id=\"3-MVVM架构：双向绑定的结构支撑\"><a href=\"#3-MVVM架构：双向绑定的结构支撑\" class=\"headerlink\" title=\"3. MVVM架构：双向绑定的结构支撑\"></a>3. MVVM架构：双向绑定的结构支撑</h3><p>Vue的双向绑定并非孤立功能，而是基于MVVM（Model-View-ViewModel）架构设计的，三层结构各司其职、协同工作：</p>\n<ul>\n<li><strong>Model（数据层）</strong>：存储应用的核心数据与业务逻辑，是应用的“数据源”，例如Vue组件中的<code>data</code>选项；</li>\n<li><strong>View（视图层）</strong>：应用的可视化展示部分，由HTML、CSS构成，是用户直接交互的界面；</li>\n<li><strong>ViewModel（业务逻辑层）</strong>：Vue框架的核心封装，充当Model与View之间的“桥梁”。它既监听Model的变化以更新View，又监听View的交互以更新Model，实现了两层之间的解耦与联动。</li>\n</ul>\n<p>ViewModel的存在让Model与View完全分离，开发者无需关心“数据如何同步到视图”“视图交互如何更新数据”，只需专注于数据逻辑与界面设计，这也是Vue开发效率高的关键原因之一。</p>\n<h2 id=\"二、底层原理：四大核心模块的协同运作\"><a href=\"#二、底层原理：四大核心模块的协同运作\" class=\"headerlink\" title=\"二、底层原理：四大核心模块的协同运作\"></a>二、底层原理：四大核心模块的协同运作</h2><p>双向绑定的实现依赖ViewModel的核心能力，而ViewModel的功能又由四个关键模块共同支撑：<strong>监听器（Observer）</strong>、<strong>解析器（Compiler）</strong>、<strong>依赖管理器（Dep）</strong>、<strong>订阅者（Watcher）</strong>。这四个模块形成闭环，完成“数据劫持-模板解析-依赖收集-更新通知”的全流程。</p>\n<h3 id=\"1-监听器（Observer）：数据的“哨兵”\"><a href=\"#1-监听器（Observer）：数据的“哨兵”\" class=\"headerlink\" title=\"1. 监听器（Observer）：数据的“哨兵”\"></a>1. 监听器（Observer）：数据的“哨兵”</h3><p>Observer的核心职责是<strong>对Model中的数据进行响应式劫持</strong>，实时监听数据的变化。其实现逻辑如下：</p>\n<ul>\n<li>遍历<code>data</code>中的所有属性（包括嵌套对象），通过<code>Object.defineProperty</code>（Vue2）或<code>Proxy</code>（Vue3）重写属性的<code>getter</code>和<code>setter</code>方法；</li>\n<li>当数据被读取时（如视图渲染时访问数据），触发<code>getter</code>方法，用于后续的依赖收集；</li>\n<li>当数据被修改时（如用户输入更新数据），触发<code>setter</code>方法，向依赖管理器发送更新通知。</li>\n</ul>\n<p>Vue2中使用<code>Object.defineProperty</code>存在一定局限（无法监听数组索引变化、对象新增属性），而Vue3改用<code>Proxy</code>，不仅解决了这些问题，还能直接监听整个对象，实现更全面、高效的响应式劫持。</p>\n<h3 id=\"2-解析器（Compiler）：视图的“翻译官”\"><a href=\"#2-解析器（Compiler）：视图的“翻译官”\" class=\"headerlink\" title=\"2. 解析器（Compiler）：视图的“翻译官”\"></a>2. 解析器（Compiler）：视图的“翻译官”</h3><p>Compiler的核心职责是<strong>解析View中的模板指令，建立View与Model的关联</strong>，其工作流程如下：</p>\n<ul>\n<li>遍历DOM树，扫描所有元素节点和文本节点，识别出包含Vue指令（如<code>v-model</code>、<code>&#123;&#123;&#125;&#125;</code>插值表达式）的节点；</li>\n<li>对插值文本（如<code>&#123;&#123;message&#125;&#125;</code>），从Model中获取对应数据，替换文本内容并初始化视图；</li>\n<li>对指令节点（如<code>&lt;input v-model=&quot;message&quot;&gt;</code>），解析指令绑定的数据属性，同时绑定视图交互事件（如<code>input</code>事件）；</li>\n<li>为每个绑定的数据属性创建对应的订阅者（Watcher），指定数据变化时的视图更新函数。</li>\n</ul>\n<p>Compiler的存在让模板中的动态绑定与Model数据建立了精准关联，为双向绑定提供了“视图层面的入口”。</p>\n<h3 id=\"3-依赖管理器（Dep）：数据与订阅者的“中介”\"><a href=\"#3-依赖管理器（Dep）：数据与订阅者的“中介”\" class=\"headerlink\" title=\"3. 依赖管理器（Dep）：数据与订阅者的“中介”\"></a>3. 依赖管理器（Dep）：数据与订阅者的“中介”</h3><p>Dep的核心职责是<strong>管理某个数据属性对应的所有订阅者（Watcher）</strong>，充当“数据-订阅者”的桥梁。其核心逻辑如下：</p>\n<ul>\n<li>每个数据属性在被响应式劫持时，会创建一个专属的Dep实例；</li>\n<li>当数据被读取（触发<code>getter</code>）时，Dep会将当前的Watcher实例添加到自身的依赖列表中（依赖收集）；</li>\n<li>当数据被修改（触发<code>setter</code>）时，Dep会遍历依赖列表，通知所有Watcher执行更新操作（更新通知）。</li>\n</ul>\n<p>由于同一个数据属性可能在视图中多次使用（如<code>message</code>在多个插值文本中出现），一个Dep实例可能管理多个Watcher，确保数据变化时所有关联视图都能同步更新。</p>\n<h3 id=\"4-订阅者（Watcher）：数据与视图的“连接器”\"><a href=\"#4-订阅者（Watcher）：数据与视图的“连接器”\" class=\"headerlink\" title=\"4. 订阅者（Watcher）：数据与视图的“连接器”\"></a>4. 订阅者（Watcher）：数据与视图的“连接器”</h3><p>Watcher是连接Model与View的核心载体，其核心职责是<strong>接收Dep的更新通知，执行视图更新函数</strong>。其工作流程如下：</p>\n<ul>\n<li>当Compiler解析模板时，会为每个动态绑定的数据属性创建一个Watcher实例，同时指定对应的视图更新函数（如替换插值文本、修改元素value值）；</li>\n<li>Watcher创建时，会主动读取对应的Model数据，触发数据的<code>getter</code>方法，从而让自身被添加到该数据的Dep依赖列表中；</li>\n<li>当数据变化时，Dep会调用Watcher的<code>update</code>方法，执行预设的更新函数，完成视图的同步更新。</li>\n</ul>\n<h3 id=\"5-双向联动的完整闭环\"><a href=\"#5-双向联动的完整闭环\" class=\"headerlink\" title=\"5. 双向联动的完整闭环\"></a>5. 双向联动的完整闭环</h3><p>结合四大模块，Vue双向绑定的完整流程可拆解为两步：</p>\n<h4 id=\"（1）数据→视图：Model驱动View更新\"><a href=\"#（1）数据→视图：Model驱动View更新\" class=\"headerlink\" title=\"（1）数据→视图：Model驱动View更新\"></a>（1）数据→视图：Model驱动View更新</h4><ol>\n<li>开发者通过代码修改Model中的数据（如<code>this.message = &quot;新内容&quot;</code>）；</li>\n<li>数据的<code>setter</code>方法被触发，调用对应Dep实例的<code>notify</code>方法；</li>\n<li>Dep遍历依赖列表，通知所有关联的Watcher执行<code>update</code>方法；</li>\n<li>Watcher调用预设的更新函数，修改DOM元素内容或属性，View同步更新。</li>\n</ol>\n<h4 id=\"（2）视图→数据：View驱动Model更新\"><a href=\"#（2）视图→数据：View驱动Model更新\" class=\"headerlink\" title=\"（2）视图→数据：View驱动Model更新\"></a>（2）视图→数据：View驱动Model更新</h4><ol>\n<li>用户操作View（如在输入框中输入内容），触发原生事件（如<code>input</code>事件）；</li>\n<li>Compiler解析<code>v-model</code>指令时已绑定该事件，事件回调函数会修改对应的Model数据；</li>\n<li>数据的<code>setter</code>方法被触发，重复“数据→视图”的流程，确保所有关联视图同步更新。</li>\n</ol>\n<h2 id=\"三、完整实现：基于Vue2思路的双向绑定落地\"><a href=\"#三、完整实现：基于Vue2思路的双向绑定落地\" class=\"headerlink\" title=\"三、完整实现：基于Vue2思路的双向绑定落地\"></a>三、完整实现：基于Vue2思路的双向绑定落地</h2><p>结合上述原理，我们基于Vue2的<code>Object.defineProperty</code>实现一个完整的双向绑定案例，覆盖“响应式劫持-模板编译-依赖收集-双向同步”全流程。</p>\n<h3 id=\"1-核心类与工具函数定义\"><a href=\"#1-核心类与工具函数定义\" class=\"headerlink\" title=\"1. 核心类与工具函数定义\"></a>1. 核心类与工具函数定义</h3><h4 id=\"（1）Vue构造函数：初始化入口\"><a href=\"#（1）Vue构造函数：初始化入口\" class=\"headerlink\" title=\"（1）Vue构造函数：初始化入口\"></a>（1）Vue构造函数：初始化入口</h4><p>负责整合响应式处理、数据代理、模板编译三大核心逻辑：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Vue</span> &#123;<br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">options</span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$options</span> = options; <span class=\"hljs-comment\">// 存储配置项（el、data等）</span><br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$data</span> = <span class=\"hljs-keyword\">typeof</span> options.<span class=\"hljs-property\">data</span> === <span class=\"hljs-string\">&#x27;function&#x27;</span> ? options.<span class=\"hljs-title function_\">data</span>() : options.<span class=\"hljs-property\">data</span>; <span class=\"hljs-comment\">// 处理data（支持函数或对象）</span><br>    <br>    <span class=\"hljs-comment\">// 1. 对data执行响应式处理</span><br>    <span class=\"hljs-title function_\">observe</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$data</span>);<br>    <span class=\"hljs-comment\">// 2. 代理data属性到Vue实例（支持this.message而非this.$data.message）</span><br>    <span class=\"hljs-title function_\">proxy</span>(<span class=\"hljs-variable language_\">this</span>, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$data</span>);<br>    <span class=\"hljs-comment\">// 3. 编译模板</span><br>    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Compile</span>(options.<span class=\"hljs-property\">el</span>, <span class=\"hljs-variable language_\">this</span>);<br>  &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 数据代理：将$data的属性代理到Vue实例</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">proxy</span>(<span class=\"hljs-params\">vm, data</span>) &#123;<br>  <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(data).<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">key</span> =&gt;</span> &#123;<br>    <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">defineProperty</span>(vm, key, &#123;<br>      <span class=\"hljs-title function_\">get</span>(<span class=\"hljs-params\"></span>) &#123;<br>        <span class=\"hljs-keyword\">return</span> data[key];<br>      &#125;,<br>      <span class=\"hljs-title function_\">set</span>(<span class=\"hljs-params\">newVal</span>) &#123;<br>        data[key] = newVal;<br>      &#125;<br>    &#125;);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"（2）Observer：响应式劫持实现\"><a href=\"#（2）Observer：响应式劫持实现\" class=\"headerlink\" title=\"（2）Observer：响应式劫持实现\"></a>（2）Observer：响应式劫持实现</h4><p>遍历数据属性，重写<code>getter</code>和<code>setter</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 入口函数：判断数据类型，非对象直接返回</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">observe</span>(<span class=\"hljs-params\">obj</span>) &#123;<br>  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">typeof</span> obj !== <span class=\"hljs-string\">&#x27;object&#x27;</span> || obj === <span class=\"hljs-literal\">null</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span>;<br>  &#125;<br>  <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Observer</span>(obj);<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Observer</span> &#123;<br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">value</span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span> = value;<br>    <span class=\"hljs-comment\">// 遍历对象属性（仅处理对象，数组需额外处理，此处简化）</span><br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">walk</span>(value);<br>  &#125;<br>  <br>  <span class=\"hljs-title function_\">walk</span>(<span class=\"hljs-params\">obj</span>) &#123;<br>    <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(obj).<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">key</span> =&gt;</span> &#123;<br>      <span class=\"hljs-title function_\">defineReactive</span>(obj, key, obj[key]);<br>    &#125;);<br>  &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 核心：重写属性的getter和setter，关联Dep</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">defineReactive</span>(<span class=\"hljs-params\">obj, key, val</span>) &#123;<br>  <span class=\"hljs-comment\">// 递归处理嵌套对象</span><br>  <span class=\"hljs-title function_\">observe</span>(val);<br>  <span class=\"hljs-comment\">// 为当前属性创建Dep实例</span><br>  <span class=\"hljs-keyword\">const</span> dep = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Dep</span>();<br>  <br>  <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">defineProperty</span>(obj, key, &#123;<br>    <span class=\"hljs-title function_\">get</span>(<span class=\"hljs-params\"></span>) &#123;<br>      <span class=\"hljs-comment\">// 依赖收集：Dep.target为当前Watcher实例</span><br>      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title class_\">Dep</span>.<span class=\"hljs-property\">target</span>) &#123;<br>        dep.<span class=\"hljs-title function_\">addDep</span>(<span class=\"hljs-title class_\">Dep</span>.<span class=\"hljs-property\">target</span>);<br>      &#125;<br>      <span class=\"hljs-keyword\">return</span> val;<br>    &#125;,<br>    <span class=\"hljs-title function_\">set</span>(<span class=\"hljs-params\">newVal</span>) &#123;<br>      <span class=\"hljs-comment\">// 数据未变化则不触发更新</span><br>      <span class=\"hljs-keyword\">if</span> (newVal === val) <span class=\"hljs-keyword\">return</span>;<br>      val = newVal;<br>      <span class=\"hljs-comment\">// 新值可能是对象，需递归响应式处理</span><br>      <span class=\"hljs-title function_\">observe</span>(newVal);<br>      <span class=\"hljs-comment\">// 通知所有Watcher更新</span><br>      dep.<span class=\"hljs-title function_\">notify</span>();<br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"（3）Dep：依赖管理器\"><a href=\"#（3）Dep：依赖管理器\" class=\"headerlink\" title=\"（3）Dep：依赖管理器\"></a>（3）Dep：依赖管理器</h4><p>管理Watcher实例，负责依赖收集与更新通知：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Dep</span> &#123;<br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">deps</span> = []; <span class=\"hljs-comment\">// 存储当前数据的所有Watcher</span><br>  &#125;<br>  <br>  <span class=\"hljs-comment\">// 添加Watcher到依赖列表</span><br>  <span class=\"hljs-title function_\">addDep</span>(<span class=\"hljs-params\">watcher</span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">deps</span>.<span class=\"hljs-title function_\">push</span>(watcher);<br>  &#125;<br>  <br>  <span class=\"hljs-comment\">// 通知所有Watcher执行更新</span><br>  <span class=\"hljs-title function_\">notify</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">deps</span>.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">watcher</span> =&gt;</span> watcher.<span class=\"hljs-title function_\">update</span>());<br>  &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 静态属性：存储当前活跃的Watcher（全局唯一，避免多Watcher冲突）</span><br><span class=\"hljs-title class_\">Dep</span>.<span class=\"hljs-property\">target</span> = <span class=\"hljs-literal\">null</span>;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"（4）Watcher：订阅者实现\"><a href=\"#（4）Watcher：订阅者实现\" class=\"headerlink\" title=\"（4）Watcher：订阅者实现\"></a>（4）Watcher：订阅者实现</h4><p>连接Dep与视图更新函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Watcher</span> &#123;<br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">vm, key, updaterFn</span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">vm</span> = vm; <span class=\"hljs-comment\">// Vue实例</span><br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">key</span> = key; <span class=\"hljs-comment\">// 绑定的数据属性名</span><br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">updaterFn</span> = updaterFn; <span class=\"hljs-comment\">// 视图更新函数</span><br>    <br>    <span class=\"hljs-comment\">// 依赖收集关键步骤：将当前Watcher设为活跃状态</span><br>    <span class=\"hljs-title class_\">Dep</span>.<span class=\"hljs-property\">target</span> = <span class=\"hljs-variable language_\">this</span>;<br>    <span class=\"hljs-comment\">// 读取数据，触发getter，完成依赖收集</span><br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">vm</span>[<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">key</span>];<br>    <span class=\"hljs-comment\">// 重置活跃Watcher，避免重复收集</span><br>    <span class=\"hljs-title class_\">Dep</span>.<span class=\"hljs-property\">target</span> = <span class=\"hljs-literal\">null</span>;<br>  &#125;<br>  <br>  <span class=\"hljs-comment\">// 接收Dep通知，执行更新函数</span><br>  <span class=\"hljs-title function_\">update</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> newValue = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">vm</span>[<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">key</span>];<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">updaterFn</span>(newValue);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"（5）Compile：模板解析实现\"><a href=\"#（5）Compile：模板解析实现\" class=\"headerlink\" title=\"（5）Compile：模板解析实现\"></a>（5）Compile：模板解析实现</h4><p>解析DOM中的指令和插值，建立数据与视图的关联：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Compile</span> &#123;<br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">el, vm</span>) &#123;<br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$vm</span> = vm; <span class=\"hljs-comment\">// Vue实例</span><br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$el</span> = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(el); <span class=\"hljs-comment\">// 挂载点DOM元素</span><br>    <br>    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$el</span>) &#123;<br>      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">compile</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$el</span>); <span class=\"hljs-comment\">// 开始编译</span><br>    &#125;<br>  &#125;<br>  <br>  <span class=\"hljs-comment\">// 递归遍历DOM树，解析所有节点</span><br>  <span class=\"hljs-title function_\">compile</span>(<span class=\"hljs-params\">el</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> childNodes = el.<span class=\"hljs-property\">childNodes</span>;<br>    <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(childNodes).<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">node</span> =&gt;</span> &#123;<br>      <span class=\"hljs-comment\">// 1. 解析元素节点（处理v-model等指令）</span><br>      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">isElementNode</span>(node)) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">compileElement</span>(node);<br>      &#125;<br>      <span class=\"hljs-comment\">// 2. 解析文本节点（处理&#123;&#123;&#125;&#125;插值）</span><br>      <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">isTextNode</span>(node) &amp;&amp; <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">isInterpolation</span>(node)) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">compileText</span>(node);<br>      &#125;<br>      <br>      <span class=\"hljs-comment\">// 递归处理子节点（支持嵌套模板）</span><br>      <span class=\"hljs-keyword\">if</span> (node.<span class=\"hljs-property\">childNodes</span> &amp;&amp; node.<span class=\"hljs-property\">childNodes</span>.<span class=\"hljs-property\">length</span> &gt; <span class=\"hljs-number\">0</span>) &#123;<br>        <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">compile</span>(node);<br>      &#125;<br>    &#125;);<br>  &#125;<br>  <br>  <span class=\"hljs-comment\">// 判断是否为元素节点（nodeType=1）</span><br>  <span class=\"hljs-title function_\">isElementNode</span>(<span class=\"hljs-params\">node</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> node.<span class=\"hljs-property\">nodeType</span> === <span class=\"hljs-number\">1</span>;<br>  &#125;<br>  <br>  <span class=\"hljs-comment\">// 判断是否为文本节点（nodeType=3）</span><br>  <span class=\"hljs-title function_\">isTextNode</span>(<span class=\"hljs-params\">node</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> node.<span class=\"hljs-property\">nodeType</span> === <span class=\"hljs-number\">3</span>;<br>  &#125;<br>  <br>  <span class=\"hljs-comment\">// 判断是否为插值文本（匹配&#123;&#123;xxx&#125;&#125;）</span><br>  <span class=\"hljs-title function_\">isInterpolation</span>(<span class=\"hljs-params\">node</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-regexp\">/\\&#123;\\&#123;(.*)\\&#125;\\&#125;/</span>.<span class=\"hljs-title function_\">test</span>(node.<span class=\"hljs-property\">textContent</span>);<br>  &#125;<br>  <br>  <span class=\"hljs-comment\">// 解析元素节点：处理v-model指令</span><br>  <span class=\"hljs-title function_\">compileElement</span>(<span class=\"hljs-params\">node</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> attributes = node.<span class=\"hljs-property\">attributes</span>;<br>    <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-title function_\">from</span>(attributes).<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">attr</span> =&gt;</span> &#123;<br>      <span class=\"hljs-comment\">// 提取指令名（如v-model）和绑定的属性名（如message）</span><br>      <span class=\"hljs-keyword\">const</span> attrName = attr.<span class=\"hljs-property\">name</span>;<br>      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">isDirective</span>(attrName)) &#123;<br>        <span class=\"hljs-keyword\">const</span> directiveName = attrName.<span class=\"hljs-title function_\">slice</span>(<span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// 去掉&quot;v-&quot;</span><br>        <span class=\"hljs-keyword\">const</span> key = attr.<span class=\"hljs-property\">value</span>; <span class=\"hljs-comment\">// 绑定的数据属性名</span><br>        <br>        <span class=\"hljs-comment\">// 处理v-model指令（双向绑定核心）</span><br>        <span class=\"hljs-keyword\">if</span> (directiveName === <span class=\"hljs-string\">&#x27;model&#x27;</span>) &#123;<br>          <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">modelUpdater</span>(node, key);<br>        &#125;<br>      &#125;<br>    &#125;);<br>  &#125;<br>  <br>  <span class=\"hljs-comment\">// 判断是否为Vue指令（以v-开头）</span><br>  <span class=\"hljs-title function_\">isDirective</span>(<span class=\"hljs-params\">attrName</span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> attrName.<span class=\"hljs-title function_\">startsWith</span>(<span class=\"hljs-string\">&#x27;v-&#x27;</span>);<br>  &#125;<br>  <br>  <span class=\"hljs-comment\">// 解析插值文本：替换&#123;&#123;xxx&#125;&#125;为实际数据</span><br>  <span class=\"hljs-title function_\">compileText</span>(<span class=\"hljs-params\">node</span>) &#123;<br>    <span class=\"hljs-comment\">// 提取&#123;&#123;&#125;&#125;中的属性名（如message）</span><br>    <span class=\"hljs-keyword\">const</span> key = <span class=\"hljs-title class_\">RegExp</span>.<span class=\"hljs-property\">$1</span>.<span class=\"hljs-title function_\">trim</span>();<br>    <span class=\"hljs-comment\">// 初始化视图：将文本替换为data中的数据</span><br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">textUpdater</span>(node, <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$vm</span>[key]);<br>    <span class=\"hljs-comment\">// 创建Watcher：数据变化时更新文本</span><br>    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Watcher</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$vm</span>, key, <span class=\"hljs-function\">(<span class=\"hljs-params\">newValue</span>) =&gt;</span> &#123;<br>      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">textUpdater</span>(node, newValue);<br>    &#125;);<br>  &#125;<br>  <br>  <span class=\"hljs-comment\">// 文本更新函数：修改文本节点内容</span><br>  <span class=\"hljs-title function_\">textUpdater</span>(<span class=\"hljs-params\">node, value</span>) &#123;<br>    node.<span class=\"hljs-property\">textContent</span> = value || <span class=\"hljs-string\">&#x27;&#x27;</span>;<br>  &#125;<br>  <br>  <span class=\"hljs-comment\">// v-model指令处理：实现双向绑定</span><br>  <span class=\"hljs-title function_\">modelUpdater</span>(<span class=\"hljs-params\">node, key</span>) &#123;<br>    <span class=\"hljs-comment\">// 初始化视图：将输入框value设为data中的数据</span><br>    node.<span class=\"hljs-property\">value</span> = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$vm</span>[key] || <span class=\"hljs-string\">&#x27;&#x27;</span>;<br>    <span class=\"hljs-comment\">// 数据→视图：创建Watcher，数据变化时更新输入框value</span><br>    <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Watcher</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$vm</span>, key, <span class=\"hljs-function\">(<span class=\"hljs-params\">newValue</span>) =&gt;</span> &#123;<br>      node.<span class=\"hljs-property\">value</span> = newValue || <span class=\"hljs-string\">&#x27;&#x27;</span>;<br>    &#125;);<br>    <span class=\"hljs-comment\">// 视图→数据：监听输入事件，更新data中的数据</span><br>    node.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;input&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">e</span>) =&gt;</span> &#123;<br>      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">$vm</span>[key] = e.<span class=\"hljs-property\">target</span>.<span class=\"hljs-property\">value</span>;<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-测试使用示例\"><a href=\"#2-测试使用示例\" class=\"headerlink\" title=\"2. 测试使用示例\"></a>2. 测试使用示例</h3><figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- HTML结构 --&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;app&quot;</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">&quot;message&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><br><span class=\"hljs-comment\">&lt;!-- JavaScript --&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\"></span><br><span class=\"language-javascript\"><span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Vue</span>(&#123;</span><br><span class=\"language-javascript\">  <span class=\"hljs-attr\">el</span>: <span class=\"hljs-string\">&#x27;#app&#x27;</span>,</span><br><span class=\"language-javascript\">  <span class=\"hljs-title function_\">data</span>(<span class=\"hljs-params\"></span>) &#123;</span><br><span class=\"language-javascript\">    <span class=\"hljs-keyword\">return</span> &#123;</span><br><span class=\"language-javascript\">      <span class=\"hljs-attr\">message</span>: <span class=\"hljs-string\">&#x27;Hello Vue双向绑定!&#x27;</span></span><br><span class=\"language-javascript\">    &#125;;</span><br><span class=\"language-javascript\">  &#125;</span><br><span class=\"language-javascript\">&#125;);</span><br><span class=\"language-javascript\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>运行效果：</p>\n<ul>\n<li>输入框输入内容时，<code>p</code>标签中的文本会实时同步（视图→数据→视图）；</li>\n<li>代码中修改<code>vm.message</code>时，输入框和<code>p</code>标签会同时更新（数据→视图）。</li>\n</ul>\n<h2 id=\"四、总结\"><a href=\"#四、总结\" class=\"headerlink\" title=\"四、总结\"></a>四、总结</h2><p>Vue双向绑定的本质，是<strong>MVVM架构下“响应式劫持+发布-订阅模式”的协同作用</strong>：</p>\n<ul>\n<li>响应式劫持（Observer）让数据具备“感知变化”的能力；</li>\n<li>模板编译（Compiler）让视图具备“关联数据”的能力；</li>\n<li>依赖管理（Dep）与订阅者（Watcher）让数据与视图的联动具备“精准高效”的特性。</li>\n</ul>\n<p>作为Vue框架中的核心内容，双向绑定机制不仅是面试中经常考察的内容，同时掌握其本质与工作原理对解读Vue源码也能够打下一个坚实的基础。</p>\n<p><strong>【往期精彩】</strong></p>\n<ul>\n<li><p><a href=\"https://mp.weixin.qq.com/s/I-hOIMdmxws1sukiAicg4w\">Vue进阶系列第1篇：说说对Vue的理解，Vue是什么，有什么作用?</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/c7IwODBilcxSyozJvjjHRw\">JavaScript ES6中的生成器(Decorator)是什么？有哪些应用场景？</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/pe4fywIh7WdigHuwRiqDlQ\">说说JavaScript中ES6 module(模块化)的诞生背景、核心语法及应用场景</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/lYqBgS0GJgQMX5PAW_snnQ\">一文说透ES6 Proxy: 从本质到应用场景</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/PtFtlNUH-UcLYU5h-xKiQw\">JavaScript ES6中的生成器(Generator)是什么？有哪些应用场景？一文全说透</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/lqn_51NNxx50YgvWkxCtEg\">一文搞懂 JavaScript 里 var、let、const 的区别\n</a></p>\n</li>\n</ul>\n"},{"title":"一个切图仔如何破茧成蝶？","date":"2025-10-28T13:14:22.000Z","banner_img":"/imgs/baners/glasses.jfif","index_img":"/imgs/baners/glasses.jfif","_content":"\n很喜欢华裔哲学家、武术家李小龙先生的一句话：“清空你的杯子，方能再行注满。” 这句话用杯子比喻人的思想与知识 —— 当杯子被装满时，便再也容不下新的事物；唯有先将其倒空，才能持续注入新的知识，实现自我迭代与进步。​\n\n那些陈旧的知识、自认为有用的经验，以及曾经屡试不爽的方法，都是杯子里的 “水”。它们像一层厚厚的茧，既为我们提供了保护，也成了束缚成长的枷锁。​\n\n## “切图仔” 真的没有 “茧” 吗？\n\n这时候或许有人会问：“什么杯子、什么水的，和我一个切图仔又有什么关系？我天天写页面，从没见过什么‘茧’啊？”​\n\n并非没有茧，只是我们自己未曾察觉罢了。​\n\n## 开发者的 “螺丝困境”\n现在的互联网公司，岗位分工能细致到什么程度？细致到使用 Vue 和 React 两个框架开发，都要分成两个独立团队 —— 一个专职写 Vue，一个专职写 React。这对公司的管理与开发效率来说是好事，但对开发者的职业发展而言，未必如此。​\n\n\n要知道，一颗螺丝即便打磨得再光亮，终究只是颗螺丝，只能固定在专属的位置上。而这些 “螺丝” 之所以不自知，不过是仗着自己对 Vue 或 Reac\n\n## 路径依赖\n\n有个概念大家或许都听说过 —— 路径依赖。它指的是一旦人做出选择，在惯性的作用下会不断强化该选择，沿着既定方向持续发展，即便过去的条件早已过时或不再适用。​\n\n换句话说，你今天写 Vue，明天写 Vue，日复一日沉浸其中，等到未来需要独立设计一个网站时，脑子里可能只剩下 Vue 的框架逻辑，可那时 Vue 或许早已淡出技术舞台。​\n相同或类似的代码写得越多，就等于一遍遍强化路径依赖，如同蚕儿一圈圈吐丝裹住自己，茧壳也会越来越厚。​\n\n## 关于破茧的一些想法\n倒掉杯子里的水，本质上就是打破这层束缚自己的茧，让自己回归到对 Web 技术一无所知的 “空杯心态”。一千多年前，孔子提出的 “温故而知新”，何尝不暗含这样的智慧？​\n\n最近我有个想法：通过撰写系列文章，梳理自己在 Web 领域积累的相关知识 —— 无论这些认知浅薄与否、是否存在疏漏，都算是一次 “清空杯子” 的尝试。如果能在这个过程中接触更多新鲜知识、拓展认知边界，那便是一次成功的突破了。\n\n期待后续文章得到大家一如既往的支持。\n","source":"_posts/break-out-of-the-cocoon.md","raw":"---\ntitle: 一个切图仔如何破茧成蝶？\ndate: 2025-10-28 21:14:22\ntags: 程序人生\nbanner_img: /imgs/baners/glasses.jfif\nindex_img: /imgs/baners/glasses.jfif\n---\n\n很喜欢华裔哲学家、武术家李小龙先生的一句话：“清空你的杯子，方能再行注满。” 这句话用杯子比喻人的思想与知识 —— 当杯子被装满时，便再也容不下新的事物；唯有先将其倒空，才能持续注入新的知识，实现自我迭代与进步。​\n\n那些陈旧的知识、自认为有用的经验，以及曾经屡试不爽的方法，都是杯子里的 “水”。它们像一层厚厚的茧，既为我们提供了保护，也成了束缚成长的枷锁。​\n\n## “切图仔” 真的没有 “茧” 吗？\n\n这时候或许有人会问：“什么杯子、什么水的，和我一个切图仔又有什么关系？我天天写页面，从没见过什么‘茧’啊？”​\n\n并非没有茧，只是我们自己未曾察觉罢了。​\n\n## 开发者的 “螺丝困境”\n现在的互联网公司，岗位分工能细致到什么程度？细致到使用 Vue 和 React 两个框架开发，都要分成两个独立团队 —— 一个专职写 Vue，一个专职写 React。这对公司的管理与开发效率来说是好事，但对开发者的职业发展而言，未必如此。​\n\n\n要知道，一颗螺丝即便打磨得再光亮，终究只是颗螺丝，只能固定在专属的位置上。而这些 “螺丝” 之所以不自知，不过是仗着自己对 Vue 或 Reac\n\n## 路径依赖\n\n有个概念大家或许都听说过 —— 路径依赖。它指的是一旦人做出选择，在惯性的作用下会不断强化该选择，沿着既定方向持续发展，即便过去的条件早已过时或不再适用。​\n\n换句话说，你今天写 Vue，明天写 Vue，日复一日沉浸其中，等到未来需要独立设计一个网站时，脑子里可能只剩下 Vue 的框架逻辑，可那时 Vue 或许早已淡出技术舞台。​\n相同或类似的代码写得越多，就等于一遍遍强化路径依赖，如同蚕儿一圈圈吐丝裹住自己，茧壳也会越来越厚。​\n\n## 关于破茧的一些想法\n倒掉杯子里的水，本质上就是打破这层束缚自己的茧，让自己回归到对 Web 技术一无所知的 “空杯心态”。一千多年前，孔子提出的 “温故而知新”，何尝不暗含这样的智慧？​\n\n最近我有个想法：通过撰写系列文章，梳理自己在 Web 领域积累的相关知识 —— 无论这些认知浅薄与否、是否存在疏漏，都算是一次 “清空杯子” 的尝试。如果能在这个过程中接触更多新鲜知识、拓展认知边界，那便是一次成功的突破了。\n\n期待后续文章得到大家一如既往的支持。\n","slug":"break-out-of-the-cocoon","published":1,"updated":"2025-10-28T13:41:55.016Z","comments":1,"layout":"post","photos":[],"_id":"cmjbml2i3000gikup9dbvgof7","content":"<p>很喜欢华裔哲学家、武术家李小龙先生的一句话：“清空你的杯子，方能再行注满。” 这句话用杯子比喻人的思想与知识 —— 当杯子被装满时，便再也容不下新的事物；唯有先将其倒空，才能持续注入新的知识，实现自我迭代与进步。​</p>\n<p>那些陈旧的知识、自认为有用的经验，以及曾经屡试不爽的方法，都是杯子里的 “水”。它们像一层厚厚的茧，既为我们提供了保护，也成了束缚成长的枷锁。​</p>\n<h2 id=\"“切图仔”-真的没有-“茧”-吗？\"><a href=\"#“切图仔”-真的没有-“茧”-吗？\" class=\"headerlink\" title=\"“切图仔” 真的没有 “茧” 吗？\"></a>“切图仔” 真的没有 “茧” 吗？</h2><p>这时候或许有人会问：“什么杯子、什么水的，和我一个切图仔又有什么关系？我天天写页面，从没见过什么‘茧’啊？”​</p>\n<p>并非没有茧，只是我们自己未曾察觉罢了。​</p>\n<h2 id=\"开发者的-“螺丝困境”\"><a href=\"#开发者的-“螺丝困境”\" class=\"headerlink\" title=\"开发者的 “螺丝困境”\"></a>开发者的 “螺丝困境”</h2><p>现在的互联网公司，岗位分工能细致到什么程度？细致到使用 Vue 和 React 两个框架开发，都要分成两个独立团队 —— 一个专职写 Vue，一个专职写 React。这对公司的管理与开发效率来说是好事，但对开发者的职业发展而言，未必如此。​</p>\n<p>要知道，一颗螺丝即便打磨得再光亮，终究只是颗螺丝，只能固定在专属的位置上。而这些 “螺丝” 之所以不自知，不过是仗着自己对 Vue 或 Reac</p>\n<h2 id=\"路径依赖\"><a href=\"#路径依赖\" class=\"headerlink\" title=\"路径依赖\"></a>路径依赖</h2><p>有个概念大家或许都听说过 —— 路径依赖。它指的是一旦人做出选择，在惯性的作用下会不断强化该选择，沿着既定方向持续发展，即便过去的条件早已过时或不再适用。​</p>\n<p>换句话说，你今天写 Vue，明天写 Vue，日复一日沉浸其中，等到未来需要独立设计一个网站时，脑子里可能只剩下 Vue 的框架逻辑，可那时 Vue 或许早已淡出技术舞台。​<br>相同或类似的代码写得越多，就等于一遍遍强化路径依赖，如同蚕儿一圈圈吐丝裹住自己，茧壳也会越来越厚。​</p>\n<h2 id=\"关于破茧的一些想法\"><a href=\"#关于破茧的一些想法\" class=\"headerlink\" title=\"关于破茧的一些想法\"></a>关于破茧的一些想法</h2><p>倒掉杯子里的水，本质上就是打破这层束缚自己的茧，让自己回归到对 Web 技术一无所知的 “空杯心态”。一千多年前，孔子提出的 “温故而知新”，何尝不暗含这样的智慧？​</p>\n<p>最近我有个想法：通过撰写系列文章，梳理自己在 Web 领域积累的相关知识 —— 无论这些认知浅薄与否、是否存在疏漏，都算是一次 “清空杯子” 的尝试。如果能在这个过程中接触更多新鲜知识、拓展认知边界，那便是一次成功的突破了。</p>\n<p>期待后续文章得到大家一如既往的支持。</p>\n","excerpt":"","more":"<p>很喜欢华裔哲学家、武术家李小龙先生的一句话：“清空你的杯子，方能再行注满。” 这句话用杯子比喻人的思想与知识 —— 当杯子被装满时，便再也容不下新的事物；唯有先将其倒空，才能持续注入新的知识，实现自我迭代与进步。​</p>\n<p>那些陈旧的知识、自认为有用的经验，以及曾经屡试不爽的方法，都是杯子里的 “水”。它们像一层厚厚的茧，既为我们提供了保护，也成了束缚成长的枷锁。​</p>\n<h2 id=\"“切图仔”-真的没有-“茧”-吗？\"><a href=\"#“切图仔”-真的没有-“茧”-吗？\" class=\"headerlink\" title=\"“切图仔” 真的没有 “茧” 吗？\"></a>“切图仔” 真的没有 “茧” 吗？</h2><p>这时候或许有人会问：“什么杯子、什么水的，和我一个切图仔又有什么关系？我天天写页面，从没见过什么‘茧’啊？”​</p>\n<p>并非没有茧，只是我们自己未曾察觉罢了。​</p>\n<h2 id=\"开发者的-“螺丝困境”\"><a href=\"#开发者的-“螺丝困境”\" class=\"headerlink\" title=\"开发者的 “螺丝困境”\"></a>开发者的 “螺丝困境”</h2><p>现在的互联网公司，岗位分工能细致到什么程度？细致到使用 Vue 和 React 两个框架开发，都要分成两个独立团队 —— 一个专职写 Vue，一个专职写 React。这对公司的管理与开发效率来说是好事，但对开发者的职业发展而言，未必如此。​</p>\n<p>要知道，一颗螺丝即便打磨得再光亮，终究只是颗螺丝，只能固定在专属的位置上。而这些 “螺丝” 之所以不自知，不过是仗着自己对 Vue 或 Reac</p>\n<h2 id=\"路径依赖\"><a href=\"#路径依赖\" class=\"headerlink\" title=\"路径依赖\"></a>路径依赖</h2><p>有个概念大家或许都听说过 —— 路径依赖。它指的是一旦人做出选择，在惯性的作用下会不断强化该选择，沿着既定方向持续发展，即便过去的条件早已过时或不再适用。​</p>\n<p>换句话说，你今天写 Vue，明天写 Vue，日复一日沉浸其中，等到未来需要独立设计一个网站时，脑子里可能只剩下 Vue 的框架逻辑，可那时 Vue 或许早已淡出技术舞台。​<br>相同或类似的代码写得越多，就等于一遍遍强化路径依赖，如同蚕儿一圈圈吐丝裹住自己，茧壳也会越来越厚。​</p>\n<h2 id=\"关于破茧的一些想法\"><a href=\"#关于破茧的一些想法\" class=\"headerlink\" title=\"关于破茧的一些想法\"></a>关于破茧的一些想法</h2><p>倒掉杯子里的水，本质上就是打破这层束缚自己的茧，让自己回归到对 Web 技术一无所知的 “空杯心态”。一千多年前，孔子提出的 “温故而知新”，何尝不暗含这样的智慧？​</p>\n<p>最近我有个想法：通过撰写系列文章，梳理自己在 Web 领域积累的相关知识 —— 无论这些认知浅薄与否、是否存在疏漏，都算是一次 “清空杯子” 的尝试。如果能在这个过程中接触更多新鲜知识、拓展认知边界，那便是一次成功的突破了。</p>\n<p>期待后续文章得到大家一如既往的支持。</p>\n"},{"title":"程序员如何打破职业瓶颈？先搬开这3块绊脚石。","date":"2025-10-19T13:46:02.000Z","keywords":"程序人生","banner_img":"/imgs/baners/break.jfif","index_img":"/imgs/baners/break.jfif","_content":"\n程序员的职业路不算长，可不少人早早就遇到了 “天花板”：想提升没方向，想突破没抓手，这就是让人头疼的 “瓶颈期”。是什么让我们陷入这种困境？又该怎么走出来？咱们一点点说清楚。\n\n## 摆烂心态\n在程序员不算长的职业生涯里，真正能实现能力跃升的黄金期，可能也就那么几年。但仅凭这几年积累的经验，在大厂“搬几年砖”解决户口问题，通常难度不大。\n\n从入职一家公司到从“新人”熬成“老油条”，快则半年到一年，慢则两年。为什么不会更久？试想，要是两年都没给你涨工资，你还会在领导面前刻意扮演“奋斗逼”吗？\n\n于是，很多人就此进入“摆烂模式”。佛系的工作态度，自然没法带来个人能力和技术的提升——摆烂心态，正是造成个人能力瓶颈的一大关键原因。\n\n\n## 基础不牢，地动山摇\n“这个世界就是个草台班子”，这句话你永远可以信。那些看似厉害的软件，说不定都是月薪几千块的外包（作者自己也曾是其中一员）写的；你可能想不到，一个简单的功能，会被写成十几个 `if else` 判断，或是三四层嵌套的 `for` 循环。\n\n上班的本质是挣钱糊口，不是为了靠技术“装X”——反正最后把东西做出来不就行了？大多数人抱着这样的想法，其实没什么错。\n\n可要是自己技术本就一般，还天天把“我到瓶颈期了”挂在嘴边，那就多少有点贻笑大方了。\n\n现在的开发工作，说穿了就是“搬砖”：把“砖头”（功能模块）放到早已搭好的框架里。像基础功能，早就靠脚手架实现了，不用再自己“刀耕火种造轮子”。这种开发模式确实给开发者省了不少事，对新手尤其友好，几乎是“有手就能做”。\n\n但方便的同时，也弱化了开发者亲手造轮子、写底层代码的能力。比如有些人用Vue写页面驾轻就熟，用element-plus也炉火纯青，可真要让他写一个Vue指令，或是开发一个Vite插件，却瞬间两眼发懵、面露难色。\n\n说到底，还是基础不够扎实。对框架、工具的理解，还停留在“只会用少数几个功能”的层面，既没去深究背后的原理，也没尝试过模仿或拓展它们的功能——这才是问题的核心。\n\n\n## 知识的混乱\n技术在不断迭代，新框架、新工具也总是层出不穷。作为开发者，要是没有一套清晰的知识体系，日子会过得很糟糕。\n\n就拿Web开发举例，要学的东西可太多了：最基础的“三剑客”JS、CSS、HTML；然后是UI渲染框架Vue、React、Angular；还有打包工具Vite、Webpack、Rollup；页面要做网络数据交互，那HTTP、TCP相关协议也得学；更复杂的还有浏览器原理……而这些，还只是冰山一角——这里面随便拎出一样，都能写成几本字典厚的书。\n\n结果就是，学的东西多了，感觉什么都懂一点，可真要深入讲解，又说不出个所以然；再加上各种知识互相“串线”，脑子里乱得像一团缠打结的麻，连线头都找不到。而这种困惑，绝不是少数开发者的专利。\n\n衣服乱放，房间会乱；书本乱放，桌子会乱；知识“乱放”，脑子自然也会乱。\n\n\n## 如何打破瓶颈期\n不管是因为什么陷入所谓的“瓶颈期”，其实都该试着走出来。\n\n如果是受了委屈，或是觉得钱给少了，想用“摆烂”的工作状态默默抗争——其实完全没必要。与其在一个地方内耗，不如换个环境、挪个地方，心态也能跟着调整过来。\n\n至于基础不牢或是知识混乱，说来说去就一句话：“小老弟，你还得练”。该看网课就去看网课，该啃官网文档就啃文档，该梳理知识分类就认真梳理。只要把时间和努力实实在在投进去，改变自然会慢慢出现。","source":"_posts/bottleneck-porid.md","raw":"---\ntitle: 程序员如何打破职业瓶颈？先搬开这3块绊脚石。\ndate: 2025-10-19 21:46:02\ntags: 程序人生\nkeywords: 程序人生\nbanner_img: /imgs/baners/break.jfif\nindex_img: /imgs/baners/break.jfif\n---\n\n程序员的职业路不算长，可不少人早早就遇到了 “天花板”：想提升没方向，想突破没抓手，这就是让人头疼的 “瓶颈期”。是什么让我们陷入这种困境？又该怎么走出来？咱们一点点说清楚。\n\n## 摆烂心态\n在程序员不算长的职业生涯里，真正能实现能力跃升的黄金期，可能也就那么几年。但仅凭这几年积累的经验，在大厂“搬几年砖”解决户口问题，通常难度不大。\n\n从入职一家公司到从“新人”熬成“老油条”，快则半年到一年，慢则两年。为什么不会更久？试想，要是两年都没给你涨工资，你还会在领导面前刻意扮演“奋斗逼”吗？\n\n于是，很多人就此进入“摆烂模式”。佛系的工作态度，自然没法带来个人能力和技术的提升——摆烂心态，正是造成个人能力瓶颈的一大关键原因。\n\n\n## 基础不牢，地动山摇\n“这个世界就是个草台班子”，这句话你永远可以信。那些看似厉害的软件，说不定都是月薪几千块的外包（作者自己也曾是其中一员）写的；你可能想不到，一个简单的功能，会被写成十几个 `if else` 判断，或是三四层嵌套的 `for` 循环。\n\n上班的本质是挣钱糊口，不是为了靠技术“装X”——反正最后把东西做出来不就行了？大多数人抱着这样的想法，其实没什么错。\n\n可要是自己技术本就一般，还天天把“我到瓶颈期了”挂在嘴边，那就多少有点贻笑大方了。\n\n现在的开发工作，说穿了就是“搬砖”：把“砖头”（功能模块）放到早已搭好的框架里。像基础功能，早就靠脚手架实现了，不用再自己“刀耕火种造轮子”。这种开发模式确实给开发者省了不少事，对新手尤其友好，几乎是“有手就能做”。\n\n但方便的同时，也弱化了开发者亲手造轮子、写底层代码的能力。比如有些人用Vue写页面驾轻就熟，用element-plus也炉火纯青，可真要让他写一个Vue指令，或是开发一个Vite插件，却瞬间两眼发懵、面露难色。\n\n说到底，还是基础不够扎实。对框架、工具的理解，还停留在“只会用少数几个功能”的层面，既没去深究背后的原理，也没尝试过模仿或拓展它们的功能——这才是问题的核心。\n\n\n## 知识的混乱\n技术在不断迭代，新框架、新工具也总是层出不穷。作为开发者，要是没有一套清晰的知识体系，日子会过得很糟糕。\n\n就拿Web开发举例，要学的东西可太多了：最基础的“三剑客”JS、CSS、HTML；然后是UI渲染框架Vue、React、Angular；还有打包工具Vite、Webpack、Rollup；页面要做网络数据交互，那HTTP、TCP相关协议也得学；更复杂的还有浏览器原理……而这些，还只是冰山一角——这里面随便拎出一样，都能写成几本字典厚的书。\n\n结果就是，学的东西多了，感觉什么都懂一点，可真要深入讲解，又说不出个所以然；再加上各种知识互相“串线”，脑子里乱得像一团缠打结的麻，连线头都找不到。而这种困惑，绝不是少数开发者的专利。\n\n衣服乱放，房间会乱；书本乱放，桌子会乱；知识“乱放”，脑子自然也会乱。\n\n\n## 如何打破瓶颈期\n不管是因为什么陷入所谓的“瓶颈期”，其实都该试着走出来。\n\n如果是受了委屈，或是觉得钱给少了，想用“摆烂”的工作状态默默抗争——其实完全没必要。与其在一个地方内耗，不如换个环境、挪个地方，心态也能跟着调整过来。\n\n至于基础不牢或是知识混乱，说来说去就一句话：“小老弟，你还得练”。该看网课就去看网课，该啃官网文档就啃文档，该梳理知识分类就认真梳理。只要把时间和努力实实在在投进去，改变自然会慢慢出现。","slug":"bottleneck-porid","published":1,"updated":"2025-10-28T13:41:23.261Z","comments":1,"layout":"post","photos":[],"_id":"cmjbml2i4000iikupf4yaed5n","content":"<p>程序员的职业路不算长，可不少人早早就遇到了 “天花板”：想提升没方向，想突破没抓手，这就是让人头疼的 “瓶颈期”。是什么让我们陷入这种困境？又该怎么走出来？咱们一点点说清楚。</p>\n<h2 id=\"摆烂心态\"><a href=\"#摆烂心态\" class=\"headerlink\" title=\"摆烂心态\"></a>摆烂心态</h2><p>在程序员不算长的职业生涯里，真正能实现能力跃升的黄金期，可能也就那么几年。但仅凭这几年积累的经验，在大厂“搬几年砖”解决户口问题，通常难度不大。</p>\n<p>从入职一家公司到从“新人”熬成“老油条”，快则半年到一年，慢则两年。为什么不会更久？试想，要是两年都没给你涨工资，你还会在领导面前刻意扮演“奋斗逼”吗？</p>\n<p>于是，很多人就此进入“摆烂模式”。佛系的工作态度，自然没法带来个人能力和技术的提升——摆烂心态，正是造成个人能力瓶颈的一大关键原因。</p>\n<h2 id=\"基础不牢，地动山摇\"><a href=\"#基础不牢，地动山摇\" class=\"headerlink\" title=\"基础不牢，地动山摇\"></a>基础不牢，地动山摇</h2><p>“这个世界就是个草台班子”，这句话你永远可以信。那些看似厉害的软件，说不定都是月薪几千块的外包（作者自己也曾是其中一员）写的；你可能想不到，一个简单的功能，会被写成十几个 <code>if else</code> 判断，或是三四层嵌套的 <code>for</code> 循环。</p>\n<p>上班的本质是挣钱糊口，不是为了靠技术“装X”——反正最后把东西做出来不就行了？大多数人抱着这样的想法，其实没什么错。</p>\n<p>可要是自己技术本就一般，还天天把“我到瓶颈期了”挂在嘴边，那就多少有点贻笑大方了。</p>\n<p>现在的开发工作，说穿了就是“搬砖”：把“砖头”（功能模块）放到早已搭好的框架里。像基础功能，早就靠脚手架实现了，不用再自己“刀耕火种造轮子”。这种开发模式确实给开发者省了不少事，对新手尤其友好，几乎是“有手就能做”。</p>\n<p>但方便的同时，也弱化了开发者亲手造轮子、写底层代码的能力。比如有些人用Vue写页面驾轻就熟，用element-plus也炉火纯青，可真要让他写一个Vue指令，或是开发一个Vite插件，却瞬间两眼发懵、面露难色。</p>\n<p>说到底，还是基础不够扎实。对框架、工具的理解，还停留在“只会用少数几个功能”的层面，既没去深究背后的原理，也没尝试过模仿或拓展它们的功能——这才是问题的核心。</p>\n<h2 id=\"知识的混乱\"><a href=\"#知识的混乱\" class=\"headerlink\" title=\"知识的混乱\"></a>知识的混乱</h2><p>技术在不断迭代，新框架、新工具也总是层出不穷。作为开发者，要是没有一套清晰的知识体系，日子会过得很糟糕。</p>\n<p>就拿Web开发举例，要学的东西可太多了：最基础的“三剑客”JS、CSS、HTML；然后是UI渲染框架Vue、React、Angular；还有打包工具Vite、Webpack、Rollup；页面要做网络数据交互，那HTTP、TCP相关协议也得学；更复杂的还有浏览器原理……而这些，还只是冰山一角——这里面随便拎出一样，都能写成几本字典厚的书。</p>\n<p>结果就是，学的东西多了，感觉什么都懂一点，可真要深入讲解，又说不出个所以然；再加上各种知识互相“串线”，脑子里乱得像一团缠打结的麻，连线头都找不到。而这种困惑，绝不是少数开发者的专利。</p>\n<p>衣服乱放，房间会乱；书本乱放，桌子会乱；知识“乱放”，脑子自然也会乱。</p>\n<h2 id=\"如何打破瓶颈期\"><a href=\"#如何打破瓶颈期\" class=\"headerlink\" title=\"如何打破瓶颈期\"></a>如何打破瓶颈期</h2><p>不管是因为什么陷入所谓的“瓶颈期”，其实都该试着走出来。</p>\n<p>如果是受了委屈，或是觉得钱给少了，想用“摆烂”的工作状态默默抗争——其实完全没必要。与其在一个地方内耗，不如换个环境、挪个地方，心态也能跟着调整过来。</p>\n<p>至于基础不牢或是知识混乱，说来说去就一句话：“小老弟，你还得练”。该看网课就去看网课，该啃官网文档就啃文档，该梳理知识分类就认真梳理。只要把时间和努力实实在在投进去，改变自然会慢慢出现。</p>\n","excerpt":"","more":"<p>程序员的职业路不算长，可不少人早早就遇到了 “天花板”：想提升没方向，想突破没抓手，这就是让人头疼的 “瓶颈期”。是什么让我们陷入这种困境？又该怎么走出来？咱们一点点说清楚。</p>\n<h2 id=\"摆烂心态\"><a href=\"#摆烂心态\" class=\"headerlink\" title=\"摆烂心态\"></a>摆烂心态</h2><p>在程序员不算长的职业生涯里，真正能实现能力跃升的黄金期，可能也就那么几年。但仅凭这几年积累的经验，在大厂“搬几年砖”解决户口问题，通常难度不大。</p>\n<p>从入职一家公司到从“新人”熬成“老油条”，快则半年到一年，慢则两年。为什么不会更久？试想，要是两年都没给你涨工资，你还会在领导面前刻意扮演“奋斗逼”吗？</p>\n<p>于是，很多人就此进入“摆烂模式”。佛系的工作态度，自然没法带来个人能力和技术的提升——摆烂心态，正是造成个人能力瓶颈的一大关键原因。</p>\n<h2 id=\"基础不牢，地动山摇\"><a href=\"#基础不牢，地动山摇\" class=\"headerlink\" title=\"基础不牢，地动山摇\"></a>基础不牢，地动山摇</h2><p>“这个世界就是个草台班子”，这句话你永远可以信。那些看似厉害的软件，说不定都是月薪几千块的外包（作者自己也曾是其中一员）写的；你可能想不到，一个简单的功能，会被写成十几个 <code>if else</code> 判断，或是三四层嵌套的 <code>for</code> 循环。</p>\n<p>上班的本质是挣钱糊口，不是为了靠技术“装X”——反正最后把东西做出来不就行了？大多数人抱着这样的想法，其实没什么错。</p>\n<p>可要是自己技术本就一般，还天天把“我到瓶颈期了”挂在嘴边，那就多少有点贻笑大方了。</p>\n<p>现在的开发工作，说穿了就是“搬砖”：把“砖头”（功能模块）放到早已搭好的框架里。像基础功能，早就靠脚手架实现了，不用再自己“刀耕火种造轮子”。这种开发模式确实给开发者省了不少事，对新手尤其友好，几乎是“有手就能做”。</p>\n<p>但方便的同时，也弱化了开发者亲手造轮子、写底层代码的能力。比如有些人用Vue写页面驾轻就熟，用element-plus也炉火纯青，可真要让他写一个Vue指令，或是开发一个Vite插件，却瞬间两眼发懵、面露难色。</p>\n<p>说到底，还是基础不够扎实。对框架、工具的理解，还停留在“只会用少数几个功能”的层面，既没去深究背后的原理，也没尝试过模仿或拓展它们的功能——这才是问题的核心。</p>\n<h2 id=\"知识的混乱\"><a href=\"#知识的混乱\" class=\"headerlink\" title=\"知识的混乱\"></a>知识的混乱</h2><p>技术在不断迭代，新框架、新工具也总是层出不穷。作为开发者，要是没有一套清晰的知识体系，日子会过得很糟糕。</p>\n<p>就拿Web开发举例，要学的东西可太多了：最基础的“三剑客”JS、CSS、HTML；然后是UI渲染框架Vue、React、Angular；还有打包工具Vite、Webpack、Rollup；页面要做网络数据交互，那HTTP、TCP相关协议也得学；更复杂的还有浏览器原理……而这些，还只是冰山一角——这里面随便拎出一样，都能写成几本字典厚的书。</p>\n<p>结果就是，学的东西多了，感觉什么都懂一点，可真要深入讲解，又说不出个所以然；再加上各种知识互相“串线”，脑子里乱得像一团缠打结的麻，连线头都找不到。而这种困惑，绝不是少数开发者的专利。</p>\n<p>衣服乱放，房间会乱；书本乱放，桌子会乱；知识“乱放”，脑子自然也会乱。</p>\n<h2 id=\"如何打破瓶颈期\"><a href=\"#如何打破瓶颈期\" class=\"headerlink\" title=\"如何打破瓶颈期\"></a>如何打破瓶颈期</h2><p>不管是因为什么陷入所谓的“瓶颈期”，其实都该试着走出来。</p>\n<p>如果是受了委屈，或是觉得钱给少了，想用“摆烂”的工作状态默默抗争——其实完全没必要。与其在一个地方内耗，不如换个环境、挪个地方，心态也能跟着调整过来。</p>\n<p>至于基础不牢或是知识混乱，说来说去就一句话：“小老弟，你还得练”。该看网课就去看网课，该啃官网文档就啃文档，该梳理知识分类就认真梳理。只要把时间和努力实实在在投进去，改变自然会慢慢出现。</p>\n"},{"title":"搭建个人博客系列--(1) 为什么每个人都该有个数字自留地","date":"2025-05-25T05:40:00.000Z","keywords":["博客搭建","免费博客平台","托管博客","模板建站"],"index_img":"imgs/build-blog1/blog1.jpg","banner_img":"imgs/build-blog1/blog1.jpg","_content":"\n从2017年写第一篇博客，到现在已经过去8个年头了。\n\n期间在不同的平台也写过不少的博客，写了又删，删了有些，留下来的其实也没有多少。\n\n这么多年后，为什么我又和许多人一样，重新开辟自己已经荒芜的自留地？\n\n### 为什么写博客\n\n\n我清晰的记得，我写第一篇博客时的心情，以及那种纯粹的对知识的分享欲。那是一篇在我解决一个困扰我很久的问题之后写下关于[虚拟机安装](https://zhuanlan.zhihu.com/p/26994950)的博客，当时是在知乎上发的。只是让我没想到的是，它至今仍然是我博客中浏览量最高的一篇，有将近30w的浏览量。\n\n纯粹的知识的分享，以及那种来自他人对自己工作的认同感，以及由此产生的成就感，是一促使一个人坚持写博客的主要动力。\n\n![](../imgs/build-blog1/blog2.jpg)\n\n写博客锻炼一个人的表达。在写博客的过程中，尤其是刚开始时，刚经常容易提笔忘字，没有想好如何表达。写得久了，表达上也变得变得清晰，变得通畅。\n\n写博客让人思考，了解自我。写作其实是一件蛮费时间和精力的事情，尤其是当自己需要向别人阐述一件事情，让对方尽可能明白自己在说什么。但写着写着，似乎长时间来，这样的坚持也并没有最初那么难受了。并且，当他人没有理解到自己所表达的意思时，也没有想象中那么郁闷，能够接受自己偶尔不被理解的样。\n\n\n### 程序员写博客的必要性\n\n一个优秀的程序员往往也是一个好的博主。写博客并不需要多门高大上的内容，也不需要华丽的辞藻堆砌。用简洁易懂的语言，把一件事记录好，表达清楚，就OKay了，就像代码一样。\n\n开发过程遇见的问题，搭建环境中遇到的各种坑，都可以作为一篇博客或者系列博客的材料。\n\n![](../imgs/build-blog1/blog6.jpg)\n时间久了，所记录下的一篇篇博客，就不仅仅是简单的博客了，而是自己开发路上成长的最好的见证者。\n\n当你有时候翻看以前博客，嘴中呢喃‘以前怎么这么菜’，觉得眼前博客拿不出手时，那么就说明你真正进步了，也成长了。\n\n### 搭建自己的数字自留地\n\n如今写博客的平台很多，像大家熟知的博客园、CSND、掘金还有思否等。\n\n像博客园这种比较有怀旧情怀的，上面其实还是有蛮多干货的，我个人也特别中意里面的一些怀旧博客主题，不过这几年好像整体流量不及其它平台了。\n\nCSDN的话相对来说对刚刚开始创作博客的人来说比较友好，流量相对来说也大一些，不过毛病也很明显。广告多了些，再就是内容相互抄袭还是比较严重的\n\n至于像掘金和思否，接触相对较少，所以了解不是别多。不过掘金这几年弄得挺不错的，身边蛮多互联网大佬对这个平台评价都挺蛮好的。\n\n![](../imgs/build-blog1/blog4.jpg)\n\n虽然平台选择很多，但依然会有很多博主像作者一样，选择自己搭建自己的独立博客。\n\n不管你是把它打算经营成一个热门博客站点，还是做一个安静记录自己所思所想的树洞，都是你自己说了算。在自己的博客站里，自己就是这里的王。\n\n在搭建博客站点中，你会学习到许多的知识点，接触和使用到许多搭建站点的工具。在自己经过一番折腾，成功搭建起这块独属于自己的数字自留地的时候，心中也会颇有一番成就感。\n\n\n### 写在最后\n\n在这个系列后续的文章中，我将会详细的讲解搭建博客站点的每一个步骤。从技术选型，到本地博客，再到自动化部署，以及如何优雅的实现自己的博客域名，我尽可能的把每一个自己踩过的坑都讲清楚，让所有读者都少走一些弯路。\n\n如果你有什么好的想法或者问题，可以留言或者关注我的公众号“我做开发那些年”，我们一起交流。","source":"_posts/build-personal-blog-1.md","raw":"---\ntitle: 搭建个人博客系列--(1) 为什么每个人都该有个数字自留地\ndate: 2025-05-25 13:40:00\ncategory: 搭建博客\ntags: \n   - 博客搭建\n   - 个人IP\nkeywords: [博客搭建, 免费博客平台, 托管博客, 模板建站]\nindex_img: imgs/build-blog1/blog1.jpg\nbanner_img: imgs/build-blog1/blog1.jpg\n---\n\n从2017年写第一篇博客，到现在已经过去8个年头了。\n\n期间在不同的平台也写过不少的博客，写了又删，删了有些，留下来的其实也没有多少。\n\n这么多年后，为什么我又和许多人一样，重新开辟自己已经荒芜的自留地？\n\n### 为什么写博客\n\n\n我清晰的记得，我写第一篇博客时的心情，以及那种纯粹的对知识的分享欲。那是一篇在我解决一个困扰我很久的问题之后写下关于[虚拟机安装](https://zhuanlan.zhihu.com/p/26994950)的博客，当时是在知乎上发的。只是让我没想到的是，它至今仍然是我博客中浏览量最高的一篇，有将近30w的浏览量。\n\n纯粹的知识的分享，以及那种来自他人对自己工作的认同感，以及由此产生的成就感，是一促使一个人坚持写博客的主要动力。\n\n![](../imgs/build-blog1/blog2.jpg)\n\n写博客锻炼一个人的表达。在写博客的过程中，尤其是刚开始时，刚经常容易提笔忘字，没有想好如何表达。写得久了，表达上也变得变得清晰，变得通畅。\n\n写博客让人思考，了解自我。写作其实是一件蛮费时间和精力的事情，尤其是当自己需要向别人阐述一件事情，让对方尽可能明白自己在说什么。但写着写着，似乎长时间来，这样的坚持也并没有最初那么难受了。并且，当他人没有理解到自己所表达的意思时，也没有想象中那么郁闷，能够接受自己偶尔不被理解的样。\n\n\n### 程序员写博客的必要性\n\n一个优秀的程序员往往也是一个好的博主。写博客并不需要多门高大上的内容，也不需要华丽的辞藻堆砌。用简洁易懂的语言，把一件事记录好，表达清楚，就OKay了，就像代码一样。\n\n开发过程遇见的问题，搭建环境中遇到的各种坑，都可以作为一篇博客或者系列博客的材料。\n\n![](../imgs/build-blog1/blog6.jpg)\n时间久了，所记录下的一篇篇博客，就不仅仅是简单的博客了，而是自己开发路上成长的最好的见证者。\n\n当你有时候翻看以前博客，嘴中呢喃‘以前怎么这么菜’，觉得眼前博客拿不出手时，那么就说明你真正进步了，也成长了。\n\n### 搭建自己的数字自留地\n\n如今写博客的平台很多，像大家熟知的博客园、CSND、掘金还有思否等。\n\n像博客园这种比较有怀旧情怀的，上面其实还是有蛮多干货的，我个人也特别中意里面的一些怀旧博客主题，不过这几年好像整体流量不及其它平台了。\n\nCSDN的话相对来说对刚刚开始创作博客的人来说比较友好，流量相对来说也大一些，不过毛病也很明显。广告多了些，再就是内容相互抄袭还是比较严重的\n\n至于像掘金和思否，接触相对较少，所以了解不是别多。不过掘金这几年弄得挺不错的，身边蛮多互联网大佬对这个平台评价都挺蛮好的。\n\n![](../imgs/build-blog1/blog4.jpg)\n\n虽然平台选择很多，但依然会有很多博主像作者一样，选择自己搭建自己的独立博客。\n\n不管你是把它打算经营成一个热门博客站点，还是做一个安静记录自己所思所想的树洞，都是你自己说了算。在自己的博客站里，自己就是这里的王。\n\n在搭建博客站点中，你会学习到许多的知识点，接触和使用到许多搭建站点的工具。在自己经过一番折腾，成功搭建起这块独属于自己的数字自留地的时候，心中也会颇有一番成就感。\n\n\n### 写在最后\n\n在这个系列后续的文章中，我将会详细的讲解搭建博客站点的每一个步骤。从技术选型，到本地博客，再到自动化部署，以及如何优雅的实现自己的博客域名，我尽可能的把每一个自己踩过的坑都讲清楚，让所有读者都少走一些弯路。\n\n如果你有什么好的想法或者问题，可以留言或者关注我的公众号“我做开发那些年”，我们一起交流。","slug":"build-personal-blog-1","published":1,"updated":"2025-08-26T10:14:36.206Z","comments":1,"layout":"post","photos":[],"_id":"cmjbml2i5000likup3zhi9y11","content":"<p>从2017年写第一篇博客，到现在已经过去8个年头了。</p>\n<p>期间在不同的平台也写过不少的博客，写了又删，删了有些，留下来的其实也没有多少。</p>\n<p>这么多年后，为什么我又和许多人一样，重新开辟自己已经荒芜的自留地？</p>\n<h3 id=\"为什么写博客\"><a href=\"#为什么写博客\" class=\"headerlink\" title=\"为什么写博客\"></a>为什么写博客</h3><p>我清晰的记得，我写第一篇博客时的心情，以及那种纯粹的对知识的分享欲。那是一篇在我解决一个困扰我很久的问题之后写下关于<a href=\"https://zhuanlan.zhihu.com/p/26994950\">虚拟机安装</a>的博客，当时是在知乎上发的。只是让我没想到的是，它至今仍然是我博客中浏览量最高的一篇，有将近30w的浏览量。</p>\n<p>纯粹的知识的分享，以及那种来自他人对自己工作的认同感，以及由此产生的成就感，是一促使一个人坚持写博客的主要动力。</p>\n<p><img src=\"/../imgs/build-blog1/blog2.jpg\"></p>\n<p>写博客锻炼一个人的表达。在写博客的过程中，尤其是刚开始时，刚经常容易提笔忘字，没有想好如何表达。写得久了，表达上也变得变得清晰，变得通畅。</p>\n<p>写博客让人思考，了解自我。写作其实是一件蛮费时间和精力的事情，尤其是当自己需要向别人阐述一件事情，让对方尽可能明白自己在说什么。但写着写着，似乎长时间来，这样的坚持也并没有最初那么难受了。并且，当他人没有理解到自己所表达的意思时，也没有想象中那么郁闷，能够接受自己偶尔不被理解的样。</p>\n<h3 id=\"程序员写博客的必要性\"><a href=\"#程序员写博客的必要性\" class=\"headerlink\" title=\"程序员写博客的必要性\"></a>程序员写博客的必要性</h3><p>一个优秀的程序员往往也是一个好的博主。写博客并不需要多门高大上的内容，也不需要华丽的辞藻堆砌。用简洁易懂的语言，把一件事记录好，表达清楚，就OKay了，就像代码一样。</p>\n<p>开发过程遇见的问题，搭建环境中遇到的各种坑，都可以作为一篇博客或者系列博客的材料。</p>\n<p><img src=\"/../imgs/build-blog1/blog6.jpg\"><br>时间久了，所记录下的一篇篇博客，就不仅仅是简单的博客了，而是自己开发路上成长的最好的见证者。</p>\n<p>当你有时候翻看以前博客，嘴中呢喃‘以前怎么这么菜’，觉得眼前博客拿不出手时，那么就说明你真正进步了，也成长了。</p>\n<h3 id=\"搭建自己的数字自留地\"><a href=\"#搭建自己的数字自留地\" class=\"headerlink\" title=\"搭建自己的数字自留地\"></a>搭建自己的数字自留地</h3><p>如今写博客的平台很多，像大家熟知的博客园、CSND、掘金还有思否等。</p>\n<p>像博客园这种比较有怀旧情怀的，上面其实还是有蛮多干货的，我个人也特别中意里面的一些怀旧博客主题，不过这几年好像整体流量不及其它平台了。</p>\n<p>CSDN的话相对来说对刚刚开始创作博客的人来说比较友好，流量相对来说也大一些，不过毛病也很明显。广告多了些，再就是内容相互抄袭还是比较严重的</p>\n<p>至于像掘金和思否，接触相对较少，所以了解不是别多。不过掘金这几年弄得挺不错的，身边蛮多互联网大佬对这个平台评价都挺蛮好的。</p>\n<p><img src=\"/../imgs/build-blog1/blog4.jpg\"></p>\n<p>虽然平台选择很多，但依然会有很多博主像作者一样，选择自己搭建自己的独立博客。</p>\n<p>不管你是把它打算经营成一个热门博客站点，还是做一个安静记录自己所思所想的树洞，都是你自己说了算。在自己的博客站里，自己就是这里的王。</p>\n<p>在搭建博客站点中，你会学习到许多的知识点，接触和使用到许多搭建站点的工具。在自己经过一番折腾，成功搭建起这块独属于自己的数字自留地的时候，心中也会颇有一番成就感。</p>\n<h3 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h3><p>在这个系列后续的文章中，我将会详细的讲解搭建博客站点的每一个步骤。从技术选型，到本地博客，再到自动化部署，以及如何优雅的实现自己的博客域名，我尽可能的把每一个自己踩过的坑都讲清楚，让所有读者都少走一些弯路。</p>\n<p>如果你有什么好的想法或者问题，可以留言或者关注我的公众号“我做开发那些年”，我们一起交流。</p>\n","excerpt":"","more":"<p>从2017年写第一篇博客，到现在已经过去8个年头了。</p>\n<p>期间在不同的平台也写过不少的博客，写了又删，删了有些，留下来的其实也没有多少。</p>\n<p>这么多年后，为什么我又和许多人一样，重新开辟自己已经荒芜的自留地？</p>\n<h3 id=\"为什么写博客\"><a href=\"#为什么写博客\" class=\"headerlink\" title=\"为什么写博客\"></a>为什么写博客</h3><p>我清晰的记得，我写第一篇博客时的心情，以及那种纯粹的对知识的分享欲。那是一篇在我解决一个困扰我很久的问题之后写下关于<a href=\"https://zhuanlan.zhihu.com/p/26994950\">虚拟机安装</a>的博客，当时是在知乎上发的。只是让我没想到的是，它至今仍然是我博客中浏览量最高的一篇，有将近30w的浏览量。</p>\n<p>纯粹的知识的分享，以及那种来自他人对自己工作的认同感，以及由此产生的成就感，是一促使一个人坚持写博客的主要动力。</p>\n<p><img src=\"/../imgs/build-blog1/blog2.jpg\"></p>\n<p>写博客锻炼一个人的表达。在写博客的过程中，尤其是刚开始时，刚经常容易提笔忘字，没有想好如何表达。写得久了，表达上也变得变得清晰，变得通畅。</p>\n<p>写博客让人思考，了解自我。写作其实是一件蛮费时间和精力的事情，尤其是当自己需要向别人阐述一件事情，让对方尽可能明白自己在说什么。但写着写着，似乎长时间来，这样的坚持也并没有最初那么难受了。并且，当他人没有理解到自己所表达的意思时，也没有想象中那么郁闷，能够接受自己偶尔不被理解的样。</p>\n<h3 id=\"程序员写博客的必要性\"><a href=\"#程序员写博客的必要性\" class=\"headerlink\" title=\"程序员写博客的必要性\"></a>程序员写博客的必要性</h3><p>一个优秀的程序员往往也是一个好的博主。写博客并不需要多门高大上的内容，也不需要华丽的辞藻堆砌。用简洁易懂的语言，把一件事记录好，表达清楚，就OKay了，就像代码一样。</p>\n<p>开发过程遇见的问题，搭建环境中遇到的各种坑，都可以作为一篇博客或者系列博客的材料。</p>\n<p><img src=\"/../imgs/build-blog1/blog6.jpg\"><br>时间久了，所记录下的一篇篇博客，就不仅仅是简单的博客了，而是自己开发路上成长的最好的见证者。</p>\n<p>当你有时候翻看以前博客，嘴中呢喃‘以前怎么这么菜’，觉得眼前博客拿不出手时，那么就说明你真正进步了，也成长了。</p>\n<h3 id=\"搭建自己的数字自留地\"><a href=\"#搭建自己的数字自留地\" class=\"headerlink\" title=\"搭建自己的数字自留地\"></a>搭建自己的数字自留地</h3><p>如今写博客的平台很多，像大家熟知的博客园、CSND、掘金还有思否等。</p>\n<p>像博客园这种比较有怀旧情怀的，上面其实还是有蛮多干货的，我个人也特别中意里面的一些怀旧博客主题，不过这几年好像整体流量不及其它平台了。</p>\n<p>CSDN的话相对来说对刚刚开始创作博客的人来说比较友好，流量相对来说也大一些，不过毛病也很明显。广告多了些，再就是内容相互抄袭还是比较严重的</p>\n<p>至于像掘金和思否，接触相对较少，所以了解不是别多。不过掘金这几年弄得挺不错的，身边蛮多互联网大佬对这个平台评价都挺蛮好的。</p>\n<p><img src=\"/../imgs/build-blog1/blog4.jpg\"></p>\n<p>虽然平台选择很多，但依然会有很多博主像作者一样，选择自己搭建自己的独立博客。</p>\n<p>不管你是把它打算经营成一个热门博客站点，还是做一个安静记录自己所思所想的树洞，都是你自己说了算。在自己的博客站里，自己就是这里的王。</p>\n<p>在搭建博客站点中，你会学习到许多的知识点，接触和使用到许多搭建站点的工具。在自己经过一番折腾，成功搭建起这块独属于自己的数字自留地的时候，心中也会颇有一番成就感。</p>\n<h3 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h3><p>在这个系列后续的文章中，我将会详细的讲解搭建博客站点的每一个步骤。从技术选型，到本地博客，再到自动化部署，以及如何优雅的实现自己的博客域名，我尽可能的把每一个自己踩过的坑都讲清楚，让所有读者都少走一些弯路。</p>\n<p>如果你有什么好的想法或者问题，可以留言或者关注我的公众号“我做开发那些年”，我们一起交流。</p>\n"},{"title":"搭建个人博客系列--(2) 动手搭建自己的第一个博客站点","date":"2025-05-27T13:02:53.000Z","keywords":["博客搭建","免费博客平台","托管博客","模板建站"],"index_img":"imgs/build-blog1/blog2.jpg","banner_img":"imgs/build-blog1/blog2.jpg","_content":"\n在上文[什么每个人都该有个数字自留地](./build-personal-blog1.md)中讲解了为什么我们要写博客以及为什么要搭建自己的独立博客，今天我们将要撸起袖子，开始干活了。认真看完本文，按照文中的步骤去做，你将拥有一个属于你自己的博客站点。\n\n## 搭建博客的几种方式\n\n说到博客，不熟悉的人对它的印象可能是微博，QQ空间日志，以及如CSDN，博客园之类的站点的样子，功能丰富，用户上手也快，一部手机就能完成所有的事情。\n\n上面所提到的站点，都是标准的商业型应用了，而作为个人，没有必要浪费过多时间在各种花哨功能构建上。\n\n个人博客，最重要的是内容，是价值输出！\n\n目前呢，搭建个人博客的方式主要有以下几种：\n\n  - **社区平台**：像`博客园`，`CSDN`, `知乎`，`微博`，`公众号`，`QQ空间`等，注册一个账号就Okay了。当然了，既然是社区平台，也就意味着没有独立的网站。\n\n  - **独立博客**: 有自己的网站，博客框架的搭建，内容的发布，都是由自己完成。对未接触过编程的人来说，上手有一定难度。比较适合有一定编程基础，然后又想挑战一下自己那种的同学。\n\n作为一个明日的大佬，自己动手整个独立博客，想必对大家来说也不是什么难事。\n\n## 考虑因素\n\n既然选择建独立博客，那么我们需要考虑以下几个问题了：\n\n  - 是否需要建立数据库，使用前后端配合的方式完成博客的增删改查？\n  - 是否考虑购买服务器，还是进行服务托管?\n  - 打算投入多少时间和金钱去建站?\n \n\n在考虑这些问题的时候，同时问问自己，自己的博客是否需要很多功能，还是作为一个简单记录自己所思所想的自由平台。\n\n个人认为，作为程序员，简洁就是最好的风格！\n\n因此，我更倾向选择的是不使用前后端，使用静态内容托管的方式来搭建自己的博客。正如前面所说的，一个个人博客站重要的是内容输出，戏台子搭得大和漂亮没有多少用，重要的是你的戏是否能够吸引观众。\n\n## 技术选型\n\n既然是使用静态托管平台，那么可供选择的方案有很多：\n  \n  - **[GitHub Pages](https://pages.github.com/)**: 自带域名可 https 访问; 可配置自定义域名\n  - **[Bitbucket Cloud](https://confluence.atlassian.com/bitbucket/publishing-a-website-on-bitbucket-cloud-221449776.html)**: 能且只能通过 https 协议访问; 无法自定义域名\n  - **[GitLab Pages](https://docs.gitlab.com/ee/user/project/pages/index.html)**: 同样跟 GitHub Pages 的功能一样\n  - **[Netlify](https://www.netlify.com/)**: 可以使用 CLI 上传代码; 支持自动构建\n\n在这里，比较推荐 Github Page 和 Netlify, 主要原因有两个：一个是比较能装，另一个是比较能装！\n\n## Github page 建站\n\n下面演示一下Github Page生成一个简单的个人站点名称，Netlify 可以自行探索一下，这里不做讲解。\n\n使用Github Page 建站，首先，你需要有一个Github 账号，如果没有，先去注册一个，注册时记得取个好一点的名字，后面有用。\n\n- **登录github, 新建一个与你名字同名的repository**\n\n登录到Github首页之后，点击右上角 `+` 号，选择 `new repository` 跳转到新建仓库页面。\n\n![step1](https://image.baidu.com/search/down?url=https://tvax4.sinaimg.cn/large/0071fJItgy1i21b6hl5rlj31i70xpe0n.jpg)\n\n其中，`repository name` 一定要是 `你的英文名称.github.io`，比如我的英文名称是`jvxiaome`， 那么我的仓库名称就是 `jvxiaome.github.io`，这个后面也是访问博客站点首页的网址，所以前面说取一个好听的名字，是有道理的。\n\n仓库的可见性选择 `Public`, 另外下面的 `Add a README file` 也可以勾上，会方便一些，至于剩下的内容，看个人需要，不清楚的可以暂时不填，最后确认 `Create repository`。\n\n\n\n![step2](https://image.baidu.com/search/down?url=http://tvax3.sinaimg.cn/large/0071fJItgy1i21ba20naej31aa1ah1ba.jpg)\n\n\n- **编辑一个你的博客主页**\n\n进入到刚刚新建的仓库，点击`add file` 新建一个文件\n\n\n![step3](https://image.baidu.com/search/down?url=http://tvax2.sinaimg.cn/large/0071fJItgy1i21batizraj31gl0ufn95.jpg)\n\n文件名称取名为 `index.html`, 这个文件中包含的就是博客主页的内容了，具体想写什么可以自由发挥\n\n![step4](https://image.baidu.com/search/down?url=http://tvax4.sinaimg.cn/large/0071fJItgy1i21bb808bfj31zr0thgzj.jpg)\n\n写完之后点击 `commit changes` 提交内容到仓库，到这一步，你的博客站就算是基本建立起来了\n![step5](https://image.baidu.com/search/down?url=http://tvax2.sinaimg.cn/large/0071fJItgy1i21bc83oxuj31eu0vyduh.jpg)\n\n\n- **访问验证**\n\n既然博客站点已经建好了，此时是不是特别期待访问自己的博客首页呢。\n\n正如前面所说的，你的仓库名称（你的英文名称.github.io）就是你的博客首页名称，以上面的例子来说，访问 `jvxiaome.github.io` 就能直接看见首页效果了。\n\n虽然整个页面都在诉说着朴素(~~丑~~)，但一点也不影响你拥有一个属于自己博客站点的那份喜悦。都18+了，怎么能没有自己的网站呢。\n\n![step6](https://image.baidu.com/search/down?url=http://tvax3.sinaimg.cn/large/0071fJItgy1i21bcpjfruj310d0k2go1.jpg)\n\n## 写在最后\n\n有了自己的博客网站，还有了域名，而这一切，不是个结束，而是开始。\n\n如何使用工具，使用主题，搭建一个简洁，漂亮的[博客网站](![my-sit](https://image.baidu.com/search/down?url=http://tvax1.sinaimg.cn/large/0071fJItgy1i21bddtgjjj32cu1h8x6q.jpg))，这将是下一篇文中的重点。\n\n\n\n\n\n\n<!-- https://github.com/lmk123/blog/issues/55 -->\n\n","source":"_posts/build-personal-blog2.md","raw":"---\ntitle: 搭建个人博客系列--(2) 动手搭建自己的第一个博客站点\ndate: 2025-05-27 21:02:53\ncategory: 搭建博客\ntags: \n   - 博客搭建\n   - 个人IP\nkeywords: [博客搭建, 免费博客平台, 托管博客, 模板建站]\nindex_img: imgs/build-blog1/blog2.jpg\nbanner_img: imgs/build-blog1/blog2.jpg\n---\n\n在上文[什么每个人都该有个数字自留地](./build-personal-blog1.md)中讲解了为什么我们要写博客以及为什么要搭建自己的独立博客，今天我们将要撸起袖子，开始干活了。认真看完本文，按照文中的步骤去做，你将拥有一个属于你自己的博客站点。\n\n## 搭建博客的几种方式\n\n说到博客，不熟悉的人对它的印象可能是微博，QQ空间日志，以及如CSDN，博客园之类的站点的样子，功能丰富，用户上手也快，一部手机就能完成所有的事情。\n\n上面所提到的站点，都是标准的商业型应用了，而作为个人，没有必要浪费过多时间在各种花哨功能构建上。\n\n个人博客，最重要的是内容，是价值输出！\n\n目前呢，搭建个人博客的方式主要有以下几种：\n\n  - **社区平台**：像`博客园`，`CSDN`, `知乎`，`微博`，`公众号`，`QQ空间`等，注册一个账号就Okay了。当然了，既然是社区平台，也就意味着没有独立的网站。\n\n  - **独立博客**: 有自己的网站，博客框架的搭建，内容的发布，都是由自己完成。对未接触过编程的人来说，上手有一定难度。比较适合有一定编程基础，然后又想挑战一下自己那种的同学。\n\n作为一个明日的大佬，自己动手整个独立博客，想必对大家来说也不是什么难事。\n\n## 考虑因素\n\n既然选择建独立博客，那么我们需要考虑以下几个问题了：\n\n  - 是否需要建立数据库，使用前后端配合的方式完成博客的增删改查？\n  - 是否考虑购买服务器，还是进行服务托管?\n  - 打算投入多少时间和金钱去建站?\n \n\n在考虑这些问题的时候，同时问问自己，自己的博客是否需要很多功能，还是作为一个简单记录自己所思所想的自由平台。\n\n个人认为，作为程序员，简洁就是最好的风格！\n\n因此，我更倾向选择的是不使用前后端，使用静态内容托管的方式来搭建自己的博客。正如前面所说的，一个个人博客站重要的是内容输出，戏台子搭得大和漂亮没有多少用，重要的是你的戏是否能够吸引观众。\n\n## 技术选型\n\n既然是使用静态托管平台，那么可供选择的方案有很多：\n  \n  - **[GitHub Pages](https://pages.github.com/)**: 自带域名可 https 访问; 可配置自定义域名\n  - **[Bitbucket Cloud](https://confluence.atlassian.com/bitbucket/publishing-a-website-on-bitbucket-cloud-221449776.html)**: 能且只能通过 https 协议访问; 无法自定义域名\n  - **[GitLab Pages](https://docs.gitlab.com/ee/user/project/pages/index.html)**: 同样跟 GitHub Pages 的功能一样\n  - **[Netlify](https://www.netlify.com/)**: 可以使用 CLI 上传代码; 支持自动构建\n\n在这里，比较推荐 Github Page 和 Netlify, 主要原因有两个：一个是比较能装，另一个是比较能装！\n\n## Github page 建站\n\n下面演示一下Github Page生成一个简单的个人站点名称，Netlify 可以自行探索一下，这里不做讲解。\n\n使用Github Page 建站，首先，你需要有一个Github 账号，如果没有，先去注册一个，注册时记得取个好一点的名字，后面有用。\n\n- **登录github, 新建一个与你名字同名的repository**\n\n登录到Github首页之后，点击右上角 `+` 号，选择 `new repository` 跳转到新建仓库页面。\n\n![step1](https://image.baidu.com/search/down?url=https://tvax4.sinaimg.cn/large/0071fJItgy1i21b6hl5rlj31i70xpe0n.jpg)\n\n其中，`repository name` 一定要是 `你的英文名称.github.io`，比如我的英文名称是`jvxiaome`， 那么我的仓库名称就是 `jvxiaome.github.io`，这个后面也是访问博客站点首页的网址，所以前面说取一个好听的名字，是有道理的。\n\n仓库的可见性选择 `Public`, 另外下面的 `Add a README file` 也可以勾上，会方便一些，至于剩下的内容，看个人需要，不清楚的可以暂时不填，最后确认 `Create repository`。\n\n\n\n![step2](https://image.baidu.com/search/down?url=http://tvax3.sinaimg.cn/large/0071fJItgy1i21ba20naej31aa1ah1ba.jpg)\n\n\n- **编辑一个你的博客主页**\n\n进入到刚刚新建的仓库，点击`add file` 新建一个文件\n\n\n![step3](https://image.baidu.com/search/down?url=http://tvax2.sinaimg.cn/large/0071fJItgy1i21batizraj31gl0ufn95.jpg)\n\n文件名称取名为 `index.html`, 这个文件中包含的就是博客主页的内容了，具体想写什么可以自由发挥\n\n![step4](https://image.baidu.com/search/down?url=http://tvax4.sinaimg.cn/large/0071fJItgy1i21bb808bfj31zr0thgzj.jpg)\n\n写完之后点击 `commit changes` 提交内容到仓库，到这一步，你的博客站就算是基本建立起来了\n![step5](https://image.baidu.com/search/down?url=http://tvax2.sinaimg.cn/large/0071fJItgy1i21bc83oxuj31eu0vyduh.jpg)\n\n\n- **访问验证**\n\n既然博客站点已经建好了，此时是不是特别期待访问自己的博客首页呢。\n\n正如前面所说的，你的仓库名称（你的英文名称.github.io）就是你的博客首页名称，以上面的例子来说，访问 `jvxiaome.github.io` 就能直接看见首页效果了。\n\n虽然整个页面都在诉说着朴素(~~丑~~)，但一点也不影响你拥有一个属于自己博客站点的那份喜悦。都18+了，怎么能没有自己的网站呢。\n\n![step6](https://image.baidu.com/search/down?url=http://tvax3.sinaimg.cn/large/0071fJItgy1i21bcpjfruj310d0k2go1.jpg)\n\n## 写在最后\n\n有了自己的博客网站，还有了域名，而这一切，不是个结束，而是开始。\n\n如何使用工具，使用主题，搭建一个简洁，漂亮的[博客网站](![my-sit](https://image.baidu.com/search/down?url=http://tvax1.sinaimg.cn/large/0071fJItgy1i21bddtgjjj32cu1h8x6q.jpg))，这将是下一篇文中的重点。\n\n\n\n\n\n\n<!-- https://github.com/lmk123/blog/issues/55 -->\n\n","slug":"build-personal-blog2","published":1,"updated":"2025-08-26T10:15:22.050Z","comments":1,"layout":"post","photos":[],"_id":"cmjbml2i6000nikup2po69taq","content":"<p>在上文<a href=\"./build-personal-blog1.md\">什么每个人都该有个数字自留地</a>中讲解了为什么我们要写博客以及为什么要搭建自己的独立博客，今天我们将要撸起袖子，开始干活了。认真看完本文，按照文中的步骤去做，你将拥有一个属于你自己的博客站点。</p>\n<h2 id=\"搭建博客的几种方式\"><a href=\"#搭建博客的几种方式\" class=\"headerlink\" title=\"搭建博客的几种方式\"></a>搭建博客的几种方式</h2><p>说到博客，不熟悉的人对它的印象可能是微博，QQ空间日志，以及如CSDN，博客园之类的站点的样子，功能丰富，用户上手也快，一部手机就能完成所有的事情。</p>\n<p>上面所提到的站点，都是标准的商业型应用了，而作为个人，没有必要浪费过多时间在各种花哨功能构建上。</p>\n<p>个人博客，最重要的是内容，是价值输出！</p>\n<p>目前呢，搭建个人博客的方式主要有以下几种：</p>\n<ul>\n<li><p><strong>社区平台</strong>：像<code>博客园</code>，<code>CSDN</code>, <code>知乎</code>，<code>微博</code>，<code>公众号</code>，<code>QQ空间</code>等，注册一个账号就Okay了。当然了，既然是社区平台，也就意味着没有独立的网站。</p>\n</li>\n<li><p><strong>独立博客</strong>: 有自己的网站，博客框架的搭建，内容的发布，都是由自己完成。对未接触过编程的人来说，上手有一定难度。比较适合有一定编程基础，然后又想挑战一下自己那种的同学。</p>\n</li>\n</ul>\n<p>作为一个明日的大佬，自己动手整个独立博客，想必对大家来说也不是什么难事。</p>\n<h2 id=\"考虑因素\"><a href=\"#考虑因素\" class=\"headerlink\" title=\"考虑因素\"></a>考虑因素</h2><p>既然选择建独立博客，那么我们需要考虑以下几个问题了：</p>\n<ul>\n<li>是否需要建立数据库，使用前后端配合的方式完成博客的增删改查？</li>\n<li>是否考虑购买服务器，还是进行服务托管?</li>\n<li>打算投入多少时间和金钱去建站?</li>\n</ul>\n<p>在考虑这些问题的时候，同时问问自己，自己的博客是否需要很多功能，还是作为一个简单记录自己所思所想的自由平台。</p>\n<p>个人认为，作为程序员，简洁就是最好的风格！</p>\n<p>因此，我更倾向选择的是不使用前后端，使用静态内容托管的方式来搭建自己的博客。正如前面所说的，一个个人博客站重要的是内容输出，戏台子搭得大和漂亮没有多少用，重要的是你的戏是否能够吸引观众。</p>\n<h2 id=\"技术选型\"><a href=\"#技术选型\" class=\"headerlink\" title=\"技术选型\"></a>技术选型</h2><p>既然是使用静态托管平台，那么可供选择的方案有很多：</p>\n<ul>\n<li><strong><a href=\"https://pages.github.com/\">GitHub Pages</a></strong>: 自带域名可 https 访问; 可配置自定义域名</li>\n<li><strong><a href=\"https://confluence.atlassian.com/bitbucket/publishing-a-website-on-bitbucket-cloud-221449776.html\">Bitbucket Cloud</a></strong>: 能且只能通过 https 协议访问; 无法自定义域名</li>\n<li><strong><a href=\"https://docs.gitlab.com/ee/user/project/pages/index.html\">GitLab Pages</a></strong>: 同样跟 GitHub Pages 的功能一样</li>\n<li><strong><a href=\"https://www.netlify.com/\">Netlify</a></strong>: 可以使用 CLI 上传代码; 支持自动构建</li>\n</ul>\n<p>在这里，比较推荐 Github Page 和 Netlify, 主要原因有两个：一个是比较能装，另一个是比较能装！</p>\n<h2 id=\"Github-page-建站\"><a href=\"#Github-page-建站\" class=\"headerlink\" title=\"Github page 建站\"></a>Github page 建站</h2><p>下面演示一下Github Page生成一个简单的个人站点名称，Netlify 可以自行探索一下，这里不做讲解。</p>\n<p>使用Github Page 建站，首先，你需要有一个Github 账号，如果没有，先去注册一个，注册时记得取个好一点的名字，后面有用。</p>\n<ul>\n<li><strong>登录github, 新建一个与你名字同名的repository</strong></li>\n</ul>\n<p>登录到Github首页之后，点击右上角 <code>+</code> 号，选择 <code>new repository</code> 跳转到新建仓库页面。</p>\n<p><img src=\"https://image.baidu.com/search/down?url=https://tvax4.sinaimg.cn/large/0071fJItgy1i21b6hl5rlj31i70xpe0n.jpg\" alt=\"step1\"></p>\n<p>其中，<code>repository name</code> 一定要是 <code>你的英文名称.github.io</code>，比如我的英文名称是<code>jvxiaome</code>， 那么我的仓库名称就是 <code>jvxiaome.github.io</code>，这个后面也是访问博客站点首页的网址，所以前面说取一个好听的名字，是有道理的。</p>\n<p>仓库的可见性选择 <code>Public</code>, 另外下面的 <code>Add a README file</code> 也可以勾上，会方便一些，至于剩下的内容，看个人需要，不清楚的可以暂时不填，最后确认 <code>Create repository</code>。</p>\n<p><img src=\"https://image.baidu.com/search/down?url=http://tvax3.sinaimg.cn/large/0071fJItgy1i21ba20naej31aa1ah1ba.jpg\" alt=\"step2\"></p>\n<ul>\n<li><strong>编辑一个你的博客主页</strong></li>\n</ul>\n<p>进入到刚刚新建的仓库，点击<code>add file</code> 新建一个文件</p>\n<p><img src=\"https://image.baidu.com/search/down?url=http://tvax2.sinaimg.cn/large/0071fJItgy1i21batizraj31gl0ufn95.jpg\" alt=\"step3\"></p>\n<p>文件名称取名为 <code>index.html</code>, 这个文件中包含的就是博客主页的内容了，具体想写什么可以自由发挥</p>\n<p><img src=\"https://image.baidu.com/search/down?url=http://tvax4.sinaimg.cn/large/0071fJItgy1i21bb808bfj31zr0thgzj.jpg\" alt=\"step4\"></p>\n<p>写完之后点击 <code>commit changes</code> 提交内容到仓库，到这一步，你的博客站就算是基本建立起来了<br><img src=\"https://image.baidu.com/search/down?url=http://tvax2.sinaimg.cn/large/0071fJItgy1i21bc83oxuj31eu0vyduh.jpg\" alt=\"step5\"></p>\n<ul>\n<li><strong>访问验证</strong></li>\n</ul>\n<p>既然博客站点已经建好了，此时是不是特别期待访问自己的博客首页呢。</p>\n<p>正如前面所说的，你的仓库名称（你的英文名称.github.io）就是你的博客首页名称，以上面的例子来说，访问 <code>jvxiaome.github.io</code> 就能直接看见首页效果了。</p>\n<p>虽然整个页面都在诉说着朴素(<del>丑</del>)，但一点也不影响你拥有一个属于自己博客站点的那份喜悦。都18+了，怎么能没有自己的网站呢。</p>\n<p><img src=\"https://image.baidu.com/search/down?url=http://tvax3.sinaimg.cn/large/0071fJItgy1i21bcpjfruj310d0k2go1.jpg\" alt=\"step6\"></p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>有了自己的博客网站，还有了域名，而这一切，不是个结束，而是开始。</p>\n<p>如何使用工具，使用主题，搭建一个简洁，漂亮的<a href=\"!%5Bmy-sit%5D(https://image.baidu.com/search/down?url=http://tvax1.sinaimg.cn/large/0071fJItgy1i21bddtgjjj32cu1h8x6q.jpg)\">博客网站</a>，这将是下一篇文中的重点。</p>\n<!-- https://github.com/lmk123/blog/issues/55 -->\n\n","excerpt":"","more":"<p>在上文<a href=\"./build-personal-blog1.md\">什么每个人都该有个数字自留地</a>中讲解了为什么我们要写博客以及为什么要搭建自己的独立博客，今天我们将要撸起袖子，开始干活了。认真看完本文，按照文中的步骤去做，你将拥有一个属于你自己的博客站点。</p>\n<h2 id=\"搭建博客的几种方式\"><a href=\"#搭建博客的几种方式\" class=\"headerlink\" title=\"搭建博客的几种方式\"></a>搭建博客的几种方式</h2><p>说到博客，不熟悉的人对它的印象可能是微博，QQ空间日志，以及如CSDN，博客园之类的站点的样子，功能丰富，用户上手也快，一部手机就能完成所有的事情。</p>\n<p>上面所提到的站点，都是标准的商业型应用了，而作为个人，没有必要浪费过多时间在各种花哨功能构建上。</p>\n<p>个人博客，最重要的是内容，是价值输出！</p>\n<p>目前呢，搭建个人博客的方式主要有以下几种：</p>\n<ul>\n<li><p><strong>社区平台</strong>：像<code>博客园</code>，<code>CSDN</code>, <code>知乎</code>，<code>微博</code>，<code>公众号</code>，<code>QQ空间</code>等，注册一个账号就Okay了。当然了，既然是社区平台，也就意味着没有独立的网站。</p>\n</li>\n<li><p><strong>独立博客</strong>: 有自己的网站，博客框架的搭建，内容的发布，都是由自己完成。对未接触过编程的人来说，上手有一定难度。比较适合有一定编程基础，然后又想挑战一下自己那种的同学。</p>\n</li>\n</ul>\n<p>作为一个明日的大佬，自己动手整个独立博客，想必对大家来说也不是什么难事。</p>\n<h2 id=\"考虑因素\"><a href=\"#考虑因素\" class=\"headerlink\" title=\"考虑因素\"></a>考虑因素</h2><p>既然选择建独立博客，那么我们需要考虑以下几个问题了：</p>\n<ul>\n<li>是否需要建立数据库，使用前后端配合的方式完成博客的增删改查？</li>\n<li>是否考虑购买服务器，还是进行服务托管?</li>\n<li>打算投入多少时间和金钱去建站?</li>\n</ul>\n<p>在考虑这些问题的时候，同时问问自己，自己的博客是否需要很多功能，还是作为一个简单记录自己所思所想的自由平台。</p>\n<p>个人认为，作为程序员，简洁就是最好的风格！</p>\n<p>因此，我更倾向选择的是不使用前后端，使用静态内容托管的方式来搭建自己的博客。正如前面所说的，一个个人博客站重要的是内容输出，戏台子搭得大和漂亮没有多少用，重要的是你的戏是否能够吸引观众。</p>\n<h2 id=\"技术选型\"><a href=\"#技术选型\" class=\"headerlink\" title=\"技术选型\"></a>技术选型</h2><p>既然是使用静态托管平台，那么可供选择的方案有很多：</p>\n<ul>\n<li><strong><a href=\"https://pages.github.com/\">GitHub Pages</a></strong>: 自带域名可 https 访问; 可配置自定义域名</li>\n<li><strong><a href=\"https://confluence.atlassian.com/bitbucket/publishing-a-website-on-bitbucket-cloud-221449776.html\">Bitbucket Cloud</a></strong>: 能且只能通过 https 协议访问; 无法自定义域名</li>\n<li><strong><a href=\"https://docs.gitlab.com/ee/user/project/pages/index.html\">GitLab Pages</a></strong>: 同样跟 GitHub Pages 的功能一样</li>\n<li><strong><a href=\"https://www.netlify.com/\">Netlify</a></strong>: 可以使用 CLI 上传代码; 支持自动构建</li>\n</ul>\n<p>在这里，比较推荐 Github Page 和 Netlify, 主要原因有两个：一个是比较能装，另一个是比较能装！</p>\n<h2 id=\"Github-page-建站\"><a href=\"#Github-page-建站\" class=\"headerlink\" title=\"Github page 建站\"></a>Github page 建站</h2><p>下面演示一下Github Page生成一个简单的个人站点名称，Netlify 可以自行探索一下，这里不做讲解。</p>\n<p>使用Github Page 建站，首先，你需要有一个Github 账号，如果没有，先去注册一个，注册时记得取个好一点的名字，后面有用。</p>\n<ul>\n<li><strong>登录github, 新建一个与你名字同名的repository</strong></li>\n</ul>\n<p>登录到Github首页之后，点击右上角 <code>+</code> 号，选择 <code>new repository</code> 跳转到新建仓库页面。</p>\n<p><img src=\"https://image.baidu.com/search/down?url=https://tvax4.sinaimg.cn/large/0071fJItgy1i21b6hl5rlj31i70xpe0n.jpg\" alt=\"step1\"></p>\n<p>其中，<code>repository name</code> 一定要是 <code>你的英文名称.github.io</code>，比如我的英文名称是<code>jvxiaome</code>， 那么我的仓库名称就是 <code>jvxiaome.github.io</code>，这个后面也是访问博客站点首页的网址，所以前面说取一个好听的名字，是有道理的。</p>\n<p>仓库的可见性选择 <code>Public</code>, 另外下面的 <code>Add a README file</code> 也可以勾上，会方便一些，至于剩下的内容，看个人需要，不清楚的可以暂时不填，最后确认 <code>Create repository</code>。</p>\n<p><img src=\"https://image.baidu.com/search/down?url=http://tvax3.sinaimg.cn/large/0071fJItgy1i21ba20naej31aa1ah1ba.jpg\" alt=\"step2\"></p>\n<ul>\n<li><strong>编辑一个你的博客主页</strong></li>\n</ul>\n<p>进入到刚刚新建的仓库，点击<code>add file</code> 新建一个文件</p>\n<p><img src=\"https://image.baidu.com/search/down?url=http://tvax2.sinaimg.cn/large/0071fJItgy1i21batizraj31gl0ufn95.jpg\" alt=\"step3\"></p>\n<p>文件名称取名为 <code>index.html</code>, 这个文件中包含的就是博客主页的内容了，具体想写什么可以自由发挥</p>\n<p><img src=\"https://image.baidu.com/search/down?url=http://tvax4.sinaimg.cn/large/0071fJItgy1i21bb808bfj31zr0thgzj.jpg\" alt=\"step4\"></p>\n<p>写完之后点击 <code>commit changes</code> 提交内容到仓库，到这一步，你的博客站就算是基本建立起来了<br><img src=\"https://image.baidu.com/search/down?url=http://tvax2.sinaimg.cn/large/0071fJItgy1i21bc83oxuj31eu0vyduh.jpg\" alt=\"step5\"></p>\n<ul>\n<li><strong>访问验证</strong></li>\n</ul>\n<p>既然博客站点已经建好了，此时是不是特别期待访问自己的博客首页呢。</p>\n<p>正如前面所说的，你的仓库名称（你的英文名称.github.io）就是你的博客首页名称，以上面的例子来说，访问 <code>jvxiaome.github.io</code> 就能直接看见首页效果了。</p>\n<p>虽然整个页面都在诉说着朴素(<del>丑</del>)，但一点也不影响你拥有一个属于自己博客站点的那份喜悦。都18+了，怎么能没有自己的网站呢。</p>\n<p><img src=\"https://image.baidu.com/search/down?url=http://tvax3.sinaimg.cn/large/0071fJItgy1i21bcpjfruj310d0k2go1.jpg\" alt=\"step6\"></p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>有了自己的博客网站，还有了域名，而这一切，不是个结束，而是开始。</p>\n<p>如何使用工具，使用主题，搭建一个简洁，漂亮的<a href=\"!%5Bmy-sit%5D(https://image.baidu.com/search/down?url=http://tvax1.sinaimg.cn/large/0071fJItgy1i21bddtgjjj32cu1h8x6q.jpg)\">博客网站</a>，这将是下一篇文中的重点。</p>\n<!-- https://github.com/lmk123/blog/issues/55 -->\n\n"},{"title":"搭建个人博客系列--(3) Hexo 静态博客搭建实战","date":"2025-06-07T16:21:58.000Z","keywords":["博客搭建","免费博客平台","托管博客","模板建站"],"index_img":"imgs/build-blog3/hexo.png","banner_img":"imgs/build-blog3/hexo.png","_content":"\n通过上一篇文章--[动手搭建自己的第一个博客站点](./build-personal-blog2.md)的介绍，相信你已经成功搭建起了自己的第一个博客网站。如果你的动手能力比较强的话，或许还给博客页面做了页面美工，添加了导航等功能。\n\n如果你的博客还停留在手写html的阶段，也没有关系，通过这篇文章，让你在10分钟内学会如何使用工具生成漂亮好看的博客页面。\n\n\n## 什么是 SSG\n\n人类与其他动物的一个显著区别在于，人类擅长制造并使用工具，撰写博客亦是如此。如今，搭建站点撰写博客早已告别了需要手动逐行编写 HTML 代码的 “刀耕火种” 时代，众多优秀工具可供选择，助力我们快速实现更出色的博客呈现效果。\n\n我们知道，一篇博客内容通常都是以HTML的形式存储的，但对于写博客的人来说，其更想要关注的是其内容本身，而不是各种HTML标签的排列组合和样式调整。\n\n![markdown-to-html](../imgs/build-blog3/md2html.png)\n\n那么是否有一种工具，可以让撰写博客的人从书写HTML和各种样式调整中解脱出来，可以直接将纯文本内容转换成带漂亮样式的HTML文件呢？\n\n有的，那就是静态站点生成器（Static Site Generator)。它是一种自动化工具，它通过模板和数据源（如 Markdown 文件、CMS 内容或 API 数据）生成完整的 HTML、CSS 和 JavaScript 文件。与传统动态网站不同，SSG 生成的页面在构建时就已完全渲染，无需在用户访问时依赖数据库或服务器端处理。\n\n\n## 一些常见的SSG工具\n\n下面是一些常见的SSG工具，其中包含一些大家都比较熟悉的，比如Next, Hugo, Jekyll还有Hexo之类的。\n\n![site-generator](../imgs//build-blog3/site-generator.png)\n![site-generator](../imgs//build-blog3/site-generator2.png)\n\n`Next.js`有完整的React生态支持，内置CSS模块化、图像优化和自动代码风格功能, 适合构建复杂交互应用。\n\n`Hugo` 是一块由Go语言开发的超高速静态站点生成器，最大的特点就是，快！\n\n`Jekyll` 算是一款老牌的静态站点生成器了，Github Pages原生就支持，非常适合搞小型项目展示页和个人博客。\n\n`Hexo` 是一款Node.js生态的轻量博客框架，Markdown只有友好，非常适合中文写作。\n\n工具那么多，我独爱Hexo! \n\n## Why Hexo?\n\n在众多的SSG工具中，为什么为独独选择Hexo呢？ 除了是个人接触比较早之外，还有一些其它的深层次的原因。\n\n![hexo](../imgs/build-blog3/hexo.png)\n\n**极低的入门门槛**，只需安装 Node 环境后，通过几条命令即可初始化站点，无需复杂配置。而且中文教程十分丰富，即使是新手，也能在10分钟之内搭建出一个基础博客。\n\n**中文生态友好**，配置文件、错误提示等均为中文，对国内开发者更友好; 社区活跃，中文主题和插件资源丰富。\n\n**灵活扩展，功能丰富**，插件系统完善，通过 npm 安装插件即可扩展功能；主题基于 EJS/Pug/Markdown 模板，支持自定义布局、样式和脚本。\n\n如果你恰好也是一名前端开发工程师，日常开发中必然常常与Node打交道，那么对于自己写Hexo插件和主题是很有优势的，Hexo对于你来说是个很不错的选择。\n\n## 实战操作\n\n前面就说了，即使是新手，也能够在10分钟之内搭建出一个基础博客。如果你正在尝试着跟着步骤做，不妨计时验证一下。\n\n多的话不说了，撸起袖子，开干！\n\n- ### step1: 准备Node环境\n\n  如果之前接触过Node或者已经安装过Node, 可以直接跳过该步骤，直接进入到step2。如果是Node新手，可以按照下面步骤来安装Node。\n  - **方法1：安装包安装**\n\n    a）前往[Node官网](https://nodejs.org/zh-cn/download)下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node安装包”获取。<br>\n    b) 双击安装包，开始安装, 傻瓜式的点击Next.\n\n\n  - **方法2：可移动二进制文件安装**\n\n      a）前往[Node官网](https://nodejs.org/zh-cn/download)下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node独立文件包”获取。<br>\n      b) 将包解压任意目录, 然后将其中的`bin`目录路径配置到环境变量 `path`中\n\n  如安装过程过程中有疑问，可参考详细教程: [Node安装保姆级教程](./install-node.md)\n\n  安装之后，打开命令行窗口，输入 `node -v` 验证，如果出现对应版本号，则说明安装成功了。\n\n- ### step2: 安装Hexo脚手架\n\n全局安装 **Hexo CLI**, 一行命令行就够了。\n\n```\nnpm install hexo-cli -g \n```\n![step2](../imgs//build-blog3/step2.png)\n\n- ### step3: 搭建博客\n\n使用hexo脚手架，完成博客搭建操作\n```\nhexo init my-blog           # 初始化博客目录\ncd my-blog && npm install   # 安装依赖\nnpm run server              # 启动本地预览（http://localhost:4000）\n```\n执行完上述操作之后，在浏览器中输入地址`http://localhost:4000`, 你将看到整个博客的样子，其中包含一篇默认的 `Hello world`博文。\n\n![landscape](../imgs/build-blog3/landscape.png)\n\n如果你想要添加新的博客，执行 `hexo new post 文章标题`即可在 `source/_post`目录下生成一个新的 `.md`文件。如果不熟悉Markdown语法，可以查阅相关资料学习，上手其实挺快的。\n\n\n### step4: 部署到Github Page\n\n执行命令下方命令\n\n``` bash\nhexo generate\n```\n\nhexo将会把所有相关资源文件进行转换，最后所有的资源都都存放在 `public`目录下。将所有文件上传到上一篇文中提到的个人仓库或者使用git命令提交，等待一两分钟，访问自己的博客站点地址，你将看内容已经更新。\n\n\n## 写在最后\n\nHexo 博客的默认主题是 `landscape`, 你也可以尝试着使用其它博客主题，如 `Next`, `Fluid`等。\n\n如果你想对博客站点做些修改，可以通过编辑其根目录下配置文件 `_config.yml` 来进行调整。如果在主题样式上需要做修改，也可以编辑其对应的配置文件，对应的配置文件在 `/themes/主题名称/`中。\n\n关于Hexo更多的配置可查阅其官方文档，里面都有十分详细的介绍。如果个人动手能力比较强，也可以尝试着写一些主题或者插件，那将是一件让你感到成就感满满的事情。\n\n","source":"_posts/build-personal-blog3.md","raw":"---\ntitle: 搭建个人博客系列--(3) Hexo 静态博客搭建实战\ndate: 2025-06-08 00:21:58\ncategory: 搭建博客\ntags: \n   - 博客搭建\n   - 个人IP\nkeywords: [博客搭建, 免费博客平台, 托管博客, 模板建站]\nindex_img: imgs/build-blog3/hexo.png\nbanner_img: imgs/build-blog3/hexo.png\n---\n\n通过上一篇文章--[动手搭建自己的第一个博客站点](./build-personal-blog2.md)的介绍，相信你已经成功搭建起了自己的第一个博客网站。如果你的动手能力比较强的话，或许还给博客页面做了页面美工，添加了导航等功能。\n\n如果你的博客还停留在手写html的阶段，也没有关系，通过这篇文章，让你在10分钟内学会如何使用工具生成漂亮好看的博客页面。\n\n\n## 什么是 SSG\n\n人类与其他动物的一个显著区别在于，人类擅长制造并使用工具，撰写博客亦是如此。如今，搭建站点撰写博客早已告别了需要手动逐行编写 HTML 代码的 “刀耕火种” 时代，众多优秀工具可供选择，助力我们快速实现更出色的博客呈现效果。\n\n我们知道，一篇博客内容通常都是以HTML的形式存储的，但对于写博客的人来说，其更想要关注的是其内容本身，而不是各种HTML标签的排列组合和样式调整。\n\n![markdown-to-html](../imgs/build-blog3/md2html.png)\n\n那么是否有一种工具，可以让撰写博客的人从书写HTML和各种样式调整中解脱出来，可以直接将纯文本内容转换成带漂亮样式的HTML文件呢？\n\n有的，那就是静态站点生成器（Static Site Generator)。它是一种自动化工具，它通过模板和数据源（如 Markdown 文件、CMS 内容或 API 数据）生成完整的 HTML、CSS 和 JavaScript 文件。与传统动态网站不同，SSG 生成的页面在构建时就已完全渲染，无需在用户访问时依赖数据库或服务器端处理。\n\n\n## 一些常见的SSG工具\n\n下面是一些常见的SSG工具，其中包含一些大家都比较熟悉的，比如Next, Hugo, Jekyll还有Hexo之类的。\n\n![site-generator](../imgs//build-blog3/site-generator.png)\n![site-generator](../imgs//build-blog3/site-generator2.png)\n\n`Next.js`有完整的React生态支持，内置CSS模块化、图像优化和自动代码风格功能, 适合构建复杂交互应用。\n\n`Hugo` 是一块由Go语言开发的超高速静态站点生成器，最大的特点就是，快！\n\n`Jekyll` 算是一款老牌的静态站点生成器了，Github Pages原生就支持，非常适合搞小型项目展示页和个人博客。\n\n`Hexo` 是一款Node.js生态的轻量博客框架，Markdown只有友好，非常适合中文写作。\n\n工具那么多，我独爱Hexo! \n\n## Why Hexo?\n\n在众多的SSG工具中，为什么为独独选择Hexo呢？ 除了是个人接触比较早之外，还有一些其它的深层次的原因。\n\n![hexo](../imgs/build-blog3/hexo.png)\n\n**极低的入门门槛**，只需安装 Node 环境后，通过几条命令即可初始化站点，无需复杂配置。而且中文教程十分丰富，即使是新手，也能在10分钟之内搭建出一个基础博客。\n\n**中文生态友好**，配置文件、错误提示等均为中文，对国内开发者更友好; 社区活跃，中文主题和插件资源丰富。\n\n**灵活扩展，功能丰富**，插件系统完善，通过 npm 安装插件即可扩展功能；主题基于 EJS/Pug/Markdown 模板，支持自定义布局、样式和脚本。\n\n如果你恰好也是一名前端开发工程师，日常开发中必然常常与Node打交道，那么对于自己写Hexo插件和主题是很有优势的，Hexo对于你来说是个很不错的选择。\n\n## 实战操作\n\n前面就说了，即使是新手，也能够在10分钟之内搭建出一个基础博客。如果你正在尝试着跟着步骤做，不妨计时验证一下。\n\n多的话不说了，撸起袖子，开干！\n\n- ### step1: 准备Node环境\n\n  如果之前接触过Node或者已经安装过Node, 可以直接跳过该步骤，直接进入到step2。如果是Node新手，可以按照下面步骤来安装Node。\n  - **方法1：安装包安装**\n\n    a）前往[Node官网](https://nodejs.org/zh-cn/download)下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node安装包”获取。<br>\n    b) 双击安装包，开始安装, 傻瓜式的点击Next.\n\n\n  - **方法2：可移动二进制文件安装**\n\n      a）前往[Node官网](https://nodejs.org/zh-cn/download)下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node独立文件包”获取。<br>\n      b) 将包解压任意目录, 然后将其中的`bin`目录路径配置到环境变量 `path`中\n\n  如安装过程过程中有疑问，可参考详细教程: [Node安装保姆级教程](./install-node.md)\n\n  安装之后，打开命令行窗口，输入 `node -v` 验证，如果出现对应版本号，则说明安装成功了。\n\n- ### step2: 安装Hexo脚手架\n\n全局安装 **Hexo CLI**, 一行命令行就够了。\n\n```\nnpm install hexo-cli -g \n```\n![step2](../imgs//build-blog3/step2.png)\n\n- ### step3: 搭建博客\n\n使用hexo脚手架，完成博客搭建操作\n```\nhexo init my-blog           # 初始化博客目录\ncd my-blog && npm install   # 安装依赖\nnpm run server              # 启动本地预览（http://localhost:4000）\n```\n执行完上述操作之后，在浏览器中输入地址`http://localhost:4000`, 你将看到整个博客的样子，其中包含一篇默认的 `Hello world`博文。\n\n![landscape](../imgs/build-blog3/landscape.png)\n\n如果你想要添加新的博客，执行 `hexo new post 文章标题`即可在 `source/_post`目录下生成一个新的 `.md`文件。如果不熟悉Markdown语法，可以查阅相关资料学习，上手其实挺快的。\n\n\n### step4: 部署到Github Page\n\n执行命令下方命令\n\n``` bash\nhexo generate\n```\n\nhexo将会把所有相关资源文件进行转换，最后所有的资源都都存放在 `public`目录下。将所有文件上传到上一篇文中提到的个人仓库或者使用git命令提交，等待一两分钟，访问自己的博客站点地址，你将看内容已经更新。\n\n\n## 写在最后\n\nHexo 博客的默认主题是 `landscape`, 你也可以尝试着使用其它博客主题，如 `Next`, `Fluid`等。\n\n如果你想对博客站点做些修改，可以通过编辑其根目录下配置文件 `_config.yml` 来进行调整。如果在主题样式上需要做修改，也可以编辑其对应的配置文件，对应的配置文件在 `/themes/主题名称/`中。\n\n关于Hexo更多的配置可查阅其官方文档，里面都有十分详细的介绍。如果个人动手能力比较强，也可以尝试着写一些主题或者插件，那将是一件让你感到成就感满满的事情。\n\n","slug":"build-personal-blog3","published":1,"updated":"2025-08-26T10:16:37.605Z","comments":1,"layout":"post","photos":[],"_id":"cmjbml2i6000rikup0jja6guf","content":"<p>通过上一篇文章–<a href=\"./build-personal-blog2.md\">动手搭建自己的第一个博客站点</a>的介绍，相信你已经成功搭建起了自己的第一个博客网站。如果你的动手能力比较强的话，或许还给博客页面做了页面美工，添加了导航等功能。</p>\n<p>如果你的博客还停留在手写html的阶段，也没有关系，通过这篇文章，让你在10分钟内学会如何使用工具生成漂亮好看的博客页面。</p>\n<h2 id=\"什么是-SSG\"><a href=\"#什么是-SSG\" class=\"headerlink\" title=\"什么是 SSG\"></a>什么是 SSG</h2><p>人类与其他动物的一个显著区别在于，人类擅长制造并使用工具，撰写博客亦是如此。如今，搭建站点撰写博客早已告别了需要手动逐行编写 HTML 代码的 “刀耕火种” 时代，众多优秀工具可供选择，助力我们快速实现更出色的博客呈现效果。</p>\n<p>我们知道，一篇博客内容通常都是以HTML的形式存储的，但对于写博客的人来说，其更想要关注的是其内容本身，而不是各种HTML标签的排列组合和样式调整。</p>\n<p><img src=\"/../imgs/build-blog3/md2html.png\" alt=\"markdown-to-html\"></p>\n<p>那么是否有一种工具，可以让撰写博客的人从书写HTML和各种样式调整中解脱出来，可以直接将纯文本内容转换成带漂亮样式的HTML文件呢？</p>\n<p>有的，那就是静态站点生成器（Static Site Generator)。它是一种自动化工具，它通过模板和数据源（如 Markdown 文件、CMS 内容或 API 数据）生成完整的 HTML、CSS 和 JavaScript 文件。与传统动态网站不同，SSG 生成的页面在构建时就已完全渲染，无需在用户访问时依赖数据库或服务器端处理。</p>\n<h2 id=\"一些常见的SSG工具\"><a href=\"#一些常见的SSG工具\" class=\"headerlink\" title=\"一些常见的SSG工具\"></a>一些常见的SSG工具</h2><p>下面是一些常见的SSG工具，其中包含一些大家都比较熟悉的，比如Next, Hugo, Jekyll还有Hexo之类的。</p>\n<p><img src=\"/../imgs/build-blog3/site-generator.png\" alt=\"site-generator\"><br><img src=\"/../imgs/build-blog3/site-generator2.png\" alt=\"site-generator\"></p>\n<p><code>Next.js</code>有完整的React生态支持，内置CSS模块化、图像优化和自动代码风格功能, 适合构建复杂交互应用。</p>\n<p><code>Hugo</code> 是一块由Go语言开发的超高速静态站点生成器，最大的特点就是，快！</p>\n<p><code>Jekyll</code> 算是一款老牌的静态站点生成器了，Github Pages原生就支持，非常适合搞小型项目展示页和个人博客。</p>\n<p><code>Hexo</code> 是一款Node.js生态的轻量博客框架，Markdown只有友好，非常适合中文写作。</p>\n<p>工具那么多，我独爱Hexo! </p>\n<h2 id=\"Why-Hexo\"><a href=\"#Why-Hexo\" class=\"headerlink\" title=\"Why Hexo?\"></a>Why Hexo?</h2><p>在众多的SSG工具中，为什么为独独选择Hexo呢？ 除了是个人接触比较早之外，还有一些其它的深层次的原因。</p>\n<p><img src=\"/../imgs/build-blog3/hexo.png\" alt=\"hexo\"></p>\n<p><strong>极低的入门门槛</strong>，只需安装 Node 环境后，通过几条命令即可初始化站点，无需复杂配置。而且中文教程十分丰富，即使是新手，也能在10分钟之内搭建出一个基础博客。</p>\n<p><strong>中文生态友好</strong>，配置文件、错误提示等均为中文，对国内开发者更友好; 社区活跃，中文主题和插件资源丰富。</p>\n<p><strong>灵活扩展，功能丰富</strong>，插件系统完善，通过 npm 安装插件即可扩展功能；主题基于 EJS&#x2F;Pug&#x2F;Markdown 模板，支持自定义布局、样式和脚本。</p>\n<p>如果你恰好也是一名前端开发工程师，日常开发中必然常常与Node打交道，那么对于自己写Hexo插件和主题是很有优势的，Hexo对于你来说是个很不错的选择。</p>\n<h2 id=\"实战操作\"><a href=\"#实战操作\" class=\"headerlink\" title=\"实战操作\"></a>实战操作</h2><p>前面就说了，即使是新手，也能够在10分钟之内搭建出一个基础博客。如果你正在尝试着跟着步骤做，不妨计时验证一下。</p>\n<p>多的话不说了，撸起袖子，开干！</p>\n<ul>\n<li><h3 id=\"step1-准备Node环境\"><a href=\"#step1-准备Node环境\" class=\"headerlink\" title=\"step1: 准备Node环境\"></a>step1: 准备Node环境</h3><p>如果之前接触过Node或者已经安装过Node, 可以直接跳过该步骤，直接进入到step2。如果是Node新手，可以按照下面步骤来安装Node。</p>\n<ul>\n<li><p><strong>方法1：安装包安装</strong></p>\n<p>a）前往<a href=\"https://nodejs.org/zh-cn/download\">Node官网</a>下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node安装包”获取。<br><br>b) 双击安装包，开始安装, 傻瓜式的点击Next.</p>\n</li>\n<li><p><strong>方法2：可移动二进制文件安装</strong></p>\n<p>  a）前往<a href=\"https://nodejs.org/zh-cn/download\">Node官网</a>下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node独立文件包”获取。<br><br>  b) 将包解压任意目录, 然后将其中的<code>bin</code>目录路径配置到环境变量 <code>path</code>中</p>\n</li>\n</ul>\n<p>如安装过程过程中有疑问，可参考详细教程: <a href=\"./install-node.md\">Node安装保姆级教程</a></p>\n<p>安装之后，打开命令行窗口，输入 <code>node -v</code> 验证，如果出现对应版本号，则说明安装成功了。</p>\n</li>\n<li><h3 id=\"step2-安装Hexo脚手架\"><a href=\"#step2-安装Hexo脚手架\" class=\"headerlink\" title=\"step2: 安装Hexo脚手架\"></a>step2: 安装Hexo脚手架</h3></li>\n</ul>\n<p>全局安装 <strong>Hexo CLI</strong>, 一行命令行就够了。</p>\n<figure class=\"highlight avrasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs avrasm\">npm install hexo-<span class=\"hljs-keyword\">cli</span> -g <br></code></pre></td></tr></table></figure>\n<p><img src=\"/../imgs/build-blog3/step2.png\" alt=\"step2\"></p>\n<ul>\n<li><h3 id=\"step3-搭建博客\"><a href=\"#step3-搭建博客\" class=\"headerlink\" title=\"step3: 搭建博客\"></a>step3: 搭建博客</h3></li>\n</ul>\n<p>使用hexo脚手架，完成博客搭建操作</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">hexo init <span class=\"hljs-keyword\">my</span>-blog           <span class=\"hljs-comment\"># 初始化博客目录</span><br>cd <span class=\"hljs-keyword\">my</span>-blog &amp;&amp; npm install   <span class=\"hljs-comment\"># 安装依赖</span><br>npm <span class=\"hljs-built_in\">run</span> server              <span class=\"hljs-comment\"># 启动本地预览（http://localhost:4000）</span><br></code></pre></td></tr></table></figure>\n<p>执行完上述操作之后，在浏览器中输入地址<code>http://localhost:4000</code>, 你将看到整个博客的样子，其中包含一篇默认的 <code>Hello world</code>博文。</p>\n<p><img src=\"/../imgs/build-blog3/landscape.png\" alt=\"landscape\"></p>\n<p>如果你想要添加新的博客，执行 <code>hexo new post 文章标题</code>即可在 <code>source/_post</code>目录下生成一个新的 <code>.md</code>文件。如果不熟悉Markdown语法，可以查阅相关资料学习，上手其实挺快的。</p>\n<h3 id=\"step4-部署到Github-Page\"><a href=\"#step4-部署到Github-Page\" class=\"headerlink\" title=\"step4: 部署到Github Page\"></a>step4: 部署到Github Page</h3><p>执行命令下方命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">hexo generate<br></code></pre></td></tr></table></figure>\n\n<p>hexo将会把所有相关资源文件进行转换，最后所有的资源都都存放在 <code>public</code>目录下。将所有文件上传到上一篇文中提到的个人仓库或者使用git命令提交，等待一两分钟，访问自己的博客站点地址，你将看内容已经更新。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>Hexo 博客的默认主题是 <code>landscape</code>, 你也可以尝试着使用其它博客主题，如 <code>Next</code>, <code>Fluid</code>等。</p>\n<p>如果你想对博客站点做些修改，可以通过编辑其根目录下配置文件 <code>_config.yml</code> 来进行调整。如果在主题样式上需要做修改，也可以编辑其对应的配置文件，对应的配置文件在 <code>/themes/主题名称/</code>中。</p>\n<p>关于Hexo更多的配置可查阅其官方文档，里面都有十分详细的介绍。如果个人动手能力比较强，也可以尝试着写一些主题或者插件，那将是一件让你感到成就感满满的事情。</p>\n","excerpt":"","more":"<p>通过上一篇文章–<a href=\"./build-personal-blog2.md\">动手搭建自己的第一个博客站点</a>的介绍，相信你已经成功搭建起了自己的第一个博客网站。如果你的动手能力比较强的话，或许还给博客页面做了页面美工，添加了导航等功能。</p>\n<p>如果你的博客还停留在手写html的阶段，也没有关系，通过这篇文章，让你在10分钟内学会如何使用工具生成漂亮好看的博客页面。</p>\n<h2 id=\"什么是-SSG\"><a href=\"#什么是-SSG\" class=\"headerlink\" title=\"什么是 SSG\"></a>什么是 SSG</h2><p>人类与其他动物的一个显著区别在于，人类擅长制造并使用工具，撰写博客亦是如此。如今，搭建站点撰写博客早已告别了需要手动逐行编写 HTML 代码的 “刀耕火种” 时代，众多优秀工具可供选择，助力我们快速实现更出色的博客呈现效果。</p>\n<p>我们知道，一篇博客内容通常都是以HTML的形式存储的，但对于写博客的人来说，其更想要关注的是其内容本身，而不是各种HTML标签的排列组合和样式调整。</p>\n<p><img src=\"/../imgs/build-blog3/md2html.png\" alt=\"markdown-to-html\"></p>\n<p>那么是否有一种工具，可以让撰写博客的人从书写HTML和各种样式调整中解脱出来，可以直接将纯文本内容转换成带漂亮样式的HTML文件呢？</p>\n<p>有的，那就是静态站点生成器（Static Site Generator)。它是一种自动化工具，它通过模板和数据源（如 Markdown 文件、CMS 内容或 API 数据）生成完整的 HTML、CSS 和 JavaScript 文件。与传统动态网站不同，SSG 生成的页面在构建时就已完全渲染，无需在用户访问时依赖数据库或服务器端处理。</p>\n<h2 id=\"一些常见的SSG工具\"><a href=\"#一些常见的SSG工具\" class=\"headerlink\" title=\"一些常见的SSG工具\"></a>一些常见的SSG工具</h2><p>下面是一些常见的SSG工具，其中包含一些大家都比较熟悉的，比如Next, Hugo, Jekyll还有Hexo之类的。</p>\n<p><img src=\"/../imgs/build-blog3/site-generator.png\" alt=\"site-generator\"><br><img src=\"/../imgs/build-blog3/site-generator2.png\" alt=\"site-generator\"></p>\n<p><code>Next.js</code>有完整的React生态支持，内置CSS模块化、图像优化和自动代码风格功能, 适合构建复杂交互应用。</p>\n<p><code>Hugo</code> 是一块由Go语言开发的超高速静态站点生成器，最大的特点就是，快！</p>\n<p><code>Jekyll</code> 算是一款老牌的静态站点生成器了，Github Pages原生就支持，非常适合搞小型项目展示页和个人博客。</p>\n<p><code>Hexo</code> 是一款Node.js生态的轻量博客框架，Markdown只有友好，非常适合中文写作。</p>\n<p>工具那么多，我独爱Hexo! </p>\n<h2 id=\"Why-Hexo\"><a href=\"#Why-Hexo\" class=\"headerlink\" title=\"Why Hexo?\"></a>Why Hexo?</h2><p>在众多的SSG工具中，为什么为独独选择Hexo呢？ 除了是个人接触比较早之外，还有一些其它的深层次的原因。</p>\n<p><img src=\"/../imgs/build-blog3/hexo.png\" alt=\"hexo\"></p>\n<p><strong>极低的入门门槛</strong>，只需安装 Node 环境后，通过几条命令即可初始化站点，无需复杂配置。而且中文教程十分丰富，即使是新手，也能在10分钟之内搭建出一个基础博客。</p>\n<p><strong>中文生态友好</strong>，配置文件、错误提示等均为中文，对国内开发者更友好; 社区活跃，中文主题和插件资源丰富。</p>\n<p><strong>灵活扩展，功能丰富</strong>，插件系统完善，通过 npm 安装插件即可扩展功能；主题基于 EJS&#x2F;Pug&#x2F;Markdown 模板，支持自定义布局、样式和脚本。</p>\n<p>如果你恰好也是一名前端开发工程师，日常开发中必然常常与Node打交道，那么对于自己写Hexo插件和主题是很有优势的，Hexo对于你来说是个很不错的选择。</p>\n<h2 id=\"实战操作\"><a href=\"#实战操作\" class=\"headerlink\" title=\"实战操作\"></a>实战操作</h2><p>前面就说了，即使是新手，也能够在10分钟之内搭建出一个基础博客。如果你正在尝试着跟着步骤做，不妨计时验证一下。</p>\n<p>多的话不说了，撸起袖子，开干！</p>\n<ul>\n<li><h3 id=\"step1-准备Node环境\"><a href=\"#step1-准备Node环境\" class=\"headerlink\" title=\"step1: 准备Node环境\"></a>step1: 准备Node环境</h3><p>如果之前接触过Node或者已经安装过Node, 可以直接跳过该步骤，直接进入到step2。如果是Node新手，可以按照下面步骤来安装Node。</p>\n<ul>\n<li><p><strong>方法1：安装包安装</strong></p>\n<p>a）前往<a href=\"https://nodejs.org/zh-cn/download\">Node官网</a>下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node安装包”获取。<br><br>b) 双击安装包，开始安装, 傻瓜式的点击Next.</p>\n</li>\n<li><p><strong>方法2：可移动二进制文件安装</strong></p>\n<p>  a）前往<a href=\"https://nodejs.org/zh-cn/download\">Node官网</a>下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node独立文件包”获取。<br><br>  b) 将包解压任意目录, 然后将其中的<code>bin</code>目录路径配置到环境变量 <code>path</code>中</p>\n</li>\n</ul>\n<p>如安装过程过程中有疑问，可参考详细教程: <a href=\"./install-node.md\">Node安装保姆级教程</a></p>\n<p>安装之后，打开命令行窗口，输入 <code>node -v</code> 验证，如果出现对应版本号，则说明安装成功了。</p>\n</li>\n<li><h3 id=\"step2-安装Hexo脚手架\"><a href=\"#step2-安装Hexo脚手架\" class=\"headerlink\" title=\"step2: 安装Hexo脚手架\"></a>step2: 安装Hexo脚手架</h3></li>\n</ul>\n<p>全局安装 <strong>Hexo CLI</strong>, 一行命令行就够了。</p>\n<figure class=\"highlight avrasm\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs avrasm\">npm install hexo-<span class=\"hljs-keyword\">cli</span> -g <br></code></pre></td></tr></table></figure>\n<p><img src=\"/../imgs/build-blog3/step2.png\" alt=\"step2\"></p>\n<ul>\n<li><h3 id=\"step3-搭建博客\"><a href=\"#step3-搭建博客\" class=\"headerlink\" title=\"step3: 搭建博客\"></a>step3: 搭建博客</h3></li>\n</ul>\n<p>使用hexo脚手架，完成博客搭建操作</p>\n<figure class=\"highlight applescript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs applescript\">hexo init <span class=\"hljs-keyword\">my</span>-blog           <span class=\"hljs-comment\"># 初始化博客目录</span><br>cd <span class=\"hljs-keyword\">my</span>-blog &amp;&amp; npm install   <span class=\"hljs-comment\"># 安装依赖</span><br>npm <span class=\"hljs-built_in\">run</span> server              <span class=\"hljs-comment\"># 启动本地预览（http://localhost:4000）</span><br></code></pre></td></tr></table></figure>\n<p>执行完上述操作之后，在浏览器中输入地址<code>http://localhost:4000</code>, 你将看到整个博客的样子，其中包含一篇默认的 <code>Hello world</code>博文。</p>\n<p><img src=\"/../imgs/build-blog3/landscape.png\" alt=\"landscape\"></p>\n<p>如果你想要添加新的博客，执行 <code>hexo new post 文章标题</code>即可在 <code>source/_post</code>目录下生成一个新的 <code>.md</code>文件。如果不熟悉Markdown语法，可以查阅相关资料学习，上手其实挺快的。</p>\n<h3 id=\"step4-部署到Github-Page\"><a href=\"#step4-部署到Github-Page\" class=\"headerlink\" title=\"step4: 部署到Github Page\"></a>step4: 部署到Github Page</h3><p>执行命令下方命令</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">hexo generate<br></code></pre></td></tr></table></figure>\n\n<p>hexo将会把所有相关资源文件进行转换，最后所有的资源都都存放在 <code>public</code>目录下。将所有文件上传到上一篇文中提到的个人仓库或者使用git命令提交，等待一两分钟，访问自己的博客站点地址，你将看内容已经更新。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>Hexo 博客的默认主题是 <code>landscape</code>, 你也可以尝试着使用其它博客主题，如 <code>Next</code>, <code>Fluid</code>等。</p>\n<p>如果你想对博客站点做些修改，可以通过编辑其根目录下配置文件 <code>_config.yml</code> 来进行调整。如果在主题样式上需要做修改，也可以编辑其对应的配置文件，对应的配置文件在 <code>/themes/主题名称/</code>中。</p>\n<p>关于Hexo更多的配置可查阅其官方文档，里面都有十分详细的介绍。如果个人动手能力比较强，也可以尝试着写一些主题或者插件，那将是一件让你感到成就感满满的事情。</p>\n"},{"title":"搭建个人博客系列--(4) 利用Github Actions自动构建博客","date":"2025-06-14T07:37:45.000Z","keywords":["Github Actions","博客搭建","免费博客平台","托管博客","模板建站"],"index_img":"imgs/build-blog1/blog4.jpg","banner_img":"imgs/build-blog1/blog4.jpg","_content":"\n经过前面的系列文章的学习和实践，相信你已经成功的利用Hexo构建自己的博客并且部署到了Github上。\n\n目前整个发布博客的流程是，用markdown文件写好博客，然后使用Hexo编译成html, 最后将public下的内容部署到github上。整个过程虽然不复杂，但每次都要重新在本地编译然后上传，多少有些繁琐。\n\n这个时候我们可以寻求一种方法，实现博客自动编译和内容的部署，它就是 **Github Actions**。\n\n## 什么是Github Actions?\n\nGitHub Actions 是 GitHub 提供的 持续集成与持续部署（CI/CD）平台，允许开发者直接在 GitHub 仓库中自动化构建、测试、打包、发布代码，实现软件开发流程的自动化。通过定义 YAML 格式的配置文件（称为 Workflow），开发者可以定制化代码仓库的自动化工作流程，例如代码提交时自动运行测试、合并分支时自动部署到服务器等。\n\n## 核心概念\n\n### Workflow（工作流）\n- 一个 Workflow 是一个自动化流程，由一个或多个 Job 组成，通过 YAML 文件（.github/workflows/ 目录下）定义。\n\n- 可以配置 Workflow 在特定事件（如代码推送、Pull Request 创建、Issue 评论等）触发，或按计划定期运行。\n\n### Job（任务）\n\n- 一个 Job 是 Workflow 中的独立任务，包含一系列 Step，默认在一个虚拟机（Runner）上运行。\n- Jobs 可以并行或按顺序执行，支持定义依赖关系（如 Job B 等待 Job A 完成）。\n\n### Step（步骤）\n\n- Step 是 Job 中的最小执行单元，可以是运行 Shell 命令（如 npm install）或调用 Action（预定义的功能模块）。\n\n- 例如：拉取代码、安装依赖、运行测试、部署到服务器等。\n\n### Action（动作）\n\n- 可复用的代码模块，用于完成特定功能（如检出代码、设置环境、发送通知等）。\n\n- GitHub Marketplace 提供大量公开 Actions（如 actions/checkout、actions/setup-node），开发者也可自定义 Actions。\n\n## 举个例子\n\n以下是一个简单的 Workflow 配置（.github/workflows/node.js.yml），用于在 Node.js 项目中执行测试：\n\n```\nname: Node.js CI\non: [push] # 当代码推送时触发\n\njobs:\n  build:\n    runs-on: ubuntu-latest # 使用 Ubuntu 最新版虚拟机\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4 # 拉取代码到 Runner\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: 20 # 指定 Node.js 版本\n\n      - name: Install dependencies\n        run: npm install # 运行 Shell 命令安装依赖\n\n      - name: Run tests\n        run: npm test # 运行测试脚本\n```\n\n## 编写自动编译并部署博客脚本\n\n如果需要实现博客的自动化部署，那么有两个步骤要走，一是在push新内容的时候编译，二是编译之后部署到Github pages上。\n\n### 编译博客\n\n在之前的内容中，我们知道编译markdown文件成html文件使用的命令是 `hexo build`, 后来我们又将其写入到 `package.json`里的`scripts`中并取名为 `build`, 那么在执行编译的时候可以使用 `npm run build`来替代之前的命令。\n\n下面我们开始来写自动化脚本，首先在根目录下新建一个`./github/workflows/update-blogs.yml`文件，整体框架可以参考上面例子，因为使用的都是 Node 环境。\n\n完成一个build操作，要执行的操作分4步骤\n - 拉取代码\n - 配置Node环境\n - 安装依赖\n - 执行编译操作\n - 上传编译内容\n```\nname: automaticly update blogs\non: \n branches:\n  - master # master分支\njobs:\n  build:\n    runs-on: ubuntu-latest # 使用 Ubuntu 最新版虚拟机\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4 # 拉取代码到 Runner\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: 20 # 指定 Node.js 版本\n\n      - name: Install dependencies\n        run: |\n          npm install\n          npm install -g hexo-cli\n\n      - name: Run build\n        run: npm run build # 运行编译操作\n      \n      - name: Upload Pages artifact\n        uses: actions/upload-pages-artifact@v3 # 上传public目录内容\n        with:\n          path: ./public\n\n```\n\n修改点：\n\n- 不想任意分支提交都执行该操作，所以选择  `master` 分支有提交的时候执行。\n\n- 安装依赖依赖，需要在全局安装 `hexo-cli`\n\n- 上传内容使用的是Github Actions 官方的一个专用 Action: actions/upload-pages-aartifact, 主要用于 将静态网站文件打包并上传为 GitHub Pages 部署所需的 “工件”。\n\n\n### 部署博客\n\n在成功编译博客之后，也是通过一个官方的Action来实现博客内容的部署\n\n```\nname: automaticly update blogs\non: \n branches:\n  - master # master分支\njobs:\n  build:\n    ...\n\n  # 部署博客  \n  deploy:\n    needs: build   # 依赖上一个build操作\n    permissions:   # # 需授予 Pages 写入权限和生成部署令牌的权限\n      pages: write\n      id-token: write\n    environment:\n      name: github-pages\n      url: ${{ steps.deployment.outputs.page_url }}\n    runs-on: ubuntu-latest\n    steps:         # 使用actions 部署\n      - name: Deploy to GitHub Pages\n        id: deployment\n        uses: actions/deploy-pages@v4\n\n```\n\n## 测试验证\n\n编写完脚本之后，提交代码至 `master` 分支，在Github对应的仓库分支上可以看见已经有对应的workflow，如作者的脚本配置。\n\n![actions](https://www.jvxiao.cn/imgs/build-blog4/actions.png)\n\n如果左侧出现刚才脚本的名称 `automaticly update blogs`, 则说明已经配置成功了，可以通过提交内容到 master分支来检验脚本的执行情况。\n\n\n## 写在最后\n\n到目前为止，整个搭建个人博客系列文章已经实现了个人博客站点的搭建和自动化部署，相信此时的你也搭建好了自己的博客站点。\n\n正如之前所说，博客站点最重要的就是价值输出，也就是要勤写内容。但是有时候，酒香也怕巷子深，如何让更多的人看到自己写的文章，增加个人影响力，这将是后面将要讨论的问题，请持续关注！","source":"_posts/build-personal-blog4.md","raw":"---\ntitle: 搭建个人博客系列--(4) 利用Github Actions自动构建博客\ndate: 2025-06-14 15:37:45\ncategory: 搭建博客\ntags: \n   - 博客搭建\n   - 个人IP\nkeywords: [Github Actions, 博客搭建, 免费博客平台, 托管博客, 模板建站]\nindex_img: imgs/build-blog1/blog4.jpg\nbanner_img: imgs/build-blog1/blog4.jpg\n---\n\n经过前面的系列文章的学习和实践，相信你已经成功的利用Hexo构建自己的博客并且部署到了Github上。\n\n目前整个发布博客的流程是，用markdown文件写好博客，然后使用Hexo编译成html, 最后将public下的内容部署到github上。整个过程虽然不复杂，但每次都要重新在本地编译然后上传，多少有些繁琐。\n\n这个时候我们可以寻求一种方法，实现博客自动编译和内容的部署，它就是 **Github Actions**。\n\n## 什么是Github Actions?\n\nGitHub Actions 是 GitHub 提供的 持续集成与持续部署（CI/CD）平台，允许开发者直接在 GitHub 仓库中自动化构建、测试、打包、发布代码，实现软件开发流程的自动化。通过定义 YAML 格式的配置文件（称为 Workflow），开发者可以定制化代码仓库的自动化工作流程，例如代码提交时自动运行测试、合并分支时自动部署到服务器等。\n\n## 核心概念\n\n### Workflow（工作流）\n- 一个 Workflow 是一个自动化流程，由一个或多个 Job 组成，通过 YAML 文件（.github/workflows/ 目录下）定义。\n\n- 可以配置 Workflow 在特定事件（如代码推送、Pull Request 创建、Issue 评论等）触发，或按计划定期运行。\n\n### Job（任务）\n\n- 一个 Job 是 Workflow 中的独立任务，包含一系列 Step，默认在一个虚拟机（Runner）上运行。\n- Jobs 可以并行或按顺序执行，支持定义依赖关系（如 Job B 等待 Job A 完成）。\n\n### Step（步骤）\n\n- Step 是 Job 中的最小执行单元，可以是运行 Shell 命令（如 npm install）或调用 Action（预定义的功能模块）。\n\n- 例如：拉取代码、安装依赖、运行测试、部署到服务器等。\n\n### Action（动作）\n\n- 可复用的代码模块，用于完成特定功能（如检出代码、设置环境、发送通知等）。\n\n- GitHub Marketplace 提供大量公开 Actions（如 actions/checkout、actions/setup-node），开发者也可自定义 Actions。\n\n## 举个例子\n\n以下是一个简单的 Workflow 配置（.github/workflows/node.js.yml），用于在 Node.js 项目中执行测试：\n\n```\nname: Node.js CI\non: [push] # 当代码推送时触发\n\njobs:\n  build:\n    runs-on: ubuntu-latest # 使用 Ubuntu 最新版虚拟机\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4 # 拉取代码到 Runner\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: 20 # 指定 Node.js 版本\n\n      - name: Install dependencies\n        run: npm install # 运行 Shell 命令安装依赖\n\n      - name: Run tests\n        run: npm test # 运行测试脚本\n```\n\n## 编写自动编译并部署博客脚本\n\n如果需要实现博客的自动化部署，那么有两个步骤要走，一是在push新内容的时候编译，二是编译之后部署到Github pages上。\n\n### 编译博客\n\n在之前的内容中，我们知道编译markdown文件成html文件使用的命令是 `hexo build`, 后来我们又将其写入到 `package.json`里的`scripts`中并取名为 `build`, 那么在执行编译的时候可以使用 `npm run build`来替代之前的命令。\n\n下面我们开始来写自动化脚本，首先在根目录下新建一个`./github/workflows/update-blogs.yml`文件，整体框架可以参考上面例子，因为使用的都是 Node 环境。\n\n完成一个build操作，要执行的操作分4步骤\n - 拉取代码\n - 配置Node环境\n - 安装依赖\n - 执行编译操作\n - 上传编译内容\n```\nname: automaticly update blogs\non: \n branches:\n  - master # master分支\njobs:\n  build:\n    runs-on: ubuntu-latest # 使用 Ubuntu 最新版虚拟机\n    steps:\n      - name: Checkout code\n        uses: actions/checkout@v4 # 拉取代码到 Runner\n\n      - name: Set up Node.js\n        uses: actions/setup-node@v4\n        with:\n          node-version: 20 # 指定 Node.js 版本\n\n      - name: Install dependencies\n        run: |\n          npm install\n          npm install -g hexo-cli\n\n      - name: Run build\n        run: npm run build # 运行编译操作\n      \n      - name: Upload Pages artifact\n        uses: actions/upload-pages-artifact@v3 # 上传public目录内容\n        with:\n          path: ./public\n\n```\n\n修改点：\n\n- 不想任意分支提交都执行该操作，所以选择  `master` 分支有提交的时候执行。\n\n- 安装依赖依赖，需要在全局安装 `hexo-cli`\n\n- 上传内容使用的是Github Actions 官方的一个专用 Action: actions/upload-pages-aartifact, 主要用于 将静态网站文件打包并上传为 GitHub Pages 部署所需的 “工件”。\n\n\n### 部署博客\n\n在成功编译博客之后，也是通过一个官方的Action来实现博客内容的部署\n\n```\nname: automaticly update blogs\non: \n branches:\n  - master # master分支\njobs:\n  build:\n    ...\n\n  # 部署博客  \n  deploy:\n    needs: build   # 依赖上一个build操作\n    permissions:   # # 需授予 Pages 写入权限和生成部署令牌的权限\n      pages: write\n      id-token: write\n    environment:\n      name: github-pages\n      url: ${{ steps.deployment.outputs.page_url }}\n    runs-on: ubuntu-latest\n    steps:         # 使用actions 部署\n      - name: Deploy to GitHub Pages\n        id: deployment\n        uses: actions/deploy-pages@v4\n\n```\n\n## 测试验证\n\n编写完脚本之后，提交代码至 `master` 分支，在Github对应的仓库分支上可以看见已经有对应的workflow，如作者的脚本配置。\n\n![actions](https://www.jvxiao.cn/imgs/build-blog4/actions.png)\n\n如果左侧出现刚才脚本的名称 `automaticly update blogs`, 则说明已经配置成功了，可以通过提交内容到 master分支来检验脚本的执行情况。\n\n\n## 写在最后\n\n到目前为止，整个搭建个人博客系列文章已经实现了个人博客站点的搭建和自动化部署，相信此时的你也搭建好了自己的博客站点。\n\n正如之前所说，博客站点最重要的就是价值输出，也就是要勤写内容。但是有时候，酒香也怕巷子深，如何让更多的人看到自己写的文章，增加个人影响力，这将是后面将要讨论的问题，请持续关注！","slug":"build-personal-blog4","published":1,"updated":"2025-08-26T10:17:52.503Z","comments":1,"layout":"post","photos":[],"_id":"cmjbml2i7000tikuphdhmg2gc","content":"<p>经过前面的系列文章的学习和实践，相信你已经成功的利用Hexo构建自己的博客并且部署到了Github上。</p>\n<p>目前整个发布博客的流程是，用markdown文件写好博客，然后使用Hexo编译成html, 最后将public下的内容部署到github上。整个过程虽然不复杂，但每次都要重新在本地编译然后上传，多少有些繁琐。</p>\n<p>这个时候我们可以寻求一种方法，实现博客自动编译和内容的部署，它就是 <strong>Github Actions</strong>。</p>\n<h2 id=\"什么是Github-Actions\"><a href=\"#什么是Github-Actions\" class=\"headerlink\" title=\"什么是Github Actions?\"></a>什么是Github Actions?</h2><p>GitHub Actions 是 GitHub 提供的 持续集成与持续部署（CI&#x2F;CD）平台，允许开发者直接在 GitHub 仓库中自动化构建、测试、打包、发布代码，实现软件开发流程的自动化。通过定义 YAML 格式的配置文件（称为 Workflow），开发者可以定制化代码仓库的自动化工作流程，例如代码提交时自动运行测试、合并分支时自动部署到服务器等。</p>\n<h2 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h2><h3 id=\"Workflow（工作流）\"><a href=\"#Workflow（工作流）\" class=\"headerlink\" title=\"Workflow（工作流）\"></a>Workflow（工作流）</h3><ul>\n<li><p>一个 Workflow 是一个自动化流程，由一个或多个 Job 组成，通过 YAML 文件（.github&#x2F;workflows&#x2F; 目录下）定义。</p>\n</li>\n<li><p>可以配置 Workflow 在特定事件（如代码推送、Pull Request 创建、Issue 评论等）触发，或按计划定期运行。</p>\n</li>\n</ul>\n<h3 id=\"Job（任务）\"><a href=\"#Job（任务）\" class=\"headerlink\" title=\"Job（任务）\"></a>Job（任务）</h3><ul>\n<li>一个 Job 是 Workflow 中的独立任务，包含一系列 Step，默认在一个虚拟机（Runner）上运行。</li>\n<li>Jobs 可以并行或按顺序执行，支持定义依赖关系（如 Job B 等待 Job A 完成）。</li>\n</ul>\n<h3 id=\"Step（步骤）\"><a href=\"#Step（步骤）\" class=\"headerlink\" title=\"Step（步骤）\"></a>Step（步骤）</h3><ul>\n<li><p>Step 是 Job 中的最小执行单元，可以是运行 Shell 命令（如 npm install）或调用 Action（预定义的功能模块）。</p>\n</li>\n<li><p>例如：拉取代码、安装依赖、运行测试、部署到服务器等。</p>\n</li>\n</ul>\n<h3 id=\"Action（动作）\"><a href=\"#Action（动作）\" class=\"headerlink\" title=\"Action（动作）\"></a>Action（动作）</h3><ul>\n<li><p>可复用的代码模块，用于完成特定功能（如检出代码、设置环境、发送通知等）。</p>\n</li>\n<li><p>GitHub Marketplace 提供大量公开 Actions（如 actions&#x2F;checkout、actions&#x2F;setup-node），开发者也可自定义 Actions。</p>\n</li>\n</ul>\n<h2 id=\"举个例子\"><a href=\"#举个例子\" class=\"headerlink\" title=\"举个例子\"></a>举个例子</h2><p>以下是一个简单的 Workflow 配置（.github&#x2F;workflows&#x2F;node.js.yml），用于在 Node.js 项目中执行测试：</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nix\"><span class=\"hljs-params\">name:</span> Node.js CI<br><span class=\"hljs-params\">on:</span> [push] <span class=\"hljs-comment\"># 当代码推送时触发</span><br><br><span class=\"hljs-params\">jobs:</span><br>  <span class=\"hljs-params\">build:</span><br>    <span class=\"hljs-params\">runs-on:</span> ubuntu-latest <span class=\"hljs-comment\"># 使用 Ubuntu 最新版虚拟机</span><br>    <span class=\"hljs-params\">steps:</span><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Checkout code<br>        <span class=\"hljs-params\">uses:</span> actions<span class=\"hljs-operator\">/</span>checkout@v4 <span class=\"hljs-comment\"># 拉取代码到 Runner</span><br><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Set up Node.js<br>        <span class=\"hljs-params\">uses:</span> actions<span class=\"hljs-operator\">/</span>setup-node@v4<br>        <span class=\"hljs-params\">with:</span><br>          <span class=\"hljs-params\">node-version:</span> <span class=\"hljs-number\">20</span> <span class=\"hljs-comment\"># 指定 Node.js 版本</span><br><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Install dependencies<br>        <span class=\"hljs-params\">run:</span> npm install <span class=\"hljs-comment\"># 运行 Shell 命令安装依赖</span><br><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Run tests<br>        <span class=\"hljs-params\">run:</span> npm test <span class=\"hljs-comment\"># 运行测试脚本</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"编写自动编译并部署博客脚本\"><a href=\"#编写自动编译并部署博客脚本\" class=\"headerlink\" title=\"编写自动编译并部署博客脚本\"></a>编写自动编译并部署博客脚本</h2><p>如果需要实现博客的自动化部署，那么有两个步骤要走，一是在push新内容的时候编译，二是编译之后部署到Github pages上。</p>\n<h3 id=\"编译博客\"><a href=\"#编译博客\" class=\"headerlink\" title=\"编译博客\"></a>编译博客</h3><p>在之前的内容中，我们知道编译markdown文件成html文件使用的命令是 <code>hexo build</code>, 后来我们又将其写入到 <code>package.json</code>里的<code>scripts</code>中并取名为 <code>build</code>, 那么在执行编译的时候可以使用 <code>npm run build</code>来替代之前的命令。</p>\n<p>下面我们开始来写自动化脚本，首先在根目录下新建一个<code>./github/workflows/update-blogs.yml</code>文件，整体框架可以参考上面例子，因为使用的都是 Node 环境。</p>\n<p>完成一个build操作，要执行的操作分4步骤</p>\n<ul>\n<li>拉取代码</li>\n<li>配置Node环境</li>\n<li>安装依赖</li>\n<li>执行编译操作</li>\n<li>上传编译内容<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nix\"><span class=\"hljs-params\">name:</span> automaticly update blogs<br><span class=\"hljs-params\">on:</span> <br> <span class=\"hljs-params\">branches:</span><br>  <span class=\"hljs-operator\">-</span> master <span class=\"hljs-comment\"># master分支</span><br><span class=\"hljs-params\">jobs:</span><br>  <span class=\"hljs-params\">build:</span><br>    <span class=\"hljs-params\">runs-on:</span> ubuntu-latest <span class=\"hljs-comment\"># 使用 Ubuntu 最新版虚拟机</span><br>    <span class=\"hljs-params\">steps:</span><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Checkout code<br>        <span class=\"hljs-params\">uses:</span> actions<span class=\"hljs-operator\">/</span>checkout@v4 <span class=\"hljs-comment\"># 拉取代码到 Runner</span><br><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Set up Node.js<br>        <span class=\"hljs-params\">uses:</span> actions<span class=\"hljs-operator\">/</span>setup-node@v4<br>        <span class=\"hljs-params\">with:</span><br>          <span class=\"hljs-params\">node-version:</span> <span class=\"hljs-number\">20</span> <span class=\"hljs-comment\"># 指定 Node.js 版本</span><br><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Install dependencies<br>        <span class=\"hljs-params\">run:</span> |<br>          npm install<br>          npm install <span class=\"hljs-operator\">-</span>g hexo-cli<br><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Run build<br>        <span class=\"hljs-params\">run:</span> npm run build <span class=\"hljs-comment\"># 运行编译操作</span><br>      <br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Upload Pages artifact<br>        <span class=\"hljs-params\">uses:</span> actions<span class=\"hljs-operator\">/</span>upload-pages-artifact@v3 <span class=\"hljs-comment\"># 上传public目录内容</span><br>        <span class=\"hljs-params\">with:</span><br>          <span class=\"hljs-params\">path:</span> <span class=\"hljs-symbol\">./public</span><br><br></code></pre></td></tr></table></figure></li>\n</ul>\n<p>修改点：</p>\n<ul>\n<li><p>不想任意分支提交都执行该操作，所以选择  <code>master</code> 分支有提交的时候执行。</p>\n</li>\n<li><p>安装依赖依赖，需要在全局安装 <code>hexo-cli</code></p>\n</li>\n<li><p>上传内容使用的是Github Actions 官方的一个专用 Action: actions&#x2F;upload-pages-aartifact, 主要用于 将静态网站文件打包并上传为 GitHub Pages 部署所需的 “工件”。</p>\n</li>\n</ul>\n<h3 id=\"部署博客\"><a href=\"#部署博客\" class=\"headerlink\" title=\"部署博客\"></a>部署博客</h3><p>在成功编译博客之后，也是通过一个官方的Action来实现博客内容的部署</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nix\"><span class=\"hljs-params\">name:</span> automaticly update blogs<br><span class=\"hljs-params\">on:</span> <br> <span class=\"hljs-params\">branches:</span><br>  <span class=\"hljs-operator\">-</span> master <span class=\"hljs-comment\"># master分支</span><br><span class=\"hljs-params\">jobs:</span><br>  <span class=\"hljs-params\">build:</span><br>    ...<br><br>  <span class=\"hljs-comment\"># 部署博客  </span><br>  <span class=\"hljs-params\">deploy:</span><br>    <span class=\"hljs-params\">needs:</span> build   <span class=\"hljs-comment\"># 依赖上一个build操作</span><br>    <span class=\"hljs-params\">permissions:</span>   <span class=\"hljs-comment\"># # 需授予 Pages 写入权限和生成部署令牌的权限</span><br>      <span class=\"hljs-params\">pages:</span> write<br>      <span class=\"hljs-params\">id-token:</span> write<br>    <span class=\"hljs-params\">environment:</span><br>      <span class=\"hljs-params\">name:</span> github-pages<br>      <span class=\"hljs-params\">url:</span> $&#123;&#123; steps.deployment.outputs.page_url &#125;&#125;<br>    <span class=\"hljs-params\">runs-on:</span> ubuntu-latest<br>    <span class=\"hljs-params\">steps:</span>         <span class=\"hljs-comment\"># 使用actions 部署</span><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Deploy to GitHub Pages<br>        <span class=\"hljs-params\">id:</span> deployment<br>        <span class=\"hljs-params\">uses:</span> actions<span class=\"hljs-operator\">/</span>deploy-pages@v4<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"测试验证\"><a href=\"#测试验证\" class=\"headerlink\" title=\"测试验证\"></a>测试验证</h2><p>编写完脚本之后，提交代码至 <code>master</code> 分支，在Github对应的仓库分支上可以看见已经有对应的workflow，如作者的脚本配置。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/build-blog4/actions.png\" alt=\"actions\"></p>\n<p>如果左侧出现刚才脚本的名称 <code>automaticly update blogs</code>, 则说明已经配置成功了，可以通过提交内容到 master分支来检验脚本的执行情况。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>到目前为止，整个搭建个人博客系列文章已经实现了个人博客站点的搭建和自动化部署，相信此时的你也搭建好了自己的博客站点。</p>\n<p>正如之前所说，博客站点最重要的就是价值输出，也就是要勤写内容。但是有时候，酒香也怕巷子深，如何让更多的人看到自己写的文章，增加个人影响力，这将是后面将要讨论的问题，请持续关注！</p>\n","excerpt":"","more":"<p>经过前面的系列文章的学习和实践，相信你已经成功的利用Hexo构建自己的博客并且部署到了Github上。</p>\n<p>目前整个发布博客的流程是，用markdown文件写好博客，然后使用Hexo编译成html, 最后将public下的内容部署到github上。整个过程虽然不复杂，但每次都要重新在本地编译然后上传，多少有些繁琐。</p>\n<p>这个时候我们可以寻求一种方法，实现博客自动编译和内容的部署，它就是 <strong>Github Actions</strong>。</p>\n<h2 id=\"什么是Github-Actions\"><a href=\"#什么是Github-Actions\" class=\"headerlink\" title=\"什么是Github Actions?\"></a>什么是Github Actions?</h2><p>GitHub Actions 是 GitHub 提供的 持续集成与持续部署（CI&#x2F;CD）平台，允许开发者直接在 GitHub 仓库中自动化构建、测试、打包、发布代码，实现软件开发流程的自动化。通过定义 YAML 格式的配置文件（称为 Workflow），开发者可以定制化代码仓库的自动化工作流程，例如代码提交时自动运行测试、合并分支时自动部署到服务器等。</p>\n<h2 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h2><h3 id=\"Workflow（工作流）\"><a href=\"#Workflow（工作流）\" class=\"headerlink\" title=\"Workflow（工作流）\"></a>Workflow（工作流）</h3><ul>\n<li><p>一个 Workflow 是一个自动化流程，由一个或多个 Job 组成，通过 YAML 文件（.github&#x2F;workflows&#x2F; 目录下）定义。</p>\n</li>\n<li><p>可以配置 Workflow 在特定事件（如代码推送、Pull Request 创建、Issue 评论等）触发，或按计划定期运行。</p>\n</li>\n</ul>\n<h3 id=\"Job（任务）\"><a href=\"#Job（任务）\" class=\"headerlink\" title=\"Job（任务）\"></a>Job（任务）</h3><ul>\n<li>一个 Job 是 Workflow 中的独立任务，包含一系列 Step，默认在一个虚拟机（Runner）上运行。</li>\n<li>Jobs 可以并行或按顺序执行，支持定义依赖关系（如 Job B 等待 Job A 完成）。</li>\n</ul>\n<h3 id=\"Step（步骤）\"><a href=\"#Step（步骤）\" class=\"headerlink\" title=\"Step（步骤）\"></a>Step（步骤）</h3><ul>\n<li><p>Step 是 Job 中的最小执行单元，可以是运行 Shell 命令（如 npm install）或调用 Action（预定义的功能模块）。</p>\n</li>\n<li><p>例如：拉取代码、安装依赖、运行测试、部署到服务器等。</p>\n</li>\n</ul>\n<h3 id=\"Action（动作）\"><a href=\"#Action（动作）\" class=\"headerlink\" title=\"Action（动作）\"></a>Action（动作）</h3><ul>\n<li><p>可复用的代码模块，用于完成特定功能（如检出代码、设置环境、发送通知等）。</p>\n</li>\n<li><p>GitHub Marketplace 提供大量公开 Actions（如 actions&#x2F;checkout、actions&#x2F;setup-node），开发者也可自定义 Actions。</p>\n</li>\n</ul>\n<h2 id=\"举个例子\"><a href=\"#举个例子\" class=\"headerlink\" title=\"举个例子\"></a>举个例子</h2><p>以下是一个简单的 Workflow 配置（.github&#x2F;workflows&#x2F;node.js.yml），用于在 Node.js 项目中执行测试：</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nix\"><span class=\"hljs-params\">name:</span> Node.js CI<br><span class=\"hljs-params\">on:</span> [push] <span class=\"hljs-comment\"># 当代码推送时触发</span><br><br><span class=\"hljs-params\">jobs:</span><br>  <span class=\"hljs-params\">build:</span><br>    <span class=\"hljs-params\">runs-on:</span> ubuntu-latest <span class=\"hljs-comment\"># 使用 Ubuntu 最新版虚拟机</span><br>    <span class=\"hljs-params\">steps:</span><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Checkout code<br>        <span class=\"hljs-params\">uses:</span> actions<span class=\"hljs-operator\">/</span>checkout@v4 <span class=\"hljs-comment\"># 拉取代码到 Runner</span><br><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Set up Node.js<br>        <span class=\"hljs-params\">uses:</span> actions<span class=\"hljs-operator\">/</span>setup-node@v4<br>        <span class=\"hljs-params\">with:</span><br>          <span class=\"hljs-params\">node-version:</span> <span class=\"hljs-number\">20</span> <span class=\"hljs-comment\"># 指定 Node.js 版本</span><br><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Install dependencies<br>        <span class=\"hljs-params\">run:</span> npm install <span class=\"hljs-comment\"># 运行 Shell 命令安装依赖</span><br><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Run tests<br>        <span class=\"hljs-params\">run:</span> npm test <span class=\"hljs-comment\"># 运行测试脚本</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"编写自动编译并部署博客脚本\"><a href=\"#编写自动编译并部署博客脚本\" class=\"headerlink\" title=\"编写自动编译并部署博客脚本\"></a>编写自动编译并部署博客脚本</h2><p>如果需要实现博客的自动化部署，那么有两个步骤要走，一是在push新内容的时候编译，二是编译之后部署到Github pages上。</p>\n<h3 id=\"编译博客\"><a href=\"#编译博客\" class=\"headerlink\" title=\"编译博客\"></a>编译博客</h3><p>在之前的内容中，我们知道编译markdown文件成html文件使用的命令是 <code>hexo build</code>, 后来我们又将其写入到 <code>package.json</code>里的<code>scripts</code>中并取名为 <code>build</code>, 那么在执行编译的时候可以使用 <code>npm run build</code>来替代之前的命令。</p>\n<p>下面我们开始来写自动化脚本，首先在根目录下新建一个<code>./github/workflows/update-blogs.yml</code>文件，整体框架可以参考上面例子，因为使用的都是 Node 环境。</p>\n<p>完成一个build操作，要执行的操作分4步骤</p>\n<ul>\n<li>拉取代码</li>\n<li>配置Node环境</li>\n<li>安装依赖</li>\n<li>执行编译操作</li>\n<li>上传编译内容<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nix\"><span class=\"hljs-params\">name:</span> automaticly update blogs<br><span class=\"hljs-params\">on:</span> <br> <span class=\"hljs-params\">branches:</span><br>  <span class=\"hljs-operator\">-</span> master <span class=\"hljs-comment\"># master分支</span><br><span class=\"hljs-params\">jobs:</span><br>  <span class=\"hljs-params\">build:</span><br>    <span class=\"hljs-params\">runs-on:</span> ubuntu-latest <span class=\"hljs-comment\"># 使用 Ubuntu 最新版虚拟机</span><br>    <span class=\"hljs-params\">steps:</span><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Checkout code<br>        <span class=\"hljs-params\">uses:</span> actions<span class=\"hljs-operator\">/</span>checkout@v4 <span class=\"hljs-comment\"># 拉取代码到 Runner</span><br><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Set up Node.js<br>        <span class=\"hljs-params\">uses:</span> actions<span class=\"hljs-operator\">/</span>setup-node@v4<br>        <span class=\"hljs-params\">with:</span><br>          <span class=\"hljs-params\">node-version:</span> <span class=\"hljs-number\">20</span> <span class=\"hljs-comment\"># 指定 Node.js 版本</span><br><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Install dependencies<br>        <span class=\"hljs-params\">run:</span> |<br>          npm install<br>          npm install <span class=\"hljs-operator\">-</span>g hexo-cli<br><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Run build<br>        <span class=\"hljs-params\">run:</span> npm run build <span class=\"hljs-comment\"># 运行编译操作</span><br>      <br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Upload Pages artifact<br>        <span class=\"hljs-params\">uses:</span> actions<span class=\"hljs-operator\">/</span>upload-pages-artifact@v3 <span class=\"hljs-comment\"># 上传public目录内容</span><br>        <span class=\"hljs-params\">with:</span><br>          <span class=\"hljs-params\">path:</span> <span class=\"hljs-symbol\">./public</span><br><br></code></pre></td></tr></table></figure></li>\n</ul>\n<p>修改点：</p>\n<ul>\n<li><p>不想任意分支提交都执行该操作，所以选择  <code>master</code> 分支有提交的时候执行。</p>\n</li>\n<li><p>安装依赖依赖，需要在全局安装 <code>hexo-cli</code></p>\n</li>\n<li><p>上传内容使用的是Github Actions 官方的一个专用 Action: actions&#x2F;upload-pages-aartifact, 主要用于 将静态网站文件打包并上传为 GitHub Pages 部署所需的 “工件”。</p>\n</li>\n</ul>\n<h3 id=\"部署博客\"><a href=\"#部署博客\" class=\"headerlink\" title=\"部署博客\"></a>部署博客</h3><p>在成功编译博客之后，也是通过一个官方的Action来实现博客内容的部署</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nix\"><span class=\"hljs-params\">name:</span> automaticly update blogs<br><span class=\"hljs-params\">on:</span> <br> <span class=\"hljs-params\">branches:</span><br>  <span class=\"hljs-operator\">-</span> master <span class=\"hljs-comment\"># master分支</span><br><span class=\"hljs-params\">jobs:</span><br>  <span class=\"hljs-params\">build:</span><br>    ...<br><br>  <span class=\"hljs-comment\"># 部署博客  </span><br>  <span class=\"hljs-params\">deploy:</span><br>    <span class=\"hljs-params\">needs:</span> build   <span class=\"hljs-comment\"># 依赖上一个build操作</span><br>    <span class=\"hljs-params\">permissions:</span>   <span class=\"hljs-comment\"># # 需授予 Pages 写入权限和生成部署令牌的权限</span><br>      <span class=\"hljs-params\">pages:</span> write<br>      <span class=\"hljs-params\">id-token:</span> write<br>    <span class=\"hljs-params\">environment:</span><br>      <span class=\"hljs-params\">name:</span> github-pages<br>      <span class=\"hljs-params\">url:</span> $&#123;&#123; steps.deployment.outputs.page_url &#125;&#125;<br>    <span class=\"hljs-params\">runs-on:</span> ubuntu-latest<br>    <span class=\"hljs-params\">steps:</span>         <span class=\"hljs-comment\"># 使用actions 部署</span><br>      <span class=\"hljs-operator\">-</span> <span class=\"hljs-params\">name:</span> Deploy to GitHub Pages<br>        <span class=\"hljs-params\">id:</span> deployment<br>        <span class=\"hljs-params\">uses:</span> actions<span class=\"hljs-operator\">/</span>deploy-pages@v4<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"测试验证\"><a href=\"#测试验证\" class=\"headerlink\" title=\"测试验证\"></a>测试验证</h2><p>编写完脚本之后，提交代码至 <code>master</code> 分支，在Github对应的仓库分支上可以看见已经有对应的workflow，如作者的脚本配置。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/build-blog4/actions.png\" alt=\"actions\"></p>\n<p>如果左侧出现刚才脚本的名称 <code>automaticly update blogs</code>, 则说明已经配置成功了，可以通过提交内容到 master分支来检验脚本的执行情况。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>到目前为止，整个搭建个人博客系列文章已经实现了个人博客站点的搭建和自动化部署，相信此时的你也搭建好了自己的博客站点。</p>\n<p>正如之前所说，博客站点最重要的就是价值输出，也就是要勤写内容。但是有时候，酒香也怕巷子深，如何让更多的人看到自己写的文章，增加个人影响力，这将是后面将要讨论的问题，请持续关注！</p>\n"},{"title":"别再被闭包 “绕晕”！3 分钟搞懂定义、形成与实战作用","date":"2025-08-14T00:04:55.000Z","keywords":["闭包，作用域"],"index_img":"imgs/closure/closure.png","banner_img":"imgs/closure/closure.png","_content":"---\n\n闭包，算得上是JavaScript中的一个难点，在面试时也被时常提及。\n\n多年前的一次面试，被问及闭包时，那种脑子里一团乱麻的感觉，至今依然清晰。\n\n本文力求以简单移动柜的语言，彻底讲清楚闭包，让读者在日后的面试和工作中，少走一些弯路，少掉一些头发。\n\n\n## 什么是闭包？\n\n要讲清楚闭包，那么我们首先得了解闭包是什么。为此，我翻阅许多资料收集了其中关于闭包的定义：\n\n- **《JavaScript权威指南（第六版）》**： 函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称之为“闭包”。\n\n- **《JavaScript 高级程序设计》**： 闭包指的是那些引用了另外一个函数作用域中变量的函数，通常是嵌套在函数中实现的。\n\n- **《你不知道的JavaScript》**： 函数可以记住并访问所在词法作用域，即使函数实在当前词法作用域之外执行，这就产生了闭包。\n\n- **MDN**: 闭包是由捆绑起来（封闭的）的函数和函数周围状态（词法环境）引用组合而成，闭包让函数能够访问它的外部作用域。\n\n\n\n好嘛，真是一看一个不吱声，根本没有一个统一的定义。有的说闭包是特性，有的直说是怎么形成的，各讲各话。\n\n你就说，看这些东西，你能不蒙？\n\n按我们的理解，定义就应该是 `xx是xx` 的格式，在这里我们以最简单的格式来定义闭包\n\n**闭包是一个函数与其周围词法环境的集合**。当函数被定义时，他会捕获其外部作用域中的变量，即使外部函数已经执行完毕，这些变量依然可以被访问和修改。\n\n以后再被问及什么是闭包的时候，粗体部分文字就是答案，剩下的则可以作为解释。\n\n\n## 闭包的形成\n\n搞清楚了闭包的定义，下面通过一个简单的案例直观地理解一下闭包的形成。\n\n```\nfunction outer() {\n  let outerVar = \"我是外部变量\"; // 外部函数的局部变量\n\n  // 内部函数定义（满足“函数嵌套”）\n  function inner() {\n    console.log(outerVar); // 内部函数引用外部变量（满足“作用域访问”）\n  }\n\n  return inner; // 内部函数被返回（满足“外部返回”）\n}\n\n// 内部函数被“带出”外部作用域，并赋值给全局变量\nconst closureFunc = outer(); \n\n// 在外部调用内部函数，闭包生效\nclosureFunc(); // 输出：\"我是外部变量\"（成功访问outer的局部变量）\n```\n\n从上面的例子我们可以看出，outer执行完毕后，outerVar本应被销毁，但由于inner被返回并赋值给closureFunc，inner仍保留对outer作用域的引用。当closureFunc()调用时，inner通过闭包访问到了outerVar。\n\n![example](../imgs/closure/example.png)\n\n闭包形成的关键就在于内部函数在外部函数中定义时，会捕获当前的作用域链（包含外部函数的作用域和全局作用域）。即使内部函数未被立即调用，它也会保留对这些作用域的引用。\n\n## 闭包的作用\n\n明白了闭包的形成之后，我们再来看看闭包在实际开发过程中的一些用途。\n\n当然了，下面的内容都是围绕着闭包的核心作用展开的：**让内部函数能够保留对外部作用域的引用，即使外部函数已经执行完毕**。\n\n- **保存变量状态（数据私有化与封装）**\n\n闭包可以将变量 “隐藏” 在外部函数的作用域中，只通过内部函数暴露操作接口，实现类似 “私有变量” 的效果，避免全局变量污染。\n\n```javascript\nfunction createCounter() {\n  let count = 0; // 被闭包“保护”的变量，外部无法直接访问\n  return {\n    increment: () => { count++; return count; },\n    decrement: () => { count--; return count; }\n  };\n}\n\nconst counter = createCounter();\nconsole.log(counter.increment()); // 1（count被修改并保留状态）\nconsole.log(counter.increment()); // 2（状态持续保留）\n```\n\n- **实现函数工厂（动态生成定制化函数）**\n\n通过闭包可以创建带有 “记忆” 能力的函数，根据外部变量的不同生成不同逻辑的函数，提高代码复用性。\n\n```javascript\nfunction createGreeting(prefix) {\n  return function(name) { // 内部函数记住prefix的值\n    console.log(`${prefix}, ${name}!`);\n  };\n}\n\nconst sayHello = createGreeting(\"Hello\");\nconst sayHi = createGreeting(\"Hi\");\n\nsayHello(\"Alice\"); // \"Hello, Alice!\"（记住prefix为\"Hello\"）\nsayHi(\"Bob\");      // \"Hi, Bob!\"（记住prefix为\"Hi\"）\n```\n\n- **延迟执行与回调函数中的状态保留**\n\n闭包可以保留回调函数创建时的上下文状态，避免因变量作用域变化导致的问题, 这个在涉及一些定时器、或者事件监听等操作时非常有用。\n\n来一个大家都熟悉的例子\n\n```\nfor (var i = 0; i < 3; i++) {\n  // 使用闭包保留每次循环的i值\n  (function(j) {\n    setTimeout(() => {\n      console.log(j); // 输出0、1、2（而非3次3）\n    }, 1000);\n  })(i);\n}\n```\n若不使用闭包，定时器回调会共享全局的i，最终输出 3 次3；闭包则让每次循环的i值被独立保存。\n\n- **模块化开发**\n\n在 ES6 模块出现之前，闭包是实现模块化的核心方式：通过外部函数包裹代码，只暴露需要公开的接口，隐藏内部实现细节。\n\n\n## 写在最后\n\nOkay, 到这里想必都已经清楚了闭包的定义，它的形成和作用了，在日后的面试中和工作中遇到了闭包也用不着犯难了。\n\n闭包在开发过程中应用非常广，在一些高级函数，封装操作或者状态管理中都能看到闭包的影子。\n\n虽然好用，但是也不要滥用，过多的使用闭包可能占用过多内存，甚至引发内存泄漏，毕竟不是所有开发者都会自觉清理掉不必要引用的，哈哈，偷笑~。","source":"_posts/closure.md","raw":"---\ntitle: 别再被闭包 “绕晕”！3 分钟搞懂定义、形成与实战作用\ndate: 2025-08-14 08:04:55\ntags: [闭包，作用域]\nkeywords: [闭包，作用域]\nindex_img: imgs/closure/closure.png\nbanner_img: imgs/closure/closure.png\n---\n---\n\n闭包，算得上是JavaScript中的一个难点，在面试时也被时常提及。\n\n多年前的一次面试，被问及闭包时，那种脑子里一团乱麻的感觉，至今依然清晰。\n\n本文力求以简单移动柜的语言，彻底讲清楚闭包，让读者在日后的面试和工作中，少走一些弯路，少掉一些头发。\n\n\n## 什么是闭包？\n\n要讲清楚闭包，那么我们首先得了解闭包是什么。为此，我翻阅许多资料收集了其中关于闭包的定义：\n\n- **《JavaScript权威指南（第六版）》**： 函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称之为“闭包”。\n\n- **《JavaScript 高级程序设计》**： 闭包指的是那些引用了另外一个函数作用域中变量的函数，通常是嵌套在函数中实现的。\n\n- **《你不知道的JavaScript》**： 函数可以记住并访问所在词法作用域，即使函数实在当前词法作用域之外执行，这就产生了闭包。\n\n- **MDN**: 闭包是由捆绑起来（封闭的）的函数和函数周围状态（词法环境）引用组合而成，闭包让函数能够访问它的外部作用域。\n\n\n\n好嘛，真是一看一个不吱声，根本没有一个统一的定义。有的说闭包是特性，有的直说是怎么形成的，各讲各话。\n\n你就说，看这些东西，你能不蒙？\n\n按我们的理解，定义就应该是 `xx是xx` 的格式，在这里我们以最简单的格式来定义闭包\n\n**闭包是一个函数与其周围词法环境的集合**。当函数被定义时，他会捕获其外部作用域中的变量，即使外部函数已经执行完毕，这些变量依然可以被访问和修改。\n\n以后再被问及什么是闭包的时候，粗体部分文字就是答案，剩下的则可以作为解释。\n\n\n## 闭包的形成\n\n搞清楚了闭包的定义，下面通过一个简单的案例直观地理解一下闭包的形成。\n\n```\nfunction outer() {\n  let outerVar = \"我是外部变量\"; // 外部函数的局部变量\n\n  // 内部函数定义（满足“函数嵌套”）\n  function inner() {\n    console.log(outerVar); // 内部函数引用外部变量（满足“作用域访问”）\n  }\n\n  return inner; // 内部函数被返回（满足“外部返回”）\n}\n\n// 内部函数被“带出”外部作用域，并赋值给全局变量\nconst closureFunc = outer(); \n\n// 在外部调用内部函数，闭包生效\nclosureFunc(); // 输出：\"我是外部变量\"（成功访问outer的局部变量）\n```\n\n从上面的例子我们可以看出，outer执行完毕后，outerVar本应被销毁，但由于inner被返回并赋值给closureFunc，inner仍保留对outer作用域的引用。当closureFunc()调用时，inner通过闭包访问到了outerVar。\n\n![example](../imgs/closure/example.png)\n\n闭包形成的关键就在于内部函数在外部函数中定义时，会捕获当前的作用域链（包含外部函数的作用域和全局作用域）。即使内部函数未被立即调用，它也会保留对这些作用域的引用。\n\n## 闭包的作用\n\n明白了闭包的形成之后，我们再来看看闭包在实际开发过程中的一些用途。\n\n当然了，下面的内容都是围绕着闭包的核心作用展开的：**让内部函数能够保留对外部作用域的引用，即使外部函数已经执行完毕**。\n\n- **保存变量状态（数据私有化与封装）**\n\n闭包可以将变量 “隐藏” 在外部函数的作用域中，只通过内部函数暴露操作接口，实现类似 “私有变量” 的效果，避免全局变量污染。\n\n```javascript\nfunction createCounter() {\n  let count = 0; // 被闭包“保护”的变量，外部无法直接访问\n  return {\n    increment: () => { count++; return count; },\n    decrement: () => { count--; return count; }\n  };\n}\n\nconst counter = createCounter();\nconsole.log(counter.increment()); // 1（count被修改并保留状态）\nconsole.log(counter.increment()); // 2（状态持续保留）\n```\n\n- **实现函数工厂（动态生成定制化函数）**\n\n通过闭包可以创建带有 “记忆” 能力的函数，根据外部变量的不同生成不同逻辑的函数，提高代码复用性。\n\n```javascript\nfunction createGreeting(prefix) {\n  return function(name) { // 内部函数记住prefix的值\n    console.log(`${prefix}, ${name}!`);\n  };\n}\n\nconst sayHello = createGreeting(\"Hello\");\nconst sayHi = createGreeting(\"Hi\");\n\nsayHello(\"Alice\"); // \"Hello, Alice!\"（记住prefix为\"Hello\"）\nsayHi(\"Bob\");      // \"Hi, Bob!\"（记住prefix为\"Hi\"）\n```\n\n- **延迟执行与回调函数中的状态保留**\n\n闭包可以保留回调函数创建时的上下文状态，避免因变量作用域变化导致的问题, 这个在涉及一些定时器、或者事件监听等操作时非常有用。\n\n来一个大家都熟悉的例子\n\n```\nfor (var i = 0; i < 3; i++) {\n  // 使用闭包保留每次循环的i值\n  (function(j) {\n    setTimeout(() => {\n      console.log(j); // 输出0、1、2（而非3次3）\n    }, 1000);\n  })(i);\n}\n```\n若不使用闭包，定时器回调会共享全局的i，最终输出 3 次3；闭包则让每次循环的i值被独立保存。\n\n- **模块化开发**\n\n在 ES6 模块出现之前，闭包是实现模块化的核心方式：通过外部函数包裹代码，只暴露需要公开的接口，隐藏内部实现细节。\n\n\n## 写在最后\n\nOkay, 到这里想必都已经清楚了闭包的定义，它的形成和作用了，在日后的面试中和工作中遇到了闭包也用不着犯难了。\n\n闭包在开发过程中应用非常广，在一些高级函数，封装操作或者状态管理中都能看到闭包的影子。\n\n虽然好用，但是也不要滥用，过多的使用闭包可能占用过多内存，甚至引发内存泄漏，毕竟不是所有开发者都会自觉清理掉不必要引用的，哈哈，偷笑~。","slug":"closure","published":1,"updated":"2025-08-26T10:34:20.653Z","comments":1,"layout":"post","photos":[],"_id":"cmjbml2i8000yikupg5c33fb6","content":"<hr>\n<p>闭包，算得上是JavaScript中的一个难点，在面试时也被时常提及。</p>\n<p>多年前的一次面试，被问及闭包时，那种脑子里一团乱麻的感觉，至今依然清晰。</p>\n<p>本文力求以简单移动柜的语言，彻底讲清楚闭包，让读者在日后的面试和工作中，少走一些弯路，少掉一些头发。</p>\n<h2 id=\"什么是闭包？\"><a href=\"#什么是闭包？\" class=\"headerlink\" title=\"什么是闭包？\"></a>什么是闭包？</h2><p>要讲清楚闭包，那么我们首先得了解闭包是什么。为此，我翻阅许多资料收集了其中关于闭包的定义：</p>\n<ul>\n<li><p><strong>《JavaScript权威指南（第六版）》</strong>： 函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称之为“闭包”。</p>\n</li>\n<li><p><strong>《JavaScript 高级程序设计》</strong>： 闭包指的是那些引用了另外一个函数作用域中变量的函数，通常是嵌套在函数中实现的。</p>\n</li>\n<li><p><strong>《你不知道的JavaScript》</strong>： 函数可以记住并访问所在词法作用域，即使函数实在当前词法作用域之外执行，这就产生了闭包。</p>\n</li>\n<li><p><strong>MDN</strong>: 闭包是由捆绑起来（封闭的）的函数和函数周围状态（词法环境）引用组合而成，闭包让函数能够访问它的外部作用域。</p>\n</li>\n</ul>\n<p>好嘛，真是一看一个不吱声，根本没有一个统一的定义。有的说闭包是特性，有的直说是怎么形成的，各讲各话。</p>\n<p>你就说，看这些东西，你能不蒙？</p>\n<p>按我们的理解，定义就应该是 <code>xx是xx</code> 的格式，在这里我们以最简单的格式来定义闭包</p>\n<p><strong>闭包是一个函数与其周围词法环境的集合</strong>。当函数被定义时，他会捕获其外部作用域中的变量，即使外部函数已经执行完毕，这些变量依然可以被访问和修改。</p>\n<p>以后再被问及什么是闭包的时候，粗体部分文字就是答案，剩下的则可以作为解释。</p>\n<h2 id=\"闭包的形成\"><a href=\"#闭包的形成\" class=\"headerlink\" title=\"闭包的形成\"></a>闭包的形成</h2><p>搞清楚了闭包的定义，下面通过一个简单的案例直观地理解一下闭包的形成。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">outer</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> outerVar = <span class=\"hljs-string\">&quot;我是外部变量&quot;</span>; <span class=\"hljs-comment\">// 外部函数的局部变量</span><br><br>  <span class=\"hljs-comment\">// 内部函数定义（满足“函数嵌套”）</span><br>  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">inner</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(outerVar); <span class=\"hljs-comment\">// 内部函数引用外部变量（满足“作用域访问”）</span><br>  &#125;<br><br>  <span class=\"hljs-keyword\">return</span> inner; <span class=\"hljs-comment\">// 内部函数被返回（满足“外部返回”）</span><br>&#125;<br><br><span class=\"hljs-comment\">// 内部函数被“带出”外部作用域，并赋值给全局变量</span><br><span class=\"hljs-keyword\">const</span> closureFunc = <span class=\"hljs-title function_\">outer</span>(); <br><br><span class=\"hljs-comment\">// 在外部调用内部函数，闭包生效</span><br><span class=\"hljs-title function_\">closureFunc</span>(); <span class=\"hljs-comment\">// 输出：&quot;我是外部变量&quot;（成功访问outer的局部变量）</span><br></code></pre></td></tr></table></figure>\n\n<p>从上面的例子我们可以看出，outer执行完毕后，outerVar本应被销毁，但由于inner被返回并赋值给closureFunc，inner仍保留对outer作用域的引用。当closureFunc()调用时，inner通过闭包访问到了outerVar。</p>\n<p><img src=\"/../imgs/closure/example.png\" alt=\"example\"></p>\n<p>闭包形成的关键就在于内部函数在外部函数中定义时，会捕获当前的作用域链（包含外部函数的作用域和全局作用域）。即使内部函数未被立即调用，它也会保留对这些作用域的引用。</p>\n<h2 id=\"闭包的作用\"><a href=\"#闭包的作用\" class=\"headerlink\" title=\"闭包的作用\"></a>闭包的作用</h2><p>明白了闭包的形成之后，我们再来看看闭包在实际开发过程中的一些用途。</p>\n<p>当然了，下面的内容都是围绕着闭包的核心作用展开的：<strong>让内部函数能够保留对外部作用域的引用，即使外部函数已经执行完毕</strong>。</p>\n<ul>\n<li><strong>保存变量状态（数据私有化与封装）</strong></li>\n</ul>\n<p>闭包可以将变量 “隐藏” 在外部函数的作用域中，只通过内部函数暴露操作接口，实现类似 “私有变量” 的效果，避免全局变量污染。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createCounter</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> count = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// 被闭包“保护”的变量，外部无法直接访问</span><br>  <span class=\"hljs-keyword\">return</span> &#123;<br>    <span class=\"hljs-attr\">increment</span>: <span class=\"hljs-function\">() =&gt;</span> &#123; count++; <span class=\"hljs-keyword\">return</span> count; &#125;,<br>    <span class=\"hljs-attr\">decrement</span>: <span class=\"hljs-function\">() =&gt;</span> &#123; count--; <span class=\"hljs-keyword\">return</span> count; &#125;<br>  &#125;;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> counter = <span class=\"hljs-title function_\">createCounter</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(counter.<span class=\"hljs-title function_\">increment</span>()); <span class=\"hljs-comment\">// 1（count被修改并保留状态）</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(counter.<span class=\"hljs-title function_\">increment</span>()); <span class=\"hljs-comment\">// 2（状态持续保留）</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>实现函数工厂（动态生成定制化函数）</strong></li>\n</ul>\n<p>通过闭包可以创建带有 “记忆” 能力的函数，根据外部变量的不同生成不同逻辑的函数，提高代码复用性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createGreeting</span>(<span class=\"hljs-params\">prefix</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">name</span>) &#123; <span class=\"hljs-comment\">// 内部函数记住prefix的值</span><br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;prefix&#125;</span>, <span class=\"hljs-subst\">$&#123;name&#125;</span>!`</span>);<br>  &#125;;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> sayHello = <span class=\"hljs-title function_\">createGreeting</span>(<span class=\"hljs-string\">&quot;Hello&quot;</span>);<br><span class=\"hljs-keyword\">const</span> sayHi = <span class=\"hljs-title function_\">createGreeting</span>(<span class=\"hljs-string\">&quot;Hi&quot;</span>);<br><br><span class=\"hljs-title function_\">sayHello</span>(<span class=\"hljs-string\">&quot;Alice&quot;</span>); <span class=\"hljs-comment\">// &quot;Hello, Alice!&quot;（记住prefix为&quot;Hello&quot;）</span><br><span class=\"hljs-title function_\">sayHi</span>(<span class=\"hljs-string\">&quot;Bob&quot;</span>);      <span class=\"hljs-comment\">// &quot;Hi, Bob!&quot;（记住prefix为&quot;Hi&quot;）</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>延迟执行与回调函数中的状态保留</strong></li>\n</ul>\n<p>闭包可以保留回调函数创建时的上下文状态，避免因变量作用域变化导致的问题, 这个在涉及一些定时器、或者事件监听等操作时非常有用。</p>\n<p>来一个大家都熟悉的例子</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">3</span>; i++) &#123;<br>  <span class=\"hljs-comment\">// 使用闭包保留每次循环的i值</span><br>  (<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">j</span>) &#123;<br>    setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> &#123;<br>      <span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(j); <span class=\"hljs-comment\">// 输出0、1、2（而非3次3）</span><br>    &#125;, <span class=\"hljs-number\">1000</span>);<br>  &#125;)(i);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>若不使用闭包，定时器回调会共享全局的i，最终输出 3 次3；闭包则让每次循环的i值被独立保存。</p>\n<ul>\n<li><strong>模块化开发</strong></li>\n</ul>\n<p>在 ES6 模块出现之前，闭包是实现模块化的核心方式：通过外部函数包裹代码，只暴露需要公开的接口，隐藏内部实现细节。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>Okay, 到这里想必都已经清楚了闭包的定义，它的形成和作用了，在日后的面试中和工作中遇到了闭包也用不着犯难了。</p>\n<p>闭包在开发过程中应用非常广，在一些高级函数，封装操作或者状态管理中都能看到闭包的影子。</p>\n<p>虽然好用，但是也不要滥用，过多的使用闭包可能占用过多内存，甚至引发内存泄漏，毕竟不是所有开发者都会自觉清理掉不必要引用的，哈哈，偷笑~。</p>\n","excerpt":"","more":"<hr>\n<p>闭包，算得上是JavaScript中的一个难点，在面试时也被时常提及。</p>\n<p>多年前的一次面试，被问及闭包时，那种脑子里一团乱麻的感觉，至今依然清晰。</p>\n<p>本文力求以简单移动柜的语言，彻底讲清楚闭包，让读者在日后的面试和工作中，少走一些弯路，少掉一些头发。</p>\n<h2 id=\"什么是闭包？\"><a href=\"#什么是闭包？\" class=\"headerlink\" title=\"什么是闭包？\"></a>什么是闭包？</h2><p>要讲清楚闭包，那么我们首先得了解闭包是什么。为此，我翻阅许多资料收集了其中关于闭包的定义：</p>\n<ul>\n<li><p><strong>《JavaScript权威指南（第六版）》</strong>： 函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性在计算机科学文献中称之为“闭包”。</p>\n</li>\n<li><p><strong>《JavaScript 高级程序设计》</strong>： 闭包指的是那些引用了另外一个函数作用域中变量的函数，通常是嵌套在函数中实现的。</p>\n</li>\n<li><p><strong>《你不知道的JavaScript》</strong>： 函数可以记住并访问所在词法作用域，即使函数实在当前词法作用域之外执行，这就产生了闭包。</p>\n</li>\n<li><p><strong>MDN</strong>: 闭包是由捆绑起来（封闭的）的函数和函数周围状态（词法环境）引用组合而成，闭包让函数能够访问它的外部作用域。</p>\n</li>\n</ul>\n<p>好嘛，真是一看一个不吱声，根本没有一个统一的定义。有的说闭包是特性，有的直说是怎么形成的，各讲各话。</p>\n<p>你就说，看这些东西，你能不蒙？</p>\n<p>按我们的理解，定义就应该是 <code>xx是xx</code> 的格式，在这里我们以最简单的格式来定义闭包</p>\n<p><strong>闭包是一个函数与其周围词法环境的集合</strong>。当函数被定义时，他会捕获其外部作用域中的变量，即使外部函数已经执行完毕，这些变量依然可以被访问和修改。</p>\n<p>以后再被问及什么是闭包的时候，粗体部分文字就是答案，剩下的则可以作为解释。</p>\n<h2 id=\"闭包的形成\"><a href=\"#闭包的形成\" class=\"headerlink\" title=\"闭包的形成\"></a>闭包的形成</h2><p>搞清楚了闭包的定义，下面通过一个简单的案例直观地理解一下闭包的形成。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">outer</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> outerVar = <span class=\"hljs-string\">&quot;我是外部变量&quot;</span>; <span class=\"hljs-comment\">// 外部函数的局部变量</span><br><br>  <span class=\"hljs-comment\">// 内部函数定义（满足“函数嵌套”）</span><br>  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">inner</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(outerVar); <span class=\"hljs-comment\">// 内部函数引用外部变量（满足“作用域访问”）</span><br>  &#125;<br><br>  <span class=\"hljs-keyword\">return</span> inner; <span class=\"hljs-comment\">// 内部函数被返回（满足“外部返回”）</span><br>&#125;<br><br><span class=\"hljs-comment\">// 内部函数被“带出”外部作用域，并赋值给全局变量</span><br><span class=\"hljs-keyword\">const</span> closureFunc = <span class=\"hljs-title function_\">outer</span>(); <br><br><span class=\"hljs-comment\">// 在外部调用内部函数，闭包生效</span><br><span class=\"hljs-title function_\">closureFunc</span>(); <span class=\"hljs-comment\">// 输出：&quot;我是外部变量&quot;（成功访问outer的局部变量）</span><br></code></pre></td></tr></table></figure>\n\n<p>从上面的例子我们可以看出，outer执行完毕后，outerVar本应被销毁，但由于inner被返回并赋值给closureFunc，inner仍保留对outer作用域的引用。当closureFunc()调用时，inner通过闭包访问到了outerVar。</p>\n<p><img src=\"/../imgs/closure/example.png\" alt=\"example\"></p>\n<p>闭包形成的关键就在于内部函数在外部函数中定义时，会捕获当前的作用域链（包含外部函数的作用域和全局作用域）。即使内部函数未被立即调用，它也会保留对这些作用域的引用。</p>\n<h2 id=\"闭包的作用\"><a href=\"#闭包的作用\" class=\"headerlink\" title=\"闭包的作用\"></a>闭包的作用</h2><p>明白了闭包的形成之后，我们再来看看闭包在实际开发过程中的一些用途。</p>\n<p>当然了，下面的内容都是围绕着闭包的核心作用展开的：<strong>让内部函数能够保留对外部作用域的引用，即使外部函数已经执行完毕</strong>。</p>\n<ul>\n<li><strong>保存变量状态（数据私有化与封装）</strong></li>\n</ul>\n<p>闭包可以将变量 “隐藏” 在外部函数的作用域中，只通过内部函数暴露操作接口，实现类似 “私有变量” 的效果，避免全局变量污染。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createCounter</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> count = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// 被闭包“保护”的变量，外部无法直接访问</span><br>  <span class=\"hljs-keyword\">return</span> &#123;<br>    <span class=\"hljs-attr\">increment</span>: <span class=\"hljs-function\">() =&gt;</span> &#123; count++; <span class=\"hljs-keyword\">return</span> count; &#125;,<br>    <span class=\"hljs-attr\">decrement</span>: <span class=\"hljs-function\">() =&gt;</span> &#123; count--; <span class=\"hljs-keyword\">return</span> count; &#125;<br>  &#125;;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> counter = <span class=\"hljs-title function_\">createCounter</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(counter.<span class=\"hljs-title function_\">increment</span>()); <span class=\"hljs-comment\">// 1（count被修改并保留状态）</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(counter.<span class=\"hljs-title function_\">increment</span>()); <span class=\"hljs-comment\">// 2（状态持续保留）</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>实现函数工厂（动态生成定制化函数）</strong></li>\n</ul>\n<p>通过闭包可以创建带有 “记忆” 能力的函数，根据外部变量的不同生成不同逻辑的函数，提高代码复用性。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createGreeting</span>(<span class=\"hljs-params\">prefix</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">name</span>) &#123; <span class=\"hljs-comment\">// 内部函数记住prefix的值</span><br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;prefix&#125;</span>, <span class=\"hljs-subst\">$&#123;name&#125;</span>!`</span>);<br>  &#125;;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> sayHello = <span class=\"hljs-title function_\">createGreeting</span>(<span class=\"hljs-string\">&quot;Hello&quot;</span>);<br><span class=\"hljs-keyword\">const</span> sayHi = <span class=\"hljs-title function_\">createGreeting</span>(<span class=\"hljs-string\">&quot;Hi&quot;</span>);<br><br><span class=\"hljs-title function_\">sayHello</span>(<span class=\"hljs-string\">&quot;Alice&quot;</span>); <span class=\"hljs-comment\">// &quot;Hello, Alice!&quot;（记住prefix为&quot;Hello&quot;）</span><br><span class=\"hljs-title function_\">sayHi</span>(<span class=\"hljs-string\">&quot;Bob&quot;</span>);      <span class=\"hljs-comment\">// &quot;Hi, Bob!&quot;（记住prefix为&quot;Hi&quot;）</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>延迟执行与回调函数中的状态保留</strong></li>\n</ul>\n<p>闭包可以保留回调函数创建时的上下文状态，避免因变量作用域变化导致的问题, 这个在涉及一些定时器、或者事件监听等操作时非常有用。</p>\n<p>来一个大家都熟悉的例子</p>\n<figure class=\"highlight arcade\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs arcade\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">3</span>; i++) &#123;<br>  <span class=\"hljs-comment\">// 使用闭包保留每次循环的i值</span><br>  (<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">j</span>) &#123;<br>    setTimeout(<span class=\"hljs-function\"><span class=\"hljs-params\">()</span> =&gt;</span> &#123;<br>      <span class=\"hljs-built_in\">console</span>.<span class=\"hljs-built_in\">log</span>(j); <span class=\"hljs-comment\">// 输出0、1、2（而非3次3）</span><br>    &#125;, <span class=\"hljs-number\">1000</span>);<br>  &#125;)(i);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>若不使用闭包，定时器回调会共享全局的i，最终输出 3 次3；闭包则让每次循环的i值被独立保存。</p>\n<ul>\n<li><strong>模块化开发</strong></li>\n</ul>\n<p>在 ES6 模块出现之前，闭包是实现模块化的核心方式：通过外部函数包裹代码，只暴露需要公开的接口，隐藏内部实现细节。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>Okay, 到这里想必都已经清楚了闭包的定义，它的形成和作用了，在日后的面试中和工作中遇到了闭包也用不着犯难了。</p>\n<p>闭包在开发过程中应用非常广，在一些高级函数，封装操作或者状态管理中都能看到闭包的影子。</p>\n<p>虽然好用，但是也不要滥用，过多的使用闭包可能占用过多内存，甚至引发内存泄漏，毕竟不是所有开发者都会自觉清理掉不必要引用的，哈哈，偷笑~。</p>\n"},{"title":"为什么团队总在写烂代码？因为 “背锅侠” 根本不存在","date":"2025-06-25T10:20:41.000Z","keywords":["Vue","组件"],"banner_img":"/imgs/baners/team.jfif","index_img":"/imgs/baners/team.jfif","_content":"\n > CV: Copy & Paste, 复制的意思\n\n### 草台班子的代码现状：烂却能跑的魔幻现实\n\n做开发越久，你就越能感受到“这个世界，就是个巨大的草台班子”这句话的含金量。很多看似不错的项目，其代码质量和整理设计往往都经不起推敲。\n\n项目中的冗余代码堆砌，不做修改的暴力复制，混乱的逻辑判断，以及令人作呕的文件命名，有时候自己都会不禁发出灵魂拷问：\n\n“这东西能跑起来吗？ 这东西为什么能跑起来？”\n\n可是，没有人一开始就是奔着要把整个项目写烂为目的的吧？ 没有吧！ 但事实就是这样啊，它虽然很烂，但它能用。虽然它能用，但也是真的烂。\n\nWhy? Tell me why?\n\n![](../imgs/bad-code/en.jfif)\n\n###  熵增的起点：一次复制、一个else if的蝴蝶效应\n\n它肯定不是一开始就是这么烂的，但随着时间的推移，版本的迭代，似乎有种 力量在不断地将他慢慢往变烂的的方向推。而且随着时间的变长，作为项目的开发者，能够明显的感觉到这种力量越来越强，整个项目的维护成本也越来越高。\n\n而这一些，最初可能只是一次简单的代码复制，文件拷贝，也可能只是在原来的判断逻辑上加了一条 `else if` 判断语句...\n\n而做这些的原因，可能是一次的需求变更，也可能是新特性的加入，又或是一次错误的代码优化，但最终的结果是一样的--整个项目的复杂度提高了，代码混乱程度也变高了，换句话来说就是，整个项目的**熵**增加了。\n\n### 协作困境：通用性在功能优先主义下的妥协\n\n对于一个生命周期还没有走到成熟那步的项目来说，需求点的增加和改动是必然的。而需求点的增加和改动，对原有代码的通用性造成的影响有时候是破坏性的。\n\n而在保证项目功能优先的情况下，开发者往往会选择通过牺牲一定通用性来实现对应的功能。虽然可以通过提升组件抽象层次来保证组件的通用性，但这种设计上下多个层次的改动，工作量会比前者多出很多。\n\n而且对于一个多人协作开发的项目而言，每个人并非对指定组件或者模块负责，而是对某些功能点负责，因此在维护组件通用的积极性并没有那么强。\n\n于是今天少一点通用性，明天少一点通用性，直到有一天，协同开发的同事小明需要使用该组件，但是又涉及到内部改动，不好评估改动对整个项目带来的影响。索性生死看淡，不符就干，直接来个CV操作。\n\n至此，回归到了CV的路上。\n\n\n###  伪组件化陷阱：看似复用，实则埋雷\n\n通常，我们对弈是否要将一部分代码抽取成一个模块或者组件的判断还是比较朴素的。\n\n比如，有一段判断逻辑，如果有在3个或3个以上地方出现，这个时候我们就可以考虑将其抽取成一个函数。对于组件也是一样，频繁出现内容相近的表单，也可以封装成一个公共组件。\n\n为什么说这种判断依据比较朴素呢？ 通过一定参数或者内部逻辑适配，使得一个组件能够在多个地方应用，在开发是确实方便了很多。但是，这一操作本身可能就破坏了组件的单一性职责，而且其内部代码将比原来三者中任意一个都负责。\n\n而且，**通过简单适配出来的组件，其本身的通用性在复杂多变的需求面前是十分脆弱的**。\n\n### 烂代码的本质：团队责任感的集体缺位\n\n不可否认，一个项目在功能变复杂的过程中，其代码的复杂程度是会对应增加的，代码烂的程度也会增加。但比较可悲的是，我们往往总是把这种结果归咎于事情本身，而不是管理机制和人。\n\n每一位开发者都在关注着自己手头上的功能，“人和代码，有一个能跑就行”，把手头上的功能做完即可。 整个团队中，没有人需要为项目的烂代码兜底，因为它不是烂在自己手上的。\n\n**责任感的缺位，导致烂代码就像癌细胞一样逐渐扩散到整个项目**。“能用就行，能跑就行，现就这样吧，之前又不是我写的”，这样的思想侵蚀着开发者的责任感。\n\n按理说，每个项目的代码都是有代码审查环节，但在实际操作中，代码审查者往往都是起一个橡皮图章的作用，要么根本没有参与到开发中，要么就是随便瞅两眼后便何如代码。代码审查，本该是把好代码质量的一道重要的门，但却形同虚设，这样又怎能保证代码的质量呢？\n\n组件的通用性差，代码乱复制，冗余代码堆砌...这些烂代码的现象，其实也都是表象。说到底，**项目代码的烂，本质是研发团队管理机制和责任感的烂**。\n\n先说到这吧，散了散了...","source":"_posts/component-versatility.md","raw":"---\ntitle: 为什么团队总在写烂代码？因为 “背锅侠” 根本不存在\ndate: 2025-06-25 18:20:41\ntags: [Vue, 组件]\nkeywords: [Vue, 组件]\ncategory: Web开发\nbanner_img: /imgs/baners/team.jfif\nindex_img: /imgs/baners/team.jfif\n---\n\n > CV: Copy & Paste, 复制的意思\n\n### 草台班子的代码现状：烂却能跑的魔幻现实\n\n做开发越久，你就越能感受到“这个世界，就是个巨大的草台班子”这句话的含金量。很多看似不错的项目，其代码质量和整理设计往往都经不起推敲。\n\n项目中的冗余代码堆砌，不做修改的暴力复制，混乱的逻辑判断，以及令人作呕的文件命名，有时候自己都会不禁发出灵魂拷问：\n\n“这东西能跑起来吗？ 这东西为什么能跑起来？”\n\n可是，没有人一开始就是奔着要把整个项目写烂为目的的吧？ 没有吧！ 但事实就是这样啊，它虽然很烂，但它能用。虽然它能用，但也是真的烂。\n\nWhy? Tell me why?\n\n![](../imgs/bad-code/en.jfif)\n\n###  熵增的起点：一次复制、一个else if的蝴蝶效应\n\n它肯定不是一开始就是这么烂的，但随着时间的推移，版本的迭代，似乎有种 力量在不断地将他慢慢往变烂的的方向推。而且随着时间的变长，作为项目的开发者，能够明显的感觉到这种力量越来越强，整个项目的维护成本也越来越高。\n\n而这一些，最初可能只是一次简单的代码复制，文件拷贝，也可能只是在原来的判断逻辑上加了一条 `else if` 判断语句...\n\n而做这些的原因，可能是一次的需求变更，也可能是新特性的加入，又或是一次错误的代码优化，但最终的结果是一样的--整个项目的复杂度提高了，代码混乱程度也变高了，换句话来说就是，整个项目的**熵**增加了。\n\n### 协作困境：通用性在功能优先主义下的妥协\n\n对于一个生命周期还没有走到成熟那步的项目来说，需求点的增加和改动是必然的。而需求点的增加和改动，对原有代码的通用性造成的影响有时候是破坏性的。\n\n而在保证项目功能优先的情况下，开发者往往会选择通过牺牲一定通用性来实现对应的功能。虽然可以通过提升组件抽象层次来保证组件的通用性，但这种设计上下多个层次的改动，工作量会比前者多出很多。\n\n而且对于一个多人协作开发的项目而言，每个人并非对指定组件或者模块负责，而是对某些功能点负责，因此在维护组件通用的积极性并没有那么强。\n\n于是今天少一点通用性，明天少一点通用性，直到有一天，协同开发的同事小明需要使用该组件，但是又涉及到内部改动，不好评估改动对整个项目带来的影响。索性生死看淡，不符就干，直接来个CV操作。\n\n至此，回归到了CV的路上。\n\n\n###  伪组件化陷阱：看似复用，实则埋雷\n\n通常，我们对弈是否要将一部分代码抽取成一个模块或者组件的判断还是比较朴素的。\n\n比如，有一段判断逻辑，如果有在3个或3个以上地方出现，这个时候我们就可以考虑将其抽取成一个函数。对于组件也是一样，频繁出现内容相近的表单，也可以封装成一个公共组件。\n\n为什么说这种判断依据比较朴素呢？ 通过一定参数或者内部逻辑适配，使得一个组件能够在多个地方应用，在开发是确实方便了很多。但是，这一操作本身可能就破坏了组件的单一性职责，而且其内部代码将比原来三者中任意一个都负责。\n\n而且，**通过简单适配出来的组件，其本身的通用性在复杂多变的需求面前是十分脆弱的**。\n\n### 烂代码的本质：团队责任感的集体缺位\n\n不可否认，一个项目在功能变复杂的过程中，其代码的复杂程度是会对应增加的，代码烂的程度也会增加。但比较可悲的是，我们往往总是把这种结果归咎于事情本身，而不是管理机制和人。\n\n每一位开发者都在关注着自己手头上的功能，“人和代码，有一个能跑就行”，把手头上的功能做完即可。 整个团队中，没有人需要为项目的烂代码兜底，因为它不是烂在自己手上的。\n\n**责任感的缺位，导致烂代码就像癌细胞一样逐渐扩散到整个项目**。“能用就行，能跑就行，现就这样吧，之前又不是我写的”，这样的思想侵蚀着开发者的责任感。\n\n按理说，每个项目的代码都是有代码审查环节，但在实际操作中，代码审查者往往都是起一个橡皮图章的作用，要么根本没有参与到开发中，要么就是随便瞅两眼后便何如代码。代码审查，本该是把好代码质量的一道重要的门，但却形同虚设，这样又怎能保证代码的质量呢？\n\n组件的通用性差，代码乱复制，冗余代码堆砌...这些烂代码的现象，其实也都是表象。说到底，**项目代码的烂，本质是研发团队管理机制和责任感的烂**。\n\n先说到这吧，散了散了...","slug":"component-versatility","published":1,"updated":"2025-08-26T10:51:25.343Z","comments":1,"layout":"post","photos":[],"_id":"cmjbml2i80010ikupck7rgh18","content":"<blockquote>\n<p>CV: Copy &amp; Paste, 复制的意思</p>\n</blockquote>\n<h3 id=\"草台班子的代码现状：烂却能跑的魔幻现实\"><a href=\"#草台班子的代码现状：烂却能跑的魔幻现实\" class=\"headerlink\" title=\"草台班子的代码现状：烂却能跑的魔幻现实\"></a>草台班子的代码现状：烂却能跑的魔幻现实</h3><p>做开发越久，你就越能感受到“这个世界，就是个巨大的草台班子”这句话的含金量。很多看似不错的项目，其代码质量和整理设计往往都经不起推敲。</p>\n<p>项目中的冗余代码堆砌，不做修改的暴力复制，混乱的逻辑判断，以及令人作呕的文件命名，有时候自己都会不禁发出灵魂拷问：</p>\n<p>“这东西能跑起来吗？ 这东西为什么能跑起来？”</p>\n<p>可是，没有人一开始就是奔着要把整个项目写烂为目的的吧？ 没有吧！ 但事实就是这样啊，它虽然很烂，但它能用。虽然它能用，但也是真的烂。</p>\n<p>Why? Tell me why?</p>\n<p><img src=\"/../imgs/bad-code/en.jfif\"></p>\n<h3 id=\"熵增的起点：一次复制、一个else-if的蝴蝶效应\"><a href=\"#熵增的起点：一次复制、一个else-if的蝴蝶效应\" class=\"headerlink\" title=\"熵增的起点：一次复制、一个else if的蝴蝶效应\"></a>熵增的起点：一次复制、一个else if的蝴蝶效应</h3><p>它肯定不是一开始就是这么烂的，但随着时间的推移，版本的迭代，似乎有种 力量在不断地将他慢慢往变烂的的方向推。而且随着时间的变长，作为项目的开发者，能够明显的感觉到这种力量越来越强，整个项目的维护成本也越来越高。</p>\n<p>而这一些，最初可能只是一次简单的代码复制，文件拷贝，也可能只是在原来的判断逻辑上加了一条 <code>else if</code> 判断语句…</p>\n<p>而做这些的原因，可能是一次的需求变更，也可能是新特性的加入，又或是一次错误的代码优化，但最终的结果是一样的–整个项目的复杂度提高了，代码混乱程度也变高了，换句话来说就是，整个项目的<strong>熵</strong>增加了。</p>\n<h3 id=\"协作困境：通用性在功能优先主义下的妥协\"><a href=\"#协作困境：通用性在功能优先主义下的妥协\" class=\"headerlink\" title=\"协作困境：通用性在功能优先主义下的妥协\"></a>协作困境：通用性在功能优先主义下的妥协</h3><p>对于一个生命周期还没有走到成熟那步的项目来说，需求点的增加和改动是必然的。而需求点的增加和改动，对原有代码的通用性造成的影响有时候是破坏性的。</p>\n<p>而在保证项目功能优先的情况下，开发者往往会选择通过牺牲一定通用性来实现对应的功能。虽然可以通过提升组件抽象层次来保证组件的通用性，但这种设计上下多个层次的改动，工作量会比前者多出很多。</p>\n<p>而且对于一个多人协作开发的项目而言，每个人并非对指定组件或者模块负责，而是对某些功能点负责，因此在维护组件通用的积极性并没有那么强。</p>\n<p>于是今天少一点通用性，明天少一点通用性，直到有一天，协同开发的同事小明需要使用该组件，但是又涉及到内部改动，不好评估改动对整个项目带来的影响。索性生死看淡，不符就干，直接来个CV操作。</p>\n<p>至此，回归到了CV的路上。</p>\n<h3 id=\"伪组件化陷阱：看似复用，实则埋雷\"><a href=\"#伪组件化陷阱：看似复用，实则埋雷\" class=\"headerlink\" title=\"伪组件化陷阱：看似复用，实则埋雷\"></a>伪组件化陷阱：看似复用，实则埋雷</h3><p>通常，我们对弈是否要将一部分代码抽取成一个模块或者组件的判断还是比较朴素的。</p>\n<p>比如，有一段判断逻辑，如果有在3个或3个以上地方出现，这个时候我们就可以考虑将其抽取成一个函数。对于组件也是一样，频繁出现内容相近的表单，也可以封装成一个公共组件。</p>\n<p>为什么说这种判断依据比较朴素呢？ 通过一定参数或者内部逻辑适配，使得一个组件能够在多个地方应用，在开发是确实方便了很多。但是，这一操作本身可能就破坏了组件的单一性职责，而且其内部代码将比原来三者中任意一个都负责。</p>\n<p>而且，<strong>通过简单适配出来的组件，其本身的通用性在复杂多变的需求面前是十分脆弱的</strong>。</p>\n<h3 id=\"烂代码的本质：团队责任感的集体缺位\"><a href=\"#烂代码的本质：团队责任感的集体缺位\" class=\"headerlink\" title=\"烂代码的本质：团队责任感的集体缺位\"></a>烂代码的本质：团队责任感的集体缺位</h3><p>不可否认，一个项目在功能变复杂的过程中，其代码的复杂程度是会对应增加的，代码烂的程度也会增加。但比较可悲的是，我们往往总是把这种结果归咎于事情本身，而不是管理机制和人。</p>\n<p>每一位开发者都在关注着自己手头上的功能，“人和代码，有一个能跑就行”，把手头上的功能做完即可。 整个团队中，没有人需要为项目的烂代码兜底，因为它不是烂在自己手上的。</p>\n<p><strong>责任感的缺位，导致烂代码就像癌细胞一样逐渐扩散到整个项目</strong>。“能用就行，能跑就行，现就这样吧，之前又不是我写的”，这样的思想侵蚀着开发者的责任感。</p>\n<p>按理说，每个项目的代码都是有代码审查环节，但在实际操作中，代码审查者往往都是起一个橡皮图章的作用，要么根本没有参与到开发中，要么就是随便瞅两眼后便何如代码。代码审查，本该是把好代码质量的一道重要的门，但却形同虚设，这样又怎能保证代码的质量呢？</p>\n<p>组件的通用性差，代码乱复制，冗余代码堆砌…这些烂代码的现象，其实也都是表象。说到底，<strong>项目代码的烂，本质是研发团队管理机制和责任感的烂</strong>。</p>\n<p>先说到这吧，散了散了…</p>\n","excerpt":"","more":"<blockquote>\n<p>CV: Copy &amp; Paste, 复制的意思</p>\n</blockquote>\n<h3 id=\"草台班子的代码现状：烂却能跑的魔幻现实\"><a href=\"#草台班子的代码现状：烂却能跑的魔幻现实\" class=\"headerlink\" title=\"草台班子的代码现状：烂却能跑的魔幻现实\"></a>草台班子的代码现状：烂却能跑的魔幻现实</h3><p>做开发越久，你就越能感受到“这个世界，就是个巨大的草台班子”这句话的含金量。很多看似不错的项目，其代码质量和整理设计往往都经不起推敲。</p>\n<p>项目中的冗余代码堆砌，不做修改的暴力复制，混乱的逻辑判断，以及令人作呕的文件命名，有时候自己都会不禁发出灵魂拷问：</p>\n<p>“这东西能跑起来吗？ 这东西为什么能跑起来？”</p>\n<p>可是，没有人一开始就是奔着要把整个项目写烂为目的的吧？ 没有吧！ 但事实就是这样啊，它虽然很烂，但它能用。虽然它能用，但也是真的烂。</p>\n<p>Why? Tell me why?</p>\n<p><img src=\"/../imgs/bad-code/en.jfif\"></p>\n<h3 id=\"熵增的起点：一次复制、一个else-if的蝴蝶效应\"><a href=\"#熵增的起点：一次复制、一个else-if的蝴蝶效应\" class=\"headerlink\" title=\"熵增的起点：一次复制、一个else if的蝴蝶效应\"></a>熵增的起点：一次复制、一个else if的蝴蝶效应</h3><p>它肯定不是一开始就是这么烂的，但随着时间的推移，版本的迭代，似乎有种 力量在不断地将他慢慢往变烂的的方向推。而且随着时间的变长，作为项目的开发者，能够明显的感觉到这种力量越来越强，整个项目的维护成本也越来越高。</p>\n<p>而这一些，最初可能只是一次简单的代码复制，文件拷贝，也可能只是在原来的判断逻辑上加了一条 <code>else if</code> 判断语句…</p>\n<p>而做这些的原因，可能是一次的需求变更，也可能是新特性的加入，又或是一次错误的代码优化，但最终的结果是一样的–整个项目的复杂度提高了，代码混乱程度也变高了，换句话来说就是，整个项目的<strong>熵</strong>增加了。</p>\n<h3 id=\"协作困境：通用性在功能优先主义下的妥协\"><a href=\"#协作困境：通用性在功能优先主义下的妥协\" class=\"headerlink\" title=\"协作困境：通用性在功能优先主义下的妥协\"></a>协作困境：通用性在功能优先主义下的妥协</h3><p>对于一个生命周期还没有走到成熟那步的项目来说，需求点的增加和改动是必然的。而需求点的增加和改动，对原有代码的通用性造成的影响有时候是破坏性的。</p>\n<p>而在保证项目功能优先的情况下，开发者往往会选择通过牺牲一定通用性来实现对应的功能。虽然可以通过提升组件抽象层次来保证组件的通用性，但这种设计上下多个层次的改动，工作量会比前者多出很多。</p>\n<p>而且对于一个多人协作开发的项目而言，每个人并非对指定组件或者模块负责，而是对某些功能点负责，因此在维护组件通用的积极性并没有那么强。</p>\n<p>于是今天少一点通用性，明天少一点通用性，直到有一天，协同开发的同事小明需要使用该组件，但是又涉及到内部改动，不好评估改动对整个项目带来的影响。索性生死看淡，不符就干，直接来个CV操作。</p>\n<p>至此，回归到了CV的路上。</p>\n<h3 id=\"伪组件化陷阱：看似复用，实则埋雷\"><a href=\"#伪组件化陷阱：看似复用，实则埋雷\" class=\"headerlink\" title=\"伪组件化陷阱：看似复用，实则埋雷\"></a>伪组件化陷阱：看似复用，实则埋雷</h3><p>通常，我们对弈是否要将一部分代码抽取成一个模块或者组件的判断还是比较朴素的。</p>\n<p>比如，有一段判断逻辑，如果有在3个或3个以上地方出现，这个时候我们就可以考虑将其抽取成一个函数。对于组件也是一样，频繁出现内容相近的表单，也可以封装成一个公共组件。</p>\n<p>为什么说这种判断依据比较朴素呢？ 通过一定参数或者内部逻辑适配，使得一个组件能够在多个地方应用，在开发是确实方便了很多。但是，这一操作本身可能就破坏了组件的单一性职责，而且其内部代码将比原来三者中任意一个都负责。</p>\n<p>而且，<strong>通过简单适配出来的组件，其本身的通用性在复杂多变的需求面前是十分脆弱的</strong>。</p>\n<h3 id=\"烂代码的本质：团队责任感的集体缺位\"><a href=\"#烂代码的本质：团队责任感的集体缺位\" class=\"headerlink\" title=\"烂代码的本质：团队责任感的集体缺位\"></a>烂代码的本质：团队责任感的集体缺位</h3><p>不可否认，一个项目在功能变复杂的过程中，其代码的复杂程度是会对应增加的，代码烂的程度也会增加。但比较可悲的是，我们往往总是把这种结果归咎于事情本身，而不是管理机制和人。</p>\n<p>每一位开发者都在关注着自己手头上的功能，“人和代码，有一个能跑就行”，把手头上的功能做完即可。 整个团队中，没有人需要为项目的烂代码兜底，因为它不是烂在自己手上的。</p>\n<p><strong>责任感的缺位，导致烂代码就像癌细胞一样逐渐扩散到整个项目</strong>。“能用就行，能跑就行，现就这样吧，之前又不是我写的”，这样的思想侵蚀着开发者的责任感。</p>\n<p>按理说，每个项目的代码都是有代码审查环节，但在实际操作中，代码审查者往往都是起一个橡皮图章的作用，要么根本没有参与到开发中，要么就是随便瞅两眼后便何如代码。代码审查，本该是把好代码质量的一道重要的门，但却形同虚设，这样又怎能保证代码的质量呢？</p>\n<p>组件的通用性差，代码乱复制，冗余代码堆砌…这些烂代码的现象，其实也都是表象。说到底，<strong>项目代码的烂，本质是研发团队管理机制和责任感的烂</strong>。</p>\n<p>先说到这吧，散了散了…</p>\n"},{"title":"从崩溃到稳定：前端开发者必学的 Node.js 守护进程实战指南","date":"2025-07-15T13:37:08.000Z","index_img":"imgs/daemon/640.jfif","banner_img":"imgs/daemon/640.jfif","_content":"\n说到守护进程，绝大多数开发者其实都不陌生，甚至有些记性比较好的同学还能大段背诵关于进程的面试八股文呢。虽然在日常的Web开发工作中很少使用到它，而且可能从写Web第一天到离职都没有真正写过一个守护进程，即使有或许还是学校里教学用的--使用C语言实现的Demo。\n\n不要怪作者嘴巴毒，事实就是这样的，即使一个工作5,6年的老Web开发，你让他现场写个守护进程，还真不一定就能立马写出来。今天就尝试着使用Node来实现一个守护进程，试着唤醒你那将要死去的记忆。\n\n把一个大象关进冰箱分几步？ 写一个守护进程又分几步？\n\n## 1. 创建子进程并脱离控制终端\n\n当我们使用Node执行某一个js脚本时，Node会创建一个进程，当脚本执行结束了，进程也就结束了。\n\n为了创建守护进程，需要在脚本执行的过程中(父进程)创建一个子进程，并且在子进程创建之后，要让其自立门户，脱离父进程，这样即使父进程退出，也不会影响子进程\n\n```javascript\n// start.js\nconst { fork } = require('child_process');\nconst path = require('path');\n\n// 创建子进程\nconst child = fork(path.join(__dirname, 'daemon.js'), {\n    detached: true,  // 使子进程成为新的进程组领导\n    stdio: 'ignore'  // 忽略标准输入/输出/错误\n});\n\n// 解除父进程对子进程的引用\nchild.unref();\n\n//父进程退出\nprocess.exit(0);\n```\n\n如上述代码所示，使用 `chilrd_process`中的 `fork`方法创建一个子进程，它会自动建立父子进程间的 IPC 通信通道。其中的几个参数，详细讲解一下：\n\n- 第一个参数 daemon.js 是要执行的子进程脚本路径，通过 `path.join(__dirname, ...)` 确保路径正确。\n- 第二个参数是配置对象，包含关键选项：\n\n  - **detached: true**​：使子进程成为新进程组的领导者（非 Windows 系统）或拥有独立控制台（Windows），允许子进程在父进程退出后继续运行\n\n  - ​**stdio\\: ignore**​：忽略子进程的标准输入/输出/错误流，避免管道阻塞问题\n\n## 2. 设置工作目录和文件权限\n\n```javascript\n// daemon.js\n\n// 改变工作目录到根目录或特定目录\nprocess.chdir('/');\n\n// 重设文件权限掩码\nprocess.umask(0);\n```\n\n为了将守护进程独立于启动它的环境，我们通过改变工作目录来实现隔离，而且这样还可以避免挂载点无法卸载。\n\n另外还需要关注一下权限的问题，将掩码设置为0，这样守护进程创建的文件和目录将使用系统的默认权限。\n\n\n## 3. 配置日志模块\n\n守护进程不同于在终端执行命令行的进程，它是不占用终端的，所以是看不到它输出内容在终端上。因此，需要配置一个日志模块，用于记录下一些关键信息，避免在报错或者调试的时候两眼抓瞎。\n\n日志模块其实很简单，功能就是将内容记录到文本中即可\n\n```javascript\n// daemon.js\n\n// 设置日志记录\nconst util = require('util');\nconst logFile = fs.createWriteStream('daemon.log', { flags: 'a' });\nconst log = function(msg) {\n    logFile.write(util.format(msg) + '\\n');\n};\n\n```\n\n\n## 4. 处理信号和错误\n\n为了提高守护进程的稳定性和可靠性，需要对一些系统信号做处理，从而应对各种意外，毕竟总不希望守护进程挂掉了，而自己却连什么时候挂掉了都不知道吧。\n\n其中，重点是以下几个信号量：\n\n- **SIGINT (Ctrl+C)**: \n通常由用户在终端中按下 `Ctrl+C` 发送\n\n- **SIGTERM**: \n系统关闭或通过 kill <pid> 发送的默认信号\n\n- **SIGHUP**: \n传统上表示控制终端关闭,守护进程通常忽略此信号或用于重新加载配置\n\n```javascript\n// 处理进程信号\nprocess.on('SIGINT', () => {\n  log('收到 SIGINT 信号，准备停止...');\n  // 执行清理和停止逻辑\n});\n\nprocess.on('SIGTERM', () => {\n log('收到 SIGTERM 信号，准备停止...');\n  // 执行清理和停止逻辑\n});\n\n// 忽略挂起信号(SIGHUP)\nprocess.on('SIGHUP', () => {});\n\n// 全局错误处理\nprocess.on('uncaughtException', (err) => {\n    log(`未捕获异常: ${err}`);\n    // 可以添加重启逻辑\n});\n\nprocess.on('unhandledRejection', (reason, promise) => {\n    log(`未处理的Promise拒绝:', ${reason}`);\n});\n\n```\n\n## 5. 实现守护进程主体内容\n\n前面的一些列操作，都是为了保证守护进程能够正常启动和执行，接下来就到了相对来说简单的部分了。\n\n守护进程主体内容，通常来说最好是个循环，定时任务，或者对外的请求监听，这样才不会运行之后马上就结束。\n\n下面以一个简单的 `httpServer`作为例子。\n\n```javascript\nconst http = require('http');\nconst port = 5000;\nconst app = http.createServer((req, res) => {\n  console.log(`${req.method} ${req.url}`);\n  res.end('Hello daemon');\n})\n\napp.listen(port, '0.0.0.0', () => {\n  console.log(`Server listening on: http://localhost:${port}`);\n})\n\n```\n\n## 6. 启动服务并验证\n\n完成代码编写之后，我们尝试着启动服务并验证服务是否启动成功了。打开终端，执行 `node start.js`。父进程在执行完之后，会立即退出，因此不会占用终端。\n\n通过浏览器访问地址 `http://localhost:5000`, 能够正确显示内容，说明守护进程启动成功了。\n\n![success](https://www.jvxiao.cn/imgs/daemon/success.png)\n\n另外查看一下日志文件 `daemon.log`，可以看到服务启动和请求的记录。\n![success](https://www.jvxiao.cn/imgs/daemon/logs.png)\n\n\n在任务管理中，也能看到一个一直活跃的 node 进程。\n![success](https://www.jvxiao.cn/imgs/daemon/panel.png)\n\nBingo~~~, 一个简单的守护进程就这么实现了。\n\n\n## 写在最后\n\n除了上面的方法，其实也还有其它一些快捷的方式来创建守护进程，如使用`pm2` 或者 `forever`, 但是纯手工创建守护进程的基本功不能丢了。\n\n实现守护进程的过程，也是深入理解 Node.js 进程模型和操作系统交互的绝佳机会。从工作目录设置、权限管理到信号处理、错误捕获，每一个细节都体现了对系统编程的深刻理解。这些知识不仅适用于守护进程开发，更能帮助我们编写更健壮的 Node.js 应用。","source":"_posts/create-daemond-with-node.md","raw":"---\ntitle: 从崩溃到稳定：前端开发者必学的 Node.js 守护进程实战指南\ndate: 2025-07-15 21:37:08\ntags: [守护进程, Node]\ncategory: Web开发\nindex_img: imgs/daemon/640.jfif\nbanner_img: imgs/daemon/640.jfif\n---\n\n说到守护进程，绝大多数开发者其实都不陌生，甚至有些记性比较好的同学还能大段背诵关于进程的面试八股文呢。虽然在日常的Web开发工作中很少使用到它，而且可能从写Web第一天到离职都没有真正写过一个守护进程，即使有或许还是学校里教学用的--使用C语言实现的Demo。\n\n不要怪作者嘴巴毒，事实就是这样的，即使一个工作5,6年的老Web开发，你让他现场写个守护进程，还真不一定就能立马写出来。今天就尝试着使用Node来实现一个守护进程，试着唤醒你那将要死去的记忆。\n\n把一个大象关进冰箱分几步？ 写一个守护进程又分几步？\n\n## 1. 创建子进程并脱离控制终端\n\n当我们使用Node执行某一个js脚本时，Node会创建一个进程，当脚本执行结束了，进程也就结束了。\n\n为了创建守护进程，需要在脚本执行的过程中(父进程)创建一个子进程，并且在子进程创建之后，要让其自立门户，脱离父进程，这样即使父进程退出，也不会影响子进程\n\n```javascript\n// start.js\nconst { fork } = require('child_process');\nconst path = require('path');\n\n// 创建子进程\nconst child = fork(path.join(__dirname, 'daemon.js'), {\n    detached: true,  // 使子进程成为新的进程组领导\n    stdio: 'ignore'  // 忽略标准输入/输出/错误\n});\n\n// 解除父进程对子进程的引用\nchild.unref();\n\n//父进程退出\nprocess.exit(0);\n```\n\n如上述代码所示，使用 `chilrd_process`中的 `fork`方法创建一个子进程，它会自动建立父子进程间的 IPC 通信通道。其中的几个参数，详细讲解一下：\n\n- 第一个参数 daemon.js 是要执行的子进程脚本路径，通过 `path.join(__dirname, ...)` 确保路径正确。\n- 第二个参数是配置对象，包含关键选项：\n\n  - **detached: true**​：使子进程成为新进程组的领导者（非 Windows 系统）或拥有独立控制台（Windows），允许子进程在父进程退出后继续运行\n\n  - ​**stdio\\: ignore**​：忽略子进程的标准输入/输出/错误流，避免管道阻塞问题\n\n## 2. 设置工作目录和文件权限\n\n```javascript\n// daemon.js\n\n// 改变工作目录到根目录或特定目录\nprocess.chdir('/');\n\n// 重设文件权限掩码\nprocess.umask(0);\n```\n\n为了将守护进程独立于启动它的环境，我们通过改变工作目录来实现隔离，而且这样还可以避免挂载点无法卸载。\n\n另外还需要关注一下权限的问题，将掩码设置为0，这样守护进程创建的文件和目录将使用系统的默认权限。\n\n\n## 3. 配置日志模块\n\n守护进程不同于在终端执行命令行的进程，它是不占用终端的，所以是看不到它输出内容在终端上。因此，需要配置一个日志模块，用于记录下一些关键信息，避免在报错或者调试的时候两眼抓瞎。\n\n日志模块其实很简单，功能就是将内容记录到文本中即可\n\n```javascript\n// daemon.js\n\n// 设置日志记录\nconst util = require('util');\nconst logFile = fs.createWriteStream('daemon.log', { flags: 'a' });\nconst log = function(msg) {\n    logFile.write(util.format(msg) + '\\n');\n};\n\n```\n\n\n## 4. 处理信号和错误\n\n为了提高守护进程的稳定性和可靠性，需要对一些系统信号做处理，从而应对各种意外，毕竟总不希望守护进程挂掉了，而自己却连什么时候挂掉了都不知道吧。\n\n其中，重点是以下几个信号量：\n\n- **SIGINT (Ctrl+C)**: \n通常由用户在终端中按下 `Ctrl+C` 发送\n\n- **SIGTERM**: \n系统关闭或通过 kill <pid> 发送的默认信号\n\n- **SIGHUP**: \n传统上表示控制终端关闭,守护进程通常忽略此信号或用于重新加载配置\n\n```javascript\n// 处理进程信号\nprocess.on('SIGINT', () => {\n  log('收到 SIGINT 信号，准备停止...');\n  // 执行清理和停止逻辑\n});\n\nprocess.on('SIGTERM', () => {\n log('收到 SIGTERM 信号，准备停止...');\n  // 执行清理和停止逻辑\n});\n\n// 忽略挂起信号(SIGHUP)\nprocess.on('SIGHUP', () => {});\n\n// 全局错误处理\nprocess.on('uncaughtException', (err) => {\n    log(`未捕获异常: ${err}`);\n    // 可以添加重启逻辑\n});\n\nprocess.on('unhandledRejection', (reason, promise) => {\n    log(`未处理的Promise拒绝:', ${reason}`);\n});\n\n```\n\n## 5. 实现守护进程主体内容\n\n前面的一些列操作，都是为了保证守护进程能够正常启动和执行，接下来就到了相对来说简单的部分了。\n\n守护进程主体内容，通常来说最好是个循环，定时任务，或者对外的请求监听，这样才不会运行之后马上就结束。\n\n下面以一个简单的 `httpServer`作为例子。\n\n```javascript\nconst http = require('http');\nconst port = 5000;\nconst app = http.createServer((req, res) => {\n  console.log(`${req.method} ${req.url}`);\n  res.end('Hello daemon');\n})\n\napp.listen(port, '0.0.0.0', () => {\n  console.log(`Server listening on: http://localhost:${port}`);\n})\n\n```\n\n## 6. 启动服务并验证\n\n完成代码编写之后，我们尝试着启动服务并验证服务是否启动成功了。打开终端，执行 `node start.js`。父进程在执行完之后，会立即退出，因此不会占用终端。\n\n通过浏览器访问地址 `http://localhost:5000`, 能够正确显示内容，说明守护进程启动成功了。\n\n![success](https://www.jvxiao.cn/imgs/daemon/success.png)\n\n另外查看一下日志文件 `daemon.log`，可以看到服务启动和请求的记录。\n![success](https://www.jvxiao.cn/imgs/daemon/logs.png)\n\n\n在任务管理中，也能看到一个一直活跃的 node 进程。\n![success](https://www.jvxiao.cn/imgs/daemon/panel.png)\n\nBingo~~~, 一个简单的守护进程就这么实现了。\n\n\n## 写在最后\n\n除了上面的方法，其实也还有其它一些快捷的方式来创建守护进程，如使用`pm2` 或者 `forever`, 但是纯手工创建守护进程的基本功不能丢了。\n\n实现守护进程的过程，也是深入理解 Node.js 进程模型和操作系统交互的绝佳机会。从工作目录设置、权限管理到信号处理、错误捕获，每一个细节都体现了对系统编程的深刻理解。这些知识不仅适用于守护进程开发，更能帮助我们编写更健壮的 Node.js 应用。","slug":"create-daemond-with-node","published":1,"updated":"2025-08-26T10:41:18.347Z","comments":1,"layout":"post","photos":[],"_id":"cmjbml2i90014ikup0vnces7x","content":"<p>说到守护进程，绝大多数开发者其实都不陌生，甚至有些记性比较好的同学还能大段背诵关于进程的面试八股文呢。虽然在日常的Web开发工作中很少使用到它，而且可能从写Web第一天到离职都没有真正写过一个守护进程，即使有或许还是学校里教学用的–使用C语言实现的Demo。</p>\n<p>不要怪作者嘴巴毒，事实就是这样的，即使一个工作5,6年的老Web开发，你让他现场写个守护进程，还真不一定就能立马写出来。今天就尝试着使用Node来实现一个守护进程，试着唤醒你那将要死去的记忆。</p>\n<p>把一个大象关进冰箱分几步？ 写一个守护进程又分几步？</p>\n<h2 id=\"1-创建子进程并脱离控制终端\"><a href=\"#1-创建子进程并脱离控制终端\" class=\"headerlink\" title=\"1. 创建子进程并脱离控制终端\"></a>1. 创建子进程并脱离控制终端</h2><p>当我们使用Node执行某一个js脚本时，Node会创建一个进程，当脚本执行结束了，进程也就结束了。</p>\n<p>为了创建守护进程，需要在脚本执行的过程中(父进程)创建一个子进程，并且在子进程创建之后，要让其自立门户，脱离父进程，这样即使父进程退出，也不会影响子进程</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// start.js</span><br><span class=\"hljs-keyword\">const</span> &#123; fork &#125; = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;child_process&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;path&#x27;</span>);<br><br><span class=\"hljs-comment\">// 创建子进程</span><br><span class=\"hljs-keyword\">const</span> child = <span class=\"hljs-title function_\">fork</span>(path.<span class=\"hljs-title function_\">join</span>(__dirname, <span class=\"hljs-string\">&#x27;daemon.js&#x27;</span>), &#123;<br>    <span class=\"hljs-attr\">detached</span>: <span class=\"hljs-literal\">true</span>,  <span class=\"hljs-comment\">// 使子进程成为新的进程组领导</span><br>    <span class=\"hljs-attr\">stdio</span>: <span class=\"hljs-string\">&#x27;ignore&#x27;</span>  <span class=\"hljs-comment\">// 忽略标准输入/输出/错误</span><br>&#125;);<br><br><span class=\"hljs-comment\">// 解除父进程对子进程的引用</span><br>child.<span class=\"hljs-title function_\">unref</span>();<br><br><span class=\"hljs-comment\">//父进程退出</span><br>process.<span class=\"hljs-title function_\">exit</span>(<span class=\"hljs-number\">0</span>);<br></code></pre></td></tr></table></figure>\n\n<p>如上述代码所示，使用 <code>chilrd_process</code>中的 <code>fork</code>方法创建一个子进程，它会自动建立父子进程间的 IPC 通信通道。其中的几个参数，详细讲解一下：</p>\n<ul>\n<li><p>第一个参数 daemon.js 是要执行的子进程脚本路径，通过 <code>path.join(__dirname, ...)</code> 确保路径正确。</p>\n</li>\n<li><p>第二个参数是配置对象，包含关键选项：</p>\n<ul>\n<li><p><strong>detached: true</strong>​：使子进程成为新进程组的领导者（非 Windows 系统）或拥有独立控制台（Windows），允许子进程在父进程退出后继续运行</p>\n</li>\n<li><p>​<strong>stdio: ignore</strong>​：忽略子进程的标准输入&#x2F;输出&#x2F;错误流，避免管道阻塞问题</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-设置工作目录和文件权限\"><a href=\"#2-设置工作目录和文件权限\" class=\"headerlink\" title=\"2. 设置工作目录和文件权限\"></a>2. 设置工作目录和文件权限</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// daemon.js</span><br><br><span class=\"hljs-comment\">// 改变工作目录到根目录或特定目录</span><br>process.<span class=\"hljs-title function_\">chdir</span>(<span class=\"hljs-string\">&#x27;/&#x27;</span>);<br><br><span class=\"hljs-comment\">// 重设文件权限掩码</span><br>process.<span class=\"hljs-title function_\">umask</span>(<span class=\"hljs-number\">0</span>);<br></code></pre></td></tr></table></figure>\n\n<p>为了将守护进程独立于启动它的环境，我们通过改变工作目录来实现隔离，而且这样还可以避免挂载点无法卸载。</p>\n<p>另外还需要关注一下权限的问题，将掩码设置为0，这样守护进程创建的文件和目录将使用系统的默认权限。</p>\n<h2 id=\"3-配置日志模块\"><a href=\"#3-配置日志模块\" class=\"headerlink\" title=\"3. 配置日志模块\"></a>3. 配置日志模块</h2><p>守护进程不同于在终端执行命令行的进程，它是不占用终端的，所以是看不到它输出内容在终端上。因此，需要配置一个日志模块，用于记录下一些关键信息，避免在报错或者调试的时候两眼抓瞎。</p>\n<p>日志模块其实很简单，功能就是将内容记录到文本中即可</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// daemon.js</span><br><br><span class=\"hljs-comment\">// 设置日志记录</span><br><span class=\"hljs-keyword\">const</span> util = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;util&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> logFile = fs.<span class=\"hljs-title function_\">createWriteStream</span>(<span class=\"hljs-string\">&#x27;daemon.log&#x27;</span>, &#123; <span class=\"hljs-attr\">flags</span>: <span class=\"hljs-string\">&#x27;a&#x27;</span> &#125;);<br><span class=\"hljs-keyword\">const</span> log = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">msg</span>) &#123;<br>    logFile.<span class=\"hljs-title function_\">write</span>(util.<span class=\"hljs-title function_\">format</span>(msg) + <span class=\"hljs-string\">&#x27;\\n&#x27;</span>);<br>&#125;;<br><br></code></pre></td></tr></table></figure>\n\n\n<h2 id=\"4-处理信号和错误\"><a href=\"#4-处理信号和错误\" class=\"headerlink\" title=\"4. 处理信号和错误\"></a>4. 处理信号和错误</h2><p>为了提高守护进程的稳定性和可靠性，需要对一些系统信号做处理，从而应对各种意外，毕竟总不希望守护进程挂掉了，而自己却连什么时候挂掉了都不知道吧。</p>\n<p>其中，重点是以下几个信号量：</p>\n<ul>\n<li><p><strong>SIGINT (Ctrl+C)</strong>:<br>通常由用户在终端中按下 <code>Ctrl+C</code> 发送</p>\n</li>\n<li><p><strong>SIGTERM</strong>:<br>系统关闭或通过 kill <pid> 发送的默认信号</p>\n</li>\n<li><p><strong>SIGHUP</strong>:<br>传统上表示控制终端关闭,守护进程通常忽略此信号或用于重新加载配置</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 处理进程信号</span><br>process.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;SIGINT&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;收到 SIGINT 信号，准备停止...&#x27;</span>);<br>  <span class=\"hljs-comment\">// 执行清理和停止逻辑</span><br>&#125;);<br><br>process.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;SIGTERM&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;<br> <span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;收到 SIGTERM 信号，准备停止...&#x27;</span>);<br>  <span class=\"hljs-comment\">// 执行清理和停止逻辑</span><br>&#125;);<br><br><span class=\"hljs-comment\">// 忽略挂起信号(SIGHUP)</span><br>process.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;SIGHUP&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;&#125;);<br><br><span class=\"hljs-comment\">// 全局错误处理</span><br>process.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;uncaughtException&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">err</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`未捕获异常: <span class=\"hljs-subst\">$&#123;err&#125;</span>`</span>);<br>    <span class=\"hljs-comment\">// 可以添加重启逻辑</span><br>&#125;);<br><br>process.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;unhandledRejection&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">reason, promise</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`未处理的Promise拒绝:&#x27;, <span class=\"hljs-subst\">$&#123;reason&#125;</span>`</span>);<br>&#125;);<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"5-实现守护进程主体内容\"><a href=\"#5-实现守护进程主体内容\" class=\"headerlink\" title=\"5. 实现守护进程主体内容\"></a>5. 实现守护进程主体内容</h2><p>前面的一些列操作，都是为了保证守护进程能够正常启动和执行，接下来就到了相对来说简单的部分了。</p>\n<p>守护进程主体内容，通常来说最好是个循环，定时任务，或者对外的请求监听，这样才不会运行之后马上就结束。</p>\n<p>下面以一个简单的 <code>httpServer</code>作为例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;http&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> port = <span class=\"hljs-number\">5000</span>;<br><span class=\"hljs-keyword\">const</span> app = http.<span class=\"hljs-title function_\">createServer</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">req, res</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;req.method&#125;</span> <span class=\"hljs-subst\">$&#123;req.url&#125;</span>`</span>);<br>  res.<span class=\"hljs-title function_\">end</span>(<span class=\"hljs-string\">&#x27;Hello daemon&#x27;</span>);<br>&#125;)<br><br>app.<span class=\"hljs-title function_\">listen</span>(port, <span class=\"hljs-string\">&#x27;0.0.0.0&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`Server listening on: http://localhost:<span class=\"hljs-subst\">$&#123;port&#125;</span>`</span>);<br>&#125;)<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"6-启动服务并验证\"><a href=\"#6-启动服务并验证\" class=\"headerlink\" title=\"6. 启动服务并验证\"></a>6. 启动服务并验证</h2><p>完成代码编写之后，我们尝试着启动服务并验证服务是否启动成功了。打开终端，执行 <code>node start.js</code>。父进程在执行完之后，会立即退出，因此不会占用终端。</p>\n<p>通过浏览器访问地址 <code>http://localhost:5000</code>, 能够正确显示内容，说明守护进程启动成功了。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/daemon/success.png\" alt=\"success\"></p>\n<p>另外查看一下日志文件 <code>daemon.log</code>，可以看到服务启动和请求的记录。<br><img src=\"https://www.jvxiao.cn/imgs/daemon/logs.png\" alt=\"success\"></p>\n<p>在任务管理中，也能看到一个一直活跃的 node 进程。<br><img src=\"https://www.jvxiao.cn/imgs/daemon/panel.png\" alt=\"success\"></p>\n<p>Bingo~~~, 一个简单的守护进程就这么实现了。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>除了上面的方法，其实也还有其它一些快捷的方式来创建守护进程，如使用<code>pm2</code> 或者 <code>forever</code>, 但是纯手工创建守护进程的基本功不能丢了。</p>\n<p>实现守护进程的过程，也是深入理解 Node.js 进程模型和操作系统交互的绝佳机会。从工作目录设置、权限管理到信号处理、错误捕获，每一个细节都体现了对系统编程的深刻理解。这些知识不仅适用于守护进程开发，更能帮助我们编写更健壮的 Node.js 应用。</p>\n","excerpt":"","more":"<p>说到守护进程，绝大多数开发者其实都不陌生，甚至有些记性比较好的同学还能大段背诵关于进程的面试八股文呢。虽然在日常的Web开发工作中很少使用到它，而且可能从写Web第一天到离职都没有真正写过一个守护进程，即使有或许还是学校里教学用的–使用C语言实现的Demo。</p>\n<p>不要怪作者嘴巴毒，事实就是这样的，即使一个工作5,6年的老Web开发，你让他现场写个守护进程，还真不一定就能立马写出来。今天就尝试着使用Node来实现一个守护进程，试着唤醒你那将要死去的记忆。</p>\n<p>把一个大象关进冰箱分几步？ 写一个守护进程又分几步？</p>\n<h2 id=\"1-创建子进程并脱离控制终端\"><a href=\"#1-创建子进程并脱离控制终端\" class=\"headerlink\" title=\"1. 创建子进程并脱离控制终端\"></a>1. 创建子进程并脱离控制终端</h2><p>当我们使用Node执行某一个js脚本时，Node会创建一个进程，当脚本执行结束了，进程也就结束了。</p>\n<p>为了创建守护进程，需要在脚本执行的过程中(父进程)创建一个子进程，并且在子进程创建之后，要让其自立门户，脱离父进程，这样即使父进程退出，也不会影响子进程</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// start.js</span><br><span class=\"hljs-keyword\">const</span> &#123; fork &#125; = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;child_process&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> path = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;path&#x27;</span>);<br><br><span class=\"hljs-comment\">// 创建子进程</span><br><span class=\"hljs-keyword\">const</span> child = <span class=\"hljs-title function_\">fork</span>(path.<span class=\"hljs-title function_\">join</span>(__dirname, <span class=\"hljs-string\">&#x27;daemon.js&#x27;</span>), &#123;<br>    <span class=\"hljs-attr\">detached</span>: <span class=\"hljs-literal\">true</span>,  <span class=\"hljs-comment\">// 使子进程成为新的进程组领导</span><br>    <span class=\"hljs-attr\">stdio</span>: <span class=\"hljs-string\">&#x27;ignore&#x27;</span>  <span class=\"hljs-comment\">// 忽略标准输入/输出/错误</span><br>&#125;);<br><br><span class=\"hljs-comment\">// 解除父进程对子进程的引用</span><br>child.<span class=\"hljs-title function_\">unref</span>();<br><br><span class=\"hljs-comment\">//父进程退出</span><br>process.<span class=\"hljs-title function_\">exit</span>(<span class=\"hljs-number\">0</span>);<br></code></pre></td></tr></table></figure>\n\n<p>如上述代码所示，使用 <code>chilrd_process</code>中的 <code>fork</code>方法创建一个子进程，它会自动建立父子进程间的 IPC 通信通道。其中的几个参数，详细讲解一下：</p>\n<ul>\n<li><p>第一个参数 daemon.js 是要执行的子进程脚本路径，通过 <code>path.join(__dirname, ...)</code> 确保路径正确。</p>\n</li>\n<li><p>第二个参数是配置对象，包含关键选项：</p>\n<ul>\n<li><p><strong>detached: true</strong>​：使子进程成为新进程组的领导者（非 Windows 系统）或拥有独立控制台（Windows），允许子进程在父进程退出后继续运行</p>\n</li>\n<li><p>​<strong>stdio: ignore</strong>​：忽略子进程的标准输入&#x2F;输出&#x2F;错误流，避免管道阻塞问题</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"2-设置工作目录和文件权限\"><a href=\"#2-设置工作目录和文件权限\" class=\"headerlink\" title=\"2. 设置工作目录和文件权限\"></a>2. 设置工作目录和文件权限</h2><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// daemon.js</span><br><br><span class=\"hljs-comment\">// 改变工作目录到根目录或特定目录</span><br>process.<span class=\"hljs-title function_\">chdir</span>(<span class=\"hljs-string\">&#x27;/&#x27;</span>);<br><br><span class=\"hljs-comment\">// 重设文件权限掩码</span><br>process.<span class=\"hljs-title function_\">umask</span>(<span class=\"hljs-number\">0</span>);<br></code></pre></td></tr></table></figure>\n\n<p>为了将守护进程独立于启动它的环境，我们通过改变工作目录来实现隔离，而且这样还可以避免挂载点无法卸载。</p>\n<p>另外还需要关注一下权限的问题，将掩码设置为0，这样守护进程创建的文件和目录将使用系统的默认权限。</p>\n<h2 id=\"3-配置日志模块\"><a href=\"#3-配置日志模块\" class=\"headerlink\" title=\"3. 配置日志模块\"></a>3. 配置日志模块</h2><p>守护进程不同于在终端执行命令行的进程，它是不占用终端的，所以是看不到它输出内容在终端上。因此，需要配置一个日志模块，用于记录下一些关键信息，避免在报错或者调试的时候两眼抓瞎。</p>\n<p>日志模块其实很简单，功能就是将内容记录到文本中即可</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// daemon.js</span><br><br><span class=\"hljs-comment\">// 设置日志记录</span><br><span class=\"hljs-keyword\">const</span> util = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;util&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> logFile = fs.<span class=\"hljs-title function_\">createWriteStream</span>(<span class=\"hljs-string\">&#x27;daemon.log&#x27;</span>, &#123; <span class=\"hljs-attr\">flags</span>: <span class=\"hljs-string\">&#x27;a&#x27;</span> &#125;);<br><span class=\"hljs-keyword\">const</span> log = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">msg</span>) &#123;<br>    logFile.<span class=\"hljs-title function_\">write</span>(util.<span class=\"hljs-title function_\">format</span>(msg) + <span class=\"hljs-string\">&#x27;\\n&#x27;</span>);<br>&#125;;<br><br></code></pre></td></tr></table></figure>\n\n\n<h2 id=\"4-处理信号和错误\"><a href=\"#4-处理信号和错误\" class=\"headerlink\" title=\"4. 处理信号和错误\"></a>4. 处理信号和错误</h2><p>为了提高守护进程的稳定性和可靠性，需要对一些系统信号做处理，从而应对各种意外，毕竟总不希望守护进程挂掉了，而自己却连什么时候挂掉了都不知道吧。</p>\n<p>其中，重点是以下几个信号量：</p>\n<ul>\n<li><p><strong>SIGINT (Ctrl+C)</strong>:<br>通常由用户在终端中按下 <code>Ctrl+C</code> 发送</p>\n</li>\n<li><p><strong>SIGTERM</strong>:<br>系统关闭或通过 kill <pid> 发送的默认信号</p>\n</li>\n<li><p><strong>SIGHUP</strong>:<br>传统上表示控制终端关闭,守护进程通常忽略此信号或用于重新加载配置</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 处理进程信号</span><br>process.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;SIGINT&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;收到 SIGINT 信号，准备停止...&#x27;</span>);<br>  <span class=\"hljs-comment\">// 执行清理和停止逻辑</span><br>&#125;);<br><br>process.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;SIGTERM&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;<br> <span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;收到 SIGTERM 信号，准备停止...&#x27;</span>);<br>  <span class=\"hljs-comment\">// 执行清理和停止逻辑</span><br>&#125;);<br><br><span class=\"hljs-comment\">// 忽略挂起信号(SIGHUP)</span><br>process.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;SIGHUP&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;&#125;);<br><br><span class=\"hljs-comment\">// 全局错误处理</span><br>process.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;uncaughtException&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">err</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`未捕获异常: <span class=\"hljs-subst\">$&#123;err&#125;</span>`</span>);<br>    <span class=\"hljs-comment\">// 可以添加重启逻辑</span><br>&#125;);<br><br>process.<span class=\"hljs-title function_\">on</span>(<span class=\"hljs-string\">&#x27;unhandledRejection&#x27;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">reason, promise</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`未处理的Promise拒绝:&#x27;, <span class=\"hljs-subst\">$&#123;reason&#125;</span>`</span>);<br>&#125;);<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"5-实现守护进程主体内容\"><a href=\"#5-实现守护进程主体内容\" class=\"headerlink\" title=\"5. 实现守护进程主体内容\"></a>5. 实现守护进程主体内容</h2><p>前面的一些列操作，都是为了保证守护进程能够正常启动和执行，接下来就到了相对来说简单的部分了。</p>\n<p>守护进程主体内容，通常来说最好是个循环，定时任务，或者对外的请求监听，这样才不会运行之后马上就结束。</p>\n<p>下面以一个简单的 <code>httpServer</code>作为例子。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;http&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> port = <span class=\"hljs-number\">5000</span>;<br><span class=\"hljs-keyword\">const</span> app = http.<span class=\"hljs-title function_\">createServer</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">req, res</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;req.method&#125;</span> <span class=\"hljs-subst\">$&#123;req.url&#125;</span>`</span>);<br>  res.<span class=\"hljs-title function_\">end</span>(<span class=\"hljs-string\">&#x27;Hello daemon&#x27;</span>);<br>&#125;)<br><br>app.<span class=\"hljs-title function_\">listen</span>(port, <span class=\"hljs-string\">&#x27;0.0.0.0&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`Server listening on: http://localhost:<span class=\"hljs-subst\">$&#123;port&#125;</span>`</span>);<br>&#125;)<br><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"6-启动服务并验证\"><a href=\"#6-启动服务并验证\" class=\"headerlink\" title=\"6. 启动服务并验证\"></a>6. 启动服务并验证</h2><p>完成代码编写之后，我们尝试着启动服务并验证服务是否启动成功了。打开终端，执行 <code>node start.js</code>。父进程在执行完之后，会立即退出，因此不会占用终端。</p>\n<p>通过浏览器访问地址 <code>http://localhost:5000</code>, 能够正确显示内容，说明守护进程启动成功了。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/daemon/success.png\" alt=\"success\"></p>\n<p>另外查看一下日志文件 <code>daemon.log</code>，可以看到服务启动和请求的记录。<br><img src=\"https://www.jvxiao.cn/imgs/daemon/logs.png\" alt=\"success\"></p>\n<p>在任务管理中，也能看到一个一直活跃的 node 进程。<br><img src=\"https://www.jvxiao.cn/imgs/daemon/panel.png\" alt=\"success\"></p>\n<p>Bingo~~~, 一个简单的守护进程就这么实现了。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>除了上面的方法，其实也还有其它一些快捷的方式来创建守护进程，如使用<code>pm2</code> 或者 <code>forever</code>, 但是纯手工创建守护进程的基本功不能丢了。</p>\n<p>实现守护进程的过程，也是深入理解 Node.js 进程模型和操作系统交互的绝佳机会。从工作目录设置、权限管理到信号处理、错误捕获，每一个细节都体现了对系统编程的深刻理解。这些知识不仅适用于守护进程开发，更能帮助我们编写更健壮的 Node.js 应用。</p>\n"},{"title":"一文读懂 Cookie、Session 和 Token：原理、区别与应用场景","date":"2025-07-01T13:15:32.000Z","keywords":["Cookie","Session","Token"],"banner_img":"/imgs/baners/security.jfif","index_img":"/imgs/baners/security.jfif","_content":"\n# 一文读懂Cookie、Session和Token：原理、区别与应用场景\n咱上网冲浪的时候，天天和各种网站、APP打交道。但HTTP协议有个“毛病”——它记性不好，每次请求都像第一次见面，根本不记得之前和你聊过啥。为了解决这个问题，程序员们整出了**Cookie**、**Session**和**Token**这三个“神器”，它们就像我们在网络世界的身份证、通行证，帮服务器记住你是谁，都干了啥。今天咱就唠唠这仨到底是干啥的，有啥不一样！\n\n## 一、Cookie、Session和Token都干啥用？\n### 1.1 Cookie：浏览器帮你记事儿的小本本\nCookie就是服务器给浏览器塞的小纸条，存的都是些用户信息，像登录状态、浏览偏好啥的。举个例子，你第一次进某个网站，选了中文界面、深色模式，下次再访问，网站秒变你喜欢的样子，这背后就是Cookie在偷偷“记笔记”。不过这小纸条存你电脑里，容易被人偷看，所以得小心点用！\n\n### 1.2 Session：服务器的专属“私人档案库”\nSession相当于是服务器自己的“小账本”，专门用来存用户的会话数据。当你登录网站，服务器就给你开个“档案袋”，把你购物车有啥、订单到哪一步了这些信息全塞进去。但它咋知道这份档案归谁呢？靠的就是Cookie里的Session ID，相当于档案编号，浏览器每次带着编号来，服务器一看就知道：“哦！原来是你！”\n\n### 1.3 Token：万能通行令牌\nToken就是服务器发的一串乱码“令牌”，你拿着它去访问网站的各种服务，就像拿着身份证证明“我是我”。Token最大的好处是不用服务器记太多东西，你每次来，它只需要验证令牌是真是假就行。现在流行的前后端分离、第三方登录，基本都靠Token“打天下”，移动端APP更是离了它不行。\n\n## 二、Cookie、Session和Token，到底咋区分？\n### 2.1 都藏在哪？能存多少东西？\nCookie就住你电脑里，浏览器帮你保管。不过它个头很小气，一般不能超过4KB，而且一个网站最多也就存50个左右。\nSession住在服务器那边，理论上想存多少存多少，但服务器空间有限，存太多也顶不住。\nToken呢，既可以放在客户端（比如APP里），也能在每次请求的时候跟着一起“跑”，大小没严格限制，通常几百字节。\n\n### 2.2 安不安全？容易被偷吗？\nCookie因为在客户端，就像放在桌子上的纸条，很容易被人篡改。不过可以给它加把锁：\n- `HttpOnly`让JavaScript读不到它\n- `Secure`保证它只在安全的HTTPS通道里传送\n- `SameSite`防止被别人“冒名顶替”发请求\n\nSession数据在服务器，相对安全些，但要是Session ID被坏人搞到手，也能冒充你。\nToken用签名加密，一般改不了，但一旦被偷，坏人也能用，所以得设个有效期，到期就作废。\n\n### 2.3 怎么在网络里“传送”？\n- Cookie最“自觉”，浏览器每次发请求，都会自动把相关的Cookie带上，除非你特意限制它。\n- Session得靠Cookie帮忙传递Session ID，虽然也能藏在URL里，但容易暴露，不太安全。\n- Token就比较“自由”，常见的是放在请求头的`Authorization`字段里，也能塞到请求体或URL里，全看开发者咋安排。\n\n### 2.4 能用多久？啥时候过期？\n- Cookie想“活”多久，由服务器说了算。设置了`expires`或`max-age`，它就是“长寿型”，到期才失效；不设置的话，浏览器一关，它就“凉凉”。\n- Session和Cookie里的Session ID绑在一起，服务器还会设个“闲置超时”，比如30分钟没操作，直接清空档案。\n- Token出生的时候就被定好了“保质期”（像JWT的`exp`字段），过期就得重新申请新令牌。\n\n### 2.5 能不能适应复杂的网络环境？\n要是网站用的是分布式系统（多个服务器协同工作），Cookie + Session组合就有点“吃力”。因为Session存在服务器里，多个服务器之间得同步数据，不然容易“认不出”用户。\nToken就没这烦恼，它不需要服务器存啥，验证一下令牌是真是假就行，特别适合微服务、跨域这种复杂场景。\n\n## 三、生活里都在哪见过它们？\n### 3.1 Cookie的“日常工作”\n- 刷新闻的时候，为啥总给你推爱看的内容？Cookie在“搞事情”！它记住了你的兴趣标签。\n- 还有电商网站没登录时加进购物车的商品，也是Cookie临时存着。不过拿Cookie做广告追踪得小心，一不小心就违反隐私规定了。\n\n### 3.2 Session的“用武之地”\n电商平台的购物车、订单状态，后台管理系统的用户权限，在线聊天的实时状态……这些对安全性、实时性要求高的场景，都是Session的主场。服务器随时能查看、修改你的会话数据，还能强制你下线，安全感拉满！\n\n### 3.3 Token的“高光时刻”\n- 现在很多网站支持微信、GitHub一键登录，靠的就是Token在不同平台间“传话”。\n- 前后端分离项目里，前端和后端不在一个域名下，Token能轻松实现跨域认证。\n- 还有手机APP，没Cookie可用，Token就是它唯一的“身份认证官”。\n\n## 四、到底该选谁？\n简单来说：\n- Cookie适合存点小偏好、临时数据\n- Session适合对安全要求高、需要集中管理的场景\n- Token则是跨域、移动端、微服务的“心头好”\n\n实际开发中，大家经常把它们搭配着用，比如用Cookie传Session ID，或者把Token藏在Cookie里，增强安全性。具体咋选，还得根据业务需求，综合考虑安全、性能这些因素，找到最适合的方案！\n\n要是你对哪个部分还有疑问，或者想知道更多实战技巧，欢迎随时来唠嗑！ ","source":"_posts/cookie-session-token.md","raw":"---\ntitle: 一文读懂 Cookie、Session 和 Token：原理、区别与应用场景\ndate: 2025-07-01 21:15:32\ntags: [Cookie, Session, Token]\nkeywords: [Cookie, Session, Token]\ncategory: [Web开发, 网络安全]\nbanner_img: /imgs/baners/security.jfif\nindex_img: /imgs/baners/security.jfif\n---\n\n# 一文读懂Cookie、Session和Token：原理、区别与应用场景\n咱上网冲浪的时候，天天和各种网站、APP打交道。但HTTP协议有个“毛病”——它记性不好，每次请求都像第一次见面，根本不记得之前和你聊过啥。为了解决这个问题，程序员们整出了**Cookie**、**Session**和**Token**这三个“神器”，它们就像我们在网络世界的身份证、通行证，帮服务器记住你是谁，都干了啥。今天咱就唠唠这仨到底是干啥的，有啥不一样！\n\n## 一、Cookie、Session和Token都干啥用？\n### 1.1 Cookie：浏览器帮你记事儿的小本本\nCookie就是服务器给浏览器塞的小纸条，存的都是些用户信息，像登录状态、浏览偏好啥的。举个例子，你第一次进某个网站，选了中文界面、深色模式，下次再访问，网站秒变你喜欢的样子，这背后就是Cookie在偷偷“记笔记”。不过这小纸条存你电脑里，容易被人偷看，所以得小心点用！\n\n### 1.2 Session：服务器的专属“私人档案库”\nSession相当于是服务器自己的“小账本”，专门用来存用户的会话数据。当你登录网站，服务器就给你开个“档案袋”，把你购物车有啥、订单到哪一步了这些信息全塞进去。但它咋知道这份档案归谁呢？靠的就是Cookie里的Session ID，相当于档案编号，浏览器每次带着编号来，服务器一看就知道：“哦！原来是你！”\n\n### 1.3 Token：万能通行令牌\nToken就是服务器发的一串乱码“令牌”，你拿着它去访问网站的各种服务，就像拿着身份证证明“我是我”。Token最大的好处是不用服务器记太多东西，你每次来，它只需要验证令牌是真是假就行。现在流行的前后端分离、第三方登录，基本都靠Token“打天下”，移动端APP更是离了它不行。\n\n## 二、Cookie、Session和Token，到底咋区分？\n### 2.1 都藏在哪？能存多少东西？\nCookie就住你电脑里，浏览器帮你保管。不过它个头很小气，一般不能超过4KB，而且一个网站最多也就存50个左右。\nSession住在服务器那边，理论上想存多少存多少，但服务器空间有限，存太多也顶不住。\nToken呢，既可以放在客户端（比如APP里），也能在每次请求的时候跟着一起“跑”，大小没严格限制，通常几百字节。\n\n### 2.2 安不安全？容易被偷吗？\nCookie因为在客户端，就像放在桌子上的纸条，很容易被人篡改。不过可以给它加把锁：\n- `HttpOnly`让JavaScript读不到它\n- `Secure`保证它只在安全的HTTPS通道里传送\n- `SameSite`防止被别人“冒名顶替”发请求\n\nSession数据在服务器，相对安全些，但要是Session ID被坏人搞到手，也能冒充你。\nToken用签名加密，一般改不了，但一旦被偷，坏人也能用，所以得设个有效期，到期就作废。\n\n### 2.3 怎么在网络里“传送”？\n- Cookie最“自觉”，浏览器每次发请求，都会自动把相关的Cookie带上，除非你特意限制它。\n- Session得靠Cookie帮忙传递Session ID，虽然也能藏在URL里，但容易暴露，不太安全。\n- Token就比较“自由”，常见的是放在请求头的`Authorization`字段里，也能塞到请求体或URL里，全看开发者咋安排。\n\n### 2.4 能用多久？啥时候过期？\n- Cookie想“活”多久，由服务器说了算。设置了`expires`或`max-age`，它就是“长寿型”，到期才失效；不设置的话，浏览器一关，它就“凉凉”。\n- Session和Cookie里的Session ID绑在一起，服务器还会设个“闲置超时”，比如30分钟没操作，直接清空档案。\n- Token出生的时候就被定好了“保质期”（像JWT的`exp`字段），过期就得重新申请新令牌。\n\n### 2.5 能不能适应复杂的网络环境？\n要是网站用的是分布式系统（多个服务器协同工作），Cookie + Session组合就有点“吃力”。因为Session存在服务器里，多个服务器之间得同步数据，不然容易“认不出”用户。\nToken就没这烦恼，它不需要服务器存啥，验证一下令牌是真是假就行，特别适合微服务、跨域这种复杂场景。\n\n## 三、生活里都在哪见过它们？\n### 3.1 Cookie的“日常工作”\n- 刷新闻的时候，为啥总给你推爱看的内容？Cookie在“搞事情”！它记住了你的兴趣标签。\n- 还有电商网站没登录时加进购物车的商品，也是Cookie临时存着。不过拿Cookie做广告追踪得小心，一不小心就违反隐私规定了。\n\n### 3.2 Session的“用武之地”\n电商平台的购物车、订单状态，后台管理系统的用户权限，在线聊天的实时状态……这些对安全性、实时性要求高的场景，都是Session的主场。服务器随时能查看、修改你的会话数据，还能强制你下线，安全感拉满！\n\n### 3.3 Token的“高光时刻”\n- 现在很多网站支持微信、GitHub一键登录，靠的就是Token在不同平台间“传话”。\n- 前后端分离项目里，前端和后端不在一个域名下，Token能轻松实现跨域认证。\n- 还有手机APP，没Cookie可用，Token就是它唯一的“身份认证官”。\n\n## 四、到底该选谁？\n简单来说：\n- Cookie适合存点小偏好、临时数据\n- Session适合对安全要求高、需要集中管理的场景\n- Token则是跨域、移动端、微服务的“心头好”\n\n实际开发中，大家经常把它们搭配着用，比如用Cookie传Session ID，或者把Token藏在Cookie里，增强安全性。具体咋选，还得根据业务需求，综合考虑安全、性能这些因素，找到最适合的方案！\n\n要是你对哪个部分还有疑问，或者想知道更多实战技巧，欢迎随时来唠嗑！ ","slug":"cookie-session-token","published":1,"updated":"2025-08-26T10:47:25.358Z","comments":1,"layout":"post","photos":[],"_id":"cmjbml2ia0015ikupfme23rqd","content":"<h1 id=\"一文读懂Cookie、Session和Token：原理、区别与应用场景\"><a href=\"#一文读懂Cookie、Session和Token：原理、区别与应用场景\" class=\"headerlink\" title=\"一文读懂Cookie、Session和Token：原理、区别与应用场景\"></a>一文读懂Cookie、Session和Token：原理、区别与应用场景</h1><p>咱上网冲浪的时候，天天和各种网站、APP打交道。但HTTP协议有个“毛病”——它记性不好，每次请求都像第一次见面，根本不记得之前和你聊过啥。为了解决这个问题，程序员们整出了<strong>Cookie</strong>、<strong>Session</strong>和<strong>Token</strong>这三个“神器”，它们就像我们在网络世界的身份证、通行证，帮服务器记住你是谁，都干了啥。今天咱就唠唠这仨到底是干啥的，有啥不一样！</p>\n<h2 id=\"一、Cookie、Session和Token都干啥用？\"><a href=\"#一、Cookie、Session和Token都干啥用？\" class=\"headerlink\" title=\"一、Cookie、Session和Token都干啥用？\"></a>一、Cookie、Session和Token都干啥用？</h2><h3 id=\"1-1-Cookie：浏览器帮你记事儿的小本本\"><a href=\"#1-1-Cookie：浏览器帮你记事儿的小本本\" class=\"headerlink\" title=\"1.1 Cookie：浏览器帮你记事儿的小本本\"></a>1.1 Cookie：浏览器帮你记事儿的小本本</h3><p>Cookie就是服务器给浏览器塞的小纸条，存的都是些用户信息，像登录状态、浏览偏好啥的。举个例子，你第一次进某个网站，选了中文界面、深色模式，下次再访问，网站秒变你喜欢的样子，这背后就是Cookie在偷偷“记笔记”。不过这小纸条存你电脑里，容易被人偷看，所以得小心点用！</p>\n<h3 id=\"1-2-Session：服务器的专属“私人档案库”\"><a href=\"#1-2-Session：服务器的专属“私人档案库”\" class=\"headerlink\" title=\"1.2 Session：服务器的专属“私人档案库”\"></a>1.2 Session：服务器的专属“私人档案库”</h3><p>Session相当于是服务器自己的“小账本”，专门用来存用户的会话数据。当你登录网站，服务器就给你开个“档案袋”，把你购物车有啥、订单到哪一步了这些信息全塞进去。但它咋知道这份档案归谁呢？靠的就是Cookie里的Session ID，相当于档案编号，浏览器每次带着编号来，服务器一看就知道：“哦！原来是你！”</p>\n<h3 id=\"1-3-Token：万能通行令牌\"><a href=\"#1-3-Token：万能通行令牌\" class=\"headerlink\" title=\"1.3 Token：万能通行令牌\"></a>1.3 Token：万能通行令牌</h3><p>Token就是服务器发的一串乱码“令牌”，你拿着它去访问网站的各种服务，就像拿着身份证证明“我是我”。Token最大的好处是不用服务器记太多东西，你每次来，它只需要验证令牌是真是假就行。现在流行的前后端分离、第三方登录，基本都靠Token“打天下”，移动端APP更是离了它不行。</p>\n<h2 id=\"二、Cookie、Session和Token，到底咋区分？\"><a href=\"#二、Cookie、Session和Token，到底咋区分？\" class=\"headerlink\" title=\"二、Cookie、Session和Token，到底咋区分？\"></a>二、Cookie、Session和Token，到底咋区分？</h2><h3 id=\"2-1-都藏在哪？能存多少东西？\"><a href=\"#2-1-都藏在哪？能存多少东西？\" class=\"headerlink\" title=\"2.1 都藏在哪？能存多少东西？\"></a>2.1 都藏在哪？能存多少东西？</h3><p>Cookie就住你电脑里，浏览器帮你保管。不过它个头很小气，一般不能超过4KB，而且一个网站最多也就存50个左右。<br>Session住在服务器那边，理论上想存多少存多少，但服务器空间有限，存太多也顶不住。<br>Token呢，既可以放在客户端（比如APP里），也能在每次请求的时候跟着一起“跑”，大小没严格限制，通常几百字节。</p>\n<h3 id=\"2-2-安不安全？容易被偷吗？\"><a href=\"#2-2-安不安全？容易被偷吗？\" class=\"headerlink\" title=\"2.2 安不安全？容易被偷吗？\"></a>2.2 安不安全？容易被偷吗？</h3><p>Cookie因为在客户端，就像放在桌子上的纸条，很容易被人篡改。不过可以给它加把锁：</p>\n<ul>\n<li><code>HttpOnly</code>让JavaScript读不到它</li>\n<li><code>Secure</code>保证它只在安全的HTTPS通道里传送</li>\n<li><code>SameSite</code>防止被别人“冒名顶替”发请求</li>\n</ul>\n<p>Session数据在服务器，相对安全些，但要是Session ID被坏人搞到手，也能冒充你。<br>Token用签名加密，一般改不了，但一旦被偷，坏人也能用，所以得设个有效期，到期就作废。</p>\n<h3 id=\"2-3-怎么在网络里“传送”？\"><a href=\"#2-3-怎么在网络里“传送”？\" class=\"headerlink\" title=\"2.3 怎么在网络里“传送”？\"></a>2.3 怎么在网络里“传送”？</h3><ul>\n<li>Cookie最“自觉”，浏览器每次发请求，都会自动把相关的Cookie带上，除非你特意限制它。</li>\n<li>Session得靠Cookie帮忙传递Session ID，虽然也能藏在URL里，但容易暴露，不太安全。</li>\n<li>Token就比较“自由”，常见的是放在请求头的<code>Authorization</code>字段里，也能塞到请求体或URL里，全看开发者咋安排。</li>\n</ul>\n<h3 id=\"2-4-能用多久？啥时候过期？\"><a href=\"#2-4-能用多久？啥时候过期？\" class=\"headerlink\" title=\"2.4 能用多久？啥时候过期？\"></a>2.4 能用多久？啥时候过期？</h3><ul>\n<li>Cookie想“活”多久，由服务器说了算。设置了<code>expires</code>或<code>max-age</code>，它就是“长寿型”，到期才失效；不设置的话，浏览器一关，它就“凉凉”。</li>\n<li>Session和Cookie里的Session ID绑在一起，服务器还会设个“闲置超时”，比如30分钟没操作，直接清空档案。</li>\n<li>Token出生的时候就被定好了“保质期”（像JWT的<code>exp</code>字段），过期就得重新申请新令牌。</li>\n</ul>\n<h3 id=\"2-5-能不能适应复杂的网络环境？\"><a href=\"#2-5-能不能适应复杂的网络环境？\" class=\"headerlink\" title=\"2.5 能不能适应复杂的网络环境？\"></a>2.5 能不能适应复杂的网络环境？</h3><p>要是网站用的是分布式系统（多个服务器协同工作），Cookie + Session组合就有点“吃力”。因为Session存在服务器里，多个服务器之间得同步数据，不然容易“认不出”用户。<br>Token就没这烦恼，它不需要服务器存啥，验证一下令牌是真是假就行，特别适合微服务、跨域这种复杂场景。</p>\n<h2 id=\"三、生活里都在哪见过它们？\"><a href=\"#三、生活里都在哪见过它们？\" class=\"headerlink\" title=\"三、生活里都在哪见过它们？\"></a>三、生活里都在哪见过它们？</h2><h3 id=\"3-1-Cookie的“日常工作”\"><a href=\"#3-1-Cookie的“日常工作”\" class=\"headerlink\" title=\"3.1 Cookie的“日常工作”\"></a>3.1 Cookie的“日常工作”</h3><ul>\n<li>刷新闻的时候，为啥总给你推爱看的内容？Cookie在“搞事情”！它记住了你的兴趣标签。</li>\n<li>还有电商网站没登录时加进购物车的商品，也是Cookie临时存着。不过拿Cookie做广告追踪得小心，一不小心就违反隐私规定了。</li>\n</ul>\n<h3 id=\"3-2-Session的“用武之地”\"><a href=\"#3-2-Session的“用武之地”\" class=\"headerlink\" title=\"3.2 Session的“用武之地”\"></a>3.2 Session的“用武之地”</h3><p>电商平台的购物车、订单状态，后台管理系统的用户权限，在线聊天的实时状态……这些对安全性、实时性要求高的场景，都是Session的主场。服务器随时能查看、修改你的会话数据，还能强制你下线，安全感拉满！</p>\n<h3 id=\"3-3-Token的“高光时刻”\"><a href=\"#3-3-Token的“高光时刻”\" class=\"headerlink\" title=\"3.3 Token的“高光时刻”\"></a>3.3 Token的“高光时刻”</h3><ul>\n<li>现在很多网站支持微信、GitHub一键登录，靠的就是Token在不同平台间“传话”。</li>\n<li>前后端分离项目里，前端和后端不在一个域名下，Token能轻松实现跨域认证。</li>\n<li>还有手机APP，没Cookie可用，Token就是它唯一的“身份认证官”。</li>\n</ul>\n<h2 id=\"四、到底该选谁？\"><a href=\"#四、到底该选谁？\" class=\"headerlink\" title=\"四、到底该选谁？\"></a>四、到底该选谁？</h2><p>简单来说：</p>\n<ul>\n<li>Cookie适合存点小偏好、临时数据</li>\n<li>Session适合对安全要求高、需要集中管理的场景</li>\n<li>Token则是跨域、移动端、微服务的“心头好”</li>\n</ul>\n<p>实际开发中，大家经常把它们搭配着用，比如用Cookie传Session ID，或者把Token藏在Cookie里，增强安全性。具体咋选，还得根据业务需求，综合考虑安全、性能这些因素，找到最适合的方案！</p>\n<p>要是你对哪个部分还有疑问，或者想知道更多实战技巧，欢迎随时来唠嗑！ </p>\n","excerpt":"","more":"<h1 id=\"一文读懂Cookie、Session和Token：原理、区别与应用场景\"><a href=\"#一文读懂Cookie、Session和Token：原理、区别与应用场景\" class=\"headerlink\" title=\"一文读懂Cookie、Session和Token：原理、区别与应用场景\"></a>一文读懂Cookie、Session和Token：原理、区别与应用场景</h1><p>咱上网冲浪的时候，天天和各种网站、APP打交道。但HTTP协议有个“毛病”——它记性不好，每次请求都像第一次见面，根本不记得之前和你聊过啥。为了解决这个问题，程序员们整出了<strong>Cookie</strong>、<strong>Session</strong>和<strong>Token</strong>这三个“神器”，它们就像我们在网络世界的身份证、通行证，帮服务器记住你是谁，都干了啥。今天咱就唠唠这仨到底是干啥的，有啥不一样！</p>\n<h2 id=\"一、Cookie、Session和Token都干啥用？\"><a href=\"#一、Cookie、Session和Token都干啥用？\" class=\"headerlink\" title=\"一、Cookie、Session和Token都干啥用？\"></a>一、Cookie、Session和Token都干啥用？</h2><h3 id=\"1-1-Cookie：浏览器帮你记事儿的小本本\"><a href=\"#1-1-Cookie：浏览器帮你记事儿的小本本\" class=\"headerlink\" title=\"1.1 Cookie：浏览器帮你记事儿的小本本\"></a>1.1 Cookie：浏览器帮你记事儿的小本本</h3><p>Cookie就是服务器给浏览器塞的小纸条，存的都是些用户信息，像登录状态、浏览偏好啥的。举个例子，你第一次进某个网站，选了中文界面、深色模式，下次再访问，网站秒变你喜欢的样子，这背后就是Cookie在偷偷“记笔记”。不过这小纸条存你电脑里，容易被人偷看，所以得小心点用！</p>\n<h3 id=\"1-2-Session：服务器的专属“私人档案库”\"><a href=\"#1-2-Session：服务器的专属“私人档案库”\" class=\"headerlink\" title=\"1.2 Session：服务器的专属“私人档案库”\"></a>1.2 Session：服务器的专属“私人档案库”</h3><p>Session相当于是服务器自己的“小账本”，专门用来存用户的会话数据。当你登录网站，服务器就给你开个“档案袋”，把你购物车有啥、订单到哪一步了这些信息全塞进去。但它咋知道这份档案归谁呢？靠的就是Cookie里的Session ID，相当于档案编号，浏览器每次带着编号来，服务器一看就知道：“哦！原来是你！”</p>\n<h3 id=\"1-3-Token：万能通行令牌\"><a href=\"#1-3-Token：万能通行令牌\" class=\"headerlink\" title=\"1.3 Token：万能通行令牌\"></a>1.3 Token：万能通行令牌</h3><p>Token就是服务器发的一串乱码“令牌”，你拿着它去访问网站的各种服务，就像拿着身份证证明“我是我”。Token最大的好处是不用服务器记太多东西，你每次来，它只需要验证令牌是真是假就行。现在流行的前后端分离、第三方登录，基本都靠Token“打天下”，移动端APP更是离了它不行。</p>\n<h2 id=\"二、Cookie、Session和Token，到底咋区分？\"><a href=\"#二、Cookie、Session和Token，到底咋区分？\" class=\"headerlink\" title=\"二、Cookie、Session和Token，到底咋区分？\"></a>二、Cookie、Session和Token，到底咋区分？</h2><h3 id=\"2-1-都藏在哪？能存多少东西？\"><a href=\"#2-1-都藏在哪？能存多少东西？\" class=\"headerlink\" title=\"2.1 都藏在哪？能存多少东西？\"></a>2.1 都藏在哪？能存多少东西？</h3><p>Cookie就住你电脑里，浏览器帮你保管。不过它个头很小气，一般不能超过4KB，而且一个网站最多也就存50个左右。<br>Session住在服务器那边，理论上想存多少存多少，但服务器空间有限，存太多也顶不住。<br>Token呢，既可以放在客户端（比如APP里），也能在每次请求的时候跟着一起“跑”，大小没严格限制，通常几百字节。</p>\n<h3 id=\"2-2-安不安全？容易被偷吗？\"><a href=\"#2-2-安不安全？容易被偷吗？\" class=\"headerlink\" title=\"2.2 安不安全？容易被偷吗？\"></a>2.2 安不安全？容易被偷吗？</h3><p>Cookie因为在客户端，就像放在桌子上的纸条，很容易被人篡改。不过可以给它加把锁：</p>\n<ul>\n<li><code>HttpOnly</code>让JavaScript读不到它</li>\n<li><code>Secure</code>保证它只在安全的HTTPS通道里传送</li>\n<li><code>SameSite</code>防止被别人“冒名顶替”发请求</li>\n</ul>\n<p>Session数据在服务器，相对安全些，但要是Session ID被坏人搞到手，也能冒充你。<br>Token用签名加密，一般改不了，但一旦被偷，坏人也能用，所以得设个有效期，到期就作废。</p>\n<h3 id=\"2-3-怎么在网络里“传送”？\"><a href=\"#2-3-怎么在网络里“传送”？\" class=\"headerlink\" title=\"2.3 怎么在网络里“传送”？\"></a>2.3 怎么在网络里“传送”？</h3><ul>\n<li>Cookie最“自觉”，浏览器每次发请求，都会自动把相关的Cookie带上，除非你特意限制它。</li>\n<li>Session得靠Cookie帮忙传递Session ID，虽然也能藏在URL里，但容易暴露，不太安全。</li>\n<li>Token就比较“自由”，常见的是放在请求头的<code>Authorization</code>字段里，也能塞到请求体或URL里，全看开发者咋安排。</li>\n</ul>\n<h3 id=\"2-4-能用多久？啥时候过期？\"><a href=\"#2-4-能用多久？啥时候过期？\" class=\"headerlink\" title=\"2.4 能用多久？啥时候过期？\"></a>2.4 能用多久？啥时候过期？</h3><ul>\n<li>Cookie想“活”多久，由服务器说了算。设置了<code>expires</code>或<code>max-age</code>，它就是“长寿型”，到期才失效；不设置的话，浏览器一关，它就“凉凉”。</li>\n<li>Session和Cookie里的Session ID绑在一起，服务器还会设个“闲置超时”，比如30分钟没操作，直接清空档案。</li>\n<li>Token出生的时候就被定好了“保质期”（像JWT的<code>exp</code>字段），过期就得重新申请新令牌。</li>\n</ul>\n<h3 id=\"2-5-能不能适应复杂的网络环境？\"><a href=\"#2-5-能不能适应复杂的网络环境？\" class=\"headerlink\" title=\"2.5 能不能适应复杂的网络环境？\"></a>2.5 能不能适应复杂的网络环境？</h3><p>要是网站用的是分布式系统（多个服务器协同工作），Cookie + Session组合就有点“吃力”。因为Session存在服务器里，多个服务器之间得同步数据，不然容易“认不出”用户。<br>Token就没这烦恼，它不需要服务器存啥，验证一下令牌是真是假就行，特别适合微服务、跨域这种复杂场景。</p>\n<h2 id=\"三、生活里都在哪见过它们？\"><a href=\"#三、生活里都在哪见过它们？\" class=\"headerlink\" title=\"三、生活里都在哪见过它们？\"></a>三、生活里都在哪见过它们？</h2><h3 id=\"3-1-Cookie的“日常工作”\"><a href=\"#3-1-Cookie的“日常工作”\" class=\"headerlink\" title=\"3.1 Cookie的“日常工作”\"></a>3.1 Cookie的“日常工作”</h3><ul>\n<li>刷新闻的时候，为啥总给你推爱看的内容？Cookie在“搞事情”！它记住了你的兴趣标签。</li>\n<li>还有电商网站没登录时加进购物车的商品，也是Cookie临时存着。不过拿Cookie做广告追踪得小心，一不小心就违反隐私规定了。</li>\n</ul>\n<h3 id=\"3-2-Session的“用武之地”\"><a href=\"#3-2-Session的“用武之地”\" class=\"headerlink\" title=\"3.2 Session的“用武之地”\"></a>3.2 Session的“用武之地”</h3><p>电商平台的购物车、订单状态，后台管理系统的用户权限，在线聊天的实时状态……这些对安全性、实时性要求高的场景，都是Session的主场。服务器随时能查看、修改你的会话数据，还能强制你下线，安全感拉满！</p>\n<h3 id=\"3-3-Token的“高光时刻”\"><a href=\"#3-3-Token的“高光时刻”\" class=\"headerlink\" title=\"3.3 Token的“高光时刻”\"></a>3.3 Token的“高光时刻”</h3><ul>\n<li>现在很多网站支持微信、GitHub一键登录，靠的就是Token在不同平台间“传话”。</li>\n<li>前后端分离项目里，前端和后端不在一个域名下，Token能轻松实现跨域认证。</li>\n<li>还有手机APP，没Cookie可用，Token就是它唯一的“身份认证官”。</li>\n</ul>\n<h2 id=\"四、到底该选谁？\"><a href=\"#四、到底该选谁？\" class=\"headerlink\" title=\"四、到底该选谁？\"></a>四、到底该选谁？</h2><p>简单来说：</p>\n<ul>\n<li>Cookie适合存点小偏好、临时数据</li>\n<li>Session适合对安全要求高、需要集中管理的场景</li>\n<li>Token则是跨域、移动端、微服务的“心头好”</li>\n</ul>\n<p>实际开发中，大家经常把它们搭配着用，比如用Cookie传Session ID，或者把Token藏在Cookie里，增强安全性。具体咋选，还得根据业务需求，综合考虑安全、性能这些因素，找到最适合的方案！</p>\n<p>要是你对哪个部分还有疑问，或者想知道更多实战技巧，欢迎随时来唠嗑！ </p>\n"},{"title":"JavaScript ES6中的装饰器(Decorator)是什么？有哪些应用场景？万字长文，谨慎阅读！","date":"2025-12-06T04:35:25.000Z","_content":"<!--# ES6 Module：重塑JavaScript模块化生态的基石 -->\n这是[JavaScript进阶系列文章](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU2MjU3MzI0MA==&action=getalbum&album_id=4120256678140837890#wechat_redirect)的第11篇文章, 今天我们来讲讲`装饰器(Decorator)`，内容有点长，代码有些多，坐稳发车了。\n\n在前端开发中，我们常面临这样的困境：如何在不修改原有代码的前提下，为类、方法或属性添加日志、权限校验、缓存等通用功能？\n\n如果直接在业务逻辑中嵌入这些辅助代码，会导致核心逻辑与通用逻辑耦合，代码可读性和可维护性大幅下降。而 ES6 提案中`Decorator(装饰器)`，正是为解决这一问题而生的优雅方案。\n\n本文将从 Decorator 的**核心本质**出发，详解其**语法特性**、**使用场景**，并结合实战案例说明其在项目中的价值，帮助开发者真正掌握这一“非侵入式扩展”的利器。\n\n## Decorator 是什么？ \n### 核心定义\nDecorator 是基于 **“包装模式”（Wrapper Pattern）** 的语法糖，其核心目标是：**在不侵入原有代码结构的前提下，为类、类成员（方法/属性）动态扩展功能**。\n\n它的本质是一个`特殊函数`：接收被装饰的“目标对象”作为参数，通过修改或包装目标对象，返回增强后的新对象。简单来说，Decorator 就像给礼物包装——礼物本身（核心业务逻辑）不变，但包装（通用辅助逻辑）能让它具备额外的“属性”（如美观、防护）。\n\n### 核心价值\nDecorator 最核心的价值是 **“分离关注点”**：将日志、权限、缓存等通用逻辑与核心业务逻辑解耦，实现通用逻辑的复用，让代码更简洁、可维护。\n\n举个直观的对比：\n- 无 Decorator：在每个需要日志的方法中重复写 `console.log`，业务代码与日志逻辑混杂；\n- 有 Decorator：写一个通用日志装饰器，通过 `@log` 语法一键应用到任意方法，业务代码保持纯净。\n\n## Decorator 的核心用法\nDecorator 的语法简洁，核心分为“类装饰器”和“类成员装饰器”两类，各自承担不同的扩展职责。\n\n### 1. 类装饰器：增强整个类\n类装饰器直接作用于类本身，用于为类添加静态属性、静态方法，或修改类的原型（prototype）。\n\n#### 语法与参数\n- 仅接收 1 个参数 `target`：被装饰的类本身；\n- 可选返回值：若返回新类，则新类会替代原类；若不返回，则默认使用修改后的原类。\n\n#### 实战示例：给类添加通用能力\n```javascript\n// 类装饰器：为类添加静态配置和实例初始化方法\nfunction withConfig(defaultConfig) {\n  // 支持传入参数的装饰器（高阶函数形式）\n  return function (target) {\n    // 添加静态属性：默认配置\n    target.defaultConfig = defaultConfig;\n    \n    // 添加静态方法：合并配置\n    target.mergeConfig = function (userConfig) {\n      return { ...defaultConfig, ...userConfig };\n    };\n    \n    // 增强实例构造逻辑\n    const originalConstructor = target;\n    // 重写类构造函数\n    const newConstructor = function (...args) {\n      originalConstructor.apply(this, args);\n      // 实例初始化：合并配置到实例\n      this.config = target.mergeConfig(args[0] || {});\n    };\n    \n    // 继承原类的原型（保证实例方法不丢失）\n    newConstructor.prototype = Object.create(originalConstructor.prototype);\n    newConstructor.prototype.constructor = newConstructor;\n    \n    return newConstructor;\n  };\n}\n\n// 应用装饰器：传入默认配置\n@withConfig({ theme: \"light\", size: \"medium\" })\nclass Button {\n  constructor(userConfig) {\n    // 原构造函数逻辑\n    this.name = \"按钮\";\n  }\n  \n  getStyle() {\n    return `主题：${this.config.theme}，尺寸：${this.config.size}`;\n  }\n}\n\n// 测试效果\nconsole.log(Button.defaultConfig); // { theme: \"light\", size: \"medium\" }\nconst darkButton = new Button({ theme: \"dark\" });\nconsole.log(darkButton.config); // { theme: \"dark\", size: \"medium\" }\nconsole.log(darkButton.getStyle()); // 主题：dark，尺寸：medium\n```\n\n### 2. 类成员装饰器：增强方法/属性\n类成员装饰器作用于类的方法、属性或访问器（getter/setter），是开发中最常用的场景。\n\n#### 语法与参数\n接收 3 个核心参数：\n- `target`：类的原型（针对实例方法）或类本身（针对静态方法）；\n- `name`：被装饰的成员名称（方法名/属性名）；\n- `descriptor`：成员的属性描述符（`Object.getOwnPropertyDescriptor(target, name)` 的返回值），包含 `value`（方法本身）、`writable`（是否可修改）、`enumerable`（是否可枚举）等属性。\n\n#### 实战示例：包装方法实现日志记录\n```javascript\n// 方法装饰器：记录方法调用参数、返回值和执行时间\nfunction logPerformance(target, name, descriptor) {\n  // 保存原方法（避免覆盖后丢失）\n  const originalMethod = descriptor.value;\n  \n  // 重写方法逻辑\n  descriptor.value = async function (...args) {\n    const start = Date.now();\n    console.log(`[${name}] 开始执行，参数：`, args);\n    \n    try {\n      // 执行原方法（绑定 this 上下文，确保实例方法的 this 正确）\n      const result = await originalMethod.apply(this, args);\n      console.log(`[${name}] 执行成功，返回值：`, result);\n      return result;\n    } catch (error) {\n      console.error(`[${name}] 执行失败，错误：`, error);\n      throw error; // 抛出错误，不影响上层处理\n    } finally {\n      const duration = Date.now() - start;\n      console.log(`[${name}] 执行耗时：${duration}ms`);\n    }\n  };\n  \n  // 返回修改后的描述符（替代原成员）\n  return descriptor;\n}\n\nclass DataService {\n  // 应用方法装饰器\n  @logPerformance\n  async fetchData(url) {\n    // 模拟接口请求\n    const response = await fetch(url);\n    return response.json();\n  }\n}\n\n// 测试\nconst service = new DataService();\nservice.fetchData(\"https://api.example.com/data\");\n// 输出：\n// [fetchData] 开始执行，参数： [\"https://api.example.com/data\"]\n// [fetchData] 执行成功，返回值： { ...接口返回数据... }\n// [fetchData] 执行耗时：320ms\n```\n\n## 三、Decorator 的典型使用场景：让通用逻辑复用更优雅\nDecorator 的核心优势在于通用逻辑的复用，以下是前端开发中最实用的 6 个场景，覆盖日志、权限、缓存等高频需求。\n\n### 1. 日志与性能监控\n为核心业务方法（如接口请求、数据处理）添加日志，自动记录调用参数、返回值、执行时间，无需侵入业务代码。适合用于线上问题排查和性能优化。\n\n```javascript\n// 通用日志装饰器：支持开关和自定义格式\nfunction log(options = { enable: true, format: \"default\" }) {\n  return function (target, name, descriptor) {\n    if (!options.enable) return descriptor; // 关闭日志时直接返回原描述符\n    \n    const original = descriptor.value;\n    descriptor.value = function (...args) {\n      const time = new Date().toLocaleString();\n      // 自定义日志格式\n      if (options.format === \"detail\") {\n        console.log(`[${time}] [${target.constructor.name}.${name}] 调用参数：`, args);\n      } else {\n        console.log(`[${time}] [${name}] 调用参数：`, args);\n      }\n      return original.apply(this, args);\n    };\n    return descriptor;\n  };\n}\n\nclass OrderService {\n  @log({ enable: true, format: \"detail\" })\n  createOrder(params) {\n    console.log(\"创建订单：\", params);\n    return { orderId: \"123456\" };\n  }\n}\n```\n\n### 2. 权限校验与访问控制\n限制敏感方法的调用权限（如管理员操作、用户登录态校验），将权限逻辑与业务逻辑分离，避免在每个方法中重复写校验代码。\n\n```javascript\n// 权限装饰器：支持多角色校验\nfunction requireRoles(...allowedRoles) {\n  return function (target, name, descriptor) {\n    const original = descriptor.value;\n    descriptor.value = function (...args) {\n      // 假设从全局状态或实例中获取当前用户角色\n      const userRole = this.getCurrentUserRole();\n      \n      if (!allowedRoles.includes(userRole)) {\n        throw new Error(`权限不足！当前角色：${userRole}，允许角色：${allowedRoles.join(\",\")}`);\n      }\n      \n      return original.apply(this, args);\n    };\n    return descriptor;\n  };\n}\n\nclass SystemManager {\n  getCurrentUserRole() {\n    return \"admin\"; // 实际场景中从登录态获取\n  }\n  \n  @requireRoles(\"admin\", \"super_admin\") // 仅管理员和超级管理员可调用\n  deleteUser(userId) {\n    console.log(`删除用户：${userId}`);\n  }\n  \n  @requireRoles(\"user\", \"admin\") // 普通用户和管理员均可调用\n  queryUser(userId) {\n    console.log(`查询用户：${userId}`);\n  }\n}\n```\n\n### 3. 缓存优化（记忆化）\n对计算密集型方法（如递归、大数据处理）或高频调用的接口添加缓存，避免重复计算或请求，提升性能。\n\n```javascript\n// 缓存装饰器：支持过期时间\nfunction cache(options = { ttl: Infinity }) {\n  const cacheMap = new Map(); // 缓存容器\n  \n  return function (target, name, descriptor) {\n    const original = descriptor.value;\n    descriptor.value = function (...args) {\n      // 用参数生成唯一缓存键（复杂参数可使用 hash 函数优化）\n      const cacheKey = `${name}_${JSON.stringify(args)}`;\n      \n      // 检查缓存是否存在且未过期\n      if (cacheMap.has(cacheKey)) {\n        const { data, timestamp } = cacheMap.get(cacheKey);\n        if (Date.now() - timestamp < options.ttl) {\n          console.log(`[${name}] 命中缓存`);\n          return data;\n        }\n        console.log(`[${name}] 缓存过期，重新计算`);\n        cacheMap.delete(cacheKey);\n      }\n      \n      // 执行原方法并缓存结果\n      const result = original.apply(this, args);\n      cacheMap.set(cacheKey, {\n        data: result,\n        timestamp: Date.now()\n      });\n      \n      return result;\n    };\n    return descriptor;\n  };\n}\n\n// 斐波那契数列计算（计算密集型）\nclass FibCalculator {\n  @cache({ ttl: 5000 }) // 缓存 5 秒\n  fib(n) {\n    console.log(`[fib] 计算 fib(${n})`);\n    if (n <= 1) return n;\n    return this.fib(n - 1) + this.fib(n - 2);\n  }\n}\n\nconst calculator = new FibCalculator();\ncalculator.fib(10); // 首次计算，打印多次 \"计算 fib(n)\"\ncalculator.fib(10); // 命中缓存，直接返回结果\nsetTimeout(() => calculator.fib(10), 6000); // 缓存过期，重新计算\n```\n\n### 4. 防抖与节流\n装饰事件处理方法（如输入框搜索、按钮点击、窗口resize），避免频繁触发，提升用户体验。\n\n```javascript\n// 防抖装饰器：延迟执行，多次触发仅最后一次生效\nfunction debounce(delay = 300, immediate = false) {\n  let timer = null;\n  \n  return function (target, name, descriptor) {\n    const original = descriptor.value;\n    descriptor.value = function (...args) {\n      clearTimeout(timer);\n      \n      // 立即执行模式：首次触发时立即执行\n      if (immediate && !timer) {\n        original.apply(this, args);\n      }\n      \n      timer = setTimeout(() => {\n        original.apply(this, args);\n        timer = null;\n      }, delay);\n    };\n    return descriptor;\n  };\n}\n\n// 节流装饰器：固定时间内仅执行一次\nfunction throttle(interval = 500) {\n  let lastTime = 0;\n  \n  return function (target, name, descriptor) {\n    const original = descriptor.value;\n    descriptor.value = function (...args) {\n      const now = Date.now();\n      if (now - lastTime >= interval) {\n        lastTime = now;\n        original.apply(this, args);\n      }\n    };\n    return descriptor;\n  };\n}\n\nclass SearchComponent {\n  @debounce(500) // 输入停止 500ms 后执行搜索\n  handleSearch(keyword) {\n    console.log(\"搜索关键词：\", keyword);\n  }\n  \n  @throttle(1000) // 1 秒内仅执行一次\n  handleScroll() {\n    console.log(\"窗口滚动\");\n  }\n}\n```\n\n### 5. 错误捕获与统一处理\n捕获方法执行中的错误，避免程序崩溃，并统一进行错误上报、用户提示等处理，减少重复的 try/catch 代码。\n\n```javascript\n// 错误处理装饰器：支持自定义错误回调\nfunction errorHandler(cb = (err) => {\n  console.error(\"发生错误：\", err);\n  alert(\"操作失败，请重试\");\n}) {\n  return function (target, name, descriptor) {\n    const original = descriptor.value;\n    descriptor.value = async function (...args) {\n      try {\n        return await original.apply(this, args);\n      } catch (err) {\n        // 统一处理错误：回调函数支持自定义逻辑\n        cb(err, { method: name, args });\n      }\n    };\n    return descriptor;\n  };\n}\n\nclass APIService {\n  @errorHandler(async (err, info) => {\n    // 自定义错误处理：上报日志到后端\n    await fetch(\"/api/error-report\", {\n      method: \"POST\",\n      body: JSON.stringify({\n        message: err.message,\n        stack: err.stack,\n        method: info.method,\n        args: info.args,\n        time: new Date().toLocaleString()\n      })\n    });\n    alert(\"网络异常，请稍后再试\");\n  })\n  async getUserInfo(userId) {\n    const response = await fetch(`/api/users/${userId}`);\n    if (!response.ok) throw new Error(`HTTP 错误：${response.status}`);\n    return response.json();\n  }\n}\n```\n\n### 6. 框架集成（React/Vue）\n在类组件中复用框架能力，简化代码。例如 React 中连接 Redux、路由守卫，Vue 中装饰组件选项等。\n\n#### React 中连接 Redux（react-redux）\n```javascript\nimport React from \"react\";\nimport { connect } from \"react-redux\";\nimport { increment, decrement } from \"./store/actions\";\n\n// 用装饰器简化 connect 逻辑\n@connect(\n  // mapStateToProps：将 Redux 状态映射到组件 props\n  state => ({ count: state.counter.count }),\n  // mapDispatchToProps：将 action 映射到组件 props\n  { increment, decrement }\n)\nclass Counter extends React.Component {\n  render() {\n    const { count, increment, decrement } = this.props;\n    return (\n      <div>\n        <p>计数：{count}</p>\n        <button onClick={increment}>+1</button>\n        <button onClick={decrement}>-1</button>\n      </div>\n    );\n  }\n}\n\nexport default Counter;\n```\n\n#### Vue 中装饰组件（vue-class-component）\n```javascript\nimport Vue from \"vue\";\nimport Component from \"vue-class-component\";\nimport { Prop } from \"vue-property-decorator\";\n\n// 用装饰器定义 Vue 组件\n@Component({\n  template: `\n    <div>\n      <p>{{ message }}</p>\n      <button @click=\"sayHello\">点击</button>\n    </div>\n  `\n})\nexport default class HelloWorld extends Vue {\n  // 用 Prop 装饰器定义属性\n  @Prop({ type: String, default: \"Hello Vue\" })\n  message!: string;\n  \n  sayHello() {\n    console.log(this.message);\n  }\n}\n```\n\n## 使用 Decorator 的注意事项与避坑指南\n\n- **提案兼容性问题**\n2025 年 Decorator 仍处于 TC39 Stage 3 阶段，不同工具链的配置需适配最新语。\n\n\n- **装饰器的执行顺序**\n多个装饰器叠加时，执行顺序为 `“从右到左、从上到下`（外层装饰器包裹内层装饰器）\n```javascript\n@decoratorA\n@decoratorB\n@decoratorC\nclass MyClass {}\n\n// 等价于：decoratorA(decoratorB(decoratorC(MyClass)))\n```\n\n- **this 上下文绑定**\n方法装饰器中，原方法的 `this` 默认指向 `undefined`（严格模式下），需通过 `original.apply(this,args)` 或者`original.call(this, ...args)` 绑定当前实例的 `this`，否则会导致 `this` 丢失。\n\n-  **不可装饰普通函数**\n当前 Stage 3 提案仅支持装饰“类”和“类成员”，不支持直接装饰普通函数。若需扩展普通函数，可使用高阶函数替代：\n```javascript\n// 普通函数的“装饰”（高阶函数形式）\nfunction logFunc(fn) {\n  return function (...args) {\n    console.log(\"调用参数：\", args);\n    return fn.apply(this, args);\n  };\n}\n\n// 应用高阶函数\nfunction add(a, b) {\n  return a + b;\n}\n\nconst addWithLog = logFunc(add);\naddWithLog(1, 2); // 输出：调用参数：[1,2]，返回 3\n```\n\n## 写在最后\nDecorator 并非 ES6 正式标准，但它已成为前端开发中“非侵入式扩展”的经典方案，其核心价值在于分离通用逻辑与业务逻辑，实现代码复用，同时使得代码更加优雅。\n\n如果你在开发中面临“通用逻辑重复编写”“业务代码被辅助逻辑侵入”等问题，不妨尝试使用 Decorator——它会让你的代码更简洁、更优雅、更具扩展性。\n\n**【往期精彩】**\n- [说说JavaScript中ES6 module(模块化)的诞生背景、核心语法及应用场景](https://mp.weixin.qq.com/s/pe4fywIh7WdigHuwRiqDlQ)\n- [一文说透ES6 Proxy: 从本质到应用场景](https://mp.weixin.qq.com/s/lYqBgS0GJgQMX5PAW_snnQ)\n- [JavaScript ES6中的生成器(Generator)是什么？有哪些应用场景？一文全说透](https://mp.weixin.qq.com/s/PtFtlNUH-UcLYU5h-xKiQw)\n- [聊聊ES6里的Promise：简单理解和实际用法](https://mp.weixin.qq.com/s/9pnvL5fTO5U9yT-1mPfeQw)\n- [一文搞懂 JavaScript 里 var、let、const 的区别\n](https://mp.weixin.qq.com/s/lqn_51NNxx50YgvWkxCtEg)\n- [为什么 ES6 要新增 Set 和 Map？看完这篇就懂了](https://mp.weixin.qq.com/s/UuJeSErftQY7ee1a54Pv4A)\n","source":"_posts/decorator-in-es6.md","raw":"---\ntitle: JavaScript ES6中的装饰器(Decorator)是什么？有哪些应用场景？万字长文，谨慎阅读！\ndate: 2025-12-06 12:35:25\ntags: JavaScript进阶, ES6进阶\ncategory: ES6进阶\n---\n<!--# ES6 Module：重塑JavaScript模块化生态的基石 -->\n这是[JavaScript进阶系列文章](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU2MjU3MzI0MA==&action=getalbum&album_id=4120256678140837890#wechat_redirect)的第11篇文章, 今天我们来讲讲`装饰器(Decorator)`，内容有点长，代码有些多，坐稳发车了。\n\n在前端开发中，我们常面临这样的困境：如何在不修改原有代码的前提下，为类、方法或属性添加日志、权限校验、缓存等通用功能？\n\n如果直接在业务逻辑中嵌入这些辅助代码，会导致核心逻辑与通用逻辑耦合，代码可读性和可维护性大幅下降。而 ES6 提案中`Decorator(装饰器)`，正是为解决这一问题而生的优雅方案。\n\n本文将从 Decorator 的**核心本质**出发，详解其**语法特性**、**使用场景**，并结合实战案例说明其在项目中的价值，帮助开发者真正掌握这一“非侵入式扩展”的利器。\n\n## Decorator 是什么？ \n### 核心定义\nDecorator 是基于 **“包装模式”（Wrapper Pattern）** 的语法糖，其核心目标是：**在不侵入原有代码结构的前提下，为类、类成员（方法/属性）动态扩展功能**。\n\n它的本质是一个`特殊函数`：接收被装饰的“目标对象”作为参数，通过修改或包装目标对象，返回增强后的新对象。简单来说，Decorator 就像给礼物包装——礼物本身（核心业务逻辑）不变，但包装（通用辅助逻辑）能让它具备额外的“属性”（如美观、防护）。\n\n### 核心价值\nDecorator 最核心的价值是 **“分离关注点”**：将日志、权限、缓存等通用逻辑与核心业务逻辑解耦，实现通用逻辑的复用，让代码更简洁、可维护。\n\n举个直观的对比：\n- 无 Decorator：在每个需要日志的方法中重复写 `console.log`，业务代码与日志逻辑混杂；\n- 有 Decorator：写一个通用日志装饰器，通过 `@log` 语法一键应用到任意方法，业务代码保持纯净。\n\n## Decorator 的核心用法\nDecorator 的语法简洁，核心分为“类装饰器”和“类成员装饰器”两类，各自承担不同的扩展职责。\n\n### 1. 类装饰器：增强整个类\n类装饰器直接作用于类本身，用于为类添加静态属性、静态方法，或修改类的原型（prototype）。\n\n#### 语法与参数\n- 仅接收 1 个参数 `target`：被装饰的类本身；\n- 可选返回值：若返回新类，则新类会替代原类；若不返回，则默认使用修改后的原类。\n\n#### 实战示例：给类添加通用能力\n```javascript\n// 类装饰器：为类添加静态配置和实例初始化方法\nfunction withConfig(defaultConfig) {\n  // 支持传入参数的装饰器（高阶函数形式）\n  return function (target) {\n    // 添加静态属性：默认配置\n    target.defaultConfig = defaultConfig;\n    \n    // 添加静态方法：合并配置\n    target.mergeConfig = function (userConfig) {\n      return { ...defaultConfig, ...userConfig };\n    };\n    \n    // 增强实例构造逻辑\n    const originalConstructor = target;\n    // 重写类构造函数\n    const newConstructor = function (...args) {\n      originalConstructor.apply(this, args);\n      // 实例初始化：合并配置到实例\n      this.config = target.mergeConfig(args[0] || {});\n    };\n    \n    // 继承原类的原型（保证实例方法不丢失）\n    newConstructor.prototype = Object.create(originalConstructor.prototype);\n    newConstructor.prototype.constructor = newConstructor;\n    \n    return newConstructor;\n  };\n}\n\n// 应用装饰器：传入默认配置\n@withConfig({ theme: \"light\", size: \"medium\" })\nclass Button {\n  constructor(userConfig) {\n    // 原构造函数逻辑\n    this.name = \"按钮\";\n  }\n  \n  getStyle() {\n    return `主题：${this.config.theme}，尺寸：${this.config.size}`;\n  }\n}\n\n// 测试效果\nconsole.log(Button.defaultConfig); // { theme: \"light\", size: \"medium\" }\nconst darkButton = new Button({ theme: \"dark\" });\nconsole.log(darkButton.config); // { theme: \"dark\", size: \"medium\" }\nconsole.log(darkButton.getStyle()); // 主题：dark，尺寸：medium\n```\n\n### 2. 类成员装饰器：增强方法/属性\n类成员装饰器作用于类的方法、属性或访问器（getter/setter），是开发中最常用的场景。\n\n#### 语法与参数\n接收 3 个核心参数：\n- `target`：类的原型（针对实例方法）或类本身（针对静态方法）；\n- `name`：被装饰的成员名称（方法名/属性名）；\n- `descriptor`：成员的属性描述符（`Object.getOwnPropertyDescriptor(target, name)` 的返回值），包含 `value`（方法本身）、`writable`（是否可修改）、`enumerable`（是否可枚举）等属性。\n\n#### 实战示例：包装方法实现日志记录\n```javascript\n// 方法装饰器：记录方法调用参数、返回值和执行时间\nfunction logPerformance(target, name, descriptor) {\n  // 保存原方法（避免覆盖后丢失）\n  const originalMethod = descriptor.value;\n  \n  // 重写方法逻辑\n  descriptor.value = async function (...args) {\n    const start = Date.now();\n    console.log(`[${name}] 开始执行，参数：`, args);\n    \n    try {\n      // 执行原方法（绑定 this 上下文，确保实例方法的 this 正确）\n      const result = await originalMethod.apply(this, args);\n      console.log(`[${name}] 执行成功，返回值：`, result);\n      return result;\n    } catch (error) {\n      console.error(`[${name}] 执行失败，错误：`, error);\n      throw error; // 抛出错误，不影响上层处理\n    } finally {\n      const duration = Date.now() - start;\n      console.log(`[${name}] 执行耗时：${duration}ms`);\n    }\n  };\n  \n  // 返回修改后的描述符（替代原成员）\n  return descriptor;\n}\n\nclass DataService {\n  // 应用方法装饰器\n  @logPerformance\n  async fetchData(url) {\n    // 模拟接口请求\n    const response = await fetch(url);\n    return response.json();\n  }\n}\n\n// 测试\nconst service = new DataService();\nservice.fetchData(\"https://api.example.com/data\");\n// 输出：\n// [fetchData] 开始执行，参数： [\"https://api.example.com/data\"]\n// [fetchData] 执行成功，返回值： { ...接口返回数据... }\n// [fetchData] 执行耗时：320ms\n```\n\n## 三、Decorator 的典型使用场景：让通用逻辑复用更优雅\nDecorator 的核心优势在于通用逻辑的复用，以下是前端开发中最实用的 6 个场景，覆盖日志、权限、缓存等高频需求。\n\n### 1. 日志与性能监控\n为核心业务方法（如接口请求、数据处理）添加日志，自动记录调用参数、返回值、执行时间，无需侵入业务代码。适合用于线上问题排查和性能优化。\n\n```javascript\n// 通用日志装饰器：支持开关和自定义格式\nfunction log(options = { enable: true, format: \"default\" }) {\n  return function (target, name, descriptor) {\n    if (!options.enable) return descriptor; // 关闭日志时直接返回原描述符\n    \n    const original = descriptor.value;\n    descriptor.value = function (...args) {\n      const time = new Date().toLocaleString();\n      // 自定义日志格式\n      if (options.format === \"detail\") {\n        console.log(`[${time}] [${target.constructor.name}.${name}] 调用参数：`, args);\n      } else {\n        console.log(`[${time}] [${name}] 调用参数：`, args);\n      }\n      return original.apply(this, args);\n    };\n    return descriptor;\n  };\n}\n\nclass OrderService {\n  @log({ enable: true, format: \"detail\" })\n  createOrder(params) {\n    console.log(\"创建订单：\", params);\n    return { orderId: \"123456\" };\n  }\n}\n```\n\n### 2. 权限校验与访问控制\n限制敏感方法的调用权限（如管理员操作、用户登录态校验），将权限逻辑与业务逻辑分离，避免在每个方法中重复写校验代码。\n\n```javascript\n// 权限装饰器：支持多角色校验\nfunction requireRoles(...allowedRoles) {\n  return function (target, name, descriptor) {\n    const original = descriptor.value;\n    descriptor.value = function (...args) {\n      // 假设从全局状态或实例中获取当前用户角色\n      const userRole = this.getCurrentUserRole();\n      \n      if (!allowedRoles.includes(userRole)) {\n        throw new Error(`权限不足！当前角色：${userRole}，允许角色：${allowedRoles.join(\",\")}`);\n      }\n      \n      return original.apply(this, args);\n    };\n    return descriptor;\n  };\n}\n\nclass SystemManager {\n  getCurrentUserRole() {\n    return \"admin\"; // 实际场景中从登录态获取\n  }\n  \n  @requireRoles(\"admin\", \"super_admin\") // 仅管理员和超级管理员可调用\n  deleteUser(userId) {\n    console.log(`删除用户：${userId}`);\n  }\n  \n  @requireRoles(\"user\", \"admin\") // 普通用户和管理员均可调用\n  queryUser(userId) {\n    console.log(`查询用户：${userId}`);\n  }\n}\n```\n\n### 3. 缓存优化（记忆化）\n对计算密集型方法（如递归、大数据处理）或高频调用的接口添加缓存，避免重复计算或请求，提升性能。\n\n```javascript\n// 缓存装饰器：支持过期时间\nfunction cache(options = { ttl: Infinity }) {\n  const cacheMap = new Map(); // 缓存容器\n  \n  return function (target, name, descriptor) {\n    const original = descriptor.value;\n    descriptor.value = function (...args) {\n      // 用参数生成唯一缓存键（复杂参数可使用 hash 函数优化）\n      const cacheKey = `${name}_${JSON.stringify(args)}`;\n      \n      // 检查缓存是否存在且未过期\n      if (cacheMap.has(cacheKey)) {\n        const { data, timestamp } = cacheMap.get(cacheKey);\n        if (Date.now() - timestamp < options.ttl) {\n          console.log(`[${name}] 命中缓存`);\n          return data;\n        }\n        console.log(`[${name}] 缓存过期，重新计算`);\n        cacheMap.delete(cacheKey);\n      }\n      \n      // 执行原方法并缓存结果\n      const result = original.apply(this, args);\n      cacheMap.set(cacheKey, {\n        data: result,\n        timestamp: Date.now()\n      });\n      \n      return result;\n    };\n    return descriptor;\n  };\n}\n\n// 斐波那契数列计算（计算密集型）\nclass FibCalculator {\n  @cache({ ttl: 5000 }) // 缓存 5 秒\n  fib(n) {\n    console.log(`[fib] 计算 fib(${n})`);\n    if (n <= 1) return n;\n    return this.fib(n - 1) + this.fib(n - 2);\n  }\n}\n\nconst calculator = new FibCalculator();\ncalculator.fib(10); // 首次计算，打印多次 \"计算 fib(n)\"\ncalculator.fib(10); // 命中缓存，直接返回结果\nsetTimeout(() => calculator.fib(10), 6000); // 缓存过期，重新计算\n```\n\n### 4. 防抖与节流\n装饰事件处理方法（如输入框搜索、按钮点击、窗口resize），避免频繁触发，提升用户体验。\n\n```javascript\n// 防抖装饰器：延迟执行，多次触发仅最后一次生效\nfunction debounce(delay = 300, immediate = false) {\n  let timer = null;\n  \n  return function (target, name, descriptor) {\n    const original = descriptor.value;\n    descriptor.value = function (...args) {\n      clearTimeout(timer);\n      \n      // 立即执行模式：首次触发时立即执行\n      if (immediate && !timer) {\n        original.apply(this, args);\n      }\n      \n      timer = setTimeout(() => {\n        original.apply(this, args);\n        timer = null;\n      }, delay);\n    };\n    return descriptor;\n  };\n}\n\n// 节流装饰器：固定时间内仅执行一次\nfunction throttle(interval = 500) {\n  let lastTime = 0;\n  \n  return function (target, name, descriptor) {\n    const original = descriptor.value;\n    descriptor.value = function (...args) {\n      const now = Date.now();\n      if (now - lastTime >= interval) {\n        lastTime = now;\n        original.apply(this, args);\n      }\n    };\n    return descriptor;\n  };\n}\n\nclass SearchComponent {\n  @debounce(500) // 输入停止 500ms 后执行搜索\n  handleSearch(keyword) {\n    console.log(\"搜索关键词：\", keyword);\n  }\n  \n  @throttle(1000) // 1 秒内仅执行一次\n  handleScroll() {\n    console.log(\"窗口滚动\");\n  }\n}\n```\n\n### 5. 错误捕获与统一处理\n捕获方法执行中的错误，避免程序崩溃，并统一进行错误上报、用户提示等处理，减少重复的 try/catch 代码。\n\n```javascript\n// 错误处理装饰器：支持自定义错误回调\nfunction errorHandler(cb = (err) => {\n  console.error(\"发生错误：\", err);\n  alert(\"操作失败，请重试\");\n}) {\n  return function (target, name, descriptor) {\n    const original = descriptor.value;\n    descriptor.value = async function (...args) {\n      try {\n        return await original.apply(this, args);\n      } catch (err) {\n        // 统一处理错误：回调函数支持自定义逻辑\n        cb(err, { method: name, args });\n      }\n    };\n    return descriptor;\n  };\n}\n\nclass APIService {\n  @errorHandler(async (err, info) => {\n    // 自定义错误处理：上报日志到后端\n    await fetch(\"/api/error-report\", {\n      method: \"POST\",\n      body: JSON.stringify({\n        message: err.message,\n        stack: err.stack,\n        method: info.method,\n        args: info.args,\n        time: new Date().toLocaleString()\n      })\n    });\n    alert(\"网络异常，请稍后再试\");\n  })\n  async getUserInfo(userId) {\n    const response = await fetch(`/api/users/${userId}`);\n    if (!response.ok) throw new Error(`HTTP 错误：${response.status}`);\n    return response.json();\n  }\n}\n```\n\n### 6. 框架集成（React/Vue）\n在类组件中复用框架能力，简化代码。例如 React 中连接 Redux、路由守卫，Vue 中装饰组件选项等。\n\n#### React 中连接 Redux（react-redux）\n```javascript\nimport React from \"react\";\nimport { connect } from \"react-redux\";\nimport { increment, decrement } from \"./store/actions\";\n\n// 用装饰器简化 connect 逻辑\n@connect(\n  // mapStateToProps：将 Redux 状态映射到组件 props\n  state => ({ count: state.counter.count }),\n  // mapDispatchToProps：将 action 映射到组件 props\n  { increment, decrement }\n)\nclass Counter extends React.Component {\n  render() {\n    const { count, increment, decrement } = this.props;\n    return (\n      <div>\n        <p>计数：{count}</p>\n        <button onClick={increment}>+1</button>\n        <button onClick={decrement}>-1</button>\n      </div>\n    );\n  }\n}\n\nexport default Counter;\n```\n\n#### Vue 中装饰组件（vue-class-component）\n```javascript\nimport Vue from \"vue\";\nimport Component from \"vue-class-component\";\nimport { Prop } from \"vue-property-decorator\";\n\n// 用装饰器定义 Vue 组件\n@Component({\n  template: `\n    <div>\n      <p>{{ message }}</p>\n      <button @click=\"sayHello\">点击</button>\n    </div>\n  `\n})\nexport default class HelloWorld extends Vue {\n  // 用 Prop 装饰器定义属性\n  @Prop({ type: String, default: \"Hello Vue\" })\n  message!: string;\n  \n  sayHello() {\n    console.log(this.message);\n  }\n}\n```\n\n## 使用 Decorator 的注意事项与避坑指南\n\n- **提案兼容性问题**\n2025 年 Decorator 仍处于 TC39 Stage 3 阶段，不同工具链的配置需适配最新语。\n\n\n- **装饰器的执行顺序**\n多个装饰器叠加时，执行顺序为 `“从右到左、从上到下`（外层装饰器包裹内层装饰器）\n```javascript\n@decoratorA\n@decoratorB\n@decoratorC\nclass MyClass {}\n\n// 等价于：decoratorA(decoratorB(decoratorC(MyClass)))\n```\n\n- **this 上下文绑定**\n方法装饰器中，原方法的 `this` 默认指向 `undefined`（严格模式下），需通过 `original.apply(this,args)` 或者`original.call(this, ...args)` 绑定当前实例的 `this`，否则会导致 `this` 丢失。\n\n-  **不可装饰普通函数**\n当前 Stage 3 提案仅支持装饰“类”和“类成员”，不支持直接装饰普通函数。若需扩展普通函数，可使用高阶函数替代：\n```javascript\n// 普通函数的“装饰”（高阶函数形式）\nfunction logFunc(fn) {\n  return function (...args) {\n    console.log(\"调用参数：\", args);\n    return fn.apply(this, args);\n  };\n}\n\n// 应用高阶函数\nfunction add(a, b) {\n  return a + b;\n}\n\nconst addWithLog = logFunc(add);\naddWithLog(1, 2); // 输出：调用参数：[1,2]，返回 3\n```\n\n## 写在最后\nDecorator 并非 ES6 正式标准，但它已成为前端开发中“非侵入式扩展”的经典方案，其核心价值在于分离通用逻辑与业务逻辑，实现代码复用，同时使得代码更加优雅。\n\n如果你在开发中面临“通用逻辑重复编写”“业务代码被辅助逻辑侵入”等问题，不妨尝试使用 Decorator——它会让你的代码更简洁、更优雅、更具扩展性。\n\n**【往期精彩】**\n- [说说JavaScript中ES6 module(模块化)的诞生背景、核心语法及应用场景](https://mp.weixin.qq.com/s/pe4fywIh7WdigHuwRiqDlQ)\n- [一文说透ES6 Proxy: 从本质到应用场景](https://mp.weixin.qq.com/s/lYqBgS0GJgQMX5PAW_snnQ)\n- [JavaScript ES6中的生成器(Generator)是什么？有哪些应用场景？一文全说透](https://mp.weixin.qq.com/s/PtFtlNUH-UcLYU5h-xKiQw)\n- [聊聊ES6里的Promise：简单理解和实际用法](https://mp.weixin.qq.com/s/9pnvL5fTO5U9yT-1mPfeQw)\n- [一文搞懂 JavaScript 里 var、let、const 的区别\n](https://mp.weixin.qq.com/s/lqn_51NNxx50YgvWkxCtEg)\n- [为什么 ES6 要新增 Set 和 Map？看完这篇就懂了](https://mp.weixin.qq.com/s/UuJeSErftQY7ee1a54Pv4A)\n","slug":"decorator-in-es6","published":1,"updated":"2025-12-06T04:47:41.769Z","comments":1,"layout":"post","photos":[],"_id":"cmjbml2ia0018ikupad3vdtx1","content":"<!--# ES6 Module：重塑JavaScript模块化生态的基石 -->\n<p>这是<a href=\"https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU2MjU3MzI0MA==&action=getalbum&album_id=4120256678140837890#wechat_redirect\">JavaScript进阶系列文章</a>的第11篇文章, 今天我们来讲讲<code>装饰器(Decorator)</code>，内容有点长，代码有些多，坐稳发车了。</p>\n<p>在前端开发中，我们常面临这样的困境：如何在不修改原有代码的前提下，为类、方法或属性添加日志、权限校验、缓存等通用功能？</p>\n<p>如果直接在业务逻辑中嵌入这些辅助代码，会导致核心逻辑与通用逻辑耦合，代码可读性和可维护性大幅下降。而 ES6 提案中<code>Decorator(装饰器)</code>，正是为解决这一问题而生的优雅方案。</p>\n<p>本文将从 Decorator 的<strong>核心本质</strong>出发，详解其<strong>语法特性</strong>、<strong>使用场景</strong>，并结合实战案例说明其在项目中的价值，帮助开发者真正掌握这一“非侵入式扩展”的利器。</p>\n<h2 id=\"Decorator-是什么？\"><a href=\"#Decorator-是什么？\" class=\"headerlink\" title=\"Decorator 是什么？\"></a>Decorator 是什么？</h2><h3 id=\"核心定义\"><a href=\"#核心定义\" class=\"headerlink\" title=\"核心定义\"></a>核心定义</h3><p>Decorator 是基于 <strong>“包装模式”（Wrapper Pattern）</strong> 的语法糖，其核心目标是：<strong>在不侵入原有代码结构的前提下，为类、类成员（方法&#x2F;属性）动态扩展功能</strong>。</p>\n<p>它的本质是一个<code>特殊函数</code>：接收被装饰的“目标对象”作为参数，通过修改或包装目标对象，返回增强后的新对象。简单来说，Decorator 就像给礼物包装——礼物本身（核心业务逻辑）不变，但包装（通用辅助逻辑）能让它具备额外的“属性”（如美观、防护）。</p>\n<h3 id=\"核心价值\"><a href=\"#核心价值\" class=\"headerlink\" title=\"核心价值\"></a>核心价值</h3><p>Decorator 最核心的价值是 <strong>“分离关注点”</strong>：将日志、权限、缓存等通用逻辑与核心业务逻辑解耦，实现通用逻辑的复用，让代码更简洁、可维护。</p>\n<p>举个直观的对比：</p>\n<ul>\n<li>无 Decorator：在每个需要日志的方法中重复写 <code>console.log</code>，业务代码与日志逻辑混杂；</li>\n<li>有 Decorator：写一个通用日志装饰器，通过 <code>@log</code> 语法一键应用到任意方法，业务代码保持纯净。</li>\n</ul>\n<h2 id=\"Decorator-的核心用法\"><a href=\"#Decorator-的核心用法\" class=\"headerlink\" title=\"Decorator 的核心用法\"></a>Decorator 的核心用法</h2><p>Decorator 的语法简洁，核心分为“类装饰器”和“类成员装饰器”两类，各自承担不同的扩展职责。</p>\n<h3 id=\"1-类装饰器：增强整个类\"><a href=\"#1-类装饰器：增强整个类\" class=\"headerlink\" title=\"1. 类装饰器：增强整个类\"></a>1. 类装饰器：增强整个类</h3><p>类装饰器直接作用于类本身，用于为类添加静态属性、静态方法，或修改类的原型（prototype）。</p>\n<h4 id=\"语法与参数\"><a href=\"#语法与参数\" class=\"headerlink\" title=\"语法与参数\"></a>语法与参数</h4><ul>\n<li>仅接收 1 个参数 <code>target</code>：被装饰的类本身；</li>\n<li>可选返回值：若返回新类，则新类会替代原类；若不返回，则默认使用修改后的原类。</li>\n</ul>\n<h4 id=\"实战示例：给类添加通用能力\"><a href=\"#实战示例：给类添加通用能力\" class=\"headerlink\" title=\"实战示例：给类添加通用能力\"></a>实战示例：给类添加通用能力</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 类装饰器：为类添加静态配置和实例初始化方法</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">withConfig</span>(<span class=\"hljs-params\">defaultConfig</span>) &#123;<br>  <span class=\"hljs-comment\">// 支持传入参数的装饰器（高阶函数形式）</span><br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">target</span>) &#123;<br>    <span class=\"hljs-comment\">// 添加静态属性：默认配置</span><br>    target.<span class=\"hljs-property\">defaultConfig</span> = defaultConfig;<br>    <br>    <span class=\"hljs-comment\">// 添加静态方法：合并配置</span><br>    target.<span class=\"hljs-property\">mergeConfig</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">userConfig</span>) &#123;<br>      <span class=\"hljs-keyword\">return</span> &#123; ...defaultConfig, ...userConfig &#125;;<br>    &#125;;<br>    <br>    <span class=\"hljs-comment\">// 增强实例构造逻辑</span><br>    <span class=\"hljs-keyword\">const</span> originalConstructor = target;<br>    <span class=\"hljs-comment\">// 重写类构造函数</span><br>    <span class=\"hljs-keyword\">const</span> newConstructor = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...args</span>) &#123;<br>      originalConstructor.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args);<br>      <span class=\"hljs-comment\">// 实例初始化：合并配置到实例</span><br>      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">config</span> = target.<span class=\"hljs-title function_\">mergeConfig</span>(args[<span class=\"hljs-number\">0</span>] || &#123;&#125;);<br>    &#125;;<br>    <br>    <span class=\"hljs-comment\">// 继承原类的原型（保证实例方法不丢失）</span><br>    newConstructor.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(originalConstructor.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);<br>    newConstructor.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">constructor</span> = newConstructor;<br>    <br>    <span class=\"hljs-keyword\">return</span> newConstructor;<br>  &#125;;<br>&#125;<br><br><span class=\"hljs-comment\">// 应用装饰器：传入默认配置</span><br>@<span class=\"hljs-title function_\">withConfig</span>(&#123; <span class=\"hljs-attr\">theme</span>: <span class=\"hljs-string\">&quot;light&quot;</span>, <span class=\"hljs-attr\">size</span>: <span class=\"hljs-string\">&quot;medium&quot;</span> &#125;)<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Button</span> &#123;<br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">userConfig</span>) &#123;<br>    <span class=\"hljs-comment\">// 原构造函数逻辑</span><br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = <span class=\"hljs-string\">&quot;按钮&quot;</span>;<br>  &#125;<br>  <br>  <span class=\"hljs-title function_\">getStyle</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`主题：<span class=\"hljs-subst\">$&#123;<span class=\"hljs-variable language_\">this</span>.config.theme&#125;</span>，尺寸：<span class=\"hljs-subst\">$&#123;<span class=\"hljs-variable language_\">this</span>.config.size&#125;</span>`</span>;<br>  &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 测试效果</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Button</span>.<span class=\"hljs-property\">defaultConfig</span>); <span class=\"hljs-comment\">// &#123; theme: &quot;light&quot;, size: &quot;medium&quot; &#125;</span><br><span class=\"hljs-keyword\">const</span> darkButton = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Button</span>(&#123; <span class=\"hljs-attr\">theme</span>: <span class=\"hljs-string\">&quot;dark&quot;</span> &#125;);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(darkButton.<span class=\"hljs-property\">config</span>); <span class=\"hljs-comment\">// &#123; theme: &quot;dark&quot;, size: &quot;medium&quot; &#125;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(darkButton.<span class=\"hljs-title function_\">getStyle</span>()); <span class=\"hljs-comment\">// 主题：dark，尺寸：medium</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-类成员装饰器：增强方法-属性\"><a href=\"#2-类成员装饰器：增强方法-属性\" class=\"headerlink\" title=\"2. 类成员装饰器：增强方法&#x2F;属性\"></a>2. 类成员装饰器：增强方法&#x2F;属性</h3><p>类成员装饰器作用于类的方法、属性或访问器（getter&#x2F;setter），是开发中最常用的场景。</p>\n<h4 id=\"语法与参数-1\"><a href=\"#语法与参数-1\" class=\"headerlink\" title=\"语法与参数\"></a>语法与参数</h4><p>接收 3 个核心参数：</p>\n<ul>\n<li><code>target</code>：类的原型（针对实例方法）或类本身（针对静态方法）；</li>\n<li><code>name</code>：被装饰的成员名称（方法名&#x2F;属性名）；</li>\n<li><code>descriptor</code>：成员的属性描述符（<code>Object.getOwnPropertyDescriptor(target, name)</code> 的返回值），包含 <code>value</code>（方法本身）、<code>writable</code>（是否可修改）、<code>enumerable</code>（是否可枚举）等属性。</li>\n</ul>\n<h4 id=\"实战示例：包装方法实现日志记录\"><a href=\"#实战示例：包装方法实现日志记录\" class=\"headerlink\" title=\"实战示例：包装方法实现日志记录\"></a>实战示例：包装方法实现日志记录</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 方法装饰器：记录方法调用参数、返回值和执行时间</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">logPerformance</span>(<span class=\"hljs-params\">target, name, descriptor</span>) &#123;<br>  <span class=\"hljs-comment\">// 保存原方法（避免覆盖后丢失）</span><br>  <span class=\"hljs-keyword\">const</span> originalMethod = descriptor.<span class=\"hljs-property\">value</span>;<br>  <br>  <span class=\"hljs-comment\">// 重写方法逻辑</span><br>  descriptor.<span class=\"hljs-property\">value</span> = <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...args</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> start = <span class=\"hljs-title class_\">Date</span>.<span class=\"hljs-title function_\">now</span>();<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`[<span class=\"hljs-subst\">$&#123;name&#125;</span>] 开始执行，参数：`</span>, args);<br>    <br>    <span class=\"hljs-keyword\">try</span> &#123;<br>      <span class=\"hljs-comment\">// 执行原方法（绑定 this 上下文，确保实例方法的 this 正确）</span><br>      <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">await</span> originalMethod.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args);<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`[<span class=\"hljs-subst\">$&#123;name&#125;</span>] 执行成功，返回值：`</span>, result);<br>      <span class=\"hljs-keyword\">return</span> result;<br>    &#125; <span class=\"hljs-keyword\">catch</span> (error) &#123;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`[<span class=\"hljs-subst\">$&#123;name&#125;</span>] 执行失败，错误：`</span>, error);<br>      <span class=\"hljs-keyword\">throw</span> error; <span class=\"hljs-comment\">// 抛出错误，不影响上层处理</span><br>    &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>      <span class=\"hljs-keyword\">const</span> duration = <span class=\"hljs-title class_\">Date</span>.<span class=\"hljs-title function_\">now</span>() - start;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`[<span class=\"hljs-subst\">$&#123;name&#125;</span>] 执行耗时：<span class=\"hljs-subst\">$&#123;duration&#125;</span>ms`</span>);<br>    &#125;<br>  &#125;;<br>  <br>  <span class=\"hljs-comment\">// 返回修改后的描述符（替代原成员）</span><br>  <span class=\"hljs-keyword\">return</span> descriptor;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DataService</span> &#123;<br>  <span class=\"hljs-comment\">// 应用方法装饰器</span><br>  @logPerformance<br>  <span class=\"hljs-keyword\">async</span> <span class=\"hljs-title function_\">fetchData</span>(<span class=\"hljs-params\">url</span>) &#123;<br>    <span class=\"hljs-comment\">// 模拟接口请求</span><br>    <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(url);<br>    <span class=\"hljs-keyword\">return</span> response.<span class=\"hljs-title function_\">json</span>();<br>  &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 测试</span><br><span class=\"hljs-keyword\">const</span> service = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DataService</span>();<br>service.<span class=\"hljs-title function_\">fetchData</span>(<span class=\"hljs-string\">&quot;https://api.example.com/data&quot;</span>);<br><span class=\"hljs-comment\">// 输出：</span><br><span class=\"hljs-comment\">// [fetchData] 开始执行，参数： [&quot;https://api.example.com/data&quot;]</span><br><span class=\"hljs-comment\">// [fetchData] 执行成功，返回值： &#123; ...接口返回数据... &#125;</span><br><span class=\"hljs-comment\">// [fetchData] 执行耗时：320ms</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"三、Decorator-的典型使用场景：让通用逻辑复用更优雅\"><a href=\"#三、Decorator-的典型使用场景：让通用逻辑复用更优雅\" class=\"headerlink\" title=\"三、Decorator 的典型使用场景：让通用逻辑复用更优雅\"></a>三、Decorator 的典型使用场景：让通用逻辑复用更优雅</h2><p>Decorator 的核心优势在于通用逻辑的复用，以下是前端开发中最实用的 6 个场景，覆盖日志、权限、缓存等高频需求。</p>\n<h3 id=\"1-日志与性能监控\"><a href=\"#1-日志与性能监控\" class=\"headerlink\" title=\"1. 日志与性能监控\"></a>1. 日志与性能监控</h3><p>为核心业务方法（如接口请求、数据处理）添加日志，自动记录调用参数、返回值、执行时间，无需侵入业务代码。适合用于线上问题排查和性能优化。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 通用日志装饰器：支持开关和自定义格式</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">log</span>(<span class=\"hljs-params\">options = &#123; enable: <span class=\"hljs-literal\">true</span>, format: <span class=\"hljs-string\">&quot;default&quot;</span> &#125;</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">target, name, descriptor</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (!options.<span class=\"hljs-property\">enable</span>) <span class=\"hljs-keyword\">return</span> descriptor; <span class=\"hljs-comment\">// 关闭日志时直接返回原描述符</span><br>    <br>    <span class=\"hljs-keyword\">const</span> original = descriptor.<span class=\"hljs-property\">value</span>;<br>    descriptor.<span class=\"hljs-property\">value</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...args</span>) &#123;<br>      <span class=\"hljs-keyword\">const</span> time = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>().<span class=\"hljs-title function_\">toLocaleString</span>();<br>      <span class=\"hljs-comment\">// 自定义日志格式</span><br>      <span class=\"hljs-keyword\">if</span> (options.<span class=\"hljs-property\">format</span> === <span class=\"hljs-string\">&quot;detail&quot;</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`[<span class=\"hljs-subst\">$&#123;time&#125;</span>] [<span class=\"hljs-subst\">$&#123;target.constructor.name&#125;</span>.<span class=\"hljs-subst\">$&#123;name&#125;</span>] 调用参数：`</span>, args);<br>      &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`[<span class=\"hljs-subst\">$&#123;time&#125;</span>] [<span class=\"hljs-subst\">$&#123;name&#125;</span>] 调用参数：`</span>, args);<br>      &#125;<br>      <span class=\"hljs-keyword\">return</span> original.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args);<br>    &#125;;<br>    <span class=\"hljs-keyword\">return</span> descriptor;<br>  &#125;;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OrderService</span> &#123;<br>  @<span class=\"hljs-title function_\">log</span>(&#123; <span class=\"hljs-attr\">enable</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">format</span>: <span class=\"hljs-string\">&quot;detail&quot;</span> &#125;)<br>  <span class=\"hljs-title function_\">createOrder</span>(<span class=\"hljs-params\">params</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;创建订单：&quot;</span>, params);<br>    <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">orderId</span>: <span class=\"hljs-string\">&quot;123456&quot;</span> &#125;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-权限校验与访问控制\"><a href=\"#2-权限校验与访问控制\" class=\"headerlink\" title=\"2. 权限校验与访问控制\"></a>2. 权限校验与访问控制</h3><p>限制敏感方法的调用权限（如管理员操作、用户登录态校验），将权限逻辑与业务逻辑分离，避免在每个方法中重复写校验代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 权限装饰器：支持多角色校验</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">requireRoles</span>(<span class=\"hljs-params\">...allowedRoles</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">target, name, descriptor</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> original = descriptor.<span class=\"hljs-property\">value</span>;<br>    descriptor.<span class=\"hljs-property\">value</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...args</span>) &#123;<br>      <span class=\"hljs-comment\">// 假设从全局状态或实例中获取当前用户角色</span><br>      <span class=\"hljs-keyword\">const</span> userRole = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">getCurrentUserRole</span>();<br>      <br>      <span class=\"hljs-keyword\">if</span> (!allowedRoles.<span class=\"hljs-title function_\">includes</span>(userRole)) &#123;<br>        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">`权限不足！当前角色：<span class=\"hljs-subst\">$&#123;userRole&#125;</span>，允许角色：<span class=\"hljs-subst\">$&#123;allowedRoles.join(<span class=\"hljs-string\">&quot;,&quot;</span>)&#125;</span>`</span>);<br>      &#125;<br>      <br>      <span class=\"hljs-keyword\">return</span> original.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args);<br>    &#125;;<br>    <span class=\"hljs-keyword\">return</span> descriptor;<br>  &#125;;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SystemManager</span> &#123;<br>  <span class=\"hljs-title function_\">getCurrentUserRole</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;admin&quot;</span>; <span class=\"hljs-comment\">// 实际场景中从登录态获取</span><br>  &#125;<br>  <br>  @<span class=\"hljs-title function_\">requireRoles</span>(<span class=\"hljs-string\">&quot;admin&quot;</span>, <span class=\"hljs-string\">&quot;super_admin&quot;</span>) <span class=\"hljs-comment\">// 仅管理员和超级管理员可调用</span><br>  <span class=\"hljs-title function_\">deleteUser</span>(<span class=\"hljs-params\">userId</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`删除用户：<span class=\"hljs-subst\">$&#123;userId&#125;</span>`</span>);<br>  &#125;<br>  <br>  @<span class=\"hljs-title function_\">requireRoles</span>(<span class=\"hljs-string\">&quot;user&quot;</span>, <span class=\"hljs-string\">&quot;admin&quot;</span>) <span class=\"hljs-comment\">// 普通用户和管理员均可调用</span><br>  <span class=\"hljs-title function_\">queryUser</span>(<span class=\"hljs-params\">userId</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`查询用户：<span class=\"hljs-subst\">$&#123;userId&#125;</span>`</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-缓存优化（记忆化）\"><a href=\"#3-缓存优化（记忆化）\" class=\"headerlink\" title=\"3. 缓存优化（记忆化）\"></a>3. 缓存优化（记忆化）</h3><p>对计算密集型方法（如递归、大数据处理）或高频调用的接口添加缓存，避免重复计算或请求，提升性能。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 缓存装饰器：支持过期时间</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">cache</span>(<span class=\"hljs-params\">options = &#123; ttl: <span class=\"hljs-literal\">Infinity</span> &#125;</span>) &#123;<br>  <span class=\"hljs-keyword\">const</span> cacheMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(); <span class=\"hljs-comment\">// 缓存容器</span><br>  <br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">target, name, descriptor</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> original = descriptor.<span class=\"hljs-property\">value</span>;<br>    descriptor.<span class=\"hljs-property\">value</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...args</span>) &#123;<br>      <span class=\"hljs-comment\">// 用参数生成唯一缓存键（复杂参数可使用 hash 函数优化）</span><br>      <span class=\"hljs-keyword\">const</span> cacheKey = <span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;name&#125;</span>_<span class=\"hljs-subst\">$&#123;<span class=\"hljs-built_in\">JSON</span>.stringify(args)&#125;</span>`</span>;<br>      <br>      <span class=\"hljs-comment\">// 检查缓存是否存在且未过期</span><br>      <span class=\"hljs-keyword\">if</span> (cacheMap.<span class=\"hljs-title function_\">has</span>(cacheKey)) &#123;<br>        <span class=\"hljs-keyword\">const</span> &#123; data, timestamp &#125; = cacheMap.<span class=\"hljs-title function_\">get</span>(cacheKey);<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title class_\">Date</span>.<span class=\"hljs-title function_\">now</span>() - timestamp &lt; options.<span class=\"hljs-property\">ttl</span>) &#123;<br>          <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`[<span class=\"hljs-subst\">$&#123;name&#125;</span>] 命中缓存`</span>);<br>          <span class=\"hljs-keyword\">return</span> data;<br>        &#125;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`[<span class=\"hljs-subst\">$&#123;name&#125;</span>] 缓存过期，重新计算`</span>);<br>        cacheMap.<span class=\"hljs-title function_\">delete</span>(cacheKey);<br>      &#125;<br>      <br>      <span class=\"hljs-comment\">// 执行原方法并缓存结果</span><br>      <span class=\"hljs-keyword\">const</span> result = original.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args);<br>      cacheMap.<span class=\"hljs-title function_\">set</span>(cacheKey, &#123;<br>        <span class=\"hljs-attr\">data</span>: result,<br>        <span class=\"hljs-attr\">timestamp</span>: <span class=\"hljs-title class_\">Date</span>.<span class=\"hljs-title function_\">now</span>()<br>      &#125;);<br>      <br>      <span class=\"hljs-keyword\">return</span> result;<br>    &#125;;<br>    <span class=\"hljs-keyword\">return</span> descriptor;<br>  &#125;;<br>&#125;<br><br><span class=\"hljs-comment\">// 斐波那契数列计算（计算密集型）</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FibCalculator</span> &#123;<br>  @<span class=\"hljs-title function_\">cache</span>(&#123; <span class=\"hljs-attr\">ttl</span>: <span class=\"hljs-number\">5000</span> &#125;) <span class=\"hljs-comment\">// 缓存 5 秒</span><br>  <span class=\"hljs-title function_\">fib</span>(<span class=\"hljs-params\">n</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`[fib] 计算 fib(<span class=\"hljs-subst\">$&#123;n&#125;</span>)`</span>);<br>    <span class=\"hljs-keyword\">if</span> (n &lt;= <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span> n;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">fib</span>(n - <span class=\"hljs-number\">1</span>) + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">fib</span>(n - <span class=\"hljs-number\">2</span>);<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> calculator = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FibCalculator</span>();<br>calculator.<span class=\"hljs-title function_\">fib</span>(<span class=\"hljs-number\">10</span>); <span class=\"hljs-comment\">// 首次计算，打印多次 &quot;计算 fib(n)&quot;</span><br>calculator.<span class=\"hljs-title function_\">fib</span>(<span class=\"hljs-number\">10</span>); <span class=\"hljs-comment\">// 命中缓存，直接返回结果</span><br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> calculator.<span class=\"hljs-title function_\">fib</span>(<span class=\"hljs-number\">10</span>), <span class=\"hljs-number\">6000</span>); <span class=\"hljs-comment\">// 缓存过期，重新计算</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"4-防抖与节流\"><a href=\"#4-防抖与节流\" class=\"headerlink\" title=\"4. 防抖与节流\"></a>4. 防抖与节流</h3><p>装饰事件处理方法（如输入框搜索、按钮点击、窗口resize），避免频繁触发，提升用户体验。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 防抖装饰器：延迟执行，多次触发仅最后一次生效</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">debounce</span>(<span class=\"hljs-params\">delay = <span class=\"hljs-number\">300</span>, immediate = <span class=\"hljs-literal\">false</span></span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> timer = <span class=\"hljs-literal\">null</span>;<br>  <br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">target, name, descriptor</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> original = descriptor.<span class=\"hljs-property\">value</span>;<br>    descriptor.<span class=\"hljs-property\">value</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...args</span>) &#123;<br>      <span class=\"hljs-built_in\">clearTimeout</span>(timer);<br>      <br>      <span class=\"hljs-comment\">// 立即执行模式：首次触发时立即执行</span><br>      <span class=\"hljs-keyword\">if</span> (immediate &amp;&amp; !timer) &#123;<br>        original.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args);<br>      &#125;<br>      <br>      timer = <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>        original.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args);<br>        timer = <span class=\"hljs-literal\">null</span>;<br>      &#125;, delay);<br>    &#125;;<br>    <span class=\"hljs-keyword\">return</span> descriptor;<br>  &#125;;<br>&#125;<br><br><span class=\"hljs-comment\">// 节流装饰器：固定时间内仅执行一次</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">throttle</span>(<span class=\"hljs-params\">interval = <span class=\"hljs-number\">500</span></span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> lastTime = <span class=\"hljs-number\">0</span>;<br>  <br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">target, name, descriptor</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> original = descriptor.<span class=\"hljs-property\">value</span>;<br>    descriptor.<span class=\"hljs-property\">value</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...args</span>) &#123;<br>      <span class=\"hljs-keyword\">const</span> now = <span class=\"hljs-title class_\">Date</span>.<span class=\"hljs-title function_\">now</span>();<br>      <span class=\"hljs-keyword\">if</span> (now - lastTime &gt;= interval) &#123;<br>        lastTime = now;<br>        original.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args);<br>      &#125;<br>    &#125;;<br>    <span class=\"hljs-keyword\">return</span> descriptor;<br>  &#125;;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SearchComponent</span> &#123;<br>  @<span class=\"hljs-title function_\">debounce</span>(<span class=\"hljs-number\">500</span>) <span class=\"hljs-comment\">// 输入停止 500ms 后执行搜索</span><br>  <span class=\"hljs-title function_\">handleSearch</span>(<span class=\"hljs-params\">keyword</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;搜索关键词：&quot;</span>, keyword);<br>  &#125;<br>  <br>  @<span class=\"hljs-title function_\">throttle</span>(<span class=\"hljs-number\">1000</span>) <span class=\"hljs-comment\">// 1 秒内仅执行一次</span><br>  <span class=\"hljs-title function_\">handleScroll</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;窗口滚动&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"5-错误捕获与统一处理\"><a href=\"#5-错误捕获与统一处理\" class=\"headerlink\" title=\"5. 错误捕获与统一处理\"></a>5. 错误捕获与统一处理</h3><p>捕获方法执行中的错误，避免程序崩溃，并统一进行错误上报、用户提示等处理，减少重复的 try&#x2F;catch 代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 错误处理装饰器：支持自定义错误回调</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">errorHandler</span>(<span class=\"hljs-params\">cb = (err) =&gt; &#123;</span><br><span class=\"hljs-params\">  <span class=\"hljs-variable language_\">console</span>.error(<span class=\"hljs-string\">&quot;发生错误：&quot;</span>, err);</span><br><span class=\"hljs-params\">  alert(<span class=\"hljs-string\">&quot;操作失败，请重试&quot;</span>);</span><br><span class=\"hljs-params\">&#125;</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">target, name, descriptor</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> original = descriptor.<span class=\"hljs-property\">value</span>;<br>    descriptor.<span class=\"hljs-property\">value</span> = <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...args</span>) &#123;<br>      <span class=\"hljs-keyword\">try</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">await</span> original.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args);<br>      &#125; <span class=\"hljs-keyword\">catch</span> (err) &#123;<br>        <span class=\"hljs-comment\">// 统一处理错误：回调函数支持自定义逻辑</span><br>        <span class=\"hljs-title function_\">cb</span>(err, &#123; <span class=\"hljs-attr\">method</span>: name, args &#125;);<br>      &#125;<br>    &#125;;<br>    <span class=\"hljs-keyword\">return</span> descriptor;<br>  &#125;;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">APIService</span> &#123;<br>  @<span class=\"hljs-title function_\">errorHandler</span>(<span class=\"hljs-title function_\">async</span> (err, info) =&gt; &#123;<br>    <span class=\"hljs-comment\">// 自定义错误处理：上报日志到后端</span><br>    <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&quot;/api/error-report&quot;</span>, &#123;<br>      <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">&quot;POST&quot;</span>,<br>      <span class=\"hljs-attr\">body</span>: <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(&#123;<br>        <span class=\"hljs-attr\">message</span>: err.<span class=\"hljs-property\">message</span>,<br>        <span class=\"hljs-attr\">stack</span>: err.<span class=\"hljs-property\">stack</span>,<br>        <span class=\"hljs-attr\">method</span>: info.<span class=\"hljs-property\">method</span>,<br>        <span class=\"hljs-attr\">args</span>: info.<span class=\"hljs-property\">args</span>,<br>        <span class=\"hljs-attr\">time</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>().<span class=\"hljs-title function_\">toLocaleString</span>()<br>      &#125;)<br>    &#125;);<br>    <span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-string\">&quot;网络异常，请稍后再试&quot;</span>);<br>  &#125;)<br>  <span class=\"hljs-keyword\">async</span> <span class=\"hljs-title function_\">getUserInfo</span>(<span class=\"hljs-params\">userId</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">`/api/users/<span class=\"hljs-subst\">$&#123;userId&#125;</span>`</span>);<br>    <span class=\"hljs-keyword\">if</span> (!response.<span class=\"hljs-property\">ok</span>) <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">`HTTP 错误：<span class=\"hljs-subst\">$&#123;response.status&#125;</span>`</span>);<br>    <span class=\"hljs-keyword\">return</span> response.<span class=\"hljs-title function_\">json</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"6-框架集成（React-Vue）\"><a href=\"#6-框架集成（React-Vue）\" class=\"headerlink\" title=\"6. 框架集成（React&#x2F;Vue）\"></a>6. 框架集成（React&#x2F;Vue）</h3><p>在类组件中复用框架能力，简化代码。例如 React 中连接 Redux、路由守卫，Vue 中装饰组件选项等。</p>\n<h4 id=\"React-中连接-Redux（react-redux）\"><a href=\"#React-中连接-Redux（react-redux）\" class=\"headerlink\" title=\"React 中连接 Redux（react-redux）\"></a>React 中连接 Redux（react-redux）</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; connect &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-redux&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; increment, decrement &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./store/actions&quot;</span>;<br><br><span class=\"hljs-comment\">// 用装饰器简化 connect 逻辑</span><br>@<span class=\"hljs-title function_\">connect</span>(<br>  <span class=\"hljs-comment\">// mapStateToProps：将 Redux 状态映射到组件 props</span><br>  <span class=\"hljs-function\"><span class=\"hljs-params\">state</span> =&gt;</span> (&#123; <span class=\"hljs-attr\">count</span>: state.<span class=\"hljs-property\">counter</span>.<span class=\"hljs-property\">count</span> &#125;),<br>  <span class=\"hljs-comment\">// mapDispatchToProps：将 action 映射到组件 props</span><br>  &#123; increment, decrement &#125;<br>)<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Counter</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">React.Component</span> &#123;<br>  <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> &#123; count, increment, decrement &#125; = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">props</span>;<br>    <span class=\"hljs-keyword\">return</span> (<br>      <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>计数：&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;increment&#125;</span>&gt;</span>+1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;decrement&#125;</span>&gt;</span>-1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Counter</span>;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"Vue-中装饰组件（vue-class-component）\"><a href=\"#Vue-中装饰组件（vue-class-component）\" class=\"headerlink\" title=\"Vue 中装饰组件（vue-class-component）\"></a>Vue 中装饰组件（vue-class-component）</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Vue</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;vue&quot;</span>;<br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Component</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;vue-class-component&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-title class_\">Prop</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;vue-property-decorator&quot;</span>;<br><br><span class=\"hljs-comment\">// 用装饰器定义 Vue 组件</span><br>@<span class=\"hljs-title class_\">Component</span>(&#123;<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;div&gt;</span><br><span class=\"hljs-string\">      &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class=\"hljs-string\">      &lt;button @click=&quot;sayHello&quot;&gt;点击&lt;/button&gt;</span><br><span class=\"hljs-string\">    &lt;/div&gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HelloWorld</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Vue</span> &#123;<br>  <span class=\"hljs-comment\">// 用 Prop 装饰器定义属性</span><br>  @<span class=\"hljs-title class_\">Prop</span>(&#123; <span class=\"hljs-attr\">type</span>: <span class=\"hljs-title class_\">String</span>, <span class=\"hljs-attr\">default</span>: <span class=\"hljs-string\">&quot;Hello Vue&quot;</span> &#125;)<br>  message!: string;<br>  <br>  <span class=\"hljs-title function_\">sayHello</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">message</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"使用-Decorator-的注意事项与避坑指南\"><a href=\"#使用-Decorator-的注意事项与避坑指南\" class=\"headerlink\" title=\"使用 Decorator 的注意事项与避坑指南\"></a>使用 Decorator 的注意事项与避坑指南</h2><ul>\n<li><p><strong>提案兼容性问题</strong><br>2025 年 Decorator 仍处于 TC39 Stage 3 阶段，不同工具链的配置需适配最新语。</p>\n</li>\n<li><p><strong>装饰器的执行顺序</strong><br>多个装饰器叠加时，执行顺序为 <code>“从右到左、从上到下</code>（外层装饰器包裹内层装饰器）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">@decoratorA<br>@decoratorB<br>@decoratorC<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyClass</span> &#123;&#125;<br><br><span class=\"hljs-comment\">// 等价于：decoratorA(decoratorB(decoratorC(MyClass)))</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>this 上下文绑定</strong><br>方法装饰器中，原方法的 <code>this</code> 默认指向 <code>undefined</code>（严格模式下），需通过 <code>original.apply(this,args)</code> 或者<code>original.call(this, ...args)</code> 绑定当前实例的 <code>this</code>，否则会导致 <code>this</code> 丢失。</p>\n</li>\n<li><p><strong>不可装饰普通函数</strong><br>当前 Stage 3 提案仅支持装饰“类”和“类成员”，不支持直接装饰普通函数。若需扩展普通函数，可使用高阶函数替代：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 普通函数的“装饰”（高阶函数形式）</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">logFunc</span>(<span class=\"hljs-params\">fn</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...args</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;调用参数：&quot;</span>, args);<br>    <span class=\"hljs-keyword\">return</span> fn.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args);<br>  &#125;;<br>&#125;<br><br><span class=\"hljs-comment\">// 应用高阶函数</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">a, b</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> a + b;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> addWithLog = <span class=\"hljs-title function_\">logFunc</span>(add);<br><span class=\"hljs-title function_\">addWithLog</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// 输出：调用参数：[1,2]，返回 3</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>Decorator 并非 ES6 正式标准，但它已成为前端开发中“非侵入式扩展”的经典方案，其核心价值在于分离通用逻辑与业务逻辑，实现代码复用，同时使得代码更加优雅。</p>\n<p>如果你在开发中面临“通用逻辑重复编写”“业务代码被辅助逻辑侵入”等问题，不妨尝试使用 Decorator——它会让你的代码更简洁、更优雅、更具扩展性。</p>\n<p><strong>【往期精彩】</strong></p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/pe4fywIh7WdigHuwRiqDlQ\">说说JavaScript中ES6 module(模块化)的诞生背景、核心语法及应用场景</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/lYqBgS0GJgQMX5PAW_snnQ\">一文说透ES6 Proxy: 从本质到应用场景</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/PtFtlNUH-UcLYU5h-xKiQw\">JavaScript ES6中的生成器(Generator)是什么？有哪些应用场景？一文全说透</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/9pnvL5fTO5U9yT-1mPfeQw\">聊聊ES6里的Promise：简单理解和实际用法</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/lqn_51NNxx50YgvWkxCtEg\">一文搞懂 JavaScript 里 var、let、const 的区别\n</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/UuJeSErftQY7ee1a54Pv4A\">为什么 ES6 要新增 Set 和 Map？看完这篇就懂了</a></li>\n</ul>\n","excerpt":"","more":"<!--# ES6 Module：重塑JavaScript模块化生态的基石 -->\n<p>这是<a href=\"https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU2MjU3MzI0MA==&action=getalbum&album_id=4120256678140837890#wechat_redirect\">JavaScript进阶系列文章</a>的第11篇文章, 今天我们来讲讲<code>装饰器(Decorator)</code>，内容有点长，代码有些多，坐稳发车了。</p>\n<p>在前端开发中，我们常面临这样的困境：如何在不修改原有代码的前提下，为类、方法或属性添加日志、权限校验、缓存等通用功能？</p>\n<p>如果直接在业务逻辑中嵌入这些辅助代码，会导致核心逻辑与通用逻辑耦合，代码可读性和可维护性大幅下降。而 ES6 提案中<code>Decorator(装饰器)</code>，正是为解决这一问题而生的优雅方案。</p>\n<p>本文将从 Decorator 的<strong>核心本质</strong>出发，详解其<strong>语法特性</strong>、<strong>使用场景</strong>，并结合实战案例说明其在项目中的价值，帮助开发者真正掌握这一“非侵入式扩展”的利器。</p>\n<h2 id=\"Decorator-是什么？\"><a href=\"#Decorator-是什么？\" class=\"headerlink\" title=\"Decorator 是什么？\"></a>Decorator 是什么？</h2><h3 id=\"核心定义\"><a href=\"#核心定义\" class=\"headerlink\" title=\"核心定义\"></a>核心定义</h3><p>Decorator 是基于 <strong>“包装模式”（Wrapper Pattern）</strong> 的语法糖，其核心目标是：<strong>在不侵入原有代码结构的前提下，为类、类成员（方法&#x2F;属性）动态扩展功能</strong>。</p>\n<p>它的本质是一个<code>特殊函数</code>：接收被装饰的“目标对象”作为参数，通过修改或包装目标对象，返回增强后的新对象。简单来说，Decorator 就像给礼物包装——礼物本身（核心业务逻辑）不变，但包装（通用辅助逻辑）能让它具备额外的“属性”（如美观、防护）。</p>\n<h3 id=\"核心价值\"><a href=\"#核心价值\" class=\"headerlink\" title=\"核心价值\"></a>核心价值</h3><p>Decorator 最核心的价值是 <strong>“分离关注点”</strong>：将日志、权限、缓存等通用逻辑与核心业务逻辑解耦，实现通用逻辑的复用，让代码更简洁、可维护。</p>\n<p>举个直观的对比：</p>\n<ul>\n<li>无 Decorator：在每个需要日志的方法中重复写 <code>console.log</code>，业务代码与日志逻辑混杂；</li>\n<li>有 Decorator：写一个通用日志装饰器，通过 <code>@log</code> 语法一键应用到任意方法，业务代码保持纯净。</li>\n</ul>\n<h2 id=\"Decorator-的核心用法\"><a href=\"#Decorator-的核心用法\" class=\"headerlink\" title=\"Decorator 的核心用法\"></a>Decorator 的核心用法</h2><p>Decorator 的语法简洁，核心分为“类装饰器”和“类成员装饰器”两类，各自承担不同的扩展职责。</p>\n<h3 id=\"1-类装饰器：增强整个类\"><a href=\"#1-类装饰器：增强整个类\" class=\"headerlink\" title=\"1. 类装饰器：增强整个类\"></a>1. 类装饰器：增强整个类</h3><p>类装饰器直接作用于类本身，用于为类添加静态属性、静态方法，或修改类的原型（prototype）。</p>\n<h4 id=\"语法与参数\"><a href=\"#语法与参数\" class=\"headerlink\" title=\"语法与参数\"></a>语法与参数</h4><ul>\n<li>仅接收 1 个参数 <code>target</code>：被装饰的类本身；</li>\n<li>可选返回值：若返回新类，则新类会替代原类；若不返回，则默认使用修改后的原类。</li>\n</ul>\n<h4 id=\"实战示例：给类添加通用能力\"><a href=\"#实战示例：给类添加通用能力\" class=\"headerlink\" title=\"实战示例：给类添加通用能力\"></a>实战示例：给类添加通用能力</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 类装饰器：为类添加静态配置和实例初始化方法</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">withConfig</span>(<span class=\"hljs-params\">defaultConfig</span>) &#123;<br>  <span class=\"hljs-comment\">// 支持传入参数的装饰器（高阶函数形式）</span><br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">target</span>) &#123;<br>    <span class=\"hljs-comment\">// 添加静态属性：默认配置</span><br>    target.<span class=\"hljs-property\">defaultConfig</span> = defaultConfig;<br>    <br>    <span class=\"hljs-comment\">// 添加静态方法：合并配置</span><br>    target.<span class=\"hljs-property\">mergeConfig</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">userConfig</span>) &#123;<br>      <span class=\"hljs-keyword\">return</span> &#123; ...defaultConfig, ...userConfig &#125;;<br>    &#125;;<br>    <br>    <span class=\"hljs-comment\">// 增强实例构造逻辑</span><br>    <span class=\"hljs-keyword\">const</span> originalConstructor = target;<br>    <span class=\"hljs-comment\">// 重写类构造函数</span><br>    <span class=\"hljs-keyword\">const</span> newConstructor = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...args</span>) &#123;<br>      originalConstructor.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args);<br>      <span class=\"hljs-comment\">// 实例初始化：合并配置到实例</span><br>      <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">config</span> = target.<span class=\"hljs-title function_\">mergeConfig</span>(args[<span class=\"hljs-number\">0</span>] || &#123;&#125;);<br>    &#125;;<br>    <br>    <span class=\"hljs-comment\">// 继承原类的原型（保证实例方法不丢失）</span><br>    newConstructor.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span> = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(originalConstructor.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>);<br>    newConstructor.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">constructor</span> = newConstructor;<br>    <br>    <span class=\"hljs-keyword\">return</span> newConstructor;<br>  &#125;;<br>&#125;<br><br><span class=\"hljs-comment\">// 应用装饰器：传入默认配置</span><br>@<span class=\"hljs-title function_\">withConfig</span>(&#123; <span class=\"hljs-attr\">theme</span>: <span class=\"hljs-string\">&quot;light&quot;</span>, <span class=\"hljs-attr\">size</span>: <span class=\"hljs-string\">&quot;medium&quot;</span> &#125;)<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Button</span> &#123;<br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\">userConfig</span>) &#123;<br>    <span class=\"hljs-comment\">// 原构造函数逻辑</span><br>    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = <span class=\"hljs-string\">&quot;按钮&quot;</span>;<br>  &#125;<br>  <br>  <span class=\"hljs-title function_\">getStyle</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">`主题：<span class=\"hljs-subst\">$&#123;<span class=\"hljs-variable language_\">this</span>.config.theme&#125;</span>，尺寸：<span class=\"hljs-subst\">$&#123;<span class=\"hljs-variable language_\">this</span>.config.size&#125;</span>`</span>;<br>  &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 测试效果</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Button</span>.<span class=\"hljs-property\">defaultConfig</span>); <span class=\"hljs-comment\">// &#123; theme: &quot;light&quot;, size: &quot;medium&quot; &#125;</span><br><span class=\"hljs-keyword\">const</span> darkButton = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Button</span>(&#123; <span class=\"hljs-attr\">theme</span>: <span class=\"hljs-string\">&quot;dark&quot;</span> &#125;);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(darkButton.<span class=\"hljs-property\">config</span>); <span class=\"hljs-comment\">// &#123; theme: &quot;dark&quot;, size: &quot;medium&quot; &#125;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(darkButton.<span class=\"hljs-title function_\">getStyle</span>()); <span class=\"hljs-comment\">// 主题：dark，尺寸：medium</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-类成员装饰器：增强方法-属性\"><a href=\"#2-类成员装饰器：增强方法-属性\" class=\"headerlink\" title=\"2. 类成员装饰器：增强方法&#x2F;属性\"></a>2. 类成员装饰器：增强方法&#x2F;属性</h3><p>类成员装饰器作用于类的方法、属性或访问器（getter&#x2F;setter），是开发中最常用的场景。</p>\n<h4 id=\"语法与参数-1\"><a href=\"#语法与参数-1\" class=\"headerlink\" title=\"语法与参数\"></a>语法与参数</h4><p>接收 3 个核心参数：</p>\n<ul>\n<li><code>target</code>：类的原型（针对实例方法）或类本身（针对静态方法）；</li>\n<li><code>name</code>：被装饰的成员名称（方法名&#x2F;属性名）；</li>\n<li><code>descriptor</code>：成员的属性描述符（<code>Object.getOwnPropertyDescriptor(target, name)</code> 的返回值），包含 <code>value</code>（方法本身）、<code>writable</code>（是否可修改）、<code>enumerable</code>（是否可枚举）等属性。</li>\n</ul>\n<h4 id=\"实战示例：包装方法实现日志记录\"><a href=\"#实战示例：包装方法实现日志记录\" class=\"headerlink\" title=\"实战示例：包装方法实现日志记录\"></a>实战示例：包装方法实现日志记录</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 方法装饰器：记录方法调用参数、返回值和执行时间</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">logPerformance</span>(<span class=\"hljs-params\">target, name, descriptor</span>) &#123;<br>  <span class=\"hljs-comment\">// 保存原方法（避免覆盖后丢失）</span><br>  <span class=\"hljs-keyword\">const</span> originalMethod = descriptor.<span class=\"hljs-property\">value</span>;<br>  <br>  <span class=\"hljs-comment\">// 重写方法逻辑</span><br>  descriptor.<span class=\"hljs-property\">value</span> = <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...args</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> start = <span class=\"hljs-title class_\">Date</span>.<span class=\"hljs-title function_\">now</span>();<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`[<span class=\"hljs-subst\">$&#123;name&#125;</span>] 开始执行，参数：`</span>, args);<br>    <br>    <span class=\"hljs-keyword\">try</span> &#123;<br>      <span class=\"hljs-comment\">// 执行原方法（绑定 this 上下文，确保实例方法的 this 正确）</span><br>      <span class=\"hljs-keyword\">const</span> result = <span class=\"hljs-keyword\">await</span> originalMethod.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args);<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`[<span class=\"hljs-subst\">$&#123;name&#125;</span>] 执行成功，返回值：`</span>, result);<br>      <span class=\"hljs-keyword\">return</span> result;<br>    &#125; <span class=\"hljs-keyword\">catch</span> (error) &#123;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">`[<span class=\"hljs-subst\">$&#123;name&#125;</span>] 执行失败，错误：`</span>, error);<br>      <span class=\"hljs-keyword\">throw</span> error; <span class=\"hljs-comment\">// 抛出错误，不影响上层处理</span><br>    &#125; <span class=\"hljs-keyword\">finally</span> &#123;<br>      <span class=\"hljs-keyword\">const</span> duration = <span class=\"hljs-title class_\">Date</span>.<span class=\"hljs-title function_\">now</span>() - start;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`[<span class=\"hljs-subst\">$&#123;name&#125;</span>] 执行耗时：<span class=\"hljs-subst\">$&#123;duration&#125;</span>ms`</span>);<br>    &#125;<br>  &#125;;<br>  <br>  <span class=\"hljs-comment\">// 返回修改后的描述符（替代原成员）</span><br>  <span class=\"hljs-keyword\">return</span> descriptor;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DataService</span> &#123;<br>  <span class=\"hljs-comment\">// 应用方法装饰器</span><br>  @logPerformance<br>  <span class=\"hljs-keyword\">async</span> <span class=\"hljs-title function_\">fetchData</span>(<span class=\"hljs-params\">url</span>) &#123;<br>    <span class=\"hljs-comment\">// 模拟接口请求</span><br>    <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(url);<br>    <span class=\"hljs-keyword\">return</span> response.<span class=\"hljs-title function_\">json</span>();<br>  &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 测试</span><br><span class=\"hljs-keyword\">const</span> service = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DataService</span>();<br>service.<span class=\"hljs-title function_\">fetchData</span>(<span class=\"hljs-string\">&quot;https://api.example.com/data&quot;</span>);<br><span class=\"hljs-comment\">// 输出：</span><br><span class=\"hljs-comment\">// [fetchData] 开始执行，参数： [&quot;https://api.example.com/data&quot;]</span><br><span class=\"hljs-comment\">// [fetchData] 执行成功，返回值： &#123; ...接口返回数据... &#125;</span><br><span class=\"hljs-comment\">// [fetchData] 执行耗时：320ms</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"三、Decorator-的典型使用场景：让通用逻辑复用更优雅\"><a href=\"#三、Decorator-的典型使用场景：让通用逻辑复用更优雅\" class=\"headerlink\" title=\"三、Decorator 的典型使用场景：让通用逻辑复用更优雅\"></a>三、Decorator 的典型使用场景：让通用逻辑复用更优雅</h2><p>Decorator 的核心优势在于通用逻辑的复用，以下是前端开发中最实用的 6 个场景，覆盖日志、权限、缓存等高频需求。</p>\n<h3 id=\"1-日志与性能监控\"><a href=\"#1-日志与性能监控\" class=\"headerlink\" title=\"1. 日志与性能监控\"></a>1. 日志与性能监控</h3><p>为核心业务方法（如接口请求、数据处理）添加日志，自动记录调用参数、返回值、执行时间，无需侵入业务代码。适合用于线上问题排查和性能优化。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 通用日志装饰器：支持开关和自定义格式</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">log</span>(<span class=\"hljs-params\">options = &#123; enable: <span class=\"hljs-literal\">true</span>, format: <span class=\"hljs-string\">&quot;default&quot;</span> &#125;</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">target, name, descriptor</span>) &#123;<br>    <span class=\"hljs-keyword\">if</span> (!options.<span class=\"hljs-property\">enable</span>) <span class=\"hljs-keyword\">return</span> descriptor; <span class=\"hljs-comment\">// 关闭日志时直接返回原描述符</span><br>    <br>    <span class=\"hljs-keyword\">const</span> original = descriptor.<span class=\"hljs-property\">value</span>;<br>    descriptor.<span class=\"hljs-property\">value</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...args</span>) &#123;<br>      <span class=\"hljs-keyword\">const</span> time = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>().<span class=\"hljs-title function_\">toLocaleString</span>();<br>      <span class=\"hljs-comment\">// 自定义日志格式</span><br>      <span class=\"hljs-keyword\">if</span> (options.<span class=\"hljs-property\">format</span> === <span class=\"hljs-string\">&quot;detail&quot;</span>) &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`[<span class=\"hljs-subst\">$&#123;time&#125;</span>] [<span class=\"hljs-subst\">$&#123;target.constructor.name&#125;</span>.<span class=\"hljs-subst\">$&#123;name&#125;</span>] 调用参数：`</span>, args);<br>      &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`[<span class=\"hljs-subst\">$&#123;time&#125;</span>] [<span class=\"hljs-subst\">$&#123;name&#125;</span>] 调用参数：`</span>, args);<br>      &#125;<br>      <span class=\"hljs-keyword\">return</span> original.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args);<br>    &#125;;<br>    <span class=\"hljs-keyword\">return</span> descriptor;<br>  &#125;;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OrderService</span> &#123;<br>  @<span class=\"hljs-title function_\">log</span>(&#123; <span class=\"hljs-attr\">enable</span>: <span class=\"hljs-literal\">true</span>, <span class=\"hljs-attr\">format</span>: <span class=\"hljs-string\">&quot;detail&quot;</span> &#125;)<br>  <span class=\"hljs-title function_\">createOrder</span>(<span class=\"hljs-params\">params</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;创建订单：&quot;</span>, params);<br>    <span class=\"hljs-keyword\">return</span> &#123; <span class=\"hljs-attr\">orderId</span>: <span class=\"hljs-string\">&quot;123456&quot;</span> &#125;;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-权限校验与访问控制\"><a href=\"#2-权限校验与访问控制\" class=\"headerlink\" title=\"2. 权限校验与访问控制\"></a>2. 权限校验与访问控制</h3><p>限制敏感方法的调用权限（如管理员操作、用户登录态校验），将权限逻辑与业务逻辑分离，避免在每个方法中重复写校验代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 权限装饰器：支持多角色校验</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">requireRoles</span>(<span class=\"hljs-params\">...allowedRoles</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">target, name, descriptor</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> original = descriptor.<span class=\"hljs-property\">value</span>;<br>    descriptor.<span class=\"hljs-property\">value</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...args</span>) &#123;<br>      <span class=\"hljs-comment\">// 假设从全局状态或实例中获取当前用户角色</span><br>      <span class=\"hljs-keyword\">const</span> userRole = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">getCurrentUserRole</span>();<br>      <br>      <span class=\"hljs-keyword\">if</span> (!allowedRoles.<span class=\"hljs-title function_\">includes</span>(userRole)) &#123;<br>        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">`权限不足！当前角色：<span class=\"hljs-subst\">$&#123;userRole&#125;</span>，允许角色：<span class=\"hljs-subst\">$&#123;allowedRoles.join(<span class=\"hljs-string\">&quot;,&quot;</span>)&#125;</span>`</span>);<br>      &#125;<br>      <br>      <span class=\"hljs-keyword\">return</span> original.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args);<br>    &#125;;<br>    <span class=\"hljs-keyword\">return</span> descriptor;<br>  &#125;;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SystemManager</span> &#123;<br>  <span class=\"hljs-title function_\">getCurrentUserRole</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;admin&quot;</span>; <span class=\"hljs-comment\">// 实际场景中从登录态获取</span><br>  &#125;<br>  <br>  @<span class=\"hljs-title function_\">requireRoles</span>(<span class=\"hljs-string\">&quot;admin&quot;</span>, <span class=\"hljs-string\">&quot;super_admin&quot;</span>) <span class=\"hljs-comment\">// 仅管理员和超级管理员可调用</span><br>  <span class=\"hljs-title function_\">deleteUser</span>(<span class=\"hljs-params\">userId</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`删除用户：<span class=\"hljs-subst\">$&#123;userId&#125;</span>`</span>);<br>  &#125;<br>  <br>  @<span class=\"hljs-title function_\">requireRoles</span>(<span class=\"hljs-string\">&quot;user&quot;</span>, <span class=\"hljs-string\">&quot;admin&quot;</span>) <span class=\"hljs-comment\">// 普通用户和管理员均可调用</span><br>  <span class=\"hljs-title function_\">queryUser</span>(<span class=\"hljs-params\">userId</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`查询用户：<span class=\"hljs-subst\">$&#123;userId&#125;</span>`</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-缓存优化（记忆化）\"><a href=\"#3-缓存优化（记忆化）\" class=\"headerlink\" title=\"3. 缓存优化（记忆化）\"></a>3. 缓存优化（记忆化）</h3><p>对计算密集型方法（如递归、大数据处理）或高频调用的接口添加缓存，避免重复计算或请求，提升性能。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 缓存装饰器：支持过期时间</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">cache</span>(<span class=\"hljs-params\">options = &#123; ttl: <span class=\"hljs-literal\">Infinity</span> &#125;</span>) &#123;<br>  <span class=\"hljs-keyword\">const</span> cacheMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(); <span class=\"hljs-comment\">// 缓存容器</span><br>  <br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">target, name, descriptor</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> original = descriptor.<span class=\"hljs-property\">value</span>;<br>    descriptor.<span class=\"hljs-property\">value</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...args</span>) &#123;<br>      <span class=\"hljs-comment\">// 用参数生成唯一缓存键（复杂参数可使用 hash 函数优化）</span><br>      <span class=\"hljs-keyword\">const</span> cacheKey = <span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;name&#125;</span>_<span class=\"hljs-subst\">$&#123;<span class=\"hljs-built_in\">JSON</span>.stringify(args)&#125;</span>`</span>;<br>      <br>      <span class=\"hljs-comment\">// 检查缓存是否存在且未过期</span><br>      <span class=\"hljs-keyword\">if</span> (cacheMap.<span class=\"hljs-title function_\">has</span>(cacheKey)) &#123;<br>        <span class=\"hljs-keyword\">const</span> &#123; data, timestamp &#125; = cacheMap.<span class=\"hljs-title function_\">get</span>(cacheKey);<br>        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title class_\">Date</span>.<span class=\"hljs-title function_\">now</span>() - timestamp &lt; options.<span class=\"hljs-property\">ttl</span>) &#123;<br>          <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`[<span class=\"hljs-subst\">$&#123;name&#125;</span>] 命中缓存`</span>);<br>          <span class=\"hljs-keyword\">return</span> data;<br>        &#125;<br>        <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`[<span class=\"hljs-subst\">$&#123;name&#125;</span>] 缓存过期，重新计算`</span>);<br>        cacheMap.<span class=\"hljs-title function_\">delete</span>(cacheKey);<br>      &#125;<br>      <br>      <span class=\"hljs-comment\">// 执行原方法并缓存结果</span><br>      <span class=\"hljs-keyword\">const</span> result = original.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args);<br>      cacheMap.<span class=\"hljs-title function_\">set</span>(cacheKey, &#123;<br>        <span class=\"hljs-attr\">data</span>: result,<br>        <span class=\"hljs-attr\">timestamp</span>: <span class=\"hljs-title class_\">Date</span>.<span class=\"hljs-title function_\">now</span>()<br>      &#125;);<br>      <br>      <span class=\"hljs-keyword\">return</span> result;<br>    &#125;;<br>    <span class=\"hljs-keyword\">return</span> descriptor;<br>  &#125;;<br>&#125;<br><br><span class=\"hljs-comment\">// 斐波那契数列计算（计算密集型）</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FibCalculator</span> &#123;<br>  @<span class=\"hljs-title function_\">cache</span>(&#123; <span class=\"hljs-attr\">ttl</span>: <span class=\"hljs-number\">5000</span> &#125;) <span class=\"hljs-comment\">// 缓存 5 秒</span><br>  <span class=\"hljs-title function_\">fib</span>(<span class=\"hljs-params\">n</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`[fib] 计算 fib(<span class=\"hljs-subst\">$&#123;n&#125;</span>)`</span>);<br>    <span class=\"hljs-keyword\">if</span> (n &lt;= <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">return</span> n;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">fib</span>(n - <span class=\"hljs-number\">1</span>) + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">fib</span>(n - <span class=\"hljs-number\">2</span>);<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> calculator = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FibCalculator</span>();<br>calculator.<span class=\"hljs-title function_\">fib</span>(<span class=\"hljs-number\">10</span>); <span class=\"hljs-comment\">// 首次计算，打印多次 &quot;计算 fib(n)&quot;</span><br>calculator.<span class=\"hljs-title function_\">fib</span>(<span class=\"hljs-number\">10</span>); <span class=\"hljs-comment\">// 命中缓存，直接返回结果</span><br><span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> calculator.<span class=\"hljs-title function_\">fib</span>(<span class=\"hljs-number\">10</span>), <span class=\"hljs-number\">6000</span>); <span class=\"hljs-comment\">// 缓存过期，重新计算</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"4-防抖与节流\"><a href=\"#4-防抖与节流\" class=\"headerlink\" title=\"4. 防抖与节流\"></a>4. 防抖与节流</h3><p>装饰事件处理方法（如输入框搜索、按钮点击、窗口resize），避免频繁触发，提升用户体验。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 防抖装饰器：延迟执行，多次触发仅最后一次生效</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">debounce</span>(<span class=\"hljs-params\">delay = <span class=\"hljs-number\">300</span>, immediate = <span class=\"hljs-literal\">false</span></span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> timer = <span class=\"hljs-literal\">null</span>;<br>  <br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">target, name, descriptor</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> original = descriptor.<span class=\"hljs-property\">value</span>;<br>    descriptor.<span class=\"hljs-property\">value</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...args</span>) &#123;<br>      <span class=\"hljs-built_in\">clearTimeout</span>(timer);<br>      <br>      <span class=\"hljs-comment\">// 立即执行模式：首次触发时立即执行</span><br>      <span class=\"hljs-keyword\">if</span> (immediate &amp;&amp; !timer) &#123;<br>        original.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args);<br>      &#125;<br>      <br>      timer = <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>        original.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args);<br>        timer = <span class=\"hljs-literal\">null</span>;<br>      &#125;, delay);<br>    &#125;;<br>    <span class=\"hljs-keyword\">return</span> descriptor;<br>  &#125;;<br>&#125;<br><br><span class=\"hljs-comment\">// 节流装饰器：固定时间内仅执行一次</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">throttle</span>(<span class=\"hljs-params\">interval = <span class=\"hljs-number\">500</span></span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> lastTime = <span class=\"hljs-number\">0</span>;<br>  <br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">target, name, descriptor</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> original = descriptor.<span class=\"hljs-property\">value</span>;<br>    descriptor.<span class=\"hljs-property\">value</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...args</span>) &#123;<br>      <span class=\"hljs-keyword\">const</span> now = <span class=\"hljs-title class_\">Date</span>.<span class=\"hljs-title function_\">now</span>();<br>      <span class=\"hljs-keyword\">if</span> (now - lastTime &gt;= interval) &#123;<br>        lastTime = now;<br>        original.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args);<br>      &#125;<br>    &#125;;<br>    <span class=\"hljs-keyword\">return</span> descriptor;<br>  &#125;;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SearchComponent</span> &#123;<br>  @<span class=\"hljs-title function_\">debounce</span>(<span class=\"hljs-number\">500</span>) <span class=\"hljs-comment\">// 输入停止 500ms 后执行搜索</span><br>  <span class=\"hljs-title function_\">handleSearch</span>(<span class=\"hljs-params\">keyword</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;搜索关键词：&quot;</span>, keyword);<br>  &#125;<br>  <br>  @<span class=\"hljs-title function_\">throttle</span>(<span class=\"hljs-number\">1000</span>) <span class=\"hljs-comment\">// 1 秒内仅执行一次</span><br>  <span class=\"hljs-title function_\">handleScroll</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;窗口滚动&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"5-错误捕获与统一处理\"><a href=\"#5-错误捕获与统一处理\" class=\"headerlink\" title=\"5. 错误捕获与统一处理\"></a>5. 错误捕获与统一处理</h3><p>捕获方法执行中的错误，避免程序崩溃，并统一进行错误上报、用户提示等处理，减少重复的 try&#x2F;catch 代码。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 错误处理装饰器：支持自定义错误回调</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">errorHandler</span>(<span class=\"hljs-params\">cb = (err) =&gt; &#123;</span><br><span class=\"hljs-params\">  <span class=\"hljs-variable language_\">console</span>.error(<span class=\"hljs-string\">&quot;发生错误：&quot;</span>, err);</span><br><span class=\"hljs-params\">  alert(<span class=\"hljs-string\">&quot;操作失败，请重试&quot;</span>);</span><br><span class=\"hljs-params\">&#125;</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">target, name, descriptor</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> original = descriptor.<span class=\"hljs-property\">value</span>;<br>    descriptor.<span class=\"hljs-property\">value</span> = <span class=\"hljs-keyword\">async</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...args</span>) &#123;<br>      <span class=\"hljs-keyword\">try</span> &#123;<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">await</span> original.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args);<br>      &#125; <span class=\"hljs-keyword\">catch</span> (err) &#123;<br>        <span class=\"hljs-comment\">// 统一处理错误：回调函数支持自定义逻辑</span><br>        <span class=\"hljs-title function_\">cb</span>(err, &#123; <span class=\"hljs-attr\">method</span>: name, args &#125;);<br>      &#125;<br>    &#125;;<br>    <span class=\"hljs-keyword\">return</span> descriptor;<br>  &#125;;<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">APIService</span> &#123;<br>  @<span class=\"hljs-title function_\">errorHandler</span>(<span class=\"hljs-title function_\">async</span> (err, info) =&gt; &#123;<br>    <span class=\"hljs-comment\">// 自定义错误处理：上报日志到后端</span><br>    <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&quot;/api/error-report&quot;</span>, &#123;<br>      <span class=\"hljs-attr\">method</span>: <span class=\"hljs-string\">&quot;POST&quot;</span>,<br>      <span class=\"hljs-attr\">body</span>: <span class=\"hljs-title class_\">JSON</span>.<span class=\"hljs-title function_\">stringify</span>(&#123;<br>        <span class=\"hljs-attr\">message</span>: err.<span class=\"hljs-property\">message</span>,<br>        <span class=\"hljs-attr\">stack</span>: err.<span class=\"hljs-property\">stack</span>,<br>        <span class=\"hljs-attr\">method</span>: info.<span class=\"hljs-property\">method</span>,<br>        <span class=\"hljs-attr\">args</span>: info.<span class=\"hljs-property\">args</span>,<br>        <span class=\"hljs-attr\">time</span>: <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Date</span>().<span class=\"hljs-title function_\">toLocaleString</span>()<br>      &#125;)<br>    &#125;);<br>    <span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-string\">&quot;网络异常，请稍后再试&quot;</span>);<br>  &#125;)<br>  <span class=\"hljs-keyword\">async</span> <span class=\"hljs-title function_\">getUserInfo</span>(<span class=\"hljs-params\">userId</span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> response = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">`/api/users/<span class=\"hljs-subst\">$&#123;userId&#125;</span>`</span>);<br>    <span class=\"hljs-keyword\">if</span> (!response.<span class=\"hljs-property\">ok</span>) <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">`HTTP 错误：<span class=\"hljs-subst\">$&#123;response.status&#125;</span>`</span>);<br>    <span class=\"hljs-keyword\">return</span> response.<span class=\"hljs-title function_\">json</span>();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"6-框架集成（React-Vue）\"><a href=\"#6-框架集成（React-Vue）\" class=\"headerlink\" title=\"6. 框架集成（React&#x2F;Vue）\"></a>6. 框架集成（React&#x2F;Vue）</h3><p>在类组件中复用框架能力，简化代码。例如 React 中连接 Redux、路由守卫，Vue 中装饰组件选项等。</p>\n<h4 id=\"React-中连接-Redux（react-redux）\"><a href=\"#React-中连接-Redux（react-redux）\" class=\"headerlink\" title=\"React 中连接 Redux（react-redux）\"></a>React 中连接 Redux（react-redux）</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">React</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; connect &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;react-redux&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; increment, decrement &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;./store/actions&quot;</span>;<br><br><span class=\"hljs-comment\">// 用装饰器简化 connect 逻辑</span><br>@<span class=\"hljs-title function_\">connect</span>(<br>  <span class=\"hljs-comment\">// mapStateToProps：将 Redux 状态映射到组件 props</span><br>  <span class=\"hljs-function\"><span class=\"hljs-params\">state</span> =&gt;</span> (&#123; <span class=\"hljs-attr\">count</span>: state.<span class=\"hljs-property\">counter</span>.<span class=\"hljs-property\">count</span> &#125;),<br>  <span class=\"hljs-comment\">// mapDispatchToProps：将 action 映射到组件 props</span><br>  &#123; increment, decrement &#125;<br>)<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Counter</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">React.Component</span> &#123;<br>  <span class=\"hljs-title function_\">render</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">const</span> &#123; count, increment, decrement &#125; = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">props</span>;<br>    <span class=\"hljs-keyword\">return</span> (<br>      <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>计数：&#123;count&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;increment&#125;</span>&gt;</span>+1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"language-xml\">        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onClick</span>=<span class=\"hljs-string\">&#123;decrement&#125;</span>&gt;</span>-1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span><br><span class=\"language-xml\">      <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-title class_\">Counter</span>;<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"Vue-中装饰组件（vue-class-component）\"><a href=\"#Vue-中装饰组件（vue-class-component）\" class=\"headerlink\" title=\"Vue 中装饰组件（vue-class-component）\"></a>Vue 中装饰组件（vue-class-component）</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Vue</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;vue&quot;</span>;<br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Component</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;vue-class-component&quot;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-title class_\">Prop</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;vue-property-decorator&quot;</span>;<br><br><span class=\"hljs-comment\">// 用装饰器定义 Vue 组件</span><br>@<span class=\"hljs-title class_\">Component</span>(&#123;<br>  <span class=\"hljs-attr\">template</span>: <span class=\"hljs-string\">`</span><br><span class=\"hljs-string\">    &lt;div&gt;</span><br><span class=\"hljs-string\">      &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt;</span><br><span class=\"hljs-string\">      &lt;button @click=&quot;sayHello&quot;&gt;点击&lt;/button&gt;</span><br><span class=\"hljs-string\">    &lt;/div&gt;</span><br><span class=\"hljs-string\">  `</span><br>&#125;)<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HelloWorld</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">Vue</span> &#123;<br>  <span class=\"hljs-comment\">// 用 Prop 装饰器定义属性</span><br>  @<span class=\"hljs-title class_\">Prop</span>(&#123; <span class=\"hljs-attr\">type</span>: <span class=\"hljs-title class_\">String</span>, <span class=\"hljs-attr\">default</span>: <span class=\"hljs-string\">&quot;Hello Vue&quot;</span> &#125;)<br>  message!: string;<br>  <br>  <span class=\"hljs-title function_\">sayHello</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">message</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"使用-Decorator-的注意事项与避坑指南\"><a href=\"#使用-Decorator-的注意事项与避坑指南\" class=\"headerlink\" title=\"使用 Decorator 的注意事项与避坑指南\"></a>使用 Decorator 的注意事项与避坑指南</h2><ul>\n<li><p><strong>提案兼容性问题</strong><br>2025 年 Decorator 仍处于 TC39 Stage 3 阶段，不同工具链的配置需适配最新语。</p>\n</li>\n<li><p><strong>装饰器的执行顺序</strong><br>多个装饰器叠加时，执行顺序为 <code>“从右到左、从上到下</code>（外层装饰器包裹内层装饰器）</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">@decoratorA<br>@decoratorB<br>@decoratorC<br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MyClass</span> &#123;&#125;<br><br><span class=\"hljs-comment\">// 等价于：decoratorA(decoratorB(decoratorC(MyClass)))</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>this 上下文绑定</strong><br>方法装饰器中，原方法的 <code>this</code> 默认指向 <code>undefined</code>（严格模式下），需通过 <code>original.apply(this,args)</code> 或者<code>original.call(this, ...args)</code> 绑定当前实例的 <code>this</code>，否则会导致 <code>this</code> 丢失。</p>\n</li>\n<li><p><strong>不可装饰普通函数</strong><br>当前 Stage 3 提案仅支持装饰“类”和“类成员”，不支持直接装饰普通函数。若需扩展普通函数，可使用高阶函数替代：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 普通函数的“装饰”（高阶函数形式）</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">logFunc</span>(<span class=\"hljs-params\">fn</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">...args</span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;调用参数：&quot;</span>, args);<br>    <span class=\"hljs-keyword\">return</span> fn.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-variable language_\">this</span>, args);<br>  &#125;;<br>&#125;<br><br><span class=\"hljs-comment\">// 应用高阶函数</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-params\">a, b</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> a + b;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> addWithLog = <span class=\"hljs-title function_\">logFunc</span>(add);<br><span class=\"hljs-title function_\">addWithLog</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// 输出：调用参数：[1,2]，返回 3</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>Decorator 并非 ES6 正式标准，但它已成为前端开发中“非侵入式扩展”的经典方案，其核心价值在于分离通用逻辑与业务逻辑，实现代码复用，同时使得代码更加优雅。</p>\n<p>如果你在开发中面临“通用逻辑重复编写”“业务代码被辅助逻辑侵入”等问题，不妨尝试使用 Decorator——它会让你的代码更简洁、更优雅、更具扩展性。</p>\n<p><strong>【往期精彩】</strong></p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/pe4fywIh7WdigHuwRiqDlQ\">说说JavaScript中ES6 module(模块化)的诞生背景、核心语法及应用场景</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/lYqBgS0GJgQMX5PAW_snnQ\">一文说透ES6 Proxy: 从本质到应用场景</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/PtFtlNUH-UcLYU5h-xKiQw\">JavaScript ES6中的生成器(Generator)是什么？有哪些应用场景？一文全说透</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/9pnvL5fTO5U9yT-1mPfeQw\">聊聊ES6里的Promise：简单理解和实际用法</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/lqn_51NNxx50YgvWkxCtEg\">一文搞懂 JavaScript 里 var、let、const 的区别\n</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/UuJeSErftQY7ee1a54Pv4A\">为什么 ES6 要新增 Set 和 Map？看完这篇就懂了</a></li>\n</ul>\n"},{"title":"JavaScript进化论：ES6如何让函数编写更加简洁、高效？","date":"2025-12-06T04:32:43.000Z","_content":"\n以前写 JavaScript 函数，真的有不少麻烦事：参数默认值得手动判断、处理多个参数要靠 `arguments` 瞎折腾、`this` 指向还老让人晕头转向。ES6 算是把这些痛点都补上了，给函数加了好多实用扩展，写代码又快又不容易踩坑。下面用大白话+简单例子，把这些功能讲明白，新手也能一看就会～\n\n## 参数默认值：不用再写 “a || 1” 啦\n以前想给函数参数设默认值，得在函数里写一堆判断，又麻烦又容易出问题。ES6 直接允许在参数列表里写默认值，省事多了。\n- 核心特点：要是没传参数，或者传了个 `undefined`，就自动用默认值。\n- 对比示例：\n```javascript\n// ES5 写法：得手动判断参数在不在\nfunction fn1(a, b) {\n  a = a || 1; // 这里有个坑啊——要是你传个 a=0，它也会被改成 1\n  b = b === undefined ? 2 : b;\n  return a + b;\n}\n\n// ES6 写法：直接在参数里设默认值，多直观\nfunction fn2(a = 1, b = 2) {\n  return a + b;\n}\n\nconsole.log(fn2()); // 输出 3（没传参数，直接用默认值 1 和 2）\nconsole.log(fn2(3)); // 输出 5（只传了 a=3，b 还是用默认值 2）\nconsole.log(fn2(0, 0)); // 输出 0（传 0 也不会被替换，完美避开 ES5 的坑）\n```\n\n---\n\n## 剩余参数：用 ... 收齐所有剩余参数\n以前处理不确定个数的参数，得用 `arguments` 这个类数组，还得手动转成真正的数组才能用 `forEach`、`map` 这些方法，太折腾了。ES6 的剩余参数直接用 ... 就能收齐所有参数，天生就是数组，不用额外处理。\n- 核心特点：只能放在参数列表最后，不管剩多少个参数，都能一次性接住。\n- 对比示例：\n```javascript\n// ES5 写法：靠 arguments 处理多个参数，麻烦到家\nfunction sum1() {\n  // 先把类数组 arguments 转成真正的数组，才能用 reduce\n  const nums = Array.prototype.slice.call(arguments);\n  return nums.reduce((total, num) => total + num, 0);\n}\n\n// ES6 写法：用 ...nums 直接收齐所有参数，省事\nfunction sum2(...nums) {\n  return nums.reduce((total, num) => total + num, 0);\n}\n\nconsole.log(sum1(1, 2, 3)); // 输出 6\nconsole.log(sum2(1, 2, 3, 4)); // 输出 10（不管传多少个参数，都能搞定）\n```\n\n---\n\n## 扩展运算符：把数组 “拆” 成参数用\n扩展运算符和剩余参数是反过来的：剩余参数是“收”参数，扩展运算符是“拆”数组，把数组里的元素一个个拆出来当函数参数，再也不用写 `apply `了。\n- 核心特点：在数组前面加个 ...，就能直接展开成逗号分隔的参数。\n- 实用示例：\n```javascript\n// 场景 1：求数组最大值（ES5 得用 apply 绕一圈）\nconst arr = [10, 20, 5, 15];\nconsole.log(Math.max.apply(null, arr)); // ES5 写法：输出 20，看着就麻烦\nconsole.log(Math.max(...arr)); // ES6 写法：输出 20，直接拆数组，多简洁\n\n// 场景 2：合并数组\nconst arr1 = [1, 2];\nconst arr2 = [3, 4];\nconsole.log([...arr1, ...arr2]); // 输出 [1,2,3,4]，直接拼就行\n\n// 场景 3：给函数传数组参数\nfunction fn(a, b, c) {\n  return a + b + c;\n}\nconsole.log(fn(...[1, 2, 3])); // 输出 6（数组直接拆成 1、2、3 三个参数）\n```\n\n---\n\n## 箭头函数：写代码快到飞起，还解决 this 坑\n箭头函数绝对是 ES6 里最常用的扩展，不仅写法极简，还把普通函数最让人头疼的 this 指向问题给解决了，再也不用记各种 this 指向规则了。\n- 核心特点：\n  - 语法超简洁：`(参数) => 返回值`，不用写 function、return，甚至连大括号都能省（单条语句时）。\n  - 没有自己的 this：this 直接继承外层作用域的，不管怎么调用都不变。\n  - 不能当构造函数：没法用 `new` 关键字创建实例。\n  - 没有 arguments：想处理多个参数，直接用剩余参数就行。\n- 对比示例：\n```javascript\n// 场景 1：简单函数简写，一行搞定\nconst add1 = function(a, b) { // ES5 普通函数，写一堆字\n  return a + b;\n};\nconst add2 = (a, b) => a + b; // ES6 箭头函数，精简到极致\n\n// 场景 2：解决 this 指向的坑（以前写代码常踩的雷）\nconst obj = {\n  name: \"张三\",\n  age: 20,\n  // ES5 普通函数：this 会跟着调用方式变，太坑了\n  sayHi1: function() {\n    setTimeout(function() {\n      console.log(`我是 ${this.name}`); // 输出 \"我是 undefined\"（this 指向 window 了）\n    }, 100);\n  },\n  // ES6 箭头函数：this 直接继承外层的 obj，稳得很\n  sayHi2: function() {\n    setTimeout(() => {\n      console.log(`我是 ${this.name}`); // 输出 \"我是 张三\"（this 一直指向 obj）\n    }, 100);\n  }\n};\nobj.sayHi1();\nobj.sayHi2();\n```\n\n---\n\n## 参数解构：直接“拆”对象/数组当参数\n有时候函数参数是个对象或数组，以前得先在函数里手动提取属性，写起来很啰嗦。ES6 能直接在参数列表里解构，把需要的属性或元素直接拿出来用。\n- 实用示例：\n```javascript\n// 场景 1：解构对象参数，还能设默认值\nfunction printUser({ name, age = 18 }) { // 直接提取 name 和 age，age 没传就用 18\n  console.log(`姓名：${name}，年龄：${age}`);\n}\nprintUser({ name: \"李四\" }); // 输出 \"姓名：李四，年龄：18\"（age 用默认值）\nprintUser({ name: \"王五\", age: 25 }); // 输出 \"姓名：王五，年龄：25\"\n\n// 场景 2：解构数组参数\nfunction printPoint([x, y]) { // 直接提取数组的前两个元素当 x 和 y\n  console.log(`坐标：(${x}, ${y})`);\n}\nprintPoint([10, 20]); // 输出 \"坐标：(10, 20)\"\n```\n\n---\n\n## name 属性优化：函数名字更靠谱了\n以前函数的 `name` 属性不太准，调试的时候容易 confusion。ES6 把这个问题修好了，函数名字能准确显示，调试起来更方便。\n- 对比示例：\n```javascript\n// ES5：匿名函数赋值给变量，name 是空字符串，调试找不到\nconst fn1 = function() {};\nconsole.log(fn1.name); // 输出 \"\"\n\n// ES6：匿名函数赋值给变量，name 就是变量名，一目了然\nconst fn2 = () => {};\nconsole.log(fn2.name); // 输出 \"fn2\"\n\n// 具名函数赋值，name 还是函数本身的名字\nconst fn3 = function myFn() {};\nconsole.log(fn3.name); // 输出 \"myFn\"\n```\n\n---\n\n## 总结：这些扩展该怎么用？\n- **箭头函数优先用**：写简单逻辑、怕 this 出错的时候，直接用箭头函数，省心又快捷。\n- **参数默认值+解构**：传对象或数组当参数时，用解构+默认值，不用手动提属性，代码更干净。\n- **剩余参数替代 arguments**：处理多个参数时，剩余参数天生是数组，比 arguments 好用多了。\n- **扩展运算符多活用**：合并数组、给函数传数组参数时，用 ... 直接拆，比 apply 简洁太多。\n\n这些扩展本质上都是为了让代码更短、更好懂、少踩坑，现在前端开发里，这些写法早就成了标配，学会了能省不少事～\n\n**【往期精彩内容】**\n- [JavaScript ES6 中对象的拓展，你了解几个？](https://mp.weixin.qq.com/s/PTI3HGsfpDz4-GvRx0i9ew)\n- [Javascript高频面试点--ES6 数组新特性](https://mp.weixin.qq.com/s/qR65z8RbPFxW326UnogLqA)\n- [一文搞懂 JavaScript 里 var、let、const 的区别\n](https://mp.weixin.qq.com/s/lqn_51NNxx50YgvWkxCtEg)\n- [程序员如何打破职业瓶颈？先搬开这3块绊脚石。](https://mp.weixin.qq.com/s/DRpZXprnTndjKb1YMqsfjQ)\n- [深入理解 JavaScript 中的原型与原型链](https://mp.weixin.qq.com/s/2lcovAIzSptuidQNtlVPwg)\n","source":"_posts/function-in-es6.md","raw":"---\ntitle: JavaScript进化论：ES6如何让函数编写更加简洁、高效？\ndate: 2025-12-06 12:32:43\ntags: JavaScript进阶, ES6进阶\ncategory: ES6进阶\n---\n\n以前写 JavaScript 函数，真的有不少麻烦事：参数默认值得手动判断、处理多个参数要靠 `arguments` 瞎折腾、`this` 指向还老让人晕头转向。ES6 算是把这些痛点都补上了，给函数加了好多实用扩展，写代码又快又不容易踩坑。下面用大白话+简单例子，把这些功能讲明白，新手也能一看就会～\n\n## 参数默认值：不用再写 “a || 1” 啦\n以前想给函数参数设默认值，得在函数里写一堆判断，又麻烦又容易出问题。ES6 直接允许在参数列表里写默认值，省事多了。\n- 核心特点：要是没传参数，或者传了个 `undefined`，就自动用默认值。\n- 对比示例：\n```javascript\n// ES5 写法：得手动判断参数在不在\nfunction fn1(a, b) {\n  a = a || 1; // 这里有个坑啊——要是你传个 a=0，它也会被改成 1\n  b = b === undefined ? 2 : b;\n  return a + b;\n}\n\n// ES6 写法：直接在参数里设默认值，多直观\nfunction fn2(a = 1, b = 2) {\n  return a + b;\n}\n\nconsole.log(fn2()); // 输出 3（没传参数，直接用默认值 1 和 2）\nconsole.log(fn2(3)); // 输出 5（只传了 a=3，b 还是用默认值 2）\nconsole.log(fn2(0, 0)); // 输出 0（传 0 也不会被替换，完美避开 ES5 的坑）\n```\n\n---\n\n## 剩余参数：用 ... 收齐所有剩余参数\n以前处理不确定个数的参数，得用 `arguments` 这个类数组，还得手动转成真正的数组才能用 `forEach`、`map` 这些方法，太折腾了。ES6 的剩余参数直接用 ... 就能收齐所有参数，天生就是数组，不用额外处理。\n- 核心特点：只能放在参数列表最后，不管剩多少个参数，都能一次性接住。\n- 对比示例：\n```javascript\n// ES5 写法：靠 arguments 处理多个参数，麻烦到家\nfunction sum1() {\n  // 先把类数组 arguments 转成真正的数组，才能用 reduce\n  const nums = Array.prototype.slice.call(arguments);\n  return nums.reduce((total, num) => total + num, 0);\n}\n\n// ES6 写法：用 ...nums 直接收齐所有参数，省事\nfunction sum2(...nums) {\n  return nums.reduce((total, num) => total + num, 0);\n}\n\nconsole.log(sum1(1, 2, 3)); // 输出 6\nconsole.log(sum2(1, 2, 3, 4)); // 输出 10（不管传多少个参数，都能搞定）\n```\n\n---\n\n## 扩展运算符：把数组 “拆” 成参数用\n扩展运算符和剩余参数是反过来的：剩余参数是“收”参数，扩展运算符是“拆”数组，把数组里的元素一个个拆出来当函数参数，再也不用写 `apply `了。\n- 核心特点：在数组前面加个 ...，就能直接展开成逗号分隔的参数。\n- 实用示例：\n```javascript\n// 场景 1：求数组最大值（ES5 得用 apply 绕一圈）\nconst arr = [10, 20, 5, 15];\nconsole.log(Math.max.apply(null, arr)); // ES5 写法：输出 20，看着就麻烦\nconsole.log(Math.max(...arr)); // ES6 写法：输出 20，直接拆数组，多简洁\n\n// 场景 2：合并数组\nconst arr1 = [1, 2];\nconst arr2 = [3, 4];\nconsole.log([...arr1, ...arr2]); // 输出 [1,2,3,4]，直接拼就行\n\n// 场景 3：给函数传数组参数\nfunction fn(a, b, c) {\n  return a + b + c;\n}\nconsole.log(fn(...[1, 2, 3])); // 输出 6（数组直接拆成 1、2、3 三个参数）\n```\n\n---\n\n## 箭头函数：写代码快到飞起，还解决 this 坑\n箭头函数绝对是 ES6 里最常用的扩展，不仅写法极简，还把普通函数最让人头疼的 this 指向问题给解决了，再也不用记各种 this 指向规则了。\n- 核心特点：\n  - 语法超简洁：`(参数) => 返回值`，不用写 function、return，甚至连大括号都能省（单条语句时）。\n  - 没有自己的 this：this 直接继承外层作用域的，不管怎么调用都不变。\n  - 不能当构造函数：没法用 `new` 关键字创建实例。\n  - 没有 arguments：想处理多个参数，直接用剩余参数就行。\n- 对比示例：\n```javascript\n// 场景 1：简单函数简写，一行搞定\nconst add1 = function(a, b) { // ES5 普通函数，写一堆字\n  return a + b;\n};\nconst add2 = (a, b) => a + b; // ES6 箭头函数，精简到极致\n\n// 场景 2：解决 this 指向的坑（以前写代码常踩的雷）\nconst obj = {\n  name: \"张三\",\n  age: 20,\n  // ES5 普通函数：this 会跟着调用方式变，太坑了\n  sayHi1: function() {\n    setTimeout(function() {\n      console.log(`我是 ${this.name}`); // 输出 \"我是 undefined\"（this 指向 window 了）\n    }, 100);\n  },\n  // ES6 箭头函数：this 直接继承外层的 obj，稳得很\n  sayHi2: function() {\n    setTimeout(() => {\n      console.log(`我是 ${this.name}`); // 输出 \"我是 张三\"（this 一直指向 obj）\n    }, 100);\n  }\n};\nobj.sayHi1();\nobj.sayHi2();\n```\n\n---\n\n## 参数解构：直接“拆”对象/数组当参数\n有时候函数参数是个对象或数组，以前得先在函数里手动提取属性，写起来很啰嗦。ES6 能直接在参数列表里解构，把需要的属性或元素直接拿出来用。\n- 实用示例：\n```javascript\n// 场景 1：解构对象参数，还能设默认值\nfunction printUser({ name, age = 18 }) { // 直接提取 name 和 age，age 没传就用 18\n  console.log(`姓名：${name}，年龄：${age}`);\n}\nprintUser({ name: \"李四\" }); // 输出 \"姓名：李四，年龄：18\"（age 用默认值）\nprintUser({ name: \"王五\", age: 25 }); // 输出 \"姓名：王五，年龄：25\"\n\n// 场景 2：解构数组参数\nfunction printPoint([x, y]) { // 直接提取数组的前两个元素当 x 和 y\n  console.log(`坐标：(${x}, ${y})`);\n}\nprintPoint([10, 20]); // 输出 \"坐标：(10, 20)\"\n```\n\n---\n\n## name 属性优化：函数名字更靠谱了\n以前函数的 `name` 属性不太准，调试的时候容易 confusion。ES6 把这个问题修好了，函数名字能准确显示，调试起来更方便。\n- 对比示例：\n```javascript\n// ES5：匿名函数赋值给变量，name 是空字符串，调试找不到\nconst fn1 = function() {};\nconsole.log(fn1.name); // 输出 \"\"\n\n// ES6：匿名函数赋值给变量，name 就是变量名，一目了然\nconst fn2 = () => {};\nconsole.log(fn2.name); // 输出 \"fn2\"\n\n// 具名函数赋值，name 还是函数本身的名字\nconst fn3 = function myFn() {};\nconsole.log(fn3.name); // 输出 \"myFn\"\n```\n\n---\n\n## 总结：这些扩展该怎么用？\n- **箭头函数优先用**：写简单逻辑、怕 this 出错的时候，直接用箭头函数，省心又快捷。\n- **参数默认值+解构**：传对象或数组当参数时，用解构+默认值，不用手动提属性，代码更干净。\n- **剩余参数替代 arguments**：处理多个参数时，剩余参数天生是数组，比 arguments 好用多了。\n- **扩展运算符多活用**：合并数组、给函数传数组参数时，用 ... 直接拆，比 apply 简洁太多。\n\n这些扩展本质上都是为了让代码更短、更好懂、少踩坑，现在前端开发里，这些写法早就成了标配，学会了能省不少事～\n\n**【往期精彩内容】**\n- [JavaScript ES6 中对象的拓展，你了解几个？](https://mp.weixin.qq.com/s/PTI3HGsfpDz4-GvRx0i9ew)\n- [Javascript高频面试点--ES6 数组新特性](https://mp.weixin.qq.com/s/qR65z8RbPFxW326UnogLqA)\n- [一文搞懂 JavaScript 里 var、let、const 的区别\n](https://mp.weixin.qq.com/s/lqn_51NNxx50YgvWkxCtEg)\n- [程序员如何打破职业瓶颈？先搬开这3块绊脚石。](https://mp.weixin.qq.com/s/DRpZXprnTndjKb1YMqsfjQ)\n- [深入理解 JavaScript 中的原型与原型链](https://mp.weixin.qq.com/s/2lcovAIzSptuidQNtlVPwg)\n","slug":"function-in-es6","published":1,"updated":"2025-12-06T04:47:41.765Z","comments":1,"layout":"post","photos":[],"_id":"cmjbml2ib001cikupdgd6706c","content":"<p>以前写 JavaScript 函数，真的有不少麻烦事：参数默认值得手动判断、处理多个参数要靠 <code>arguments</code> 瞎折腾、<code>this</code> 指向还老让人晕头转向。ES6 算是把这些痛点都补上了，给函数加了好多实用扩展，写代码又快又不容易踩坑。下面用大白话+简单例子，把这些功能讲明白，新手也能一看就会～</p>\n<h2 id=\"参数默认值：不用再写-“a-1”-啦\"><a href=\"#参数默认值：不用再写-“a-1”-啦\" class=\"headerlink\" title=\"参数默认值：不用再写 “a || 1” 啦\"></a>参数默认值：不用再写 “a || 1” 啦</h2><p>以前想给函数参数设默认值，得在函数里写一堆判断，又麻烦又容易出问题。ES6 直接允许在参数列表里写默认值，省事多了。</p>\n<ul>\n<li>核心特点：要是没传参数，或者传了个 <code>undefined</code>，就自动用默认值。</li>\n<li>对比示例：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// ES5 写法：得手动判断参数在不在</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fn1</span>(<span class=\"hljs-params\">a, b</span>) &#123;<br>  a = a || <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// 这里有个坑啊——要是你传个 a=0，它也会被改成 1</span><br>  b = b === <span class=\"hljs-literal\">undefined</span> ? <span class=\"hljs-number\">2</span> : b;<br>  <span class=\"hljs-keyword\">return</span> a + b;<br>&#125;<br><br><span class=\"hljs-comment\">// ES6 写法：直接在参数里设默认值，多直观</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fn2</span>(<span class=\"hljs-params\">a = <span class=\"hljs-number\">1</span>, b = <span class=\"hljs-number\">2</span></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> a + b;<br>&#125;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">fn2</span>()); <span class=\"hljs-comment\">// 输出 3（没传参数，直接用默认值 1 和 2）</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">fn2</span>(<span class=\"hljs-number\">3</span>)); <span class=\"hljs-comment\">// 输出 5（只传了 a=3，b 还是用默认值 2）</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">fn2</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>)); <span class=\"hljs-comment\">// 输出 0（传 0 也不会被替换，完美避开 ES5 的坑）</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h2 id=\"剩余参数：用-…-收齐所有剩余参数\"><a href=\"#剩余参数：用-…-收齐所有剩余参数\" class=\"headerlink\" title=\"剩余参数：用 … 收齐所有剩余参数\"></a>剩余参数：用 … 收齐所有剩余参数</h2><p>以前处理不确定个数的参数，得用 <code>arguments</code> 这个类数组，还得手动转成真正的数组才能用 <code>forEach</code>、<code>map</code> 这些方法，太折腾了。ES6 的剩余参数直接用 … 就能收齐所有参数，天生就是数组，不用额外处理。</p>\n<ul>\n<li>核心特点：只能放在参数列表最后，不管剩多少个参数，都能一次性接住。</li>\n<li>对比示例：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// ES5 写法：靠 arguments 处理多个参数，麻烦到家</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum1</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-comment\">// 先把类数组 arguments 转成真正的数组，才能用 reduce</span><br>  <span class=\"hljs-keyword\">const</span> nums = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">slice</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">arguments</span>);<br>  <span class=\"hljs-keyword\">return</span> nums.<span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">total, num</span>) =&gt;</span> total + num, <span class=\"hljs-number\">0</span>);<br>&#125;<br><br><span class=\"hljs-comment\">// ES6 写法：用 ...nums 直接收齐所有参数，省事</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum2</span>(<span class=\"hljs-params\">...nums</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> nums.<span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">total, num</span>) =&gt;</span> total + num, <span class=\"hljs-number\">0</span>);<br>&#125;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">sum1</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>)); <span class=\"hljs-comment\">// 输出 6</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">sum2</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>)); <span class=\"hljs-comment\">// 输出 10（不管传多少个参数，都能搞定）</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h2 id=\"扩展运算符：把数组-“拆”-成参数用\"><a href=\"#扩展运算符：把数组-“拆”-成参数用\" class=\"headerlink\" title=\"扩展运算符：把数组 “拆” 成参数用\"></a>扩展运算符：把数组 “拆” 成参数用</h2><p>扩展运算符和剩余参数是反过来的：剩余参数是“收”参数，扩展运算符是“拆”数组，把数组里的元素一个个拆出来当函数参数，再也不用写 <code>apply </code>了。</p>\n<ul>\n<li>核心特点：在数组前面加个 …，就能直接展开成逗号分隔的参数。</li>\n<li>实用示例：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 场景 1：求数组最大值（ES5 得用 apply 绕一圈）</span><br><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">15</span>];<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">max</span>.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-literal\">null</span>, arr)); <span class=\"hljs-comment\">// ES5 写法：输出 20，看着就麻烦</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">max</span>(...arr)); <span class=\"hljs-comment\">// ES6 写法：输出 20，直接拆数组，多简洁</span><br><br><span class=\"hljs-comment\">// 场景 2：合并数组</span><br><span class=\"hljs-keyword\">const</span> arr1 = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>];<br><span class=\"hljs-keyword\">const</span> arr2 = [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>];<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>([...arr1, ...arr2]); <span class=\"hljs-comment\">// 输出 [1,2,3,4]，直接拼就行</span><br><br><span class=\"hljs-comment\">// 场景 3：给函数传数组参数</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fn</span>(<span class=\"hljs-params\">a, b, c</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> a + b + c;<br>&#125;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">fn</span>(...[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>])); <span class=\"hljs-comment\">// 输出 6（数组直接拆成 1、2、3 三个参数）</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h2 id=\"箭头函数：写代码快到飞起，还解决-this-坑\"><a href=\"#箭头函数：写代码快到飞起，还解决-this-坑\" class=\"headerlink\" title=\"箭头函数：写代码快到飞起，还解决 this 坑\"></a>箭头函数：写代码快到飞起，还解决 this 坑</h2><p>箭头函数绝对是 ES6 里最常用的扩展，不仅写法极简，还把普通函数最让人头疼的 this 指向问题给解决了，再也不用记各种 this 指向规则了。</p>\n<ul>\n<li>核心特点：<ul>\n<li>语法超简洁：<code>(参数) =&gt; 返回值</code>，不用写 function、return，甚至连大括号都能省（单条语句时）。</li>\n<li>没有自己的 this：this 直接继承外层作用域的，不管怎么调用都不变。</li>\n<li>不能当构造函数：没法用 <code>new</code> 关键字创建实例。</li>\n<li>没有 arguments：想处理多个参数，直接用剩余参数就行。</li>\n</ul>\n</li>\n<li>对比示例：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 场景 1：简单函数简写，一行搞定</span><br><span class=\"hljs-keyword\">const</span> add1 = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">a, b</span>) &#123; <span class=\"hljs-comment\">// ES5 普通函数，写一堆字</span><br>  <span class=\"hljs-keyword\">return</span> a + b;<br>&#125;;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">add2</span> = (<span class=\"hljs-params\">a, b</span>) =&gt; a + b; <span class=\"hljs-comment\">// ES6 箭头函数，精简到极致</span><br><br><span class=\"hljs-comment\">// 场景 2：解决 this 指向的坑（以前写代码常踩的雷）</span><br><span class=\"hljs-keyword\">const</span> obj = &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;张三&quot;</span>,<br>  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">20</span>,<br>  <span class=\"hljs-comment\">// ES5 普通函数：this 会跟着调用方式变，太坑了</span><br>  <span class=\"hljs-attr\">sayHi1</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`我是 <span class=\"hljs-subst\">$&#123;<span class=\"hljs-variable language_\">this</span>.name&#125;</span>`</span>); <span class=\"hljs-comment\">// 输出 &quot;我是 undefined&quot;（this 指向 window 了）</span><br>    &#125;, <span class=\"hljs-number\">100</span>);<br>  &#125;,<br>  <span class=\"hljs-comment\">// ES6 箭头函数：this 直接继承外层的 obj，稳得很</span><br>  <span class=\"hljs-attr\">sayHi2</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`我是 <span class=\"hljs-subst\">$&#123;<span class=\"hljs-variable language_\">this</span>.name&#125;</span>`</span>); <span class=\"hljs-comment\">// 输出 &quot;我是 张三&quot;（this 一直指向 obj）</span><br>    &#125;, <span class=\"hljs-number\">100</span>);<br>  &#125;<br>&#125;;<br>obj.<span class=\"hljs-title function_\">sayHi1</span>();<br>obj.<span class=\"hljs-title function_\">sayHi2</span>();<br></code></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h2 id=\"参数解构：直接“拆”对象-数组当参数\"><a href=\"#参数解构：直接“拆”对象-数组当参数\" class=\"headerlink\" title=\"参数解构：直接“拆”对象&#x2F;数组当参数\"></a>参数解构：直接“拆”对象&#x2F;数组当参数</h2><p>有时候函数参数是个对象或数组，以前得先在函数里手动提取属性，写起来很啰嗦。ES6 能直接在参数列表里解构，把需要的属性或元素直接拿出来用。</p>\n<ul>\n<li>实用示例：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 场景 1：解构对象参数，还能设默认值</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">printUser</span>(<span class=\"hljs-params\">&#123; name, age = <span class=\"hljs-number\">18</span> &#125;</span>) &#123; <span class=\"hljs-comment\">// 直接提取 name 和 age，age 没传就用 18</span><br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`姓名：<span class=\"hljs-subst\">$&#123;name&#125;</span>，年龄：<span class=\"hljs-subst\">$&#123;age&#125;</span>`</span>);<br>&#125;<br><span class=\"hljs-title function_\">printUser</span>(&#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;李四&quot;</span> &#125;); <span class=\"hljs-comment\">// 输出 &quot;姓名：李四，年龄：18&quot;（age 用默认值）</span><br><span class=\"hljs-title function_\">printUser</span>(&#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;王五&quot;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">25</span> &#125;); <span class=\"hljs-comment\">// 输出 &quot;姓名：王五，年龄：25&quot;</span><br><br><span class=\"hljs-comment\">// 场景 2：解构数组参数</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">printPoint</span>(<span class=\"hljs-params\">[x, y]</span>) &#123; <span class=\"hljs-comment\">// 直接提取数组的前两个元素当 x 和 y</span><br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`坐标：(<span class=\"hljs-subst\">$&#123;x&#125;</span>, <span class=\"hljs-subst\">$&#123;y&#125;</span>)`</span>);<br>&#125;<br><span class=\"hljs-title function_\">printPoint</span>([<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>]); <span class=\"hljs-comment\">// 输出 &quot;坐标：(10, 20)&quot;</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h2 id=\"name-属性优化：函数名字更靠谱了\"><a href=\"#name-属性优化：函数名字更靠谱了\" class=\"headerlink\" title=\"name 属性优化：函数名字更靠谱了\"></a>name 属性优化：函数名字更靠谱了</h2><p>以前函数的 <code>name</code> 属性不太准，调试的时候容易 confusion。ES6 把这个问题修好了，函数名字能准确显示，调试起来更方便。</p>\n<ul>\n<li>对比示例：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// ES5：匿名函数赋值给变量，name 是空字符串，调试找不到</span><br><span class=\"hljs-keyword\">const</span> fn1 = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;&#125;;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(fn1.<span class=\"hljs-property\">name</span>); <span class=\"hljs-comment\">// 输出 &quot;&quot;</span><br><br><span class=\"hljs-comment\">// ES6：匿名函数赋值给变量，name 就是变量名，一目了然</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">fn2</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;&#125;;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(fn2.<span class=\"hljs-property\">name</span>); <span class=\"hljs-comment\">// 输出 &quot;fn2&quot;</span><br><br><span class=\"hljs-comment\">// 具名函数赋值，name 还是函数本身的名字</span><br><span class=\"hljs-keyword\">const</span> fn3 = <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">myFn</span>(<span class=\"hljs-params\"></span>) &#123;&#125;;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(fn3.<span class=\"hljs-property\">name</span>); <span class=\"hljs-comment\">// 输出 &quot;myFn&quot;</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h2 id=\"总结：这些扩展该怎么用？\"><a href=\"#总结：这些扩展该怎么用？\" class=\"headerlink\" title=\"总结：这些扩展该怎么用？\"></a>总结：这些扩展该怎么用？</h2><ul>\n<li><strong>箭头函数优先用</strong>：写简单逻辑、怕 this 出错的时候，直接用箭头函数，省心又快捷。</li>\n<li><strong>参数默认值+解构</strong>：传对象或数组当参数时，用解构+默认值，不用手动提属性，代码更干净。</li>\n<li><strong>剩余参数替代 arguments</strong>：处理多个参数时，剩余参数天生是数组，比 arguments 好用多了。</li>\n<li><strong>扩展运算符多活用</strong>：合并数组、给函数传数组参数时，用 … 直接拆，比 apply 简洁太多。</li>\n</ul>\n<p>这些扩展本质上都是为了让代码更短、更好懂、少踩坑，现在前端开发里，这些写法早就成了标配，学会了能省不少事～</p>\n<p><strong>【往期精彩内容】</strong></p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/PTI3HGsfpDz4-GvRx0i9ew\">JavaScript ES6 中对象的拓展，你了解几个？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/qR65z8RbPFxW326UnogLqA\">Javascript高频面试点–ES6 数组新特性</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/lqn_51NNxx50YgvWkxCtEg\">一文搞懂 JavaScript 里 var、let、const 的区别\n</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/DRpZXprnTndjKb1YMqsfjQ\">程序员如何打破职业瓶颈？先搬开这3块绊脚石。</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/2lcovAIzSptuidQNtlVPwg\">深入理解 JavaScript 中的原型与原型链</a></li>\n</ul>\n","excerpt":"","more":"<p>以前写 JavaScript 函数，真的有不少麻烦事：参数默认值得手动判断、处理多个参数要靠 <code>arguments</code> 瞎折腾、<code>this</code> 指向还老让人晕头转向。ES6 算是把这些痛点都补上了，给函数加了好多实用扩展，写代码又快又不容易踩坑。下面用大白话+简单例子，把这些功能讲明白，新手也能一看就会～</p>\n<h2 id=\"参数默认值：不用再写-“a-1”-啦\"><a href=\"#参数默认值：不用再写-“a-1”-啦\" class=\"headerlink\" title=\"参数默认值：不用再写 “a || 1” 啦\"></a>参数默认值：不用再写 “a || 1” 啦</h2><p>以前想给函数参数设默认值，得在函数里写一堆判断，又麻烦又容易出问题。ES6 直接允许在参数列表里写默认值，省事多了。</p>\n<ul>\n<li>核心特点：要是没传参数，或者传了个 <code>undefined</code>，就自动用默认值。</li>\n<li>对比示例：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// ES5 写法：得手动判断参数在不在</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fn1</span>(<span class=\"hljs-params\">a, b</span>) &#123;<br>  a = a || <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// 这里有个坑啊——要是你传个 a=0，它也会被改成 1</span><br>  b = b === <span class=\"hljs-literal\">undefined</span> ? <span class=\"hljs-number\">2</span> : b;<br>  <span class=\"hljs-keyword\">return</span> a + b;<br>&#125;<br><br><span class=\"hljs-comment\">// ES6 写法：直接在参数里设默认值，多直观</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fn2</span>(<span class=\"hljs-params\">a = <span class=\"hljs-number\">1</span>, b = <span class=\"hljs-number\">2</span></span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> a + b;<br>&#125;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">fn2</span>()); <span class=\"hljs-comment\">// 输出 3（没传参数，直接用默认值 1 和 2）</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">fn2</span>(<span class=\"hljs-number\">3</span>)); <span class=\"hljs-comment\">// 输出 5（只传了 a=3，b 还是用默认值 2）</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">fn2</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>)); <span class=\"hljs-comment\">// 输出 0（传 0 也不会被替换，完美避开 ES5 的坑）</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h2 id=\"剩余参数：用-…-收齐所有剩余参数\"><a href=\"#剩余参数：用-…-收齐所有剩余参数\" class=\"headerlink\" title=\"剩余参数：用 … 收齐所有剩余参数\"></a>剩余参数：用 … 收齐所有剩余参数</h2><p>以前处理不确定个数的参数，得用 <code>arguments</code> 这个类数组，还得手动转成真正的数组才能用 <code>forEach</code>、<code>map</code> 这些方法，太折腾了。ES6 的剩余参数直接用 … 就能收齐所有参数，天生就是数组，不用额外处理。</p>\n<ul>\n<li>核心特点：只能放在参数列表最后，不管剩多少个参数，都能一次性接住。</li>\n<li>对比示例：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// ES5 写法：靠 arguments 处理多个参数，麻烦到家</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum1</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-comment\">// 先把类数组 arguments 转成真正的数组，才能用 reduce</span><br>  <span class=\"hljs-keyword\">const</span> nums = <span class=\"hljs-title class_\">Array</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">slice</span>.<span class=\"hljs-title function_\">call</span>(<span class=\"hljs-variable language_\">arguments</span>);<br>  <span class=\"hljs-keyword\">return</span> nums.<span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">total, num</span>) =&gt;</span> total + num, <span class=\"hljs-number\">0</span>);<br>&#125;<br><br><span class=\"hljs-comment\">// ES6 写法：用 ...nums 直接收齐所有参数，省事</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">sum2</span>(<span class=\"hljs-params\">...nums</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> nums.<span class=\"hljs-title function_\">reduce</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">total, num</span>) =&gt;</span> total + num, <span class=\"hljs-number\">0</span>);<br>&#125;<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">sum1</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>)); <span class=\"hljs-comment\">// 输出 6</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">sum2</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>)); <span class=\"hljs-comment\">// 输出 10（不管传多少个参数，都能搞定）</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h2 id=\"扩展运算符：把数组-“拆”-成参数用\"><a href=\"#扩展运算符：把数组-“拆”-成参数用\" class=\"headerlink\" title=\"扩展运算符：把数组 “拆” 成参数用\"></a>扩展运算符：把数组 “拆” 成参数用</h2><p>扩展运算符和剩余参数是反过来的：剩余参数是“收”参数，扩展运算符是“拆”数组，把数组里的元素一个个拆出来当函数参数，再也不用写 <code>apply </code>了。</p>\n<ul>\n<li>核心特点：在数组前面加个 …，就能直接展开成逗号分隔的参数。</li>\n<li>实用示例：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 场景 1：求数组最大值（ES5 得用 apply 绕一圈）</span><br><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">15</span>];<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-property\">max</span>.<span class=\"hljs-title function_\">apply</span>(<span class=\"hljs-literal\">null</span>, arr)); <span class=\"hljs-comment\">// ES5 写法：输出 20，看着就麻烦</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">max</span>(...arr)); <span class=\"hljs-comment\">// ES6 写法：输出 20，直接拆数组，多简洁</span><br><br><span class=\"hljs-comment\">// 场景 2：合并数组</span><br><span class=\"hljs-keyword\">const</span> arr1 = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>];<br><span class=\"hljs-keyword\">const</span> arr2 = [<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>];<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>([...arr1, ...arr2]); <span class=\"hljs-comment\">// 输出 [1,2,3,4]，直接拼就行</span><br><br><span class=\"hljs-comment\">// 场景 3：给函数传数组参数</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">fn</span>(<span class=\"hljs-params\">a, b, c</span>) &#123;<br>  <span class=\"hljs-keyword\">return</span> a + b + c;<br>&#125;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">fn</span>(...[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>])); <span class=\"hljs-comment\">// 输出 6（数组直接拆成 1、2、3 三个参数）</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h2 id=\"箭头函数：写代码快到飞起，还解决-this-坑\"><a href=\"#箭头函数：写代码快到飞起，还解决-this-坑\" class=\"headerlink\" title=\"箭头函数：写代码快到飞起，还解决 this 坑\"></a>箭头函数：写代码快到飞起，还解决 this 坑</h2><p>箭头函数绝对是 ES6 里最常用的扩展，不仅写法极简，还把普通函数最让人头疼的 this 指向问题给解决了，再也不用记各种 this 指向规则了。</p>\n<ul>\n<li>核心特点：<ul>\n<li>语法超简洁：<code>(参数) =&gt; 返回值</code>，不用写 function、return，甚至连大括号都能省（单条语句时）。</li>\n<li>没有自己的 this：this 直接继承外层作用域的，不管怎么调用都不变。</li>\n<li>不能当构造函数：没法用 <code>new</code> 关键字创建实例。</li>\n<li>没有 arguments：想处理多个参数，直接用剩余参数就行。</li>\n</ul>\n</li>\n<li>对比示例：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 场景 1：简单函数简写，一行搞定</span><br><span class=\"hljs-keyword\">const</span> add1 = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">a, b</span>) &#123; <span class=\"hljs-comment\">// ES5 普通函数，写一堆字</span><br>  <span class=\"hljs-keyword\">return</span> a + b;<br>&#125;;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">add2</span> = (<span class=\"hljs-params\">a, b</span>) =&gt; a + b; <span class=\"hljs-comment\">// ES6 箭头函数，精简到极致</span><br><br><span class=\"hljs-comment\">// 场景 2：解决 this 指向的坑（以前写代码常踩的雷）</span><br><span class=\"hljs-keyword\">const</span> obj = &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;张三&quot;</span>,<br>  <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">20</span>,<br>  <span class=\"hljs-comment\">// ES5 普通函数：this 会跟着调用方式变，太坑了</span><br>  <span class=\"hljs-attr\">sayHi1</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`我是 <span class=\"hljs-subst\">$&#123;<span class=\"hljs-variable language_\">this</span>.name&#125;</span>`</span>); <span class=\"hljs-comment\">// 输出 &quot;我是 undefined&quot;（this 指向 window 了）</span><br>    &#125;, <span class=\"hljs-number\">100</span>);<br>  &#125;,<br>  <span class=\"hljs-comment\">// ES6 箭头函数：this 直接继承外层的 obj，稳得很</span><br>  <span class=\"hljs-attr\">sayHi2</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`我是 <span class=\"hljs-subst\">$&#123;<span class=\"hljs-variable language_\">this</span>.name&#125;</span>`</span>); <span class=\"hljs-comment\">// 输出 &quot;我是 张三&quot;（this 一直指向 obj）</span><br>    &#125;, <span class=\"hljs-number\">100</span>);<br>  &#125;<br>&#125;;<br>obj.<span class=\"hljs-title function_\">sayHi1</span>();<br>obj.<span class=\"hljs-title function_\">sayHi2</span>();<br></code></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h2 id=\"参数解构：直接“拆”对象-数组当参数\"><a href=\"#参数解构：直接“拆”对象-数组当参数\" class=\"headerlink\" title=\"参数解构：直接“拆”对象&#x2F;数组当参数\"></a>参数解构：直接“拆”对象&#x2F;数组当参数</h2><p>有时候函数参数是个对象或数组，以前得先在函数里手动提取属性，写起来很啰嗦。ES6 能直接在参数列表里解构，把需要的属性或元素直接拿出来用。</p>\n<ul>\n<li>实用示例：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 场景 1：解构对象参数，还能设默认值</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">printUser</span>(<span class=\"hljs-params\">&#123; name, age = <span class=\"hljs-number\">18</span> &#125;</span>) &#123; <span class=\"hljs-comment\">// 直接提取 name 和 age，age 没传就用 18</span><br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`姓名：<span class=\"hljs-subst\">$&#123;name&#125;</span>，年龄：<span class=\"hljs-subst\">$&#123;age&#125;</span>`</span>);<br>&#125;<br><span class=\"hljs-title function_\">printUser</span>(&#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;李四&quot;</span> &#125;); <span class=\"hljs-comment\">// 输出 &quot;姓名：李四，年龄：18&quot;（age 用默认值）</span><br><span class=\"hljs-title function_\">printUser</span>(&#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;王五&quot;</span>, <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">25</span> &#125;); <span class=\"hljs-comment\">// 输出 &quot;姓名：王五，年龄：25&quot;</span><br><br><span class=\"hljs-comment\">// 场景 2：解构数组参数</span><br><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">printPoint</span>(<span class=\"hljs-params\">[x, y]</span>) &#123; <span class=\"hljs-comment\">// 直接提取数组的前两个元素当 x 和 y</span><br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`坐标：(<span class=\"hljs-subst\">$&#123;x&#125;</span>, <span class=\"hljs-subst\">$&#123;y&#125;</span>)`</span>);<br>&#125;<br><span class=\"hljs-title function_\">printPoint</span>([<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">20</span>]); <span class=\"hljs-comment\">// 输出 &quot;坐标：(10, 20)&quot;</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h2 id=\"name-属性优化：函数名字更靠谱了\"><a href=\"#name-属性优化：函数名字更靠谱了\" class=\"headerlink\" title=\"name 属性优化：函数名字更靠谱了\"></a>name 属性优化：函数名字更靠谱了</h2><p>以前函数的 <code>name</code> 属性不太准，调试的时候容易 confusion。ES6 把这个问题修好了，函数名字能准确显示，调试起来更方便。</p>\n<ul>\n<li>对比示例：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// ES5：匿名函数赋值给变量，name 是空字符串，调试找不到</span><br><span class=\"hljs-keyword\">const</span> fn1 = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;&#125;;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(fn1.<span class=\"hljs-property\">name</span>); <span class=\"hljs-comment\">// 输出 &quot;&quot;</span><br><br><span class=\"hljs-comment\">// ES6：匿名函数赋值给变量，name 就是变量名，一目了然</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">fn2</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;&#125;;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(fn2.<span class=\"hljs-property\">name</span>); <span class=\"hljs-comment\">// 输出 &quot;fn2&quot;</span><br><br><span class=\"hljs-comment\">// 具名函数赋值，name 还是函数本身的名字</span><br><span class=\"hljs-keyword\">const</span> fn3 = <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">myFn</span>(<span class=\"hljs-params\"></span>) &#123;&#125;;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(fn3.<span class=\"hljs-property\">name</span>); <span class=\"hljs-comment\">// 输出 &quot;myFn&quot;</span><br></code></pre></td></tr></table></figure></li>\n</ul>\n<hr>\n<h2 id=\"总结：这些扩展该怎么用？\"><a href=\"#总结：这些扩展该怎么用？\" class=\"headerlink\" title=\"总结：这些扩展该怎么用？\"></a>总结：这些扩展该怎么用？</h2><ul>\n<li><strong>箭头函数优先用</strong>：写简单逻辑、怕 this 出错的时候，直接用箭头函数，省心又快捷。</li>\n<li><strong>参数默认值+解构</strong>：传对象或数组当参数时，用解构+默认值，不用手动提属性，代码更干净。</li>\n<li><strong>剩余参数替代 arguments</strong>：处理多个参数时，剩余参数天生是数组，比 arguments 好用多了。</li>\n<li><strong>扩展运算符多活用</strong>：合并数组、给函数传数组参数时，用 … 直接拆，比 apply 简洁太多。</li>\n</ul>\n<p>这些扩展本质上都是为了让代码更短、更好懂、少踩坑，现在前端开发里，这些写法早就成了标配，学会了能省不少事～</p>\n<p><strong>【往期精彩内容】</strong></p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/PTI3HGsfpDz4-GvRx0i9ew\">JavaScript ES6 中对象的拓展，你了解几个？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/qR65z8RbPFxW326UnogLqA\">Javascript高频面试点–ES6 数组新特性</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/lqn_51NNxx50YgvWkxCtEg\">一文搞懂 JavaScript 里 var、let、const 的区别\n</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/DRpZXprnTndjKb1YMqsfjQ\">程序员如何打破职业瓶颈？先搬开这3块绊脚石。</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/2lcovAIzSptuidQNtlVPwg\">深入理解 JavaScript 中的原型与原型链</a></li>\n</ul>\n"},{"title":"搞前端还有出路吗？如果有，在哪里？","date":"2025-07-28T10:25:42.000Z","keywords":["前端开发，职业规划"],"banner_img":"/imgs/feature-of-fe/design.jpg","index_img":"/imgs/feature-of-fe/design.jpg","_content":"\n写代码对我来说是一件很开心的事，通过写代码来糊口，也算得上是一件很幸运的事了。但工作的时间久了，一些危机感和职业的通病，多多少少也会暴露出来。\n\n从毕业到现在5年多了，算上加班，凑个7年工作经验，应该不算过分。\n\n写前端写得越久，人往往也容易麻木。有时候在想，这玩意也算是个体力活吧，找个稍微动打字的人，学习两个多礼拜，也能上手啊。\n\n这么想的人，必定不止我一人。\n\n\n## 在互联网公司也是打螺丝\n\n就现在的Web开发而言，一个项目脚手架，渲染框架，状态管理，路由等等，几乎所有的东西都已经实现了模块化以及灵活集成。而开发者需要做的，就像是小孩子给格子涂颜色一样，给指定的格子涂上颜色，工作内容本身，并没有多大的难度。\n\n“面试造火箭，上班打螺丝”，这还真不是句玩笑话。面试时的各种性能优化方式，代码规范，还有算法等等，基本上都是白扯。说到组件封装，很多时候都是个人自嗨。相似的功能，在不同的项目或者页面中却是高度定制化的，甚至在设计风格上都无法保持一致，再谈封装，多少有点自讨没趣。\n\n![design](https://www.jvxiao.cn/imgs/feature-of-fe/design.jpg)\n\n前端开发被叫成 “切图仔” 不是没有道理的，长期的、重复性的写高度相似的东西，个人能力无法得到提升，而且还容易陷入舒适圈，当然了，舒适圈没什么不好的，就是跳槽时会痛苦一些。\n\n\n## 现在搞前端，还有搞头么？\n\n就现在的情况来说，虽然说整个就业大环境不是很好，但类似金融，互联网这类的行业的就业质量还是可以的，至少 “窝囊费” 多一些。\n像前端开发这一块，不管是传统行业还是互联网公司，都需要通过网站、移动应用程序等数字化平台来展示产品和服务，对前端开发人员的需求还是比较旺盛的。\n\n![](https://www.jvxiao.cn/imgs//feature-of-fe/code.jpg)\n\n从个人编程体验来说，前端的编程体验是优于后端。你写的东西，能够在视觉层面立马呈现出来，好看还是不好看，交互是否友好，都是能够立即感受到的。\n\n此外，对于喜欢自己捣鼓一些小程序，App之类的小伙伴来说，搞前端上手相对来说比较快一些，成就感会强一些。\n\n\n## 老前端开发可以往哪些方向走？\n\n**低代码 / 零代码平台开发方向**：个人觉得这个东西比较鸡肋，但奈何几乎稍微大一点的公司，都会要求要搞一套自己的低代码或零代码平台。至于能不能用，好不好用，有没有人用，不重要的，重要的是要有。既然有这样离谱的需求，又给钱了，不妨试试。\n\n**跨平台与多端融合方向**：一套代码多端运行，这样的需求在未来很长一段时间都会比较旺盛，未来很多App都将会依托平台来进行开发，比如抖音小程序，微信小程序，快手小程序等等，使用多端融合技术，减少开发工作量。像 React Native, Flutter, Tauri 等框架在这一块做得还是不错的，社区氛围也不错。\n\n![](https://www.jvxiao.cn/imgs//feature-of-fe/tauri.png)\n\n**微前端架构方向**：微前端在大型项目中的应用会越来越多，这种架构方式能够实现多个团队独立开发和部署，提高协作效率。你需要掌握 Module Federation 等技术，实现更好的组件化和模块化管理，适应大型复杂项目的开发需求。\n\n**音视频组件开发**：这个还是有搞头的，圈子里有一些在大厂的朋友有好些个都是在做这方面的开发。音视频组件开发是前端领域中专业性强、需求旺盛的细分方向，尤其在直播、短视频、在线会议、在线教育等场景爆发的当下，相关技术人才缺口较大，发展前景广阔，这个还是值得一试的。\n\n## 写在最后\n\n个人觉得，如果你是一个新人，需要找一份开发相关的工作，个人觉得前端开发还是算不错。而如果你是一个老前端开发，在工作这么多年之后，开始进入舒适区，亦或者有危机感了，那么不妨尝试着在新的方向探索了。\n\n在当前的就业环境下，不建议频繁跳槽搞钱，毕竟打工发财是不现实的。有一份工作，能够养家糊口，上班偶尔还能摸摸鱼，差不多就可以了。大环境好的时候都搞不到钱，现在说要搞钱不是为难自己么？健康饮食，适当运动，保持一个好的身体，这就是在省钱了！\n\n扯远了...上述内容皆为个人观点，如有不同看法，欢迎评论区交流。\n","source":"_posts/future-of-front-end-development.md","raw":"---\ntitle: 搞前端还有出路吗？如果有，在哪里？\ndate: 2025-07-28 18:25:42\ntags: 前端开发\nkeywords: [前端开发，职业规划]\ncategory: Web开发\nbanner_img: /imgs/feature-of-fe/design.jpg\nindex_img: /imgs/feature-of-fe/design.jpg\n---\n\n写代码对我来说是一件很开心的事，通过写代码来糊口，也算得上是一件很幸运的事了。但工作的时间久了，一些危机感和职业的通病，多多少少也会暴露出来。\n\n从毕业到现在5年多了，算上加班，凑个7年工作经验，应该不算过分。\n\n写前端写得越久，人往往也容易麻木。有时候在想，这玩意也算是个体力活吧，找个稍微动打字的人，学习两个多礼拜，也能上手啊。\n\n这么想的人，必定不止我一人。\n\n\n## 在互联网公司也是打螺丝\n\n就现在的Web开发而言，一个项目脚手架，渲染框架，状态管理，路由等等，几乎所有的东西都已经实现了模块化以及灵活集成。而开发者需要做的，就像是小孩子给格子涂颜色一样，给指定的格子涂上颜色，工作内容本身，并没有多大的难度。\n\n“面试造火箭，上班打螺丝”，这还真不是句玩笑话。面试时的各种性能优化方式，代码规范，还有算法等等，基本上都是白扯。说到组件封装，很多时候都是个人自嗨。相似的功能，在不同的项目或者页面中却是高度定制化的，甚至在设计风格上都无法保持一致，再谈封装，多少有点自讨没趣。\n\n![design](https://www.jvxiao.cn/imgs/feature-of-fe/design.jpg)\n\n前端开发被叫成 “切图仔” 不是没有道理的，长期的、重复性的写高度相似的东西，个人能力无法得到提升，而且还容易陷入舒适圈，当然了，舒适圈没什么不好的，就是跳槽时会痛苦一些。\n\n\n## 现在搞前端，还有搞头么？\n\n就现在的情况来说，虽然说整个就业大环境不是很好，但类似金融，互联网这类的行业的就业质量还是可以的，至少 “窝囊费” 多一些。\n像前端开发这一块，不管是传统行业还是互联网公司，都需要通过网站、移动应用程序等数字化平台来展示产品和服务，对前端开发人员的需求还是比较旺盛的。\n\n![](https://www.jvxiao.cn/imgs//feature-of-fe/code.jpg)\n\n从个人编程体验来说，前端的编程体验是优于后端。你写的东西，能够在视觉层面立马呈现出来，好看还是不好看，交互是否友好，都是能够立即感受到的。\n\n此外，对于喜欢自己捣鼓一些小程序，App之类的小伙伴来说，搞前端上手相对来说比较快一些，成就感会强一些。\n\n\n## 老前端开发可以往哪些方向走？\n\n**低代码 / 零代码平台开发方向**：个人觉得这个东西比较鸡肋，但奈何几乎稍微大一点的公司，都会要求要搞一套自己的低代码或零代码平台。至于能不能用，好不好用，有没有人用，不重要的，重要的是要有。既然有这样离谱的需求，又给钱了，不妨试试。\n\n**跨平台与多端融合方向**：一套代码多端运行，这样的需求在未来很长一段时间都会比较旺盛，未来很多App都将会依托平台来进行开发，比如抖音小程序，微信小程序，快手小程序等等，使用多端融合技术，减少开发工作量。像 React Native, Flutter, Tauri 等框架在这一块做得还是不错的，社区氛围也不错。\n\n![](https://www.jvxiao.cn/imgs//feature-of-fe/tauri.png)\n\n**微前端架构方向**：微前端在大型项目中的应用会越来越多，这种架构方式能够实现多个团队独立开发和部署，提高协作效率。你需要掌握 Module Federation 等技术，实现更好的组件化和模块化管理，适应大型复杂项目的开发需求。\n\n**音视频组件开发**：这个还是有搞头的，圈子里有一些在大厂的朋友有好些个都是在做这方面的开发。音视频组件开发是前端领域中专业性强、需求旺盛的细分方向，尤其在直播、短视频、在线会议、在线教育等场景爆发的当下，相关技术人才缺口较大，发展前景广阔，这个还是值得一试的。\n\n## 写在最后\n\n个人觉得，如果你是一个新人，需要找一份开发相关的工作，个人觉得前端开发还是算不错。而如果你是一个老前端开发，在工作这么多年之后，开始进入舒适区，亦或者有危机感了，那么不妨尝试着在新的方向探索了。\n\n在当前的就业环境下，不建议频繁跳槽搞钱，毕竟打工发财是不现实的。有一份工作，能够养家糊口，上班偶尔还能摸摸鱼，差不多就可以了。大环境好的时候都搞不到钱，现在说要搞钱不是为难自己么？健康饮食，适当运动，保持一个好的身体，这就是在省钱了！\n\n扯远了...上述内容皆为个人观点，如有不同看法，欢迎评论区交流。\n","slug":"future-of-front-end-development","published":1,"updated":"2025-08-26T10:36:13.808Z","comments":1,"layout":"post","photos":[],"_id":"cmjbml2ic001gikup3bt80b06","content":"<p>写代码对我来说是一件很开心的事，通过写代码来糊口，也算得上是一件很幸运的事了。但工作的时间久了，一些危机感和职业的通病，多多少少也会暴露出来。</p>\n<p>从毕业到现在5年多了，算上加班，凑个7年工作经验，应该不算过分。</p>\n<p>写前端写得越久，人往往也容易麻木。有时候在想，这玩意也算是个体力活吧，找个稍微动打字的人，学习两个多礼拜，也能上手啊。</p>\n<p>这么想的人，必定不止我一人。</p>\n<h2 id=\"在互联网公司也是打螺丝\"><a href=\"#在互联网公司也是打螺丝\" class=\"headerlink\" title=\"在互联网公司也是打螺丝\"></a>在互联网公司也是打螺丝</h2><p>就现在的Web开发而言，一个项目脚手架，渲染框架，状态管理，路由等等，几乎所有的东西都已经实现了模块化以及灵活集成。而开发者需要做的，就像是小孩子给格子涂颜色一样，给指定的格子涂上颜色，工作内容本身，并没有多大的难度。</p>\n<p>“面试造火箭，上班打螺丝”，这还真不是句玩笑话。面试时的各种性能优化方式，代码规范，还有算法等等，基本上都是白扯。说到组件封装，很多时候都是个人自嗨。相似的功能，在不同的项目或者页面中却是高度定制化的，甚至在设计风格上都无法保持一致，再谈封装，多少有点自讨没趣。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/feature-of-fe/design.jpg\" alt=\"design\"></p>\n<p>前端开发被叫成 “切图仔” 不是没有道理的，长期的、重复性的写高度相似的东西，个人能力无法得到提升，而且还容易陷入舒适圈，当然了，舒适圈没什么不好的，就是跳槽时会痛苦一些。</p>\n<h2 id=\"现在搞前端，还有搞头么？\"><a href=\"#现在搞前端，还有搞头么？\" class=\"headerlink\" title=\"现在搞前端，还有搞头么？\"></a>现在搞前端，还有搞头么？</h2><p>就现在的情况来说，虽然说整个就业大环境不是很好，但类似金融，互联网这类的行业的就业质量还是可以的，至少 “窝囊费” 多一些。<br>像前端开发这一块，不管是传统行业还是互联网公司，都需要通过网站、移动应用程序等数字化平台来展示产品和服务，对前端开发人员的需求还是比较旺盛的。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs//feature-of-fe/code.jpg\"></p>\n<p>从个人编程体验来说，前端的编程体验是优于后端。你写的东西，能够在视觉层面立马呈现出来，好看还是不好看，交互是否友好，都是能够立即感受到的。</p>\n<p>此外，对于喜欢自己捣鼓一些小程序，App之类的小伙伴来说，搞前端上手相对来说比较快一些，成就感会强一些。</p>\n<h2 id=\"老前端开发可以往哪些方向走？\"><a href=\"#老前端开发可以往哪些方向走？\" class=\"headerlink\" title=\"老前端开发可以往哪些方向走？\"></a>老前端开发可以往哪些方向走？</h2><p><strong>低代码 &#x2F; 零代码平台开发方向</strong>：个人觉得这个东西比较鸡肋，但奈何几乎稍微大一点的公司，都会要求要搞一套自己的低代码或零代码平台。至于能不能用，好不好用，有没有人用，不重要的，重要的是要有。既然有这样离谱的需求，又给钱了，不妨试试。</p>\n<p><strong>跨平台与多端融合方向</strong>：一套代码多端运行，这样的需求在未来很长一段时间都会比较旺盛，未来很多App都将会依托平台来进行开发，比如抖音小程序，微信小程序，快手小程序等等，使用多端融合技术，减少开发工作量。像 React Native, Flutter, Tauri 等框架在这一块做得还是不错的，社区氛围也不错。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs//feature-of-fe/tauri.png\"></p>\n<p><strong>微前端架构方向</strong>：微前端在大型项目中的应用会越来越多，这种架构方式能够实现多个团队独立开发和部署，提高协作效率。你需要掌握 Module Federation 等技术，实现更好的组件化和模块化管理，适应大型复杂项目的开发需求。</p>\n<p><strong>音视频组件开发</strong>：这个还是有搞头的，圈子里有一些在大厂的朋友有好些个都是在做这方面的开发。音视频组件开发是前端领域中专业性强、需求旺盛的细分方向，尤其在直播、短视频、在线会议、在线教育等场景爆发的当下，相关技术人才缺口较大，发展前景广阔，这个还是值得一试的。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>个人觉得，如果你是一个新人，需要找一份开发相关的工作，个人觉得前端开发还是算不错。而如果你是一个老前端开发，在工作这么多年之后，开始进入舒适区，亦或者有危机感了，那么不妨尝试着在新的方向探索了。</p>\n<p>在当前的就业环境下，不建议频繁跳槽搞钱，毕竟打工发财是不现实的。有一份工作，能够养家糊口，上班偶尔还能摸摸鱼，差不多就可以了。大环境好的时候都搞不到钱，现在说要搞钱不是为难自己么？健康饮食，适当运动，保持一个好的身体，这就是在省钱了！</p>\n<p>扯远了…上述内容皆为个人观点，如有不同看法，欢迎评论区交流。</p>\n","excerpt":"","more":"<p>写代码对我来说是一件很开心的事，通过写代码来糊口，也算得上是一件很幸运的事了。但工作的时间久了，一些危机感和职业的通病，多多少少也会暴露出来。</p>\n<p>从毕业到现在5年多了，算上加班，凑个7年工作经验，应该不算过分。</p>\n<p>写前端写得越久，人往往也容易麻木。有时候在想，这玩意也算是个体力活吧，找个稍微动打字的人，学习两个多礼拜，也能上手啊。</p>\n<p>这么想的人，必定不止我一人。</p>\n<h2 id=\"在互联网公司也是打螺丝\"><a href=\"#在互联网公司也是打螺丝\" class=\"headerlink\" title=\"在互联网公司也是打螺丝\"></a>在互联网公司也是打螺丝</h2><p>就现在的Web开发而言，一个项目脚手架，渲染框架，状态管理，路由等等，几乎所有的东西都已经实现了模块化以及灵活集成。而开发者需要做的，就像是小孩子给格子涂颜色一样，给指定的格子涂上颜色，工作内容本身，并没有多大的难度。</p>\n<p>“面试造火箭，上班打螺丝”，这还真不是句玩笑话。面试时的各种性能优化方式，代码规范，还有算法等等，基本上都是白扯。说到组件封装，很多时候都是个人自嗨。相似的功能，在不同的项目或者页面中却是高度定制化的，甚至在设计风格上都无法保持一致，再谈封装，多少有点自讨没趣。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/feature-of-fe/design.jpg\" alt=\"design\"></p>\n<p>前端开发被叫成 “切图仔” 不是没有道理的，长期的、重复性的写高度相似的东西，个人能力无法得到提升，而且还容易陷入舒适圈，当然了，舒适圈没什么不好的，就是跳槽时会痛苦一些。</p>\n<h2 id=\"现在搞前端，还有搞头么？\"><a href=\"#现在搞前端，还有搞头么？\" class=\"headerlink\" title=\"现在搞前端，还有搞头么？\"></a>现在搞前端，还有搞头么？</h2><p>就现在的情况来说，虽然说整个就业大环境不是很好，但类似金融，互联网这类的行业的就业质量还是可以的，至少 “窝囊费” 多一些。<br>像前端开发这一块，不管是传统行业还是互联网公司，都需要通过网站、移动应用程序等数字化平台来展示产品和服务，对前端开发人员的需求还是比较旺盛的。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs//feature-of-fe/code.jpg\"></p>\n<p>从个人编程体验来说，前端的编程体验是优于后端。你写的东西，能够在视觉层面立马呈现出来，好看还是不好看，交互是否友好，都是能够立即感受到的。</p>\n<p>此外，对于喜欢自己捣鼓一些小程序，App之类的小伙伴来说，搞前端上手相对来说比较快一些，成就感会强一些。</p>\n<h2 id=\"老前端开发可以往哪些方向走？\"><a href=\"#老前端开发可以往哪些方向走？\" class=\"headerlink\" title=\"老前端开发可以往哪些方向走？\"></a>老前端开发可以往哪些方向走？</h2><p><strong>低代码 &#x2F; 零代码平台开发方向</strong>：个人觉得这个东西比较鸡肋，但奈何几乎稍微大一点的公司，都会要求要搞一套自己的低代码或零代码平台。至于能不能用，好不好用，有没有人用，不重要的，重要的是要有。既然有这样离谱的需求，又给钱了，不妨试试。</p>\n<p><strong>跨平台与多端融合方向</strong>：一套代码多端运行，这样的需求在未来很长一段时间都会比较旺盛，未来很多App都将会依托平台来进行开发，比如抖音小程序，微信小程序，快手小程序等等，使用多端融合技术，减少开发工作量。像 React Native, Flutter, Tauri 等框架在这一块做得还是不错的，社区氛围也不错。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs//feature-of-fe/tauri.png\"></p>\n<p><strong>微前端架构方向</strong>：微前端在大型项目中的应用会越来越多，这种架构方式能够实现多个团队独立开发和部署，提高协作效率。你需要掌握 Module Federation 等技术，实现更好的组件化和模块化管理，适应大型复杂项目的开发需求。</p>\n<p><strong>音视频组件开发</strong>：这个还是有搞头的，圈子里有一些在大厂的朋友有好些个都是在做这方面的开发。音视频组件开发是前端领域中专业性强、需求旺盛的细分方向，尤其在直播、短视频、在线会议、在线教育等场景爆发的当下，相关技术人才缺口较大，发展前景广阔，这个还是值得一试的。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>个人觉得，如果你是一个新人，需要找一份开发相关的工作，个人觉得前端开发还是算不错。而如果你是一个老前端开发，在工作这么多年之后，开始进入舒适区，亦或者有危机感了，那么不妨尝试着在新的方向探索了。</p>\n<p>在当前的就业环境下，不建议频繁跳槽搞钱，毕竟打工发财是不现实的。有一份工作，能够养家糊口，上班偶尔还能摸摸鱼，差不多就可以了。大环境好的时候都搞不到钱，现在说要搞钱不是为难自己么？健康饮食，适当运动，保持一个好的身体，这就是在省钱了！</p>\n<p>扯远了…上述内容皆为个人观点，如有不同看法，欢迎评论区交流。</p>\n"},{"title":"从 Vuex 到 Pinia：Vue 3 状态管理的全面升级","date":"2025-07-01T13:51:10.000Z","keywords":["Vuex","Pinia","Vue"],"banner_img":"/imgs/baners/pinia.png","index_img":"/imgs/baners/pinia.png","_content":"\n\n在Vue 3的“江湖”里，状态管理这块可是发生了大变化！当咱们从Vue 2“升级打怪”到Vue 3，以前常用的Vuex逐渐被更“香”的Pinia替代了。今天就来唠唠Vuex和Pinia到底有啥不一样，帮大家轻松拿捏新的状态管理姿势！\n\n\n## 1. API风格与设计：告别繁琐，拥抱简洁\nVuex就像个“老学究”，用的是类似Redux的那一套，非得让开发者把逻辑按`mutations`、`actions`、`getters`这些规矩分好类。虽然确实规范，但写起代码来可太啰嗦了，一堆模板代码看着就头大！  \n\nPinia就不一样，它紧跟Vue 3的“潮流”，用组合式API设计，直接把`mutations`“踢出局”（只保留`state`、`getters`、`actions`）。代码一下子变得超扁平、超直观，再也不用为那些复杂的条条框框费脑筋，开发起来轻松多啦！\n\n\n## 2. TypeScript支持：天生适配，用着超爽\n要是你用Vuex搭配TypeScript，那可得费点劲！得额外捣鼓不少配置和类型定义，不然根本用不顺手，就像给自行车硬装上火箭发动机，麻烦得很。  \n\nPinia可就贴心多了，它对TypeScript是“真爱”，天生适配！在定义store的时候，类型直接就能自动推导出来，完全不用手动写那些复杂的类型声明。这就好比有个贴心小助手，帮你把繁琐的活儿都干了，开发效率直接起飞，代码的安全性也拉满！\n\n\n## 3. 代码结构：新旧语法大PK\n先看看Vuex的store代码长啥样：  \n```javascript\n// Vuex store示例\nexport default new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment(state) {\n      state.count++;\n    }\n  },\n  actions: {\n    incrementAsync({ commit }) {\n      setTimeout(() => commit('increment'), 1000);\n    }\n  },\n  getters: {\n    doubleCount: state => state.count * 2\n  }\n});\n```  \n\n再瞅瞅Pinia的：  \n```javascript\n// Pinia store示例\nimport { defineStore } from 'pinia';\n\nexport const useCounterStore = defineStore('counter', {\n  state: () => ({\n    count: 0\n  }),\n  actions: {\n    increment() {\n      this.count++;\n    },\n    incrementAsync() {\n      setTimeout(() => this.increment(), 1000);\n    }\n  },\n  getters: {\n    doubleCount: state => state.count * 2\n  }\n});\n```  \n\n这么一对比，是不是瞬间觉得Pinia的代码清爽多了？没有那么多复杂的层级和重复的结构，就像把乱糟糟的房间收拾得整整齐齐，看着就舒服，写代码也更顺手！\n\n\n## 4. 响应式原理：Proxy带来的“黑科技”\nVuex用的是Vue 2的`Object.defineProperty`实现响应式，这就像给数据安了个“老旧监控”，在处理深层嵌套数据更新的时候，经常会“掉链子”，数据变了，视图却没反应，让人干着急。  \n\nPinia可就“高大上”了，它基于Vue 3的Proxy，相当于给数据配了个“智能管家”！不仅支持直接修改`state`，不用再走`mutations`那些弯弯绕绕，而且响应式超高效、超准确，数据一有风吹草动，它立马就能感知到，视图更新那叫一个快！\n\n\n## 5. 模块化方式：轻松管理，互不干扰\nVuex拆分store靠`modules`选项，但是模块之间的关系就像一团乱麻，命名空间管理起来也特别麻烦，稍不注意就容易“翻车”，把代码搞得一团糟。  \n\nPinia就聪明多了，每个store都是独立的“小个体”，用`defineStore`定义就行。模块之间井水不犯河水，完全解耦，命名空间也自动安排得明明白白。开发者管理起状态逻辑来，就像整理自己的小抽屉，想找啥一目了然，别提多轻松了！\n\n\n## 6. 插件系统：简单扩展，功能拉满\nVuex的插件机制复杂得很，开发者要是想实现点特定功能，就得自己写中间件或者插件，跟“造轮子”似的，费时又费力。  \n\nPinia的插件系统就“傻瓜式”多了，特别简洁明了。不管是扩展store功能，还是实现状态持久化，都超容易。比如用`pinia-plugin-persistedstate`插件，分分钟就能把状态存起来，就像用手机APP，点点按钮就能搞定，轻松实现功能自由！\n\n\n## 7. 与组合式API的集成：无缝配合，丝滑流畅\n在Vuex里想用组合式API？那得通过`useStore`获取store实例，写法又长又麻烦，就像绕了个大弯才能到达目的地。  \n\nPinia和组合式API简直是“最佳拍档”！直接在`setup`函数里调用`useStore()`就能拿到store，代码写起来行云流水，一点都不卡顿，用起来丝滑得不行！\n\n\n## 8. 开发工具支持：调试神器，效率翻倍\nVuex调试得靠Vue DevTools，但用起来总觉得差点意思，就像用一把不太顺手的钥匙开锁，费半天劲。  \n\nPinia和Vue DevTools那可是“深度绑定”！支持时间旅行调试，还能轻松追踪store变化。调试的时候就像拥有了“时光回溯”的超能力，哪里出问题一目了然，开发效率直接翻倍！\n\n\n## 9. 状态持久化：一键配置，轻松搞定\nVuex想实现状态持久化？得额外安装`vuex-persistedstate`插件，一顿操作猛如虎，才能把数据存起来。  \n\nPinia就简单多了，用`pinia-plugin-persistedstate`插件，简单配置一下，数据保存妥妥的，就像给数据加了个“保险箱”，一键操作，省心又省力！\n\n\n## 升级建议\n1. **慢慢过渡**：在Vue 3项目里，别着急把Vuex全换掉，可以Vuex和Pinia一起用，慢慢把旧的store迁移到Pinia，稳扎稳打，降低升级风险。  \n2. **整理代码**：把Vuex里的`mutations`合并到`actions`里，让代码结构更贴合Pinia的风格，就像给旧衣服改个新款式，焕然一新！  \n3. **用好组合式API**：充分发挥Pinia和组合式API的“CP”优势，用`setup`函数写代码，灵活安排逻辑，怎么方便怎么来！  \n4. **享受类型安全**：Pinia的类型推导超厉害，一定要好好利用，减少手动写类型声明的麻烦，让代码又快又安全！  \n\n\n从Vuex换成Pinia，可不只是换个工具那么简单，更是开发体验的大升级！Pinia凭借简洁的设计、强大的功能，还有对Vue 3的“完美适配”，妥妥成了Vue开发者状态管理的“新宠”。希望这篇文章能帮你快速上手Pinia，在Vue 3的开发路上一路“狂飙”！\n# 从Vuex到Pinia：Vue 3状态管理的全面升级\n\n家人们！在Vue 3的“江湖”里，状态管理这块可是发生了大变化！当咱们从Vue 2“升级打怪”到Vue 3，以前常用的Vuex逐渐被更“香”的Pinia替代了。今天就来唠唠Vuex和Pinia到底有啥不一样，帮大家轻松拿捏新的状态管理姿势！\n\n\n## 1. API风格与设计：告别繁琐，拥抱简洁\nVuex就像个“老学究”，用的是类似Redux的那一套，非得让开发者把逻辑按`mutations`、`actions`、`getters`这些规矩分好类。虽然确实规范，但写起代码来可太啰嗦了，一堆模板代码看着就头大！  \n\nPinia就不一样，它紧跟Vue 3的“潮流”，用组合式API设计，直接把`mutations`“踢出局”（只保留`state`、`getters`、`actions`）。代码一下子变得超扁平、超直观，再也不用为那些复杂的条条框框费脑筋，开发起来轻松多啦！\n\n\n## 2. TypeScript支持：天生适配，用着超爽\n要是你用Vuex搭配TypeScript，那可得费点劲！得额外捣鼓不少配置和类型定义，不然根本用不顺手，就像给自行车硬装上火箭发动机，麻烦得很。  \n\nPinia可就贴心多了，它对TypeScript是“真爱”，天生适配！在定义store的时候，类型直接就能自动推导出来，完全不用手动写那些复杂的类型声明。这就好比有个贴心小助手，帮你把繁琐的活儿都干了，开发效率直接起飞，代码的安全性也拉满！\n\n\n## 3. 代码结构：新旧语法大PK\n先看看Vuex的store代码长啥样：  \n```javascript\n// Vuex store示例\nexport default new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment(state) {\n      state.count++;\n    }\n  },\n  actions: {\n    incrementAsync({ commit }) {\n      setTimeout(() => commit('increment'), 1000);\n    }\n  },\n  getters: {\n    doubleCount: state => state.count * 2\n  }\n});\n```  \n\n再瞅瞅Pinia的：  \n```javascript\n// Pinia store示例\nimport { defineStore } from 'pinia';\n\nexport const useCounterStore = defineStore('counter', {\n  state: () => ({\n    count: 0\n  }),\n  actions: {\n    increment() {\n      this.count++;\n    },\n    incrementAsync() {\n      setTimeout(() => this.increment(), 1000);\n    }\n  },\n  getters: {\n    doubleCount: state => state.count * 2\n  }\n});\n```  \n\n这么一对比，是不是瞬间觉得Pinia的代码清爽多了？没有那么多复杂的层级和重复的结构，就像把乱糟糟的房间收拾得整整齐齐，看着就舒服，写代码也更顺手！\n\n\n## 4. 响应式原理：Proxy带来的“黑科技”\nVuex用的是Vue 2的`Object.defineProperty`实现响应式，这就像给数据安了个“老旧监控”，在处理深层嵌套数据更新的时候，经常会“掉链子”，数据变了，视图却没反应，让人干着急。  \n\nPinia可就“高大上”了，它基于Vue 3的Proxy，相当于给数据配了个“智能管家”！不仅支持直接修改`state`，不用再走`mutations`那些弯弯绕绕，而且响应式超高效、超准确，数据一有风吹草动，它立马就能感知到，视图更新那叫一个快！\n\n\n## 5. 模块化方式：轻松管理，互不干扰\nVuex拆分store靠`modules`选项，但是模块之间的关系就像一团乱麻，命名空间管理起来也特别麻烦，稍不注意就容易“翻车”，把代码搞得一团糟。  \n\nPinia就聪明多了，每个store都是独立的“小个体”，用`defineStore`定义就行。模块之间井水不犯河水，完全解耦，命名空间也自动安排得明明白白。开发者管理起状态逻辑来，就像整理自己的小抽屉，想找啥一目了然，别提多轻松了！\n\n\n## 6. 插件系统：简单扩展，功能拉满\nVuex的插件机制复杂得很，开发者要是想实现点特定功能，就得自己写中间件或者插件，跟“造轮子”似的，费时又费力。  \n\nPinia的插件系统就“傻瓜式”多了，特别简洁明了。不管是扩展store功能，还是实现状态持久化，都超容易。比如用`pinia-plugin-persistedstate`插件，分分钟就能把状态存起来，就像用手机APP，点点按钮就能搞定，轻松实现功能自由！\n\n\n## 7. 与组合式API的集成：无缝配合，丝滑流畅\n在Vuex里想用组合式API？那得通过`useStore`获取store实例，写法又长又麻烦，就像绕了个大弯才能到达目的地。  \n\nPinia和组合式API简直是“最佳拍档”！直接在`setup`函数里调用`useStore()`就能拿到store，代码写起来行云流水，一点都不卡顿，用起来丝滑得不行！\n\n\n## 8. 开发工具支持：调试神器，效率翻倍\nVuex调试得靠Vue DevTools，但用起来总觉得差点意思，就像用一把不太顺手的钥匙开锁，费半天劲。  \n\nPinia和Vue DevTools那可是“深度绑定”！支持时间旅行调试，还能轻松追踪store变化。调试的时候就像拥有了“时光回溯”的超能力，哪里出问题一目了然，开发效率直接翻倍！\n\n\n## 9. 状态持久化：一键配置，轻松搞定\nVuex想实现状态持久化？得额外安装`vuex-persistedstate`插件，一顿操作猛如虎，才能把数据存起来。  \n\nPinia就简单多了，用`pinia-plugin-persistedstate`插件，简单配置一下，数据保存妥妥的，就像给数据加了个“保险箱”，一键操作，省心又省力！\n\n\n## 升级建议\n1. **慢慢过渡**：在Vue 3项目里，别着急把Vuex全换掉，可以Vuex和Pinia一起用，慢慢把旧的store迁移到Pinia，稳扎稳打，降低升级风险。  \n2. **整理代码**：把Vuex里的`mutations`合并到`actions`里，让代码结构更贴合Pinia的风格，就像给旧衣服改个新款式，焕然一新！  \n3. **用好组合式API**：充分发挥Pinia和组合式API的“CP”优势，用`setup`函数写代码，灵活安排逻辑，怎么方便怎么来！  \n4. **享受类型安全**：Pinia的类型推导超厉害，一定要好好利用，减少手动写类型声明的麻烦，让代码又快又安全！  \n\n\n从Vuex换成Pinia，可不只是换个工具那么简单，更是开发体验的大升级！Pinia凭借简洁的设计、强大的功能，还有对Vue 3的“完美适配”，妥妥成了Vue开发者状态管理的“新宠”。希望这篇文章能帮你快速上手Pinia，在Vue 3的开发路上一路“狂飙”！","source":"_posts/from-vuex-to-pinia.md","raw":"---\ntitle: 从 Vuex 到 Pinia：Vue 3 状态管理的全面升级\ndate: 2025-07-01 21:51:10\ntags: [Vuex, Pinia, Vue]\nkeywords: [Vuex, Pinia, Vue]\ncategory: Web开发\nbanner_img: /imgs/baners/pinia.png\nindex_img: /imgs/baners/pinia.png\n---\n\n\n在Vue 3的“江湖”里，状态管理这块可是发生了大变化！当咱们从Vue 2“升级打怪”到Vue 3，以前常用的Vuex逐渐被更“香”的Pinia替代了。今天就来唠唠Vuex和Pinia到底有啥不一样，帮大家轻松拿捏新的状态管理姿势！\n\n\n## 1. API风格与设计：告别繁琐，拥抱简洁\nVuex就像个“老学究”，用的是类似Redux的那一套，非得让开发者把逻辑按`mutations`、`actions`、`getters`这些规矩分好类。虽然确实规范，但写起代码来可太啰嗦了，一堆模板代码看着就头大！  \n\nPinia就不一样，它紧跟Vue 3的“潮流”，用组合式API设计，直接把`mutations`“踢出局”（只保留`state`、`getters`、`actions`）。代码一下子变得超扁平、超直观，再也不用为那些复杂的条条框框费脑筋，开发起来轻松多啦！\n\n\n## 2. TypeScript支持：天生适配，用着超爽\n要是你用Vuex搭配TypeScript，那可得费点劲！得额外捣鼓不少配置和类型定义，不然根本用不顺手，就像给自行车硬装上火箭发动机，麻烦得很。  \n\nPinia可就贴心多了，它对TypeScript是“真爱”，天生适配！在定义store的时候，类型直接就能自动推导出来，完全不用手动写那些复杂的类型声明。这就好比有个贴心小助手，帮你把繁琐的活儿都干了，开发效率直接起飞，代码的安全性也拉满！\n\n\n## 3. 代码结构：新旧语法大PK\n先看看Vuex的store代码长啥样：  \n```javascript\n// Vuex store示例\nexport default new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment(state) {\n      state.count++;\n    }\n  },\n  actions: {\n    incrementAsync({ commit }) {\n      setTimeout(() => commit('increment'), 1000);\n    }\n  },\n  getters: {\n    doubleCount: state => state.count * 2\n  }\n});\n```  \n\n再瞅瞅Pinia的：  \n```javascript\n// Pinia store示例\nimport { defineStore } from 'pinia';\n\nexport const useCounterStore = defineStore('counter', {\n  state: () => ({\n    count: 0\n  }),\n  actions: {\n    increment() {\n      this.count++;\n    },\n    incrementAsync() {\n      setTimeout(() => this.increment(), 1000);\n    }\n  },\n  getters: {\n    doubleCount: state => state.count * 2\n  }\n});\n```  \n\n这么一对比，是不是瞬间觉得Pinia的代码清爽多了？没有那么多复杂的层级和重复的结构，就像把乱糟糟的房间收拾得整整齐齐，看着就舒服，写代码也更顺手！\n\n\n## 4. 响应式原理：Proxy带来的“黑科技”\nVuex用的是Vue 2的`Object.defineProperty`实现响应式，这就像给数据安了个“老旧监控”，在处理深层嵌套数据更新的时候，经常会“掉链子”，数据变了，视图却没反应，让人干着急。  \n\nPinia可就“高大上”了，它基于Vue 3的Proxy，相当于给数据配了个“智能管家”！不仅支持直接修改`state`，不用再走`mutations`那些弯弯绕绕，而且响应式超高效、超准确，数据一有风吹草动，它立马就能感知到，视图更新那叫一个快！\n\n\n## 5. 模块化方式：轻松管理，互不干扰\nVuex拆分store靠`modules`选项，但是模块之间的关系就像一团乱麻，命名空间管理起来也特别麻烦，稍不注意就容易“翻车”，把代码搞得一团糟。  \n\nPinia就聪明多了，每个store都是独立的“小个体”，用`defineStore`定义就行。模块之间井水不犯河水，完全解耦，命名空间也自动安排得明明白白。开发者管理起状态逻辑来，就像整理自己的小抽屉，想找啥一目了然，别提多轻松了！\n\n\n## 6. 插件系统：简单扩展，功能拉满\nVuex的插件机制复杂得很，开发者要是想实现点特定功能，就得自己写中间件或者插件，跟“造轮子”似的，费时又费力。  \n\nPinia的插件系统就“傻瓜式”多了，特别简洁明了。不管是扩展store功能，还是实现状态持久化，都超容易。比如用`pinia-plugin-persistedstate`插件，分分钟就能把状态存起来，就像用手机APP，点点按钮就能搞定，轻松实现功能自由！\n\n\n## 7. 与组合式API的集成：无缝配合，丝滑流畅\n在Vuex里想用组合式API？那得通过`useStore`获取store实例，写法又长又麻烦，就像绕了个大弯才能到达目的地。  \n\nPinia和组合式API简直是“最佳拍档”！直接在`setup`函数里调用`useStore()`就能拿到store，代码写起来行云流水，一点都不卡顿，用起来丝滑得不行！\n\n\n## 8. 开发工具支持：调试神器，效率翻倍\nVuex调试得靠Vue DevTools，但用起来总觉得差点意思，就像用一把不太顺手的钥匙开锁，费半天劲。  \n\nPinia和Vue DevTools那可是“深度绑定”！支持时间旅行调试，还能轻松追踪store变化。调试的时候就像拥有了“时光回溯”的超能力，哪里出问题一目了然，开发效率直接翻倍！\n\n\n## 9. 状态持久化：一键配置，轻松搞定\nVuex想实现状态持久化？得额外安装`vuex-persistedstate`插件，一顿操作猛如虎，才能把数据存起来。  \n\nPinia就简单多了，用`pinia-plugin-persistedstate`插件，简单配置一下，数据保存妥妥的，就像给数据加了个“保险箱”，一键操作，省心又省力！\n\n\n## 升级建议\n1. **慢慢过渡**：在Vue 3项目里，别着急把Vuex全换掉，可以Vuex和Pinia一起用，慢慢把旧的store迁移到Pinia，稳扎稳打，降低升级风险。  \n2. **整理代码**：把Vuex里的`mutations`合并到`actions`里，让代码结构更贴合Pinia的风格，就像给旧衣服改个新款式，焕然一新！  \n3. **用好组合式API**：充分发挥Pinia和组合式API的“CP”优势，用`setup`函数写代码，灵活安排逻辑，怎么方便怎么来！  \n4. **享受类型安全**：Pinia的类型推导超厉害，一定要好好利用，减少手动写类型声明的麻烦，让代码又快又安全！  \n\n\n从Vuex换成Pinia，可不只是换个工具那么简单，更是开发体验的大升级！Pinia凭借简洁的设计、强大的功能，还有对Vue 3的“完美适配”，妥妥成了Vue开发者状态管理的“新宠”。希望这篇文章能帮你快速上手Pinia，在Vue 3的开发路上一路“狂飙”！\n# 从Vuex到Pinia：Vue 3状态管理的全面升级\n\n家人们！在Vue 3的“江湖”里，状态管理这块可是发生了大变化！当咱们从Vue 2“升级打怪”到Vue 3，以前常用的Vuex逐渐被更“香”的Pinia替代了。今天就来唠唠Vuex和Pinia到底有啥不一样，帮大家轻松拿捏新的状态管理姿势！\n\n\n## 1. API风格与设计：告别繁琐，拥抱简洁\nVuex就像个“老学究”，用的是类似Redux的那一套，非得让开发者把逻辑按`mutations`、`actions`、`getters`这些规矩分好类。虽然确实规范，但写起代码来可太啰嗦了，一堆模板代码看着就头大！  \n\nPinia就不一样，它紧跟Vue 3的“潮流”，用组合式API设计，直接把`mutations`“踢出局”（只保留`state`、`getters`、`actions`）。代码一下子变得超扁平、超直观，再也不用为那些复杂的条条框框费脑筋，开发起来轻松多啦！\n\n\n## 2. TypeScript支持：天生适配，用着超爽\n要是你用Vuex搭配TypeScript，那可得费点劲！得额外捣鼓不少配置和类型定义，不然根本用不顺手，就像给自行车硬装上火箭发动机，麻烦得很。  \n\nPinia可就贴心多了，它对TypeScript是“真爱”，天生适配！在定义store的时候，类型直接就能自动推导出来，完全不用手动写那些复杂的类型声明。这就好比有个贴心小助手，帮你把繁琐的活儿都干了，开发效率直接起飞，代码的安全性也拉满！\n\n\n## 3. 代码结构：新旧语法大PK\n先看看Vuex的store代码长啥样：  \n```javascript\n// Vuex store示例\nexport default new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment(state) {\n      state.count++;\n    }\n  },\n  actions: {\n    incrementAsync({ commit }) {\n      setTimeout(() => commit('increment'), 1000);\n    }\n  },\n  getters: {\n    doubleCount: state => state.count * 2\n  }\n});\n```  \n\n再瞅瞅Pinia的：  \n```javascript\n// Pinia store示例\nimport { defineStore } from 'pinia';\n\nexport const useCounterStore = defineStore('counter', {\n  state: () => ({\n    count: 0\n  }),\n  actions: {\n    increment() {\n      this.count++;\n    },\n    incrementAsync() {\n      setTimeout(() => this.increment(), 1000);\n    }\n  },\n  getters: {\n    doubleCount: state => state.count * 2\n  }\n});\n```  \n\n这么一对比，是不是瞬间觉得Pinia的代码清爽多了？没有那么多复杂的层级和重复的结构，就像把乱糟糟的房间收拾得整整齐齐，看着就舒服，写代码也更顺手！\n\n\n## 4. 响应式原理：Proxy带来的“黑科技”\nVuex用的是Vue 2的`Object.defineProperty`实现响应式，这就像给数据安了个“老旧监控”，在处理深层嵌套数据更新的时候，经常会“掉链子”，数据变了，视图却没反应，让人干着急。  \n\nPinia可就“高大上”了，它基于Vue 3的Proxy，相当于给数据配了个“智能管家”！不仅支持直接修改`state`，不用再走`mutations`那些弯弯绕绕，而且响应式超高效、超准确，数据一有风吹草动，它立马就能感知到，视图更新那叫一个快！\n\n\n## 5. 模块化方式：轻松管理，互不干扰\nVuex拆分store靠`modules`选项，但是模块之间的关系就像一团乱麻，命名空间管理起来也特别麻烦，稍不注意就容易“翻车”，把代码搞得一团糟。  \n\nPinia就聪明多了，每个store都是独立的“小个体”，用`defineStore`定义就行。模块之间井水不犯河水，完全解耦，命名空间也自动安排得明明白白。开发者管理起状态逻辑来，就像整理自己的小抽屉，想找啥一目了然，别提多轻松了！\n\n\n## 6. 插件系统：简单扩展，功能拉满\nVuex的插件机制复杂得很，开发者要是想实现点特定功能，就得自己写中间件或者插件，跟“造轮子”似的，费时又费力。  \n\nPinia的插件系统就“傻瓜式”多了，特别简洁明了。不管是扩展store功能，还是实现状态持久化，都超容易。比如用`pinia-plugin-persistedstate`插件，分分钟就能把状态存起来，就像用手机APP，点点按钮就能搞定，轻松实现功能自由！\n\n\n## 7. 与组合式API的集成：无缝配合，丝滑流畅\n在Vuex里想用组合式API？那得通过`useStore`获取store实例，写法又长又麻烦，就像绕了个大弯才能到达目的地。  \n\nPinia和组合式API简直是“最佳拍档”！直接在`setup`函数里调用`useStore()`就能拿到store，代码写起来行云流水，一点都不卡顿，用起来丝滑得不行！\n\n\n## 8. 开发工具支持：调试神器，效率翻倍\nVuex调试得靠Vue DevTools，但用起来总觉得差点意思，就像用一把不太顺手的钥匙开锁，费半天劲。  \n\nPinia和Vue DevTools那可是“深度绑定”！支持时间旅行调试，还能轻松追踪store变化。调试的时候就像拥有了“时光回溯”的超能力，哪里出问题一目了然，开发效率直接翻倍！\n\n\n## 9. 状态持久化：一键配置，轻松搞定\nVuex想实现状态持久化？得额外安装`vuex-persistedstate`插件，一顿操作猛如虎，才能把数据存起来。  \n\nPinia就简单多了，用`pinia-plugin-persistedstate`插件，简单配置一下，数据保存妥妥的，就像给数据加了个“保险箱”，一键操作，省心又省力！\n\n\n## 升级建议\n1. **慢慢过渡**：在Vue 3项目里，别着急把Vuex全换掉，可以Vuex和Pinia一起用，慢慢把旧的store迁移到Pinia，稳扎稳打，降低升级风险。  \n2. **整理代码**：把Vuex里的`mutations`合并到`actions`里，让代码结构更贴合Pinia的风格，就像给旧衣服改个新款式，焕然一新！  \n3. **用好组合式API**：充分发挥Pinia和组合式API的“CP”优势，用`setup`函数写代码，灵活安排逻辑，怎么方便怎么来！  \n4. **享受类型安全**：Pinia的类型推导超厉害，一定要好好利用，减少手动写类型声明的麻烦，让代码又快又安全！  \n\n\n从Vuex换成Pinia，可不只是换个工具那么简单，更是开发体验的大升级！Pinia凭借简洁的设计、强大的功能，还有对Vue 3的“完美适配”，妥妥成了Vue开发者状态管理的“新宠”。希望这篇文章能帮你快速上手Pinia，在Vue 3的开发路上一路“狂飙”！","slug":"from-vuex-to-pinia","published":1,"updated":"2025-08-26T10:44:54.544Z","comments":1,"layout":"post","photos":[],"_id":"cmjbml2id001kikup5hz0dp7x","content":"<p>在Vue 3的“江湖”里，状态管理这块可是发生了大变化！当咱们从Vue 2“升级打怪”到Vue 3，以前常用的Vuex逐渐被更“香”的Pinia替代了。今天就来唠唠Vuex和Pinia到底有啥不一样，帮大家轻松拿捏新的状态管理姿势！</p>\n<h2 id=\"1-API风格与设计：告别繁琐，拥抱简洁\"><a href=\"#1-API风格与设计：告别繁琐，拥抱简洁\" class=\"headerlink\" title=\"1. API风格与设计：告别繁琐，拥抱简洁\"></a>1. API风格与设计：告别繁琐，拥抱简洁</h2><p>Vuex就像个“老学究”，用的是类似Redux的那一套，非得让开发者把逻辑按<code>mutations</code>、<code>actions</code>、<code>getters</code>这些规矩分好类。虽然确实规范，但写起代码来可太啰嗦了，一堆模板代码看着就头大！  </p>\n<p>Pinia就不一样，它紧跟Vue 3的“潮流”，用组合式API设计，直接把<code>mutations</code>“踢出局”（只保留<code>state</code>、<code>getters</code>、<code>actions</code>）。代码一下子变得超扁平、超直观，再也不用为那些复杂的条条框框费脑筋，开发起来轻松多啦！</p>\n<h2 id=\"2-TypeScript支持：天生适配，用着超爽\"><a href=\"#2-TypeScript支持：天生适配，用着超爽\" class=\"headerlink\" title=\"2. TypeScript支持：天生适配，用着超爽\"></a>2. TypeScript支持：天生适配，用着超爽</h2><p>要是你用Vuex搭配TypeScript，那可得费点劲！得额外捣鼓不少配置和类型定义，不然根本用不顺手，就像给自行车硬装上火箭发动机，麻烦得很。  </p>\n<p>Pinia可就贴心多了，它对TypeScript是“真爱”，天生适配！在定义store的时候，类型直接就能自动推导出来，完全不用手动写那些复杂的类型声明。这就好比有个贴心小助手，帮你把繁琐的活儿都干了，开发效率直接起飞，代码的安全性也拉满！</p>\n<h2 id=\"3-代码结构：新旧语法大PK\"><a href=\"#3-代码结构：新旧语法大PK\" class=\"headerlink\" title=\"3. 代码结构：新旧语法大PK\"></a>3. 代码结构：新旧语法大PK</h2><p>先看看Vuex的store代码长啥样：  </p>\n<pre><code class=\"javascript\">// Vuex store示例\nexport default new Vuex.Store(&#123;\n  state: &#123;\n    count: 0\n  &#125;,\n  mutations: &#123;\n    increment(state) &#123;\n      state.count++;\n    &#125;\n  &#125;,\n  actions: &#123;\n    incrementAsync(&#123; commit &#125;) &#123;\n      setTimeout(() =&gt; commit(&#39;increment&#39;), 1000);\n    &#125;\n  &#125;,\n  getters: &#123;\n    doubleCount: state =&gt; state.count * 2\n  &#125;\n&#125;);\n</code></pre>\n<p>再瞅瞅Pinia的：  </p>\n<pre><code class=\"javascript\">// Pinia store示例\nimport &#123; defineStore &#125; from &#39;pinia&#39;;\n\nexport const useCounterStore = defineStore(&#39;counter&#39;, &#123;\n  state: () =&gt; (&#123;\n    count: 0\n  &#125;),\n  actions: &#123;\n    increment() &#123;\n      this.count++;\n    &#125;,\n    incrementAsync() &#123;\n      setTimeout(() =&gt; this.increment(), 1000);\n    &#125;\n  &#125;,\n  getters: &#123;\n    doubleCount: state =&gt; state.count * 2\n  &#125;\n&#125;);\n</code></pre>\n<p>这么一对比，是不是瞬间觉得Pinia的代码清爽多了？没有那么多复杂的层级和重复的结构，就像把乱糟糟的房间收拾得整整齐齐，看着就舒服，写代码也更顺手！</p>\n<h2 id=\"4-响应式原理：Proxy带来的“黑科技”\"><a href=\"#4-响应式原理：Proxy带来的“黑科技”\" class=\"headerlink\" title=\"4. 响应式原理：Proxy带来的“黑科技”\"></a>4. 响应式原理：Proxy带来的“黑科技”</h2><p>Vuex用的是Vue 2的<code>Object.defineProperty</code>实现响应式，这就像给数据安了个“老旧监控”，在处理深层嵌套数据更新的时候，经常会“掉链子”，数据变了，视图却没反应，让人干着急。  </p>\n<p>Pinia可就“高大上”了，它基于Vue 3的Proxy，相当于给数据配了个“智能管家”！不仅支持直接修改<code>state</code>，不用再走<code>mutations</code>那些弯弯绕绕，而且响应式超高效、超准确，数据一有风吹草动，它立马就能感知到，视图更新那叫一个快！</p>\n<h2 id=\"5-模块化方式：轻松管理，互不干扰\"><a href=\"#5-模块化方式：轻松管理，互不干扰\" class=\"headerlink\" title=\"5. 模块化方式：轻松管理，互不干扰\"></a>5. 模块化方式：轻松管理，互不干扰</h2><p>Vuex拆分store靠<code>modules</code>选项，但是模块之间的关系就像一团乱麻，命名空间管理起来也特别麻烦，稍不注意就容易“翻车”，把代码搞得一团糟。  </p>\n<p>Pinia就聪明多了，每个store都是独立的“小个体”，用<code>defineStore</code>定义就行。模块之间井水不犯河水，完全解耦，命名空间也自动安排得明明白白。开发者管理起状态逻辑来，就像整理自己的小抽屉，想找啥一目了然，别提多轻松了！</p>\n<h2 id=\"6-插件系统：简单扩展，功能拉满\"><a href=\"#6-插件系统：简单扩展，功能拉满\" class=\"headerlink\" title=\"6. 插件系统：简单扩展，功能拉满\"></a>6. 插件系统：简单扩展，功能拉满</h2><p>Vuex的插件机制复杂得很，开发者要是想实现点特定功能，就得自己写中间件或者插件，跟“造轮子”似的，费时又费力。  </p>\n<p>Pinia的插件系统就“傻瓜式”多了，特别简洁明了。不管是扩展store功能，还是实现状态持久化，都超容易。比如用<code>pinia-plugin-persistedstate</code>插件，分分钟就能把状态存起来，就像用手机APP，点点按钮就能搞定，轻松实现功能自由！</p>\n<h2 id=\"7-与组合式API的集成：无缝配合，丝滑流畅\"><a href=\"#7-与组合式API的集成：无缝配合，丝滑流畅\" class=\"headerlink\" title=\"7. 与组合式API的集成：无缝配合，丝滑流畅\"></a>7. 与组合式API的集成：无缝配合，丝滑流畅</h2><p>在Vuex里想用组合式API？那得通过<code>useStore</code>获取store实例，写法又长又麻烦，就像绕了个大弯才能到达目的地。  </p>\n<p>Pinia和组合式API简直是“最佳拍档”！直接在<code>setup</code>函数里调用<code>useStore()</code>就能拿到store，代码写起来行云流水，一点都不卡顿，用起来丝滑得不行！</p>\n<h2 id=\"8-开发工具支持：调试神器，效率翻倍\"><a href=\"#8-开发工具支持：调试神器，效率翻倍\" class=\"headerlink\" title=\"8. 开发工具支持：调试神器，效率翻倍\"></a>8. 开发工具支持：调试神器，效率翻倍</h2><p>Vuex调试得靠Vue DevTools，但用起来总觉得差点意思，就像用一把不太顺手的钥匙开锁，费半天劲。  </p>\n<p>Pinia和Vue DevTools那可是“深度绑定”！支持时间旅行调试，还能轻松追踪store变化。调试的时候就像拥有了“时光回溯”的超能力，哪里出问题一目了然，开发效率直接翻倍！</p>\n<h2 id=\"9-状态持久化：一键配置，轻松搞定\"><a href=\"#9-状态持久化：一键配置，轻松搞定\" class=\"headerlink\" title=\"9. 状态持久化：一键配置，轻松搞定\"></a>9. 状态持久化：一键配置，轻松搞定</h2><p>Vuex想实现状态持久化？得额外安装<code>vuex-persistedstate</code>插件，一顿操作猛如虎，才能把数据存起来。  </p>\n<p>Pinia就简单多了，用<code>pinia-plugin-persistedstate</code>插件，简单配置一下，数据保存妥妥的，就像给数据加了个“保险箱”，一键操作，省心又省力！</p>\n<h2 id=\"升级建议\"><a href=\"#升级建议\" class=\"headerlink\" title=\"升级建议\"></a>升级建议</h2><ol>\n<li><strong>慢慢过渡</strong>：在Vue 3项目里，别着急把Vuex全换掉，可以Vuex和Pinia一起用，慢慢把旧的store迁移到Pinia，稳扎稳打，降低升级风险。  </li>\n<li><strong>整理代码</strong>：把Vuex里的<code>mutations</code>合并到<code>actions</code>里，让代码结构更贴合Pinia的风格，就像给旧衣服改个新款式，焕然一新！  </li>\n<li><strong>用好组合式API</strong>：充分发挥Pinia和组合式API的“CP”优势，用<code>setup</code>函数写代码，灵活安排逻辑，怎么方便怎么来！  </li>\n<li><strong>享受类型安全</strong>：Pinia的类型推导超厉害，一定要好好利用，减少手动写类型声明的麻烦，让代码又快又安全！</li>\n</ol>\n<p>从Vuex换成Pinia，可不只是换个工具那么简单，更是开发体验的大升级！Pinia凭借简洁的设计、强大的功能，还有对Vue 3的“完美适配”，妥妥成了Vue开发者状态管理的“新宠”。希望这篇文章能帮你快速上手Pinia，在Vue 3的开发路上一路“狂飙”！</p>\n<h1 id=\"从Vuex到Pinia：Vue-3状态管理的全面升级\"><a href=\"#从Vuex到Pinia：Vue-3状态管理的全面升级\" class=\"headerlink\" title=\"从Vuex到Pinia：Vue 3状态管理的全面升级\"></a>从Vuex到Pinia：Vue 3状态管理的全面升级</h1><p>家人们！在Vue 3的“江湖”里，状态管理这块可是发生了大变化！当咱们从Vue 2“升级打怪”到Vue 3，以前常用的Vuex逐渐被更“香”的Pinia替代了。今天就来唠唠Vuex和Pinia到底有啥不一样，帮大家轻松拿捏新的状态管理姿势！</p>\n<h2 id=\"1-API风格与设计：告别繁琐，拥抱简洁-1\"><a href=\"#1-API风格与设计：告别繁琐，拥抱简洁-1\" class=\"headerlink\" title=\"1. API风格与设计：告别繁琐，拥抱简洁\"></a>1. API风格与设计：告别繁琐，拥抱简洁</h2><p>Vuex就像个“老学究”，用的是类似Redux的那一套，非得让开发者把逻辑按<code>mutations</code>、<code>actions</code>、<code>getters</code>这些规矩分好类。虽然确实规范，但写起代码来可太啰嗦了，一堆模板代码看着就头大！  </p>\n<p>Pinia就不一样，它紧跟Vue 3的“潮流”，用组合式API设计，直接把<code>mutations</code>“踢出局”（只保留<code>state</code>、<code>getters</code>、<code>actions</code>）。代码一下子变得超扁平、超直观，再也不用为那些复杂的条条框框费脑筋，开发起来轻松多啦！</p>\n<h2 id=\"2-TypeScript支持：天生适配，用着超爽-1\"><a href=\"#2-TypeScript支持：天生适配，用着超爽-1\" class=\"headerlink\" title=\"2. TypeScript支持：天生适配，用着超爽\"></a>2. TypeScript支持：天生适配，用着超爽</h2><p>要是你用Vuex搭配TypeScript，那可得费点劲！得额外捣鼓不少配置和类型定义，不然根本用不顺手，就像给自行车硬装上火箭发动机，麻烦得很。  </p>\n<p>Pinia可就贴心多了，它对TypeScript是“真爱”，天生适配！在定义store的时候，类型直接就能自动推导出来，完全不用手动写那些复杂的类型声明。这就好比有个贴心小助手，帮你把繁琐的活儿都干了，开发效率直接起飞，代码的安全性也拉满！</p>\n<h2 id=\"3-代码结构：新旧语法大PK-1\"><a href=\"#3-代码结构：新旧语法大PK-1\" class=\"headerlink\" title=\"3. 代码结构：新旧语法大PK\"></a>3. 代码结构：新旧语法大PK</h2><p>先看看Vuex的store代码长啥样：  </p>\n<pre><code class=\"javascript\">// Vuex store示例\nexport default new Vuex.Store(&#123;\n  state: &#123;\n    count: 0\n  &#125;,\n  mutations: &#123;\n    increment(state) &#123;\n      state.count++;\n    &#125;\n  &#125;,\n  actions: &#123;\n    incrementAsync(&#123; commit &#125;) &#123;\n      setTimeout(() =&gt; commit(&#39;increment&#39;), 1000);\n    &#125;\n  &#125;,\n  getters: &#123;\n    doubleCount: state =&gt; state.count * 2\n  &#125;\n&#125;);\n</code></pre>\n<p>再瞅瞅Pinia的：  </p>\n<pre><code class=\"javascript\">// Pinia store示例\nimport &#123; defineStore &#125; from &#39;pinia&#39;;\n\nexport const useCounterStore = defineStore(&#39;counter&#39;, &#123;\n  state: () =&gt; (&#123;\n    count: 0\n  &#125;),\n  actions: &#123;\n    increment() &#123;\n      this.count++;\n    &#125;,\n    incrementAsync() &#123;\n      setTimeout(() =&gt; this.increment(), 1000);\n    &#125;\n  &#125;,\n  getters: &#123;\n    doubleCount: state =&gt; state.count * 2\n  &#125;\n&#125;);\n</code></pre>\n<p>这么一对比，是不是瞬间觉得Pinia的代码清爽多了？没有那么多复杂的层级和重复的结构，就像把乱糟糟的房间收拾得整整齐齐，看着就舒服，写代码也更顺手！</p>\n<h2 id=\"4-响应式原理：Proxy带来的“黑科技”-1\"><a href=\"#4-响应式原理：Proxy带来的“黑科技”-1\" class=\"headerlink\" title=\"4. 响应式原理：Proxy带来的“黑科技”\"></a>4. 响应式原理：Proxy带来的“黑科技”</h2><p>Vuex用的是Vue 2的<code>Object.defineProperty</code>实现响应式，这就像给数据安了个“老旧监控”，在处理深层嵌套数据更新的时候，经常会“掉链子”，数据变了，视图却没反应，让人干着急。  </p>\n<p>Pinia可就“高大上”了，它基于Vue 3的Proxy，相当于给数据配了个“智能管家”！不仅支持直接修改<code>state</code>，不用再走<code>mutations</code>那些弯弯绕绕，而且响应式超高效、超准确，数据一有风吹草动，它立马就能感知到，视图更新那叫一个快！</p>\n<h2 id=\"5-模块化方式：轻松管理，互不干扰-1\"><a href=\"#5-模块化方式：轻松管理，互不干扰-1\" class=\"headerlink\" title=\"5. 模块化方式：轻松管理，互不干扰\"></a>5. 模块化方式：轻松管理，互不干扰</h2><p>Vuex拆分store靠<code>modules</code>选项，但是模块之间的关系就像一团乱麻，命名空间管理起来也特别麻烦，稍不注意就容易“翻车”，把代码搞得一团糟。  </p>\n<p>Pinia就聪明多了，每个store都是独立的“小个体”，用<code>defineStore</code>定义就行。模块之间井水不犯河水，完全解耦，命名空间也自动安排得明明白白。开发者管理起状态逻辑来，就像整理自己的小抽屉，想找啥一目了然，别提多轻松了！</p>\n<h2 id=\"6-插件系统：简单扩展，功能拉满-1\"><a href=\"#6-插件系统：简单扩展，功能拉满-1\" class=\"headerlink\" title=\"6. 插件系统：简单扩展，功能拉满\"></a>6. 插件系统：简单扩展，功能拉满</h2><p>Vuex的插件机制复杂得很，开发者要是想实现点特定功能，就得自己写中间件或者插件，跟“造轮子”似的，费时又费力。  </p>\n<p>Pinia的插件系统就“傻瓜式”多了，特别简洁明了。不管是扩展store功能，还是实现状态持久化，都超容易。比如用<code>pinia-plugin-persistedstate</code>插件，分分钟就能把状态存起来，就像用手机APP，点点按钮就能搞定，轻松实现功能自由！</p>\n<h2 id=\"7-与组合式API的集成：无缝配合，丝滑流畅-1\"><a href=\"#7-与组合式API的集成：无缝配合，丝滑流畅-1\" class=\"headerlink\" title=\"7. 与组合式API的集成：无缝配合，丝滑流畅\"></a>7. 与组合式API的集成：无缝配合，丝滑流畅</h2><p>在Vuex里想用组合式API？那得通过<code>useStore</code>获取store实例，写法又长又麻烦，就像绕了个大弯才能到达目的地。  </p>\n<p>Pinia和组合式API简直是“最佳拍档”！直接在<code>setup</code>函数里调用<code>useStore()</code>就能拿到store，代码写起来行云流水，一点都不卡顿，用起来丝滑得不行！</p>\n<h2 id=\"8-开发工具支持：调试神器，效率翻倍-1\"><a href=\"#8-开发工具支持：调试神器，效率翻倍-1\" class=\"headerlink\" title=\"8. 开发工具支持：调试神器，效率翻倍\"></a>8. 开发工具支持：调试神器，效率翻倍</h2><p>Vuex调试得靠Vue DevTools，但用起来总觉得差点意思，就像用一把不太顺手的钥匙开锁，费半天劲。  </p>\n<p>Pinia和Vue DevTools那可是“深度绑定”！支持时间旅行调试，还能轻松追踪store变化。调试的时候就像拥有了“时光回溯”的超能力，哪里出问题一目了然，开发效率直接翻倍！</p>\n<h2 id=\"9-状态持久化：一键配置，轻松搞定-1\"><a href=\"#9-状态持久化：一键配置，轻松搞定-1\" class=\"headerlink\" title=\"9. 状态持久化：一键配置，轻松搞定\"></a>9. 状态持久化：一键配置，轻松搞定</h2><p>Vuex想实现状态持久化？得额外安装<code>vuex-persistedstate</code>插件，一顿操作猛如虎，才能把数据存起来。  </p>\n<p>Pinia就简单多了，用<code>pinia-plugin-persistedstate</code>插件，简单配置一下，数据保存妥妥的，就像给数据加了个“保险箱”，一键操作，省心又省力！</p>\n<h2 id=\"升级建议-1\"><a href=\"#升级建议-1\" class=\"headerlink\" title=\"升级建议\"></a>升级建议</h2><ol>\n<li><strong>慢慢过渡</strong>：在Vue 3项目里，别着急把Vuex全换掉，可以Vuex和Pinia一起用，慢慢把旧的store迁移到Pinia，稳扎稳打，降低升级风险。  </li>\n<li><strong>整理代码</strong>：把Vuex里的<code>mutations</code>合并到<code>actions</code>里，让代码结构更贴合Pinia的风格，就像给旧衣服改个新款式，焕然一新！  </li>\n<li><strong>用好组合式API</strong>：充分发挥Pinia和组合式API的“CP”优势，用<code>setup</code>函数写代码，灵活安排逻辑，怎么方便怎么来！  </li>\n<li><strong>享受类型安全</strong>：Pinia的类型推导超厉害，一定要好好利用，减少手动写类型声明的麻烦，让代码又快又安全！</li>\n</ol>\n<p>从Vuex换成Pinia，可不只是换个工具那么简单，更是开发体验的大升级！Pinia凭借简洁的设计、强大的功能，还有对Vue 3的“完美适配”，妥妥成了Vue开发者状态管理的“新宠”。希望这篇文章能帮你快速上手Pinia，在Vue 3的开发路上一路“狂飙”！</p>\n","excerpt":"","more":"<p>在Vue 3的“江湖”里，状态管理这块可是发生了大变化！当咱们从Vue 2“升级打怪”到Vue 3，以前常用的Vuex逐渐被更“香”的Pinia替代了。今天就来唠唠Vuex和Pinia到底有啥不一样，帮大家轻松拿捏新的状态管理姿势！</p>\n<h2 id=\"1-API风格与设计：告别繁琐，拥抱简洁\"><a href=\"#1-API风格与设计：告别繁琐，拥抱简洁\" class=\"headerlink\" title=\"1. API风格与设计：告别繁琐，拥抱简洁\"></a>1. API风格与设计：告别繁琐，拥抱简洁</h2><p>Vuex就像个“老学究”，用的是类似Redux的那一套，非得让开发者把逻辑按<code>mutations</code>、<code>actions</code>、<code>getters</code>这些规矩分好类。虽然确实规范，但写起代码来可太啰嗦了，一堆模板代码看着就头大！  </p>\n<p>Pinia就不一样，它紧跟Vue 3的“潮流”，用组合式API设计，直接把<code>mutations</code>“踢出局”（只保留<code>state</code>、<code>getters</code>、<code>actions</code>）。代码一下子变得超扁平、超直观，再也不用为那些复杂的条条框框费脑筋，开发起来轻松多啦！</p>\n<h2 id=\"2-TypeScript支持：天生适配，用着超爽\"><a href=\"#2-TypeScript支持：天生适配，用着超爽\" class=\"headerlink\" title=\"2. TypeScript支持：天生适配，用着超爽\"></a>2. TypeScript支持：天生适配，用着超爽</h2><p>要是你用Vuex搭配TypeScript，那可得费点劲！得额外捣鼓不少配置和类型定义，不然根本用不顺手，就像给自行车硬装上火箭发动机，麻烦得很。  </p>\n<p>Pinia可就贴心多了，它对TypeScript是“真爱”，天生适配！在定义store的时候，类型直接就能自动推导出来，完全不用手动写那些复杂的类型声明。这就好比有个贴心小助手，帮你把繁琐的活儿都干了，开发效率直接起飞，代码的安全性也拉满！</p>\n<h2 id=\"3-代码结构：新旧语法大PK\"><a href=\"#3-代码结构：新旧语法大PK\" class=\"headerlink\" title=\"3. 代码结构：新旧语法大PK\"></a>3. 代码结构：新旧语法大PK</h2><p>先看看Vuex的store代码长啥样：  </p>\n<pre><code class=\"javascript\">// Vuex store示例\nexport default new Vuex.Store(&#123;\n  state: &#123;\n    count: 0\n  &#125;,\n  mutations: &#123;\n    increment(state) &#123;\n      state.count++;\n    &#125;\n  &#125;,\n  actions: &#123;\n    incrementAsync(&#123; commit &#125;) &#123;\n      setTimeout(() =&gt; commit(&#39;increment&#39;), 1000);\n    &#125;\n  &#125;,\n  getters: &#123;\n    doubleCount: state =&gt; state.count * 2\n  &#125;\n&#125;);\n</code></pre>\n<p>再瞅瞅Pinia的：  </p>\n<pre><code class=\"javascript\">// Pinia store示例\nimport &#123; defineStore &#125; from &#39;pinia&#39;;\n\nexport const useCounterStore = defineStore(&#39;counter&#39;, &#123;\n  state: () =&gt; (&#123;\n    count: 0\n  &#125;),\n  actions: &#123;\n    increment() &#123;\n      this.count++;\n    &#125;,\n    incrementAsync() &#123;\n      setTimeout(() =&gt; this.increment(), 1000);\n    &#125;\n  &#125;,\n  getters: &#123;\n    doubleCount: state =&gt; state.count * 2\n  &#125;\n&#125;);\n</code></pre>\n<p>这么一对比，是不是瞬间觉得Pinia的代码清爽多了？没有那么多复杂的层级和重复的结构，就像把乱糟糟的房间收拾得整整齐齐，看着就舒服，写代码也更顺手！</p>\n<h2 id=\"4-响应式原理：Proxy带来的“黑科技”\"><a href=\"#4-响应式原理：Proxy带来的“黑科技”\" class=\"headerlink\" title=\"4. 响应式原理：Proxy带来的“黑科技”\"></a>4. 响应式原理：Proxy带来的“黑科技”</h2><p>Vuex用的是Vue 2的<code>Object.defineProperty</code>实现响应式，这就像给数据安了个“老旧监控”，在处理深层嵌套数据更新的时候，经常会“掉链子”，数据变了，视图却没反应，让人干着急。  </p>\n<p>Pinia可就“高大上”了，它基于Vue 3的Proxy，相当于给数据配了个“智能管家”！不仅支持直接修改<code>state</code>，不用再走<code>mutations</code>那些弯弯绕绕，而且响应式超高效、超准确，数据一有风吹草动，它立马就能感知到，视图更新那叫一个快！</p>\n<h2 id=\"5-模块化方式：轻松管理，互不干扰\"><a href=\"#5-模块化方式：轻松管理，互不干扰\" class=\"headerlink\" title=\"5. 模块化方式：轻松管理，互不干扰\"></a>5. 模块化方式：轻松管理，互不干扰</h2><p>Vuex拆分store靠<code>modules</code>选项，但是模块之间的关系就像一团乱麻，命名空间管理起来也特别麻烦，稍不注意就容易“翻车”，把代码搞得一团糟。  </p>\n<p>Pinia就聪明多了，每个store都是独立的“小个体”，用<code>defineStore</code>定义就行。模块之间井水不犯河水，完全解耦，命名空间也自动安排得明明白白。开发者管理起状态逻辑来，就像整理自己的小抽屉，想找啥一目了然，别提多轻松了！</p>\n<h2 id=\"6-插件系统：简单扩展，功能拉满\"><a href=\"#6-插件系统：简单扩展，功能拉满\" class=\"headerlink\" title=\"6. 插件系统：简单扩展，功能拉满\"></a>6. 插件系统：简单扩展，功能拉满</h2><p>Vuex的插件机制复杂得很，开发者要是想实现点特定功能，就得自己写中间件或者插件，跟“造轮子”似的，费时又费力。  </p>\n<p>Pinia的插件系统就“傻瓜式”多了，特别简洁明了。不管是扩展store功能，还是实现状态持久化，都超容易。比如用<code>pinia-plugin-persistedstate</code>插件，分分钟就能把状态存起来，就像用手机APP，点点按钮就能搞定，轻松实现功能自由！</p>\n<h2 id=\"7-与组合式API的集成：无缝配合，丝滑流畅\"><a href=\"#7-与组合式API的集成：无缝配合，丝滑流畅\" class=\"headerlink\" title=\"7. 与组合式API的集成：无缝配合，丝滑流畅\"></a>7. 与组合式API的集成：无缝配合，丝滑流畅</h2><p>在Vuex里想用组合式API？那得通过<code>useStore</code>获取store实例，写法又长又麻烦，就像绕了个大弯才能到达目的地。  </p>\n<p>Pinia和组合式API简直是“最佳拍档”！直接在<code>setup</code>函数里调用<code>useStore()</code>就能拿到store，代码写起来行云流水，一点都不卡顿，用起来丝滑得不行！</p>\n<h2 id=\"8-开发工具支持：调试神器，效率翻倍\"><a href=\"#8-开发工具支持：调试神器，效率翻倍\" class=\"headerlink\" title=\"8. 开发工具支持：调试神器，效率翻倍\"></a>8. 开发工具支持：调试神器，效率翻倍</h2><p>Vuex调试得靠Vue DevTools，但用起来总觉得差点意思，就像用一把不太顺手的钥匙开锁，费半天劲。  </p>\n<p>Pinia和Vue DevTools那可是“深度绑定”！支持时间旅行调试，还能轻松追踪store变化。调试的时候就像拥有了“时光回溯”的超能力，哪里出问题一目了然，开发效率直接翻倍！</p>\n<h2 id=\"9-状态持久化：一键配置，轻松搞定\"><a href=\"#9-状态持久化：一键配置，轻松搞定\" class=\"headerlink\" title=\"9. 状态持久化：一键配置，轻松搞定\"></a>9. 状态持久化：一键配置，轻松搞定</h2><p>Vuex想实现状态持久化？得额外安装<code>vuex-persistedstate</code>插件，一顿操作猛如虎，才能把数据存起来。  </p>\n<p>Pinia就简单多了，用<code>pinia-plugin-persistedstate</code>插件，简单配置一下，数据保存妥妥的，就像给数据加了个“保险箱”，一键操作，省心又省力！</p>\n<h2 id=\"升级建议\"><a href=\"#升级建议\" class=\"headerlink\" title=\"升级建议\"></a>升级建议</h2><ol>\n<li><strong>慢慢过渡</strong>：在Vue 3项目里，别着急把Vuex全换掉，可以Vuex和Pinia一起用，慢慢把旧的store迁移到Pinia，稳扎稳打，降低升级风险。  </li>\n<li><strong>整理代码</strong>：把Vuex里的<code>mutations</code>合并到<code>actions</code>里，让代码结构更贴合Pinia的风格，就像给旧衣服改个新款式，焕然一新！  </li>\n<li><strong>用好组合式API</strong>：充分发挥Pinia和组合式API的“CP”优势，用<code>setup</code>函数写代码，灵活安排逻辑，怎么方便怎么来！  </li>\n<li><strong>享受类型安全</strong>：Pinia的类型推导超厉害，一定要好好利用，减少手动写类型声明的麻烦，让代码又快又安全！</li>\n</ol>\n<p>从Vuex换成Pinia，可不只是换个工具那么简单，更是开发体验的大升级！Pinia凭借简洁的设计、强大的功能，还有对Vue 3的“完美适配”，妥妥成了Vue开发者状态管理的“新宠”。希望这篇文章能帮你快速上手Pinia，在Vue 3的开发路上一路“狂飙”！</p>\n<h1 id=\"从Vuex到Pinia：Vue-3状态管理的全面升级\"><a href=\"#从Vuex到Pinia：Vue-3状态管理的全面升级\" class=\"headerlink\" title=\"从Vuex到Pinia：Vue 3状态管理的全面升级\"></a>从Vuex到Pinia：Vue 3状态管理的全面升级</h1><p>家人们！在Vue 3的“江湖”里，状态管理这块可是发生了大变化！当咱们从Vue 2“升级打怪”到Vue 3，以前常用的Vuex逐渐被更“香”的Pinia替代了。今天就来唠唠Vuex和Pinia到底有啥不一样，帮大家轻松拿捏新的状态管理姿势！</p>\n<h2 id=\"1-API风格与设计：告别繁琐，拥抱简洁-1\"><a href=\"#1-API风格与设计：告别繁琐，拥抱简洁-1\" class=\"headerlink\" title=\"1. API风格与设计：告别繁琐，拥抱简洁\"></a>1. API风格与设计：告别繁琐，拥抱简洁</h2><p>Vuex就像个“老学究”，用的是类似Redux的那一套，非得让开发者把逻辑按<code>mutations</code>、<code>actions</code>、<code>getters</code>这些规矩分好类。虽然确实规范，但写起代码来可太啰嗦了，一堆模板代码看着就头大！  </p>\n<p>Pinia就不一样，它紧跟Vue 3的“潮流”，用组合式API设计，直接把<code>mutations</code>“踢出局”（只保留<code>state</code>、<code>getters</code>、<code>actions</code>）。代码一下子变得超扁平、超直观，再也不用为那些复杂的条条框框费脑筋，开发起来轻松多啦！</p>\n<h2 id=\"2-TypeScript支持：天生适配，用着超爽-1\"><a href=\"#2-TypeScript支持：天生适配，用着超爽-1\" class=\"headerlink\" title=\"2. TypeScript支持：天生适配，用着超爽\"></a>2. TypeScript支持：天生适配，用着超爽</h2><p>要是你用Vuex搭配TypeScript，那可得费点劲！得额外捣鼓不少配置和类型定义，不然根本用不顺手，就像给自行车硬装上火箭发动机，麻烦得很。  </p>\n<p>Pinia可就贴心多了，它对TypeScript是“真爱”，天生适配！在定义store的时候，类型直接就能自动推导出来，完全不用手动写那些复杂的类型声明。这就好比有个贴心小助手，帮你把繁琐的活儿都干了，开发效率直接起飞，代码的安全性也拉满！</p>\n<h2 id=\"3-代码结构：新旧语法大PK-1\"><a href=\"#3-代码结构：新旧语法大PK-1\" class=\"headerlink\" title=\"3. 代码结构：新旧语法大PK\"></a>3. 代码结构：新旧语法大PK</h2><p>先看看Vuex的store代码长啥样：  </p>\n<pre><code class=\"javascript\">// Vuex store示例\nexport default new Vuex.Store(&#123;\n  state: &#123;\n    count: 0\n  &#125;,\n  mutations: &#123;\n    increment(state) &#123;\n      state.count++;\n    &#125;\n  &#125;,\n  actions: &#123;\n    incrementAsync(&#123; commit &#125;) &#123;\n      setTimeout(() =&gt; commit(&#39;increment&#39;), 1000);\n    &#125;\n  &#125;,\n  getters: &#123;\n    doubleCount: state =&gt; state.count * 2\n  &#125;\n&#125;);\n</code></pre>\n<p>再瞅瞅Pinia的：  </p>\n<pre><code class=\"javascript\">// Pinia store示例\nimport &#123; defineStore &#125; from &#39;pinia&#39;;\n\nexport const useCounterStore = defineStore(&#39;counter&#39;, &#123;\n  state: () =&gt; (&#123;\n    count: 0\n  &#125;),\n  actions: &#123;\n    increment() &#123;\n      this.count++;\n    &#125;,\n    incrementAsync() &#123;\n      setTimeout(() =&gt; this.increment(), 1000);\n    &#125;\n  &#125;,\n  getters: &#123;\n    doubleCount: state =&gt; state.count * 2\n  &#125;\n&#125;);\n</code></pre>\n<p>这么一对比，是不是瞬间觉得Pinia的代码清爽多了？没有那么多复杂的层级和重复的结构，就像把乱糟糟的房间收拾得整整齐齐，看着就舒服，写代码也更顺手！</p>\n<h2 id=\"4-响应式原理：Proxy带来的“黑科技”-1\"><a href=\"#4-响应式原理：Proxy带来的“黑科技”-1\" class=\"headerlink\" title=\"4. 响应式原理：Proxy带来的“黑科技”\"></a>4. 响应式原理：Proxy带来的“黑科技”</h2><p>Vuex用的是Vue 2的<code>Object.defineProperty</code>实现响应式，这就像给数据安了个“老旧监控”，在处理深层嵌套数据更新的时候，经常会“掉链子”，数据变了，视图却没反应，让人干着急。  </p>\n<p>Pinia可就“高大上”了，它基于Vue 3的Proxy，相当于给数据配了个“智能管家”！不仅支持直接修改<code>state</code>，不用再走<code>mutations</code>那些弯弯绕绕，而且响应式超高效、超准确，数据一有风吹草动，它立马就能感知到，视图更新那叫一个快！</p>\n<h2 id=\"5-模块化方式：轻松管理，互不干扰-1\"><a href=\"#5-模块化方式：轻松管理，互不干扰-1\" class=\"headerlink\" title=\"5. 模块化方式：轻松管理，互不干扰\"></a>5. 模块化方式：轻松管理，互不干扰</h2><p>Vuex拆分store靠<code>modules</code>选项，但是模块之间的关系就像一团乱麻，命名空间管理起来也特别麻烦，稍不注意就容易“翻车”，把代码搞得一团糟。  </p>\n<p>Pinia就聪明多了，每个store都是独立的“小个体”，用<code>defineStore</code>定义就行。模块之间井水不犯河水，完全解耦，命名空间也自动安排得明明白白。开发者管理起状态逻辑来，就像整理自己的小抽屉，想找啥一目了然，别提多轻松了！</p>\n<h2 id=\"6-插件系统：简单扩展，功能拉满-1\"><a href=\"#6-插件系统：简单扩展，功能拉满-1\" class=\"headerlink\" title=\"6. 插件系统：简单扩展，功能拉满\"></a>6. 插件系统：简单扩展，功能拉满</h2><p>Vuex的插件机制复杂得很，开发者要是想实现点特定功能，就得自己写中间件或者插件，跟“造轮子”似的，费时又费力。  </p>\n<p>Pinia的插件系统就“傻瓜式”多了，特别简洁明了。不管是扩展store功能，还是实现状态持久化，都超容易。比如用<code>pinia-plugin-persistedstate</code>插件，分分钟就能把状态存起来，就像用手机APP，点点按钮就能搞定，轻松实现功能自由！</p>\n<h2 id=\"7-与组合式API的集成：无缝配合，丝滑流畅-1\"><a href=\"#7-与组合式API的集成：无缝配合，丝滑流畅-1\" class=\"headerlink\" title=\"7. 与组合式API的集成：无缝配合，丝滑流畅\"></a>7. 与组合式API的集成：无缝配合，丝滑流畅</h2><p>在Vuex里想用组合式API？那得通过<code>useStore</code>获取store实例，写法又长又麻烦，就像绕了个大弯才能到达目的地。  </p>\n<p>Pinia和组合式API简直是“最佳拍档”！直接在<code>setup</code>函数里调用<code>useStore()</code>就能拿到store，代码写起来行云流水，一点都不卡顿，用起来丝滑得不行！</p>\n<h2 id=\"8-开发工具支持：调试神器，效率翻倍-1\"><a href=\"#8-开发工具支持：调试神器，效率翻倍-1\" class=\"headerlink\" title=\"8. 开发工具支持：调试神器，效率翻倍\"></a>8. 开发工具支持：调试神器，效率翻倍</h2><p>Vuex调试得靠Vue DevTools，但用起来总觉得差点意思，就像用一把不太顺手的钥匙开锁，费半天劲。  </p>\n<p>Pinia和Vue DevTools那可是“深度绑定”！支持时间旅行调试，还能轻松追踪store变化。调试的时候就像拥有了“时光回溯”的超能力，哪里出问题一目了然，开发效率直接翻倍！</p>\n<h2 id=\"9-状态持久化：一键配置，轻松搞定-1\"><a href=\"#9-状态持久化：一键配置，轻松搞定-1\" class=\"headerlink\" title=\"9. 状态持久化：一键配置，轻松搞定\"></a>9. 状态持久化：一键配置，轻松搞定</h2><p>Vuex想实现状态持久化？得额外安装<code>vuex-persistedstate</code>插件，一顿操作猛如虎，才能把数据存起来。  </p>\n<p>Pinia就简单多了，用<code>pinia-plugin-persistedstate</code>插件，简单配置一下，数据保存妥妥的，就像给数据加了个“保险箱”，一键操作，省心又省力！</p>\n<h2 id=\"升级建议-1\"><a href=\"#升级建议-1\" class=\"headerlink\" title=\"升级建议\"></a>升级建议</h2><ol>\n<li><strong>慢慢过渡</strong>：在Vue 3项目里，别着急把Vuex全换掉，可以Vuex和Pinia一起用，慢慢把旧的store迁移到Pinia，稳扎稳打，降低升级风险。  </li>\n<li><strong>整理代码</strong>：把Vuex里的<code>mutations</code>合并到<code>actions</code>里，让代码结构更贴合Pinia的风格，就像给旧衣服改个新款式，焕然一新！  </li>\n<li><strong>用好组合式API</strong>：充分发挥Pinia和组合式API的“CP”优势，用<code>setup</code>函数写代码，灵活安排逻辑，怎么方便怎么来！  </li>\n<li><strong>享受类型安全</strong>：Pinia的类型推导超厉害，一定要好好利用，减少手动写类型声明的麻烦，让代码又快又安全！</li>\n</ol>\n<p>从Vuex换成Pinia，可不只是换个工具那么简单，更是开发体验的大升级！Pinia凭借简洁的设计、强大的功能，还有对Vue 3的“完美适配”，妥妥成了Vue开发者状态管理的“新宠”。希望这篇文章能帮你快速上手Pinia，在Vue 3的开发路上一路“狂飙”！</p>\n"},{"title":"JavaScript ES6中的生成器(Generator)是什么？有哪些应用场景？一文全说透","date":"2025-12-06T04:34:14.000Z","_content":"今天是[JavaScript进阶系列文章](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU2MjU3MzI0MA==&action=getalbum&album_id=4120256678140837890#wechat_redirect)的第8篇文章了，今天我们来讲讲ES6中的生成器(Generator)。\n\nGenerator 是 ES6 新加的一种特殊函数，简单说就是**能暂停、能继续、能分批次给结果的函数**。普通函数一旦调用就从头跑到尾，而它像带了暂停键，想停就停，想继续就继续。核心特点就三个：\n\n##  怎么写？So easy!\n- 函数名前加 `function*`（星号跟着 function 写最清楚）\n- 用 `yield` 当“暂停标记”，碰到它就停，还能把后面的值抛出来\n- 调用后不会立马执行，会返回一个“操作手柄”（生成器对象），按手柄上的 `next()` 按钮才会启动/继续\n\n```javascript\n// 举个例子：分三次给数字\nfunction* numberGenerator() {\n  yield 1; // 第一次暂停，返回1\n  yield 2; // 第二次暂停，返回2\n  return 3; // 结束了，返回3\n}\n\n// 拿个操作手柄\nconst gen = numberGenerator();\n\nconsole.log(gen.next()); // { value: 1, done: false } → 按第一次，跑到第一个暂停点\nconsole.log(gen.next()); // { value: 2, done: false } → 按第二次，跑到第二个暂停点\nconsole.log(gen.next()); // { value: 3, done: true } → 按第三次，跑完了\n```\n\n 打个比方，普通函数像自助售货机一次性把所有商品全吐出来（全程不停）\n\n而生成器(Generator) 函数就是投一次币出一件货（出完就等下一次投币，也就是按 next()）\n\n---\n\n## 工作原理：记着暂停位置的“执行机器”\nGenerator 能暂停续跑，全靠一套“记位置的规则”（迭代器协议），本质就是个**带记忆的执行机器**，步骤特简单：\n\n **拿手柄不启动**：调用  `numberGenerator()` 时，函数里的代码一动不动，只给你个“手柄”（生成器对象）。\n \n **按 next() 才走**：每按一次手柄上的 `next()`，就从上次暂停的地方接着跑，直到碰到下一个 `yield` 或 `return`。\n \n**跑一步给个反馈**：`next()` 会返回一个对象，里面有俩信息：\n - `value`：这次跑出来的结果（yield 后面的值或 return 的值）\n  - `done`：布尔值，`false` 表示没跑完，`true` 表示彻底结束了\n    \n **结束就停摆**：一旦 `done` 变成 `true`，再按 `next()` 也没用，只会返回 `{ value: undefined, done: true }`。\n\n---\n\n## 好用的特性：不止能暂停\n\n### 能跟函数“对话”\n按 `next()` 时还能传参数，这个参数会变成**上一个 yield 的返回值**，相当于函数内外能互相传消息：\n\n```javascript\n// 模拟聊天机器人\nfunction* chatGenerator() {\n  // 暂停并问问题，等外部传名字进来\n  const name = yield \"请问你叫什么名字？\";\n  // 收到名字后，返回问候语\n  yield `你好，${name}！`;\n}\n\nconst chat = chatGenerator();\nconsole.log(chat.next().value); // 请问你叫什么名字？（第一次按，只提问）\nconsole.log(chat.next(\"张三\").value); // 你好，张三！（传名字过去，得到回应）\n```\n\n###  能抓错不崩溃\n可以主动给函数里抛错误，配合 `try/catch` 就能接住，不会让整个程序挂掉：\n\n```javascript\nfunction* safeGenerator() {\n  try {\n    yield \"正在正常跑\";\n    yield \"没出问题\";\n  } catch (err) {\n    // 接住错误并返回提示\n    yield `出错了：${err.message}`;\n  }\n}\n\nconst gen = safeGenerator();\nconsole.log(gen.next().value); // 正在正常跑\n// 主动抛个“网络断了”的错\nconsole.log(gen.throw(new Error(\"网络中断\")).value); // 出错了：网络中断\n```\n\n### 能叫“帮手”干活（yield*）\n用 `yield*` 能让别的“可迭代对象”（比如另一个 Generator、数组、字符串）帮着出结果，不用自己写重复代码：\n\n```javascript\n// 帮手1：负责出1和2\nfunction* gen1() { yield 1; yield 2; }\n// 主函数：让帮手先干活，再自己出3\nfunction* gen2() {\n  yield* gen1(); // 叫帮手gen1先上\n  yield 3;\n}\n\n[...gen2()] // 结果是 [1,2,3]，帮手的结果直接接过来\n\n// 也能让数组当帮手\nfunction* stringGenerator() {\n  yield* \"ABC\"; // 相当于依次出'A'、'B'、'C'\n}\n```\n\n###  能强制“叫停”\n用 `return()` 能直接终止函数，不管后面还有没有 `yield`，之后再按 `next()` 也没用：\n\n```javascript\nconst gen = numberGenerator();\nconsole.log(gen.next().value); // 1（跑第一步）\nconsole.log(gen.return(\"不跑了\").value); // 不跑了（强制叫停）\nconsole.log(gen.next().done); // true（彻底结束）\n```\n\n---\n\n## 什么场景用它？\n\n### 异步代码变“直”（替代回调地狱）\n以前写异步请求（比如调接口）要嵌套一堆回调，Generator 能让代码像同步一样写，不过得配合 Promise 和“自动按按钮的工具”（比如 co 库）：\n\n```javascript\n// 模拟调接口拿数据（1秒后返回结果）\nconst fetchData = (url) => new Promise(resolve => {\n  setTimeout(() => resolve(`从${url}拿到的数据`), 1000);\n});\n\n// 用Generator写异步流程，跟写同步代码一样\nfunction* asyncTask() {\n  try {\n    const user = yield fetchData(\"/api/user\"); // 等用户数据\n    const posts = yield fetchData(`/api/posts?uid=${user.id}`); // 再拿文章\n    return posts;\n  } catch (err) {\n    console.error(\"请求失败：\", err);\n  }\n}\n\n// 用co库自动按next（不用自己一次次点）\nconst co = require(\"co\");\nco(asyncTask).then(result => console.log(\"最终结果：\", result));\n```\n> 原理特简单：co库会盯着每次 yield 出来的 Promise，等它有结果了，自动按 next 把结果传进去，一直到函数跑完。\n\n###  自定义遍历逻辑（想要啥数据自己造）\nGenerator 天生就能当“遍历器”，比自己写复杂的遍历代码简单多了，比如：\n- 生成无限序列（比如斐波那契数列）\n- 遍历树、图这种复杂结构\n- 分批加载数据（用多少取多少）\n\n```javascript\n// 生成斐波那契数列（要多少取多少，不占内存）\nfunction* fibonacci() {\n  let a = 0, b = 1;\n  while (true) { // 无限循环也不怕，因为会暂停\n    [a, b] = [b, a + b];\n    yield b;\n  }\n}\n\nconst fib = fibonacci();\n// 只取前10个，不会一下生成无数个占内存\nfor (let i = 0; i < 10; i++) {\n  console.log(fib.next().value); // 1,2,3,5,8...\n}\n```\n\n### 分批处理大数据（不卡崩页面）\n处理海量数据或分页加载时，用 Generator 一次拿一批，避免一次性加载太多数据把页面卡崩：\n\n```javascript\n// 分页加载数据的工具\nfunction* paginatedLoader(pageSize = 10) {\n  let page = 1;\n  while (true) {\n    // 每次暂停，等着拿这一页的数据\n    const data = yield fetch(`/api/data?page=${page}&size=${pageSize}`);\n    if (data.length === 0) break; // 没数据了就停\n    page++;\n  }\n}\n\n// 用的时候按需加载\nconst loader = paginatedLoader();\nloader.next().then(data => 处理第1页数据(data));\nloader.next().then(data => 处理第2页数据(data));\n```\n\n###  管理状态流转（比如订单状态）\nGenerator 的“暂停-续跑”特别适合记录状态变化，每个 `yield` 就是一个状态，比如订单从“待支付”到“已完成”：\n\n```javascript\n// 订单状态机\nfunction* orderStateMachine() {\n  yield \"待支付\"; // 下单后状态\n  yield \"已支付\"; // 付款后状态\n  yield \"已发货\"; // 商家发货后\n  yield \"已完成\"; // 收货后\n}\n\nconst order = orderStateMachine();\nconsole.log(order.next().value); // 待支付（刚下单）\nconsole.log(order.next().value); // 已支付（付完钱）\nconsole.log(order.next().value); // 已发货（商家发了货）\n```\n\n---\n\n## Generator 和 async/await 啥关系？为啥还要学？\nasync/await 其实是 Generator 的“简化版”（底层就是 Generator + Promise），但它俩不是谁替代谁的关系，各有各的用处：\n\n| 特点         | Generator                | async/await          |\n|--------------|--------------------------|----------------------|\n| 写法         | function* + yield        | async + await        |\n| 要不要帮手   | 要（比如co库或自己按next）| 不用，浏览器直接支持  |\n| 主要能干啥   | 啥都能搞（暂停、遍历、状态）| 专门优化异步代码      |\n| 出错怎么抓   | 要调throw()方法          | 直接用try/catch就行  |\n\n为啥现在还要学 Generator？因为它有不可替代的地方：\n- **懂底层才会用上层**：明白 Generator 怎么跑，才真的懂 async/await 不是“黑魔法”；\n\n- **复杂遍历更简单**：生成无限序列、遍历树结构，比 async/await 代码短多了；\n - **能手动控制节奏**：比如做游戏帧同步、逐帧渲染动画，需要精确控制执行时机，Generator 更灵活。\n\n---\n\n## 总结：Generator 核心就是“能控制”\nGenerator 最牛的地方，就是给 JavaScript 加了“可控制的执行流程”——以前函数要么不跑，要么一口气跑完，现在能想停就停、想续就续、想传消息就传消息。\n\n虽然 async/await 抢了它“异步编程”的风头，但在造遍历器、管状态、处理大数据这些场景里，它还是无可替代。学懂它不光能解决实际问题，更能明白 JavaScript 函数是怎么“干活”的，算得上是从“会写代码”到“懂代码”的关键一步。\n\n**【往期精彩】**\n\n- [聊聊ES6里的Promise：简单理解和实际用法](https://mp.weixin.qq.com/s/9pnvL5fTO5U9yT-1mPfeQw)\n- [为什么 ES6 要新增 Set 和 Map？看完这篇就懂了](https://mp.weixin.qq.com/s/UuJeSErftQY7ee1a54Pv4A)\n- [JavaScript进化论：ES6如何让函数编写更加简洁、高效？](https://mp.weixin.qq.com/s/haq8TFc_YJlPjeWdyXokQw)\n- [JavaScript ES6中Object的拓展，你了解几个？](https://mp.weixin.qq.com/s/PTI3HGsfpDz4-GvRx0i9ew)\n- [Javascript高频面试点--ES6 数组新特性](https://mp.weixin.qq.com/s/qR65z8RbPFxW326UnogLqA)\n- [一文搞懂 JavaScript 里 var、let、const 的区别\n](https://mp.weixin.qq.com/s/lqn_51NNxx50YgvWkxCtEg)\n","source":"_posts/generator-in-es6.md","raw":"---\ntitle: JavaScript ES6中的生成器(Generator)是什么？有哪些应用场景？一文全说透\ndate: 2025-12-06 12:34:14\ntags: JavaScript进阶, ES6进阶\ncategory: ES6进阶\n---\n今天是[JavaScript进阶系列文章](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU2MjU3MzI0MA==&action=getalbum&album_id=4120256678140837890#wechat_redirect)的第8篇文章了，今天我们来讲讲ES6中的生成器(Generator)。\n\nGenerator 是 ES6 新加的一种特殊函数，简单说就是**能暂停、能继续、能分批次给结果的函数**。普通函数一旦调用就从头跑到尾，而它像带了暂停键，想停就停，想继续就继续。核心特点就三个：\n\n##  怎么写？So easy!\n- 函数名前加 `function*`（星号跟着 function 写最清楚）\n- 用 `yield` 当“暂停标记”，碰到它就停，还能把后面的值抛出来\n- 调用后不会立马执行，会返回一个“操作手柄”（生成器对象），按手柄上的 `next()` 按钮才会启动/继续\n\n```javascript\n// 举个例子：分三次给数字\nfunction* numberGenerator() {\n  yield 1; // 第一次暂停，返回1\n  yield 2; // 第二次暂停，返回2\n  return 3; // 结束了，返回3\n}\n\n// 拿个操作手柄\nconst gen = numberGenerator();\n\nconsole.log(gen.next()); // { value: 1, done: false } → 按第一次，跑到第一个暂停点\nconsole.log(gen.next()); // { value: 2, done: false } → 按第二次，跑到第二个暂停点\nconsole.log(gen.next()); // { value: 3, done: true } → 按第三次，跑完了\n```\n\n 打个比方，普通函数像自助售货机一次性把所有商品全吐出来（全程不停）\n\n而生成器(Generator) 函数就是投一次币出一件货（出完就等下一次投币，也就是按 next()）\n\n---\n\n## 工作原理：记着暂停位置的“执行机器”\nGenerator 能暂停续跑，全靠一套“记位置的规则”（迭代器协议），本质就是个**带记忆的执行机器**，步骤特简单：\n\n **拿手柄不启动**：调用  `numberGenerator()` 时，函数里的代码一动不动，只给你个“手柄”（生成器对象）。\n \n **按 next() 才走**：每按一次手柄上的 `next()`，就从上次暂停的地方接着跑，直到碰到下一个 `yield` 或 `return`。\n \n**跑一步给个反馈**：`next()` 会返回一个对象，里面有俩信息：\n - `value`：这次跑出来的结果（yield 后面的值或 return 的值）\n  - `done`：布尔值，`false` 表示没跑完，`true` 表示彻底结束了\n    \n **结束就停摆**：一旦 `done` 变成 `true`，再按 `next()` 也没用，只会返回 `{ value: undefined, done: true }`。\n\n---\n\n## 好用的特性：不止能暂停\n\n### 能跟函数“对话”\n按 `next()` 时还能传参数，这个参数会变成**上一个 yield 的返回值**，相当于函数内外能互相传消息：\n\n```javascript\n// 模拟聊天机器人\nfunction* chatGenerator() {\n  // 暂停并问问题，等外部传名字进来\n  const name = yield \"请问你叫什么名字？\";\n  // 收到名字后，返回问候语\n  yield `你好，${name}！`;\n}\n\nconst chat = chatGenerator();\nconsole.log(chat.next().value); // 请问你叫什么名字？（第一次按，只提问）\nconsole.log(chat.next(\"张三\").value); // 你好，张三！（传名字过去，得到回应）\n```\n\n###  能抓错不崩溃\n可以主动给函数里抛错误，配合 `try/catch` 就能接住，不会让整个程序挂掉：\n\n```javascript\nfunction* safeGenerator() {\n  try {\n    yield \"正在正常跑\";\n    yield \"没出问题\";\n  } catch (err) {\n    // 接住错误并返回提示\n    yield `出错了：${err.message}`;\n  }\n}\n\nconst gen = safeGenerator();\nconsole.log(gen.next().value); // 正在正常跑\n// 主动抛个“网络断了”的错\nconsole.log(gen.throw(new Error(\"网络中断\")).value); // 出错了：网络中断\n```\n\n### 能叫“帮手”干活（yield*）\n用 `yield*` 能让别的“可迭代对象”（比如另一个 Generator、数组、字符串）帮着出结果，不用自己写重复代码：\n\n```javascript\n// 帮手1：负责出1和2\nfunction* gen1() { yield 1; yield 2; }\n// 主函数：让帮手先干活，再自己出3\nfunction* gen2() {\n  yield* gen1(); // 叫帮手gen1先上\n  yield 3;\n}\n\n[...gen2()] // 结果是 [1,2,3]，帮手的结果直接接过来\n\n// 也能让数组当帮手\nfunction* stringGenerator() {\n  yield* \"ABC\"; // 相当于依次出'A'、'B'、'C'\n}\n```\n\n###  能强制“叫停”\n用 `return()` 能直接终止函数，不管后面还有没有 `yield`，之后再按 `next()` 也没用：\n\n```javascript\nconst gen = numberGenerator();\nconsole.log(gen.next().value); // 1（跑第一步）\nconsole.log(gen.return(\"不跑了\").value); // 不跑了（强制叫停）\nconsole.log(gen.next().done); // true（彻底结束）\n```\n\n---\n\n## 什么场景用它？\n\n### 异步代码变“直”（替代回调地狱）\n以前写异步请求（比如调接口）要嵌套一堆回调，Generator 能让代码像同步一样写，不过得配合 Promise 和“自动按按钮的工具”（比如 co 库）：\n\n```javascript\n// 模拟调接口拿数据（1秒后返回结果）\nconst fetchData = (url) => new Promise(resolve => {\n  setTimeout(() => resolve(`从${url}拿到的数据`), 1000);\n});\n\n// 用Generator写异步流程，跟写同步代码一样\nfunction* asyncTask() {\n  try {\n    const user = yield fetchData(\"/api/user\"); // 等用户数据\n    const posts = yield fetchData(`/api/posts?uid=${user.id}`); // 再拿文章\n    return posts;\n  } catch (err) {\n    console.error(\"请求失败：\", err);\n  }\n}\n\n// 用co库自动按next（不用自己一次次点）\nconst co = require(\"co\");\nco(asyncTask).then(result => console.log(\"最终结果：\", result));\n```\n> 原理特简单：co库会盯着每次 yield 出来的 Promise，等它有结果了，自动按 next 把结果传进去，一直到函数跑完。\n\n###  自定义遍历逻辑（想要啥数据自己造）\nGenerator 天生就能当“遍历器”，比自己写复杂的遍历代码简单多了，比如：\n- 生成无限序列（比如斐波那契数列）\n- 遍历树、图这种复杂结构\n- 分批加载数据（用多少取多少）\n\n```javascript\n// 生成斐波那契数列（要多少取多少，不占内存）\nfunction* fibonacci() {\n  let a = 0, b = 1;\n  while (true) { // 无限循环也不怕，因为会暂停\n    [a, b] = [b, a + b];\n    yield b;\n  }\n}\n\nconst fib = fibonacci();\n// 只取前10个，不会一下生成无数个占内存\nfor (let i = 0; i < 10; i++) {\n  console.log(fib.next().value); // 1,2,3,5,8...\n}\n```\n\n### 分批处理大数据（不卡崩页面）\n处理海量数据或分页加载时，用 Generator 一次拿一批，避免一次性加载太多数据把页面卡崩：\n\n```javascript\n// 分页加载数据的工具\nfunction* paginatedLoader(pageSize = 10) {\n  let page = 1;\n  while (true) {\n    // 每次暂停，等着拿这一页的数据\n    const data = yield fetch(`/api/data?page=${page}&size=${pageSize}`);\n    if (data.length === 0) break; // 没数据了就停\n    page++;\n  }\n}\n\n// 用的时候按需加载\nconst loader = paginatedLoader();\nloader.next().then(data => 处理第1页数据(data));\nloader.next().then(data => 处理第2页数据(data));\n```\n\n###  管理状态流转（比如订单状态）\nGenerator 的“暂停-续跑”特别适合记录状态变化，每个 `yield` 就是一个状态，比如订单从“待支付”到“已完成”：\n\n```javascript\n// 订单状态机\nfunction* orderStateMachine() {\n  yield \"待支付\"; // 下单后状态\n  yield \"已支付\"; // 付款后状态\n  yield \"已发货\"; // 商家发货后\n  yield \"已完成\"; // 收货后\n}\n\nconst order = orderStateMachine();\nconsole.log(order.next().value); // 待支付（刚下单）\nconsole.log(order.next().value); // 已支付（付完钱）\nconsole.log(order.next().value); // 已发货（商家发了货）\n```\n\n---\n\n## Generator 和 async/await 啥关系？为啥还要学？\nasync/await 其实是 Generator 的“简化版”（底层就是 Generator + Promise），但它俩不是谁替代谁的关系，各有各的用处：\n\n| 特点         | Generator                | async/await          |\n|--------------|--------------------------|----------------------|\n| 写法         | function* + yield        | async + await        |\n| 要不要帮手   | 要（比如co库或自己按next）| 不用，浏览器直接支持  |\n| 主要能干啥   | 啥都能搞（暂停、遍历、状态）| 专门优化异步代码      |\n| 出错怎么抓   | 要调throw()方法          | 直接用try/catch就行  |\n\n为啥现在还要学 Generator？因为它有不可替代的地方：\n- **懂底层才会用上层**：明白 Generator 怎么跑，才真的懂 async/await 不是“黑魔法”；\n\n- **复杂遍历更简单**：生成无限序列、遍历树结构，比 async/await 代码短多了；\n - **能手动控制节奏**：比如做游戏帧同步、逐帧渲染动画，需要精确控制执行时机，Generator 更灵活。\n\n---\n\n## 总结：Generator 核心就是“能控制”\nGenerator 最牛的地方，就是给 JavaScript 加了“可控制的执行流程”——以前函数要么不跑，要么一口气跑完，现在能想停就停、想续就续、想传消息就传消息。\n\n虽然 async/await 抢了它“异步编程”的风头，但在造遍历器、管状态、处理大数据这些场景里，它还是无可替代。学懂它不光能解决实际问题，更能明白 JavaScript 函数是怎么“干活”的，算得上是从“会写代码”到“懂代码”的关键一步。\n\n**【往期精彩】**\n\n- [聊聊ES6里的Promise：简单理解和实际用法](https://mp.weixin.qq.com/s/9pnvL5fTO5U9yT-1mPfeQw)\n- [为什么 ES6 要新增 Set 和 Map？看完这篇就懂了](https://mp.weixin.qq.com/s/UuJeSErftQY7ee1a54Pv4A)\n- [JavaScript进化论：ES6如何让函数编写更加简洁、高效？](https://mp.weixin.qq.com/s/haq8TFc_YJlPjeWdyXokQw)\n- [JavaScript ES6中Object的拓展，你了解几个？](https://mp.weixin.qq.com/s/PTI3HGsfpDz4-GvRx0i9ew)\n- [Javascript高频面试点--ES6 数组新特性](https://mp.weixin.qq.com/s/qR65z8RbPFxW326UnogLqA)\n- [一文搞懂 JavaScript 里 var、let、const 的区别\n](https://mp.weixin.qq.com/s/lqn_51NNxx50YgvWkxCtEg)\n","slug":"generator-in-es6","published":1,"updated":"2025-12-06T04:47:41.768Z","comments":1,"layout":"post","photos":[],"_id":"cmjbml2id001mikup7p874pb1","content":"<p>今天是<a href=\"https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU2MjU3MzI0MA==&action=getalbum&album_id=4120256678140837890#wechat_redirect\">JavaScript进阶系列文章</a>的第8篇文章了，今天我们来讲讲ES6中的生成器(Generator)。</p>\n<p>Generator 是 ES6 新加的一种特殊函数，简单说就是<strong>能暂停、能继续、能分批次给结果的函数</strong>。普通函数一旦调用就从头跑到尾，而它像带了暂停键，想停就停，想继续就继续。核心特点就三个：</p>\n<h2 id=\"怎么写？So-easy\"><a href=\"#怎么写？So-easy\" class=\"headerlink\" title=\"怎么写？So easy!\"></a>怎么写？So easy!</h2><ul>\n<li>函数名前加 <code>function*</code>（星号跟着 function 写最清楚）</li>\n<li>用 <code>yield</code> 当“暂停标记”，碰到它就停，还能把后面的值抛出来</li>\n<li>调用后不会立马执行，会返回一个“操作手柄”（生成器对象），按手柄上的 <code>next()</code> 按钮才会启动&#x2F;继续</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 举个例子：分三次给数字</span><br><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">numberGenerator</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// 第一次暂停，返回1</span><br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// 第二次暂停，返回2</span><br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">3</span>; <span class=\"hljs-comment\">// 结束了，返回3</span><br>&#125;<br><br><span class=\"hljs-comment\">// 拿个操作手柄</span><br><span class=\"hljs-keyword\">const</span> gen = <span class=\"hljs-title function_\">numberGenerator</span>();<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(gen.<span class=\"hljs-title function_\">next</span>()); <span class=\"hljs-comment\">// &#123; value: 1, done: false &#125; → 按第一次，跑到第一个暂停点</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(gen.<span class=\"hljs-title function_\">next</span>()); <span class=\"hljs-comment\">// &#123; value: 2, done: false &#125; → 按第二次，跑到第二个暂停点</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(gen.<span class=\"hljs-title function_\">next</span>()); <span class=\"hljs-comment\">// &#123; value: 3, done: true &#125; → 按第三次，跑完了</span><br></code></pre></td></tr></table></figure>\n\n<p> 打个比方，普通函数像自助售货机一次性把所有商品全吐出来（全程不停）</p>\n<p>而生成器(Generator) 函数就是投一次币出一件货（出完就等下一次投币，也就是按 next()）</p>\n<hr>\n<h2 id=\"工作原理：记着暂停位置的“执行机器”\"><a href=\"#工作原理：记着暂停位置的“执行机器”\" class=\"headerlink\" title=\"工作原理：记着暂停位置的“执行机器”\"></a>工作原理：记着暂停位置的“执行机器”</h2><p>Generator 能暂停续跑，全靠一套“记位置的规则”（迭代器协议），本质就是个<strong>带记忆的执行机器</strong>，步骤特简单：</p>\n<p> <strong>拿手柄不启动</strong>：调用  <code>numberGenerator()</code> 时，函数里的代码一动不动，只给你个“手柄”（生成器对象）。</p>\n<p> <strong>按 next() 才走</strong>：每按一次手柄上的 <code>next()</code>，就从上次暂停的地方接着跑，直到碰到下一个 <code>yield</code> 或 <code>return</code>。</p>\n<p><strong>跑一步给个反馈</strong>：<code>next()</code> 会返回一个对象，里面有俩信息：</p>\n<ul>\n<li><code>value</code>：这次跑出来的结果（yield 后面的值或 return 的值）</li>\n<li><code>done</code>：布尔值，<code>false</code> 表示没跑完，<code>true</code> 表示彻底结束了</li>\n</ul>\n<p> <strong>结束就停摆</strong>：一旦 <code>done</code> 变成 <code>true</code>，再按 <code>next()</code> 也没用，只会返回 <code>&#123; value: undefined, done: true &#125;</code>。</p>\n<hr>\n<h2 id=\"好用的特性：不止能暂停\"><a href=\"#好用的特性：不止能暂停\" class=\"headerlink\" title=\"好用的特性：不止能暂停\"></a>好用的特性：不止能暂停</h2><h3 id=\"能跟函数“对话”\"><a href=\"#能跟函数“对话”\" class=\"headerlink\" title=\"能跟函数“对话”\"></a>能跟函数“对话”</h3><p>按 <code>next()</code> 时还能传参数，这个参数会变成<strong>上一个 yield 的返回值</strong>，相当于函数内外能互相传消息：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 模拟聊天机器人</span><br><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">chatGenerator</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-comment\">// 暂停并问问题，等外部传名字进来</span><br>  <span class=\"hljs-keyword\">const</span> name = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&quot;请问你叫什么名字？&quot;</span>;<br>  <span class=\"hljs-comment\">// 收到名字后，返回问候语</span><br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">`你好，<span class=\"hljs-subst\">$&#123;name&#125;</span>！`</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> chat = <span class=\"hljs-title function_\">chatGenerator</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(chat.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>); <span class=\"hljs-comment\">// 请问你叫什么名字？（第一次按，只提问）</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(chat.<span class=\"hljs-title function_\">next</span>(<span class=\"hljs-string\">&quot;张三&quot;</span>).<span class=\"hljs-property\">value</span>); <span class=\"hljs-comment\">// 你好，张三！（传名字过去，得到回应）</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"能抓错不崩溃\"><a href=\"#能抓错不崩溃\" class=\"headerlink\" title=\"能抓错不崩溃\"></a>能抓错不崩溃</h3><p>可以主动给函数里抛错误，配合 <code>try/catch</code> 就能接住，不会让整个程序挂掉：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">safeGenerator</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&quot;正在正常跑&quot;</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&quot;没出问题&quot;</span>;<br>  &#125; <span class=\"hljs-keyword\">catch</span> (err) &#123;<br>    <span class=\"hljs-comment\">// 接住错误并返回提示</span><br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">`出错了：<span class=\"hljs-subst\">$&#123;err.message&#125;</span>`</span>;<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> gen = <span class=\"hljs-title function_\">safeGenerator</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(gen.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>); <span class=\"hljs-comment\">// 正在正常跑</span><br><span class=\"hljs-comment\">// 主动抛个“网络断了”的错</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(gen.<span class=\"hljs-keyword\">throw</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&quot;网络中断&quot;</span>)).<span class=\"hljs-property\">value</span>); <span class=\"hljs-comment\">// 出错了：网络中断</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"能叫“帮手”干活（yield-）\"><a href=\"#能叫“帮手”干活（yield-）\" class=\"headerlink\" title=\"能叫“帮手”干活（yield*）\"></a>能叫“帮手”干活（yield*）</h3><p>用 <code>yield*</code> 能让别的“可迭代对象”（比如另一个 Generator、数组、字符串）帮着出结果，不用自己写重复代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 帮手1：负责出1和2</span><br><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">gen1</span>(<span class=\"hljs-params\"></span>) &#123; <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>; <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>; &#125;<br><span class=\"hljs-comment\">// 主函数：让帮手先干活，再自己出3</span><br><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">gen2</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">yield</span>* <span class=\"hljs-title function_\">gen1</span>(); <span class=\"hljs-comment\">// 叫帮手gen1先上</span><br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;<br>&#125;<br><br>[...<span class=\"hljs-title function_\">gen2</span>()] <span class=\"hljs-comment\">// 结果是 [1,2,3]，帮手的结果直接接过来</span><br><br><span class=\"hljs-comment\">// 也能让数组当帮手</span><br><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">stringGenerator</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">yield</span>* <span class=\"hljs-string\">&quot;ABC&quot;</span>; <span class=\"hljs-comment\">// 相当于依次出&#x27;A&#x27;、&#x27;B&#x27;、&#x27;C&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"能强制“叫停”\"><a href=\"#能强制“叫停”\" class=\"headerlink\" title=\"能强制“叫停”\"></a>能强制“叫停”</h3><p>用 <code>return()</code> 能直接终止函数，不管后面还有没有 <code>yield</code>，之后再按 <code>next()</code> 也没用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> gen = <span class=\"hljs-title function_\">numberGenerator</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(gen.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>); <span class=\"hljs-comment\">// 1（跑第一步）</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(gen.<span class=\"hljs-keyword\">return</span>(<span class=\"hljs-string\">&quot;不跑了&quot;</span>).<span class=\"hljs-property\">value</span>); <span class=\"hljs-comment\">// 不跑了（强制叫停）</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(gen.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">done</span>); <span class=\"hljs-comment\">// true（彻底结束）</span><br></code></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"什么场景用它？\"><a href=\"#什么场景用它？\" class=\"headerlink\" title=\"什么场景用它？\"></a>什么场景用它？</h2><h3 id=\"异步代码变“直”（替代回调地狱）\"><a href=\"#异步代码变“直”（替代回调地狱）\" class=\"headerlink\" title=\"异步代码变“直”（替代回调地狱）\"></a>异步代码变“直”（替代回调地狱）</h3><p>以前写异步请求（比如调接口）要嵌套一堆回调，Generator 能让代码像同步一样写，不过得配合 Promise 和“自动按按钮的工具”（比如 co 库）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 模拟调接口拿数据（1秒后返回结果）</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">fetchData</span> = (<span class=\"hljs-params\">url</span>) =&gt; <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">`从<span class=\"hljs-subst\">$&#123;url&#125;</span>拿到的数据`</span>), <span class=\"hljs-number\">1000</span>);<br>&#125;);<br><br><span class=\"hljs-comment\">// 用Generator写异步流程，跟写同步代码一样</span><br><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">asyncTask</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> user = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">fetchData</span>(<span class=\"hljs-string\">&quot;/api/user&quot;</span>); <span class=\"hljs-comment\">// 等用户数据</span><br>    <span class=\"hljs-keyword\">const</span> posts = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">fetchData</span>(<span class=\"hljs-string\">`/api/posts?uid=<span class=\"hljs-subst\">$&#123;user.id&#125;</span>`</span>); <span class=\"hljs-comment\">// 再拿文章</span><br>    <span class=\"hljs-keyword\">return</span> posts;<br>  &#125; <span class=\"hljs-keyword\">catch</span> (err) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">&quot;请求失败：&quot;</span>, err);<br>  &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 用co库自动按next（不用自己一次次点）</span><br><span class=\"hljs-keyword\">const</span> co = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;co&quot;</span>);<br><span class=\"hljs-title function_\">co</span>(asyncTask).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">result</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;最终结果：&quot;</span>, result));<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>原理特简单：co库会盯着每次 yield 出来的 Promise，等它有结果了，自动按 next 把结果传进去，一直到函数跑完。</p>\n</blockquote>\n<h3 id=\"自定义遍历逻辑（想要啥数据自己造）\"><a href=\"#自定义遍历逻辑（想要啥数据自己造）\" class=\"headerlink\" title=\"自定义遍历逻辑（想要啥数据自己造）\"></a>自定义遍历逻辑（想要啥数据自己造）</h3><p>Generator 天生就能当“遍历器”，比自己写复杂的遍历代码简单多了，比如：</p>\n<ul>\n<li>生成无限序列（比如斐波那契数列）</li>\n<li>遍历树、图这种复杂结构</li>\n<li>分批加载数据（用多少取多少）</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 生成斐波那契数列（要多少取多少，不占内存）</span><br><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">fibonacci</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-number\">0</span>, b = <span class=\"hljs-number\">1</span>;<br>  <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123; <span class=\"hljs-comment\">// 无限循环也不怕，因为会暂停</span><br>    [a, b] = [b, a + b];<br>    <span class=\"hljs-keyword\">yield</span> b;<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> fib = <span class=\"hljs-title function_\">fibonacci</span>();<br><span class=\"hljs-comment\">// 只取前10个，不会一下生成无数个占内存</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(fib.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>); <span class=\"hljs-comment\">// 1,2,3,5,8...</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"分批处理大数据（不卡崩页面）\"><a href=\"#分批处理大数据（不卡崩页面）\" class=\"headerlink\" title=\"分批处理大数据（不卡崩页面）\"></a>分批处理大数据（不卡崩页面）</h3><p>处理海量数据或分页加载时，用 Generator 一次拿一批，避免一次性加载太多数据把页面卡崩：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 分页加载数据的工具</span><br><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">paginatedLoader</span>(<span class=\"hljs-params\">pageSize = <span class=\"hljs-number\">10</span></span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> page = <span class=\"hljs-number\">1</span>;<br>  <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>    <span class=\"hljs-comment\">// 每次暂停，等着拿这一页的数据</span><br>    <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">`/api/data?page=<span class=\"hljs-subst\">$&#123;page&#125;</span>&amp;size=<span class=\"hljs-subst\">$&#123;pageSize&#125;</span>`</span>);<br>    <span class=\"hljs-keyword\">if</span> (data.<span class=\"hljs-property\">length</span> === <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">break</span>; <span class=\"hljs-comment\">// 没数据了就停</span><br>    page++;<br>  &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 用的时候按需加载</span><br><span class=\"hljs-keyword\">const</span> loader = <span class=\"hljs-title function_\">paginatedLoader</span>();<br>loader.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> 处理第<span class=\"hljs-number\">1</span>页数据(data));<br>loader.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> 处理第<span class=\"hljs-number\">2</span>页数据(data));<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"管理状态流转（比如订单状态）\"><a href=\"#管理状态流转（比如订单状态）\" class=\"headerlink\" title=\"管理状态流转（比如订单状态）\"></a>管理状态流转（比如订单状态）</h3><p>Generator 的“暂停-续跑”特别适合记录状态变化，每个 <code>yield</code> 就是一个状态，比如订单从“待支付”到“已完成”：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 订单状态机</span><br><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">orderStateMachine</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&quot;待支付&quot;</span>; <span class=\"hljs-comment\">// 下单后状态</span><br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&quot;已支付&quot;</span>; <span class=\"hljs-comment\">// 付款后状态</span><br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&quot;已发货&quot;</span>; <span class=\"hljs-comment\">// 商家发货后</span><br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&quot;已完成&quot;</span>; <span class=\"hljs-comment\">// 收货后</span><br>&#125;<br><br><span class=\"hljs-keyword\">const</span> order = <span class=\"hljs-title function_\">orderStateMachine</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(order.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>); <span class=\"hljs-comment\">// 待支付（刚下单）</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(order.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>); <span class=\"hljs-comment\">// 已支付（付完钱）</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(order.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>); <span class=\"hljs-comment\">// 已发货（商家发了货）</span><br></code></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"Generator-和-async-await-啥关系？为啥还要学？\"><a href=\"#Generator-和-async-await-啥关系？为啥还要学？\" class=\"headerlink\" title=\"Generator 和 async&#x2F;await 啥关系？为啥还要学？\"></a>Generator 和 async&#x2F;await 啥关系？为啥还要学？</h2><p>async&#x2F;await 其实是 Generator 的“简化版”（底层就是 Generator + Promise），但它俩不是谁替代谁的关系，各有各的用处：</p>\n<table>\n<thead>\n<tr>\n<th>特点</th>\n<th>Generator</th>\n<th>async&#x2F;await</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>写法</td>\n<td>function* + yield</td>\n<td>async + await</td>\n</tr>\n<tr>\n<td>要不要帮手</td>\n<td>要（比如co库或自己按next）</td>\n<td>不用，浏览器直接支持</td>\n</tr>\n<tr>\n<td>主要能干啥</td>\n<td>啥都能搞（暂停、遍历、状态）</td>\n<td>专门优化异步代码</td>\n</tr>\n<tr>\n<td>出错怎么抓</td>\n<td>要调throw()方法</td>\n<td>直接用try&#x2F;catch就行</td>\n</tr>\n</tbody></table>\n<p>为啥现在还要学 Generator？因为它有不可替代的地方：</p>\n<ul>\n<li><p><strong>懂底层才会用上层</strong>：明白 Generator 怎么跑，才真的懂 async&#x2F;await 不是“黑魔法”；</p>\n</li>\n<li><p><strong>复杂遍历更简单</strong>：生成无限序列、遍历树结构，比 async&#x2F;await 代码短多了；</p>\n</li>\n<li><p><strong>能手动控制节奏</strong>：比如做游戏帧同步、逐帧渲染动画，需要精确控制执行时机，Generator 更灵活。</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"总结：Generator-核心就是“能控制”\"><a href=\"#总结：Generator-核心就是“能控制”\" class=\"headerlink\" title=\"总结：Generator 核心就是“能控制”\"></a>总结：Generator 核心就是“能控制”</h2><p>Generator 最牛的地方，就是给 JavaScript 加了“可控制的执行流程”——以前函数要么不跑，要么一口气跑完，现在能想停就停、想续就续、想传消息就传消息。</p>\n<p>虽然 async&#x2F;await 抢了它“异步编程”的风头，但在造遍历器、管状态、处理大数据这些场景里，它还是无可替代。学懂它不光能解决实际问题，更能明白 JavaScript 函数是怎么“干活”的，算得上是从“会写代码”到“懂代码”的关键一步。</p>\n<p><strong>【往期精彩】</strong></p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/9pnvL5fTO5U9yT-1mPfeQw\">聊聊ES6里的Promise：简单理解和实际用法</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/UuJeSErftQY7ee1a54Pv4A\">为什么 ES6 要新增 Set 和 Map？看完这篇就懂了</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/haq8TFc_YJlPjeWdyXokQw\">JavaScript进化论：ES6如何让函数编写更加简洁、高效？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/PTI3HGsfpDz4-GvRx0i9ew\">JavaScript ES6中Object的拓展，你了解几个？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/qR65z8RbPFxW326UnogLqA\">Javascript高频面试点–ES6 数组新特性</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/lqn_51NNxx50YgvWkxCtEg\">一文搞懂 JavaScript 里 var、let、const 的区别\n</a></li>\n</ul>\n","excerpt":"","more":"<p>今天是<a href=\"https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU2MjU3MzI0MA==&action=getalbum&album_id=4120256678140837890#wechat_redirect\">JavaScript进阶系列文章</a>的第8篇文章了，今天我们来讲讲ES6中的生成器(Generator)。</p>\n<p>Generator 是 ES6 新加的一种特殊函数，简单说就是<strong>能暂停、能继续、能分批次给结果的函数</strong>。普通函数一旦调用就从头跑到尾，而它像带了暂停键，想停就停，想继续就继续。核心特点就三个：</p>\n<h2 id=\"怎么写？So-easy\"><a href=\"#怎么写？So-easy\" class=\"headerlink\" title=\"怎么写？So easy!\"></a>怎么写？So easy!</h2><ul>\n<li>函数名前加 <code>function*</code>（星号跟着 function 写最清楚）</li>\n<li>用 <code>yield</code> 当“暂停标记”，碰到它就停，还能把后面的值抛出来</li>\n<li>调用后不会立马执行，会返回一个“操作手柄”（生成器对象），按手柄上的 <code>next()</code> 按钮才会启动&#x2F;继续</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 举个例子：分三次给数字</span><br><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">numberGenerator</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// 第一次暂停，返回1</span><br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>; <span class=\"hljs-comment\">// 第二次暂停，返回2</span><br>  <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">3</span>; <span class=\"hljs-comment\">// 结束了，返回3</span><br>&#125;<br><br><span class=\"hljs-comment\">// 拿个操作手柄</span><br><span class=\"hljs-keyword\">const</span> gen = <span class=\"hljs-title function_\">numberGenerator</span>();<br><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(gen.<span class=\"hljs-title function_\">next</span>()); <span class=\"hljs-comment\">// &#123; value: 1, done: false &#125; → 按第一次，跑到第一个暂停点</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(gen.<span class=\"hljs-title function_\">next</span>()); <span class=\"hljs-comment\">// &#123; value: 2, done: false &#125; → 按第二次，跑到第二个暂停点</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(gen.<span class=\"hljs-title function_\">next</span>()); <span class=\"hljs-comment\">// &#123; value: 3, done: true &#125; → 按第三次，跑完了</span><br></code></pre></td></tr></table></figure>\n\n<p> 打个比方，普通函数像自助售货机一次性把所有商品全吐出来（全程不停）</p>\n<p>而生成器(Generator) 函数就是投一次币出一件货（出完就等下一次投币，也就是按 next()）</p>\n<hr>\n<h2 id=\"工作原理：记着暂停位置的“执行机器”\"><a href=\"#工作原理：记着暂停位置的“执行机器”\" class=\"headerlink\" title=\"工作原理：记着暂停位置的“执行机器”\"></a>工作原理：记着暂停位置的“执行机器”</h2><p>Generator 能暂停续跑，全靠一套“记位置的规则”（迭代器协议），本质就是个<strong>带记忆的执行机器</strong>，步骤特简单：</p>\n<p> <strong>拿手柄不启动</strong>：调用  <code>numberGenerator()</code> 时，函数里的代码一动不动，只给你个“手柄”（生成器对象）。</p>\n<p> <strong>按 next() 才走</strong>：每按一次手柄上的 <code>next()</code>，就从上次暂停的地方接着跑，直到碰到下一个 <code>yield</code> 或 <code>return</code>。</p>\n<p><strong>跑一步给个反馈</strong>：<code>next()</code> 会返回一个对象，里面有俩信息：</p>\n<ul>\n<li><code>value</code>：这次跑出来的结果（yield 后面的值或 return 的值）</li>\n<li><code>done</code>：布尔值，<code>false</code> 表示没跑完，<code>true</code> 表示彻底结束了</li>\n</ul>\n<p> <strong>结束就停摆</strong>：一旦 <code>done</code> 变成 <code>true</code>，再按 <code>next()</code> 也没用，只会返回 <code>&#123; value: undefined, done: true &#125;</code>。</p>\n<hr>\n<h2 id=\"好用的特性：不止能暂停\"><a href=\"#好用的特性：不止能暂停\" class=\"headerlink\" title=\"好用的特性：不止能暂停\"></a>好用的特性：不止能暂停</h2><h3 id=\"能跟函数“对话”\"><a href=\"#能跟函数“对话”\" class=\"headerlink\" title=\"能跟函数“对话”\"></a>能跟函数“对话”</h3><p>按 <code>next()</code> 时还能传参数，这个参数会变成<strong>上一个 yield 的返回值</strong>，相当于函数内外能互相传消息：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 模拟聊天机器人</span><br><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">chatGenerator</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-comment\">// 暂停并问问题，等外部传名字进来</span><br>  <span class=\"hljs-keyword\">const</span> name = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&quot;请问你叫什么名字？&quot;</span>;<br>  <span class=\"hljs-comment\">// 收到名字后，返回问候语</span><br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">`你好，<span class=\"hljs-subst\">$&#123;name&#125;</span>！`</span>;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> chat = <span class=\"hljs-title function_\">chatGenerator</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(chat.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>); <span class=\"hljs-comment\">// 请问你叫什么名字？（第一次按，只提问）</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(chat.<span class=\"hljs-title function_\">next</span>(<span class=\"hljs-string\">&quot;张三&quot;</span>).<span class=\"hljs-property\">value</span>); <span class=\"hljs-comment\">// 你好，张三！（传名字过去，得到回应）</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"能抓错不崩溃\"><a href=\"#能抓错不崩溃\" class=\"headerlink\" title=\"能抓错不崩溃\"></a>能抓错不崩溃</h3><p>可以主动给函数里抛错误，配合 <code>try/catch</code> 就能接住，不会让整个程序挂掉：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">safeGenerator</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&quot;正在正常跑&quot;</span>;<br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&quot;没出问题&quot;</span>;<br>  &#125; <span class=\"hljs-keyword\">catch</span> (err) &#123;<br>    <span class=\"hljs-comment\">// 接住错误并返回提示</span><br>    <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">`出错了：<span class=\"hljs-subst\">$&#123;err.message&#125;</span>`</span>;<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> gen = <span class=\"hljs-title function_\">safeGenerator</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(gen.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>); <span class=\"hljs-comment\">// 正在正常跑</span><br><span class=\"hljs-comment\">// 主动抛个“网络断了”的错</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(gen.<span class=\"hljs-keyword\">throw</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&quot;网络中断&quot;</span>)).<span class=\"hljs-property\">value</span>); <span class=\"hljs-comment\">// 出错了：网络中断</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"能叫“帮手”干活（yield-）\"><a href=\"#能叫“帮手”干活（yield-）\" class=\"headerlink\" title=\"能叫“帮手”干活（yield*）\"></a>能叫“帮手”干活（yield*）</h3><p>用 <code>yield*</code> 能让别的“可迭代对象”（比如另一个 Generator、数组、字符串）帮着出结果，不用自己写重复代码：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 帮手1：负责出1和2</span><br><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">gen1</span>(<span class=\"hljs-params\"></span>) &#123; <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">1</span>; <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">2</span>; &#125;<br><span class=\"hljs-comment\">// 主函数：让帮手先干活，再自己出3</span><br><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">gen2</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">yield</span>* <span class=\"hljs-title function_\">gen1</span>(); <span class=\"hljs-comment\">// 叫帮手gen1先上</span><br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-number\">3</span>;<br>&#125;<br><br>[...<span class=\"hljs-title function_\">gen2</span>()] <span class=\"hljs-comment\">// 结果是 [1,2,3]，帮手的结果直接接过来</span><br><br><span class=\"hljs-comment\">// 也能让数组当帮手</span><br><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">stringGenerator</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">yield</span>* <span class=\"hljs-string\">&quot;ABC&quot;</span>; <span class=\"hljs-comment\">// 相当于依次出&#x27;A&#x27;、&#x27;B&#x27;、&#x27;C&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"能强制“叫停”\"><a href=\"#能强制“叫停”\" class=\"headerlink\" title=\"能强制“叫停”\"></a>能强制“叫停”</h3><p>用 <code>return()</code> 能直接终止函数，不管后面还有没有 <code>yield</code>，之后再按 <code>next()</code> 也没用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> gen = <span class=\"hljs-title function_\">numberGenerator</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(gen.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>); <span class=\"hljs-comment\">// 1（跑第一步）</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(gen.<span class=\"hljs-keyword\">return</span>(<span class=\"hljs-string\">&quot;不跑了&quot;</span>).<span class=\"hljs-property\">value</span>); <span class=\"hljs-comment\">// 不跑了（强制叫停）</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(gen.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">done</span>); <span class=\"hljs-comment\">// true（彻底结束）</span><br></code></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"什么场景用它？\"><a href=\"#什么场景用它？\" class=\"headerlink\" title=\"什么场景用它？\"></a>什么场景用它？</h2><h3 id=\"异步代码变“直”（替代回调地狱）\"><a href=\"#异步代码变“直”（替代回调地狱）\" class=\"headerlink\" title=\"异步代码变“直”（替代回调地狱）\"></a>异步代码变“直”（替代回调地狱）</h3><p>以前写异步请求（比如调接口）要嵌套一堆回调，Generator 能让代码像同步一样写，不过得配合 Promise 和“自动按按钮的工具”（比如 co 库）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 模拟调接口拿数据（1秒后返回结果）</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">fetchData</span> = (<span class=\"hljs-params\">url</span>) =&gt; <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">resolve</span> =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">`从<span class=\"hljs-subst\">$&#123;url&#125;</span>拿到的数据`</span>), <span class=\"hljs-number\">1000</span>);<br>&#125;);<br><br><span class=\"hljs-comment\">// 用Generator写异步流程，跟写同步代码一样</span><br><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">asyncTask</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">try</span> &#123;<br>    <span class=\"hljs-keyword\">const</span> user = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">fetchData</span>(<span class=\"hljs-string\">&quot;/api/user&quot;</span>); <span class=\"hljs-comment\">// 等用户数据</span><br>    <span class=\"hljs-keyword\">const</span> posts = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">fetchData</span>(<span class=\"hljs-string\">`/api/posts?uid=<span class=\"hljs-subst\">$&#123;user.id&#125;</span>`</span>); <span class=\"hljs-comment\">// 再拿文章</span><br>    <span class=\"hljs-keyword\">return</span> posts;<br>  &#125; <span class=\"hljs-keyword\">catch</span> (err) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">error</span>(<span class=\"hljs-string\">&quot;请求失败：&quot;</span>, err);<br>  &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 用co库自动按next（不用自己一次次点）</span><br><span class=\"hljs-keyword\">const</span> co = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;co&quot;</span>);<br><span class=\"hljs-title function_\">co</span>(asyncTask).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">result</span> =&gt;</span> <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;最终结果：&quot;</span>, result));<br></code></pre></td></tr></table></figure>\n<blockquote>\n<p>原理特简单：co库会盯着每次 yield 出来的 Promise，等它有结果了，自动按 next 把结果传进去，一直到函数跑完。</p>\n</blockquote>\n<h3 id=\"自定义遍历逻辑（想要啥数据自己造）\"><a href=\"#自定义遍历逻辑（想要啥数据自己造）\" class=\"headerlink\" title=\"自定义遍历逻辑（想要啥数据自己造）\"></a>自定义遍历逻辑（想要啥数据自己造）</h3><p>Generator 天生就能当“遍历器”，比自己写复杂的遍历代码简单多了，比如：</p>\n<ul>\n<li>生成无限序列（比如斐波那契数列）</li>\n<li>遍历树、图这种复杂结构</li>\n<li>分批加载数据（用多少取多少）</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 生成斐波那契数列（要多少取多少，不占内存）</span><br><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">fibonacci</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> a = <span class=\"hljs-number\">0</span>, b = <span class=\"hljs-number\">1</span>;<br>  <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123; <span class=\"hljs-comment\">// 无限循环也不怕，因为会暂停</span><br>    [a, b] = [b, a + b];<br>    <span class=\"hljs-keyword\">yield</span> b;<br>  &#125;<br>&#125;<br><br><span class=\"hljs-keyword\">const</span> fib = <span class=\"hljs-title function_\">fibonacci</span>();<br><span class=\"hljs-comment\">// 只取前10个，不会一下生成无数个占内存</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(fib.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>); <span class=\"hljs-comment\">// 1,2,3,5,8...</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"分批处理大数据（不卡崩页面）\"><a href=\"#分批处理大数据（不卡崩页面）\" class=\"headerlink\" title=\"分批处理大数据（不卡崩页面）\"></a>分批处理大数据（不卡崩页面）</h3><p>处理海量数据或分页加载时，用 Generator 一次拿一批，避免一次性加载太多数据把页面卡崩：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 分页加载数据的工具</span><br><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">paginatedLoader</span>(<span class=\"hljs-params\">pageSize = <span class=\"hljs-number\">10</span></span>) &#123;<br>  <span class=\"hljs-keyword\">let</span> page = <span class=\"hljs-number\">1</span>;<br>  <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>    <span class=\"hljs-comment\">// 每次暂停，等着拿这一页的数据</span><br>    <span class=\"hljs-keyword\">const</span> data = <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">`/api/data?page=<span class=\"hljs-subst\">$&#123;page&#125;</span>&amp;size=<span class=\"hljs-subst\">$&#123;pageSize&#125;</span>`</span>);<br>    <span class=\"hljs-keyword\">if</span> (data.<span class=\"hljs-property\">length</span> === <span class=\"hljs-number\">0</span>) <span class=\"hljs-keyword\">break</span>; <span class=\"hljs-comment\">// 没数据了就停</span><br>    page++;<br>  &#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 用的时候按需加载</span><br><span class=\"hljs-keyword\">const</span> loader = <span class=\"hljs-title function_\">paginatedLoader</span>();<br>loader.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> 处理第<span class=\"hljs-number\">1</span>页数据(data));<br>loader.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">data</span> =&gt;</span> 处理第<span class=\"hljs-number\">2</span>页数据(data));<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"管理状态流转（比如订单状态）\"><a href=\"#管理状态流转（比如订单状态）\" class=\"headerlink\" title=\"管理状态流转（比如订单状态）\"></a>管理状态流转（比如订单状态）</h3><p>Generator 的“暂停-续跑”特别适合记录状态变化，每个 <code>yield</code> 就是一个状态，比如订单从“待支付”到“已完成”：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 订单状态机</span><br><span class=\"hljs-keyword\">function</span>* <span class=\"hljs-title function_\">orderStateMachine</span>(<span class=\"hljs-params\"></span>) &#123;<br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&quot;待支付&quot;</span>; <span class=\"hljs-comment\">// 下单后状态</span><br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&quot;已支付&quot;</span>; <span class=\"hljs-comment\">// 付款后状态</span><br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&quot;已发货&quot;</span>; <span class=\"hljs-comment\">// 商家发货后</span><br>  <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-string\">&quot;已完成&quot;</span>; <span class=\"hljs-comment\">// 收货后</span><br>&#125;<br><br><span class=\"hljs-keyword\">const</span> order = <span class=\"hljs-title function_\">orderStateMachine</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(order.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>); <span class=\"hljs-comment\">// 待支付（刚下单）</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(order.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>); <span class=\"hljs-comment\">// 已支付（付完钱）</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(order.<span class=\"hljs-title function_\">next</span>().<span class=\"hljs-property\">value</span>); <span class=\"hljs-comment\">// 已发货（商家发了货）</span><br></code></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"Generator-和-async-await-啥关系？为啥还要学？\"><a href=\"#Generator-和-async-await-啥关系？为啥还要学？\" class=\"headerlink\" title=\"Generator 和 async&#x2F;await 啥关系？为啥还要学？\"></a>Generator 和 async&#x2F;await 啥关系？为啥还要学？</h2><p>async&#x2F;await 其实是 Generator 的“简化版”（底层就是 Generator + Promise），但它俩不是谁替代谁的关系，各有各的用处：</p>\n<table>\n<thead>\n<tr>\n<th>特点</th>\n<th>Generator</th>\n<th>async&#x2F;await</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>写法</td>\n<td>function* + yield</td>\n<td>async + await</td>\n</tr>\n<tr>\n<td>要不要帮手</td>\n<td>要（比如co库或自己按next）</td>\n<td>不用，浏览器直接支持</td>\n</tr>\n<tr>\n<td>主要能干啥</td>\n<td>啥都能搞（暂停、遍历、状态）</td>\n<td>专门优化异步代码</td>\n</tr>\n<tr>\n<td>出错怎么抓</td>\n<td>要调throw()方法</td>\n<td>直接用try&#x2F;catch就行</td>\n</tr>\n</tbody></table>\n<p>为啥现在还要学 Generator？因为它有不可替代的地方：</p>\n<ul>\n<li><p><strong>懂底层才会用上层</strong>：明白 Generator 怎么跑，才真的懂 async&#x2F;await 不是“黑魔法”；</p>\n</li>\n<li><p><strong>复杂遍历更简单</strong>：生成无限序列、遍历树结构，比 async&#x2F;await 代码短多了；</p>\n</li>\n<li><p><strong>能手动控制节奏</strong>：比如做游戏帧同步、逐帧渲染动画，需要精确控制执行时机，Generator 更灵活。</p>\n</li>\n</ul>\n<hr>\n<h2 id=\"总结：Generator-核心就是“能控制”\"><a href=\"#总结：Generator-核心就是“能控制”\" class=\"headerlink\" title=\"总结：Generator 核心就是“能控制”\"></a>总结：Generator 核心就是“能控制”</h2><p>Generator 最牛的地方，就是给 JavaScript 加了“可控制的执行流程”——以前函数要么不跑，要么一口气跑完，现在能想停就停、想续就续、想传消息就传消息。</p>\n<p>虽然 async&#x2F;await 抢了它“异步编程”的风头，但在造遍历器、管状态、处理大数据这些场景里，它还是无可替代。学懂它不光能解决实际问题，更能明白 JavaScript 函数是怎么“干活”的，算得上是从“会写代码”到“懂代码”的关键一步。</p>\n<p><strong>【往期精彩】</strong></p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/9pnvL5fTO5U9yT-1mPfeQw\">聊聊ES6里的Promise：简单理解和实际用法</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/UuJeSErftQY7ee1a54Pv4A\">为什么 ES6 要新增 Set 和 Map？看完这篇就懂了</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/haq8TFc_YJlPjeWdyXokQw\">JavaScript进化论：ES6如何让函数编写更加简洁、高效？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/PTI3HGsfpDz4-GvRx0i9ew\">JavaScript ES6中Object的拓展，你了解几个？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/qR65z8RbPFxW326UnogLqA\">Javascript高频面试点–ES6 数组新特性</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/lqn_51NNxx50YgvWkxCtEg\">一文搞懂 JavaScript 里 var、let、const 的区别\n</a></li>\n</ul>\n"},{"title":"没想到！上周写证照小程序的博文火了","date":"2025-09-02T10:13:50.000Z","banner_img":"/imgs/wxprogram/微信小程序.png","index_img":"/imgs/wxprogram/微信小程序.png","_content":"\n\n\n最近后台收到好多朋友的留言，说刷到了我之前写的那篇关于证照制作小程序的文章（[传送门](https://www.cnblogs.com/jvxiao/p/19059712)），还跟着体验了小程序。\n\n说实话，看到文章突然 “火” 起来的时候，我第一反应是惊讶，紧接着就是满满的感动 —— 原来认真分享的东西，真的能被这么多人看见和需要。\n\n## 最意外的：被 “戳中” 的共鸣感\n\n一开始写这篇文章，只是想记录下自己用小程序拍证件照的惊喜体验。毕竟谁没经历过 “为了一张一寸照，请假跑照相馆，排队 1 小时、拍照 5 分钟，最后拿到的照片还不像自己” 的糟心时刻呢？\n\n没想到文章发出去后，评论区彻底 “炸” 了 —— 有朋友说 “我去, 好用啊 白花了25去照相馆换底色”，也有用户在小程序后台留言说“很好用，给老人办理证件的时候很方便”。看着这些留言，我突然明白：这篇文章能火，不是我写得有多好，而是它刚好戳中了大家对 “便捷生活工具” 的需求。原来我们都在期待：生活里那些琐碎的小事，能少一点麻烦，多一点省心。\n\n## 最实在的：小程序被 “看见” 的喜悦\n\n文章爆火后，最直接的变化就是小程序的用户量涨得特别快。后台数据显示，文章发完的第二天，就涌入了将近200的用户，其中绝大多数都是来自咱们园子(博客园)的朋友，非常感谢大家的支持。\n\n也有很多老哥在评论区和后台提了许多非常宝贵的建议，比如“涉及用户隐私的照片建议不做存储”，比如 “希望增加儿童证件照模板”—— 这些反馈不是冷冰冰的文字，而是实实在在的认可，也让我更有动力去优化功能。\n\n其实做这个小程序的初衷很简单：就是想让大家不用再为证件照 “折腾”。现在看到它真的能帮到这么多人，那种 “被需要” 的感觉，比任何流量都珍贵。\n\n\n## 最深刻的：科技该有的 “温度”\n\n回头想想，这篇文章和小程序的 “火”，其实也藏着一个小感悟：科技从来不是冷冰冰的代码，而是能解决实际问题的 “温暖工具”。\n\n以前提到 “证件照”，大家想到的都是传统照相馆 —— 固定的营业时间、有限的风格、不菲的价格。但这个小程序打破了这些限制：在家就能拍，手机上就能调整，几秒钟就能拿到符合标准的照片。它没有多复杂的技术，但刚好解决了 “时间紧、需求急、怕麻烦” 的痛点。\n\n这也让我明白：真正有价值的技术革新，不是追求多炫酷的功能，而是能贴近普通人的生活，把 “麻烦事” 变 “省事”。就像这个小程序，它或许不算什么 “大创新”，但能让老人少跑一趟路，让年轻人少请假一次，这就是它的意义。\n\n## 最后想说的：谢谢每一份 “看见”\n\n这段时间，看着文章的阅读量一点点涨，看着小程序被越来越多人使用，我最大的感受就是：很幸运，能做一个 “连接者”—— 把好用的工具分享给需要的人，也把大家的需求传递给开发团队，昂，开发团队就是我自己了。\n\n未来我还会继续分享这些 “能解决实际问题” 的生活工具和体验，也希望大家如果有什么使用心得或者建议，都可以在评论区告诉我～毕竟好的东西，需要我们一起打磨，一起让生活变得更省心呀～\n\n再次谢谢大家的喜欢和支持💛\n\n","source":"_posts/last-popular-article.md","raw":"---\ntitle: 没想到！上周写证照小程序的博文火了\ndate: 2025-09-02 18:13:50\ntags: 微信小程序\nbanner_img: /imgs/wxprogram/微信小程序.png\nindex_img: /imgs/wxprogram/微信小程序.png\n---\n\n\n\n最近后台收到好多朋友的留言，说刷到了我之前写的那篇关于证照制作小程序的文章（[传送门](https://www.cnblogs.com/jvxiao/p/19059712)），还跟着体验了小程序。\n\n说实话，看到文章突然 “火” 起来的时候，我第一反应是惊讶，紧接着就是满满的感动 —— 原来认真分享的东西，真的能被这么多人看见和需要。\n\n## 最意外的：被 “戳中” 的共鸣感\n\n一开始写这篇文章，只是想记录下自己用小程序拍证件照的惊喜体验。毕竟谁没经历过 “为了一张一寸照，请假跑照相馆，排队 1 小时、拍照 5 分钟，最后拿到的照片还不像自己” 的糟心时刻呢？\n\n没想到文章发出去后，评论区彻底 “炸” 了 —— 有朋友说 “我去, 好用啊 白花了25去照相馆换底色”，也有用户在小程序后台留言说“很好用，给老人办理证件的时候很方便”。看着这些留言，我突然明白：这篇文章能火，不是我写得有多好，而是它刚好戳中了大家对 “便捷生活工具” 的需求。原来我们都在期待：生活里那些琐碎的小事，能少一点麻烦，多一点省心。\n\n## 最实在的：小程序被 “看见” 的喜悦\n\n文章爆火后，最直接的变化就是小程序的用户量涨得特别快。后台数据显示，文章发完的第二天，就涌入了将近200的用户，其中绝大多数都是来自咱们园子(博客园)的朋友，非常感谢大家的支持。\n\n也有很多老哥在评论区和后台提了许多非常宝贵的建议，比如“涉及用户隐私的照片建议不做存储”，比如 “希望增加儿童证件照模板”—— 这些反馈不是冷冰冰的文字，而是实实在在的认可，也让我更有动力去优化功能。\n\n其实做这个小程序的初衷很简单：就是想让大家不用再为证件照 “折腾”。现在看到它真的能帮到这么多人，那种 “被需要” 的感觉，比任何流量都珍贵。\n\n\n## 最深刻的：科技该有的 “温度”\n\n回头想想，这篇文章和小程序的 “火”，其实也藏着一个小感悟：科技从来不是冷冰冰的代码，而是能解决实际问题的 “温暖工具”。\n\n以前提到 “证件照”，大家想到的都是传统照相馆 —— 固定的营业时间、有限的风格、不菲的价格。但这个小程序打破了这些限制：在家就能拍，手机上就能调整，几秒钟就能拿到符合标准的照片。它没有多复杂的技术，但刚好解决了 “时间紧、需求急、怕麻烦” 的痛点。\n\n这也让我明白：真正有价值的技术革新，不是追求多炫酷的功能，而是能贴近普通人的生活，把 “麻烦事” 变 “省事”。就像这个小程序，它或许不算什么 “大创新”，但能让老人少跑一趟路，让年轻人少请假一次，这就是它的意义。\n\n## 最后想说的：谢谢每一份 “看见”\n\n这段时间，看着文章的阅读量一点点涨，看着小程序被越来越多人使用，我最大的感受就是：很幸运，能做一个 “连接者”—— 把好用的工具分享给需要的人，也把大家的需求传递给开发团队，昂，开发团队就是我自己了。\n\n未来我还会继续分享这些 “能解决实际问题” 的生活工具和体验，也希望大家如果有什么使用心得或者建议，都可以在评论区告诉我～毕竟好的东西，需要我们一起打磨，一起让生活变得更省心呀～\n\n再次谢谢大家的喜欢和支持💛\n\n","slug":"last-popular-article","published":1,"updated":"2025-09-02T14:23:04.597Z","comments":1,"layout":"post","photos":[],"_id":"cmjbml2ie001qikupaj7rhx4a","content":"<p>最近后台收到好多朋友的留言，说刷到了我之前写的那篇关于证照制作小程序的文章（<a href=\"https://www.cnblogs.com/jvxiao/p/19059712\">传送门</a>），还跟着体验了小程序。</p>\n<p>说实话，看到文章突然 “火” 起来的时候，我第一反应是惊讶，紧接着就是满满的感动 —— 原来认真分享的东西，真的能被这么多人看见和需要。</p>\n<h2 id=\"最意外的：被-“戳中”-的共鸣感\"><a href=\"#最意外的：被-“戳中”-的共鸣感\" class=\"headerlink\" title=\"最意外的：被 “戳中” 的共鸣感\"></a>最意外的：被 “戳中” 的共鸣感</h2><p>一开始写这篇文章，只是想记录下自己用小程序拍证件照的惊喜体验。毕竟谁没经历过 “为了一张一寸照，请假跑照相馆，排队 1 小时、拍照 5 分钟，最后拿到的照片还不像自己” 的糟心时刻呢？</p>\n<p>没想到文章发出去后，评论区彻底 “炸” 了 —— 有朋友说 “我去, 好用啊 白花了25去照相馆换底色”，也有用户在小程序后台留言说“很好用，给老人办理证件的时候很方便”。看着这些留言，我突然明白：这篇文章能火，不是我写得有多好，而是它刚好戳中了大家对 “便捷生活工具” 的需求。原来我们都在期待：生活里那些琐碎的小事，能少一点麻烦，多一点省心。</p>\n<h2 id=\"最实在的：小程序被-“看见”-的喜悦\"><a href=\"#最实在的：小程序被-“看见”-的喜悦\" class=\"headerlink\" title=\"最实在的：小程序被 “看见” 的喜悦\"></a>最实在的：小程序被 “看见” 的喜悦</h2><p>文章爆火后，最直接的变化就是小程序的用户量涨得特别快。后台数据显示，文章发完的第二天，就涌入了将近200的用户，其中绝大多数都是来自咱们园子(博客园)的朋友，非常感谢大家的支持。</p>\n<p>也有很多老哥在评论区和后台提了许多非常宝贵的建议，比如“涉及用户隐私的照片建议不做存储”，比如 “希望增加儿童证件照模板”—— 这些反馈不是冷冰冰的文字，而是实实在在的认可，也让我更有动力去优化功能。</p>\n<p>其实做这个小程序的初衷很简单：就是想让大家不用再为证件照 “折腾”。现在看到它真的能帮到这么多人，那种 “被需要” 的感觉，比任何流量都珍贵。</p>\n<h2 id=\"最深刻的：科技该有的-“温度”\"><a href=\"#最深刻的：科技该有的-“温度”\" class=\"headerlink\" title=\"最深刻的：科技该有的 “温度”\"></a>最深刻的：科技该有的 “温度”</h2><p>回头想想，这篇文章和小程序的 “火”，其实也藏着一个小感悟：科技从来不是冷冰冰的代码，而是能解决实际问题的 “温暖工具”。</p>\n<p>以前提到 “证件照”，大家想到的都是传统照相馆 —— 固定的营业时间、有限的风格、不菲的价格。但这个小程序打破了这些限制：在家就能拍，手机上就能调整，几秒钟就能拿到符合标准的照片。它没有多复杂的技术，但刚好解决了 “时间紧、需求急、怕麻烦” 的痛点。</p>\n<p>这也让我明白：真正有价值的技术革新，不是追求多炫酷的功能，而是能贴近普通人的生活，把 “麻烦事” 变 “省事”。就像这个小程序，它或许不算什么 “大创新”，但能让老人少跑一趟路，让年轻人少请假一次，这就是它的意义。</p>\n<h2 id=\"最后想说的：谢谢每一份-“看见”\"><a href=\"#最后想说的：谢谢每一份-“看见”\" class=\"headerlink\" title=\"最后想说的：谢谢每一份 “看见”\"></a>最后想说的：谢谢每一份 “看见”</h2><p>这段时间，看着文章的阅读量一点点涨，看着小程序被越来越多人使用，我最大的感受就是：很幸运，能做一个 “连接者”—— 把好用的工具分享给需要的人，也把大家的需求传递给开发团队，昂，开发团队就是我自己了。</p>\n<p>未来我还会继续分享这些 “能解决实际问题” 的生活工具和体验，也希望大家如果有什么使用心得或者建议，都可以在评论区告诉我～毕竟好的东西，需要我们一起打磨，一起让生活变得更省心呀～</p>\n<p>再次谢谢大家的喜欢和支持💛</p>\n","excerpt":"","more":"<p>最近后台收到好多朋友的留言，说刷到了我之前写的那篇关于证照制作小程序的文章（<a href=\"https://www.cnblogs.com/jvxiao/p/19059712\">传送门</a>），还跟着体验了小程序。</p>\n<p>说实话，看到文章突然 “火” 起来的时候，我第一反应是惊讶，紧接着就是满满的感动 —— 原来认真分享的东西，真的能被这么多人看见和需要。</p>\n<h2 id=\"最意外的：被-“戳中”-的共鸣感\"><a href=\"#最意外的：被-“戳中”-的共鸣感\" class=\"headerlink\" title=\"最意外的：被 “戳中” 的共鸣感\"></a>最意外的：被 “戳中” 的共鸣感</h2><p>一开始写这篇文章，只是想记录下自己用小程序拍证件照的惊喜体验。毕竟谁没经历过 “为了一张一寸照，请假跑照相馆，排队 1 小时、拍照 5 分钟，最后拿到的照片还不像自己” 的糟心时刻呢？</p>\n<p>没想到文章发出去后，评论区彻底 “炸” 了 —— 有朋友说 “我去, 好用啊 白花了25去照相馆换底色”，也有用户在小程序后台留言说“很好用，给老人办理证件的时候很方便”。看着这些留言，我突然明白：这篇文章能火，不是我写得有多好，而是它刚好戳中了大家对 “便捷生活工具” 的需求。原来我们都在期待：生活里那些琐碎的小事，能少一点麻烦，多一点省心。</p>\n<h2 id=\"最实在的：小程序被-“看见”-的喜悦\"><a href=\"#最实在的：小程序被-“看见”-的喜悦\" class=\"headerlink\" title=\"最实在的：小程序被 “看见” 的喜悦\"></a>最实在的：小程序被 “看见” 的喜悦</h2><p>文章爆火后，最直接的变化就是小程序的用户量涨得特别快。后台数据显示，文章发完的第二天，就涌入了将近200的用户，其中绝大多数都是来自咱们园子(博客园)的朋友，非常感谢大家的支持。</p>\n<p>也有很多老哥在评论区和后台提了许多非常宝贵的建议，比如“涉及用户隐私的照片建议不做存储”，比如 “希望增加儿童证件照模板”—— 这些反馈不是冷冰冰的文字，而是实实在在的认可，也让我更有动力去优化功能。</p>\n<p>其实做这个小程序的初衷很简单：就是想让大家不用再为证件照 “折腾”。现在看到它真的能帮到这么多人，那种 “被需要” 的感觉，比任何流量都珍贵。</p>\n<h2 id=\"最深刻的：科技该有的-“温度”\"><a href=\"#最深刻的：科技该有的-“温度”\" class=\"headerlink\" title=\"最深刻的：科技该有的 “温度”\"></a>最深刻的：科技该有的 “温度”</h2><p>回头想想，这篇文章和小程序的 “火”，其实也藏着一个小感悟：科技从来不是冷冰冰的代码，而是能解决实际问题的 “温暖工具”。</p>\n<p>以前提到 “证件照”，大家想到的都是传统照相馆 —— 固定的营业时间、有限的风格、不菲的价格。但这个小程序打破了这些限制：在家就能拍，手机上就能调整，几秒钟就能拿到符合标准的照片。它没有多复杂的技术，但刚好解决了 “时间紧、需求急、怕麻烦” 的痛点。</p>\n<p>这也让我明白：真正有价值的技术革新，不是追求多炫酷的功能，而是能贴近普通人的生活，把 “麻烦事” 变 “省事”。就像这个小程序，它或许不算什么 “大创新”，但能让老人少跑一趟路，让年轻人少请假一次，这就是它的意义。</p>\n<h2 id=\"最后想说的：谢谢每一份-“看见”\"><a href=\"#最后想说的：谢谢每一份-“看见”\" class=\"headerlink\" title=\"最后想说的：谢谢每一份 “看见”\"></a>最后想说的：谢谢每一份 “看见”</h2><p>这段时间，看着文章的阅读量一点点涨，看着小程序被越来越多人使用，我最大的感受就是：很幸运，能做一个 “连接者”—— 把好用的工具分享给需要的人，也把大家的需求传递给开发团队，昂，开发团队就是我自己了。</p>\n<p>未来我还会继续分享这些 “能解决实际问题” 的生活工具和体验，也希望大家如果有什么使用心得或者建议，都可以在评论区告诉我～毕竟好的东西，需要我们一起打磨，一起让生活变得更省心呀～</p>\n<p>再次谢谢大家的喜欢和支持💛</p>\n"},{"title":"Node安装保姆级教程","date":"2025-06-08T10:08:43.000Z","keywords":["Node安装，如何安装Node","Windows上安装Node"],"banner_img":"/imgs/baners/node.png","index_img":"/imgs/baners/node.png","_content":"\n## 方法1：安装包安装\n\n- **step1**: 前往[Node官网](https://nodejs.org/zh-cn/download)下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node安装包”获取。\n![Node安装](../imgs/build-blog3/NodeSite.png)\n\n- **step2** 双击安装包，开始安装, 傻瓜式的点击 `Next`.\n![Node安装](../imgs/build-blog3/Node1.png)\n\n  点击 `next`\n  ![Node安装](../imgs/build-blog3/Node2.png)\n\n  如果你不想Node默认安装在C盘目录下，可以在这一步修改安装盘\n![Node安装](../imgs/build-blog3/Node3.png)\n\n  点击 `next`\n![Node安装](../imgs/build-blog3/Node4.png)\n\n  点击 `Install`\n![Node安装](../imgs/build-blog3/Node5.png)\n\n## 方法2：可移动二进制文件安装\n\n- **step1**: 前往[Node官网](https://nodejs.org/zh-cn/download)下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node独立文件包”获取。<br>\n- **step2**: 将包解压任意目录，如我的是 在`D:\\software_install\\develop`下\n![Node安装](../imgs/build-blog3/Node-folder.png)\n- **step3**: 将Node目录下的 `bin`下的配置到window环境变量中\n  a) win+s，搜索 `环境变量`, 点击`编辑系统环境变量`\n\n  ![环境变量](../imgs/build-blog3/environment1.png)\n\n  b) 点击`环境变量`\n  ![环境变量](../imgs/build-blog3/environment2.png)\n  \n  c) 找到 `path`, 点击 `编辑`\n  ![环境变量](../imgs/build-blog3/environment3.png)\n\n  d) 点击 `浏览`\n  ![环境变量](../imgs/build-blog3/environment4.png)\n\n  e) 选择 step2 中解压的目录路径\n  ![环境变量](../imgs/build-blog3/environment5.png)\n\n  最后点击 `确定`关闭所有窗口，将环境变量保存应用。\n\n## 安装验证\n\n打开DOS窗口，输入 `node -v`, 查看是否输出对应的 Node 版本号，如果有，则说明安装成功。如果报错，则重新检查安装步骤是否出错，如果需要，重新安装。\n\n![环境变量](../imgs/build-blog3/success.png)\n","source":"_posts/install-node.md","raw":"---\ntitle: Node安装保姆级教程\ndate: 2025-06-08 18:08:43\ncategory: Web开发\ntags: [Node安装, npm]\nkeywords: [Node安装，如何安装Node, Windows上安装Node]\nbanner_img: /imgs/baners/node.png\nindex_img: /imgs/baners/node.png\n---\n\n## 方法1：安装包安装\n\n- **step1**: 前往[Node官网](https://nodejs.org/zh-cn/download)下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node安装包”获取。\n![Node安装](../imgs/build-blog3/NodeSite.png)\n\n- **step2** 双击安装包，开始安装, 傻瓜式的点击 `Next`.\n![Node安装](../imgs/build-blog3/Node1.png)\n\n  点击 `next`\n  ![Node安装](../imgs/build-blog3/Node2.png)\n\n  如果你不想Node默认安装在C盘目录下，可以在这一步修改安装盘\n![Node安装](../imgs/build-blog3/Node3.png)\n\n  点击 `next`\n![Node安装](../imgs/build-blog3/Node4.png)\n\n  点击 `Install`\n![Node安装](../imgs/build-blog3/Node5.png)\n\n## 方法2：可移动二进制文件安装\n\n- **step1**: 前往[Node官网](https://nodejs.org/zh-cn/download)下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node独立文件包”获取。<br>\n- **step2**: 将包解压任意目录，如我的是 在`D:\\software_install\\develop`下\n![Node安装](../imgs/build-blog3/Node-folder.png)\n- **step3**: 将Node目录下的 `bin`下的配置到window环境变量中\n  a) win+s，搜索 `环境变量`, 点击`编辑系统环境变量`\n\n  ![环境变量](../imgs/build-blog3/environment1.png)\n\n  b) 点击`环境变量`\n  ![环境变量](../imgs/build-blog3/environment2.png)\n  \n  c) 找到 `path`, 点击 `编辑`\n  ![环境变量](../imgs/build-blog3/environment3.png)\n\n  d) 点击 `浏览`\n  ![环境变量](../imgs/build-blog3/environment4.png)\n\n  e) 选择 step2 中解压的目录路径\n  ![环境变量](../imgs/build-blog3/environment5.png)\n\n  最后点击 `确定`关闭所有窗口，将环境变量保存应用。\n\n## 安装验证\n\n打开DOS窗口，输入 `node -v`, 查看是否输出对应的 Node 版本号，如果有，则说明安装成功。如果报错，则重新检查安装步骤是否出错，如果需要，重新安装。\n\n![环境变量](../imgs/build-blog3/success.png)\n","slug":"install-node","published":1,"updated":"2025-08-26T10:52:07.157Z","comments":1,"layout":"post","photos":[],"_id":"cmjbml2if001sikup5e1naudq","content":"<h2 id=\"方法1：安装包安装\"><a href=\"#方法1：安装包安装\" class=\"headerlink\" title=\"方法1：安装包安装\"></a>方法1：安装包安装</h2><ul>\n<li><p><strong>step1</strong>: 前往<a href=\"https://nodejs.org/zh-cn/download\">Node官网</a>下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node安装包”获取。<br><img src=\"/../imgs/build-blog3/NodeSite.png\" alt=\"Node安装\"></p>\n</li>\n<li><p><strong>step2</strong> 双击安装包，开始安装, 傻瓜式的点击 <code>Next</code>.<br><img src=\"/../imgs/build-blog3/Node1.png\" alt=\"Node安装\"></p>\n<p>点击 <code>next</code><br><img src=\"/../imgs/build-blog3/Node2.png\" alt=\"Node安装\"></p>\n<p>如果你不想Node默认安装在C盘目录下，可以在这一步修改安装盘</p>\n</li>\n</ul>\n<p><img src=\"/../imgs/build-blog3/Node3.png\" alt=\"Node安装\"></p>\n<p>  点击 <code>next</code><br><img src=\"/../imgs/build-blog3/Node4.png\" alt=\"Node安装\"></p>\n<p>  点击 <code>Install</code><br><img src=\"/../imgs/build-blog3/Node5.png\" alt=\"Node安装\"></p>\n<h2 id=\"方法2：可移动二进制文件安装\"><a href=\"#方法2：可移动二进制文件安装\" class=\"headerlink\" title=\"方法2：可移动二进制文件安装\"></a>方法2：可移动二进制文件安装</h2><ul>\n<li><p><strong>step1</strong>: 前往<a href=\"https://nodejs.org/zh-cn/download\">Node官网</a>下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node独立文件包”获取。<br></p>\n</li>\n<li><p><strong>step2</strong>: 将包解压任意目录，如我的是 在<code>D:\\software_install\\develop</code>下<br><img src=\"/../imgs/build-blog3/Node-folder.png\" alt=\"Node安装\"></p>\n</li>\n<li><p><strong>step3</strong>: 将Node目录下的 <code>bin</code>下的配置到window环境变量中<br>a) win+s，搜索 <code>环境变量</code>, 点击<code>编辑系统环境变量</code></p>\n<p><img src=\"/../imgs/build-blog3/environment1.png\" alt=\"环境变量\"></p>\n<p>b) 点击<code>环境变量</code><br><img src=\"/../imgs/build-blog3/environment2.png\" alt=\"环境变量\"></p>\n<p>c) 找到 <code>path</code>, 点击 <code>编辑</code><br><img src=\"/../imgs/build-blog3/environment3.png\" alt=\"环境变量\"></p>\n<p>d) 点击 <code>浏览</code><br><img src=\"/../imgs/build-blog3/environment4.png\" alt=\"环境变量\"></p>\n<p>e) 选择 step2 中解压的目录路径<br><img src=\"/../imgs/build-blog3/environment5.png\" alt=\"环境变量\"></p>\n<p>最后点击 <code>确定</code>关闭所有窗口，将环境变量保存应用。</p>\n</li>\n</ul>\n<h2 id=\"安装验证\"><a href=\"#安装验证\" class=\"headerlink\" title=\"安装验证\"></a>安装验证</h2><p>打开DOS窗口，输入 <code>node -v</code>, 查看是否输出对应的 Node 版本号，如果有，则说明安装成功。如果报错，则重新检查安装步骤是否出错，如果需要，重新安装。</p>\n<p><img src=\"/../imgs/build-blog3/success.png\" alt=\"环境变量\"></p>\n","excerpt":"","more":"<h2 id=\"方法1：安装包安装\"><a href=\"#方法1：安装包安装\" class=\"headerlink\" title=\"方法1：安装包安装\"></a>方法1：安装包安装</h2><ul>\n<li><p><strong>step1</strong>: 前往<a href=\"https://nodejs.org/zh-cn/download\">Node官网</a>下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node安装包”获取。<br><img src=\"/../imgs/build-blog3/NodeSite.png\" alt=\"Node安装\"></p>\n</li>\n<li><p><strong>step2</strong> 双击安装包，开始安装, 傻瓜式的点击 <code>Next</code>.<br><img src=\"/../imgs/build-blog3/Node1.png\" alt=\"Node安装\"></p>\n<p>点击 <code>next</code><br><img src=\"/../imgs/build-blog3/Node2.png\" alt=\"Node安装\"></p>\n<p>如果你不想Node默认安装在C盘目录下，可以在这一步修改安装盘</p>\n</li>\n</ul>\n<p><img src=\"/../imgs/build-blog3/Node3.png\" alt=\"Node安装\"></p>\n<p>  点击 <code>next</code><br><img src=\"/../imgs/build-blog3/Node4.png\" alt=\"Node安装\"></p>\n<p>  点击 <code>Install</code><br><img src=\"/../imgs/build-blog3/Node5.png\" alt=\"Node安装\"></p>\n<h2 id=\"方法2：可移动二进制文件安装\"><a href=\"#方法2：可移动二进制文件安装\" class=\"headerlink\" title=\"方法2：可移动二进制文件安装\"></a>方法2：可移动二进制文件安装</h2><ul>\n<li><p><strong>step1</strong>: 前往<a href=\"https://nodejs.org/zh-cn/download\">Node官网</a>下载安装包，或者关注公众号“我做开发那些年”，后台回复“Node独立文件包”获取。<br></p>\n</li>\n<li><p><strong>step2</strong>: 将包解压任意目录，如我的是 在<code>D:\\software_install\\develop</code>下<br><img src=\"/../imgs/build-blog3/Node-folder.png\" alt=\"Node安装\"></p>\n</li>\n<li><p><strong>step3</strong>: 将Node目录下的 <code>bin</code>下的配置到window环境变量中<br>a) win+s，搜索 <code>环境变量</code>, 点击<code>编辑系统环境变量</code></p>\n<p><img src=\"/../imgs/build-blog3/environment1.png\" alt=\"环境变量\"></p>\n<p>b) 点击<code>环境变量</code><br><img src=\"/../imgs/build-blog3/environment2.png\" alt=\"环境变量\"></p>\n<p>c) 找到 <code>path</code>, 点击 <code>编辑</code><br><img src=\"/../imgs/build-blog3/environment3.png\" alt=\"环境变量\"></p>\n<p>d) 点击 <code>浏览</code><br><img src=\"/../imgs/build-blog3/environment4.png\" alt=\"环境变量\"></p>\n<p>e) 选择 step2 中解压的目录路径<br><img src=\"/../imgs/build-blog3/environment5.png\" alt=\"环境变量\"></p>\n<p>最后点击 <code>确定</code>关闭所有窗口，将环境变量保存应用。</p>\n</li>\n</ul>\n<h2 id=\"安装验证\"><a href=\"#安装验证\" class=\"headerlink\" title=\"安装验证\"></a>安装验证</h2><p>打开DOS窗口，输入 <code>node -v</code>, 查看是否输出对应的 Node 版本号，如果有，则说明安装成功。如果报错，则重新检查安装步骤是否出错，如果需要，重新安装。</p>\n<p><img src=\"/../imgs/build-blog3/success.png\" alt=\"环境变量\"></p>\n"},{"title":"爆肝三周，我终于上线了自己的第一个小程序","date":"2025-08-24T15:03:53.000Z","banner_img":"/imgs/wxprogram/微信小程序.png","index_img":"/imgs/wxprogram/微信小程序.png","_content":"\n三周前，帮朋友拍证件照时差点吵起来 —— 他要白底一寸照，我用修图软件改背景，边缘总留着灰边，最后还是花 30 块去照相馆拍的。看着他吐槽 “拍个照还要跑一趟”，我突然冒了个念头：要不自己做个证件照小程序？当时也就随口一说，转头就打开电脑，真的开始琢磨起来了。\n\n## 半路出家\n选方向没纠结，就定证件照制作。之前帮人改照片总出错，要么尺寸不对，要么背景色不标准；身边朋友也常说，临时要个证件照，找修图软件半天弄不明白，去照相馆又费时间。想着做个轻量化工具，核心功能就三个：标准化尺寸调整（覆盖一寸、二寸、社保照等常用规格）、背景色一键替换（白 / 蓝 / 红三色标准色值）、电子版保存，暂时不做复杂的美颜功能，先保证基础可用性。\n\n\n真正动手才知道难。我是个半路出家的，之前只跟着网课学过基础的微信小程序开发，真要搭项目框架时，对着微信开发者工具的文档发呆能发一下午。第一天晚上熬到两点，好不容易弄出个能上传照片的静态页面，结果点击 “确认上传” 按钮毫无反应，排查半天才发现绑定的事件函数名写错了；更糟的是保存代码时误删了 pages 目录，当时坐在电脑前盯着黑屏，差点把鼠标扔了。\n\n## 这坑啊，真的一填一个不吱声\n\n中间那周简直是跟 bug 死磕。最头疼的先是**背景替换功能**，用户上传照片后，人物边缘总带着原背景的杂色，明明照着教程调了 mask 遮罩参数，到我这就变成 “大花脸”。凌晨三点蹲在开发者论坛发帖，有个匿名网友回了句 “试试把边缘羽化值从 5px 调至 7px，同时增加色彩容差阈值”，试完真的好了，盯着屏幕里干净的白底照片，傻笑到天边泛白。\n\n紧接着又遇到**图片大小的问题** —— 很多用户上传的照片是相机直出图，动辄 3-5M，远超小程序默认 1M 的上传限制，一上传就卡住闪退。一开始我试着用前端压缩插件，通过调整图片分辨率和质量参数（把 JPG 质量压缩到 80%，分辨率限制在 1080px 以内），但压缩后画质损失严重，证件照打印出来会模糊。后来查资料发现可以用云存储，对比了几家云服务后，选了有免费额度的腾讯云对象存储，花了一天时间学怎么调用 SDK 接口，把用户上传的原图先传到云服务器，再在云端完成压缩和处理，最后返回压缩后的标准图，这才解决了大小和画质的矛盾。\n\n**尺寸功能**也踩过坑，一寸照（2.5cm×3.5cm）、二寸照（3.5cm×4.9cm）的像素比例总弄混，按公式换算后（1 英寸 = 96 像素），打印出来要么头顶被截，要么两边留白太多。最后拿着尺子在纸上画实际尺寸，对着屏幕一点点校准像素值，还专门找了照相馆的标准模板对比，蹲在桌前调参数时，被蚊子叮了好几个包都没察觉。\n\n最崩溃的是上线前的流程。审核第一次被打回来，说 “涉及用户图像信息，缺少**隐私保护声明**”，我这纯工具类小程序，哪想到还要这个？打电话给微信客服，听着机器人语音转了八次人工，才搞懂要加弹窗式隐私协议，明确告知用户 “照片仅用于当前编辑，不存储服务器、编辑后自动删除”。\n\n改完隐私声明提交，又卡在了**备案上** —— 小程序要上线，必须先完成 ICP 备案。之前完全没接触过备案流程，只能跟着云服务商的指引填资料，各种证件扫描件反复改格式（要求小于 200KB 且背景纯白），负责人信息核验时因为身份证照片反光被打回两次，还得等管局审核，期间打了三次客服电话催进度，前前后后花了五天，比改 bug 还耗精力。等备案通过那天，整个人瘫在椅子上，外卖到了都没力气拆，闻着香味就睡着了。\n\n## 幸福的眼泪(假的)\n今早收到小程序审核通过的短信时，我正在给绿萝浇水。手一抖，水洒了一地，赶紧擦干净去看手机。点开自己做的小程序，上传了张旧照片，点 “换蓝底”“调一寸”，几秒就生成了标准证件照，虽然按钮排版还有点歪，但核心功能全正常。刚才朋友发消息来，说用我的小程序做了社保照片，打印出来完全合格，省了去照相馆的钱，我跟他讲 “以后要证件照就用这个”，挂了电话眼泪就下来了。\n\n\n## 写在最后\n原来自己做的工具能真正帮到别人，是这么踏实的感觉。现在回头看，那些熬到凌晨的夜晚、反复调试的代码、流程里的磕磕绊绊，都成了最实在的收获。\n\n最后，给大家分享一下我做的小程序吧，直接扫码或者搜索“**豆豆证照工坊**”，如果你觉得能帮到你，不妨分享给你的朋友们，如果觉得有做得不好的地方，欢迎留言区提建议（轻喷）。\n\n![qrcode](../imgs/wxprogram/code.png)\n\n","source":"_posts/my-first-miniprogram.md","raw":"---\ntitle: 爆肝三周，我终于上线了自己的第一个小程序\ndate: 2025-08-24 23:03:53\ntags: [微信小程序]\nbanner_img: /imgs/wxprogram/微信小程序.png\nindex_img: /imgs/wxprogram/微信小程序.png\n---\n\n三周前，帮朋友拍证件照时差点吵起来 —— 他要白底一寸照，我用修图软件改背景，边缘总留着灰边，最后还是花 30 块去照相馆拍的。看着他吐槽 “拍个照还要跑一趟”，我突然冒了个念头：要不自己做个证件照小程序？当时也就随口一说，转头就打开电脑，真的开始琢磨起来了。\n\n## 半路出家\n选方向没纠结，就定证件照制作。之前帮人改照片总出错，要么尺寸不对，要么背景色不标准；身边朋友也常说，临时要个证件照，找修图软件半天弄不明白，去照相馆又费时间。想着做个轻量化工具，核心功能就三个：标准化尺寸调整（覆盖一寸、二寸、社保照等常用规格）、背景色一键替换（白 / 蓝 / 红三色标准色值）、电子版保存，暂时不做复杂的美颜功能，先保证基础可用性。\n\n\n真正动手才知道难。我是个半路出家的，之前只跟着网课学过基础的微信小程序开发，真要搭项目框架时，对着微信开发者工具的文档发呆能发一下午。第一天晚上熬到两点，好不容易弄出个能上传照片的静态页面，结果点击 “确认上传” 按钮毫无反应，排查半天才发现绑定的事件函数名写错了；更糟的是保存代码时误删了 pages 目录，当时坐在电脑前盯着黑屏，差点把鼠标扔了。\n\n## 这坑啊，真的一填一个不吱声\n\n中间那周简直是跟 bug 死磕。最头疼的先是**背景替换功能**，用户上传照片后，人物边缘总带着原背景的杂色，明明照着教程调了 mask 遮罩参数，到我这就变成 “大花脸”。凌晨三点蹲在开发者论坛发帖，有个匿名网友回了句 “试试把边缘羽化值从 5px 调至 7px，同时增加色彩容差阈值”，试完真的好了，盯着屏幕里干净的白底照片，傻笑到天边泛白。\n\n紧接着又遇到**图片大小的问题** —— 很多用户上传的照片是相机直出图，动辄 3-5M，远超小程序默认 1M 的上传限制，一上传就卡住闪退。一开始我试着用前端压缩插件，通过调整图片分辨率和质量参数（把 JPG 质量压缩到 80%，分辨率限制在 1080px 以内），但压缩后画质损失严重，证件照打印出来会模糊。后来查资料发现可以用云存储，对比了几家云服务后，选了有免费额度的腾讯云对象存储，花了一天时间学怎么调用 SDK 接口，把用户上传的原图先传到云服务器，再在云端完成压缩和处理，最后返回压缩后的标准图，这才解决了大小和画质的矛盾。\n\n**尺寸功能**也踩过坑，一寸照（2.5cm×3.5cm）、二寸照（3.5cm×4.9cm）的像素比例总弄混，按公式换算后（1 英寸 = 96 像素），打印出来要么头顶被截，要么两边留白太多。最后拿着尺子在纸上画实际尺寸，对着屏幕一点点校准像素值，还专门找了照相馆的标准模板对比，蹲在桌前调参数时，被蚊子叮了好几个包都没察觉。\n\n最崩溃的是上线前的流程。审核第一次被打回来，说 “涉及用户图像信息，缺少**隐私保护声明**”，我这纯工具类小程序，哪想到还要这个？打电话给微信客服，听着机器人语音转了八次人工，才搞懂要加弹窗式隐私协议，明确告知用户 “照片仅用于当前编辑，不存储服务器、编辑后自动删除”。\n\n改完隐私声明提交，又卡在了**备案上** —— 小程序要上线，必须先完成 ICP 备案。之前完全没接触过备案流程，只能跟着云服务商的指引填资料，各种证件扫描件反复改格式（要求小于 200KB 且背景纯白），负责人信息核验时因为身份证照片反光被打回两次，还得等管局审核，期间打了三次客服电话催进度，前前后后花了五天，比改 bug 还耗精力。等备案通过那天，整个人瘫在椅子上，外卖到了都没力气拆，闻着香味就睡着了。\n\n## 幸福的眼泪(假的)\n今早收到小程序审核通过的短信时，我正在给绿萝浇水。手一抖，水洒了一地，赶紧擦干净去看手机。点开自己做的小程序，上传了张旧照片，点 “换蓝底”“调一寸”，几秒就生成了标准证件照，虽然按钮排版还有点歪，但核心功能全正常。刚才朋友发消息来，说用我的小程序做了社保照片，打印出来完全合格，省了去照相馆的钱，我跟他讲 “以后要证件照就用这个”，挂了电话眼泪就下来了。\n\n\n## 写在最后\n原来自己做的工具能真正帮到别人，是这么踏实的感觉。现在回头看，那些熬到凌晨的夜晚、反复调试的代码、流程里的磕磕绊绊，都成了最实在的收获。\n\n最后，给大家分享一下我做的小程序吧，直接扫码或者搜索“**豆豆证照工坊**”，如果你觉得能帮到你，不妨分享给你的朋友们，如果觉得有做得不好的地方，欢迎留言区提建议（轻喷）。\n\n![qrcode](../imgs/wxprogram/code.png)\n\n","slug":"my-first-miniprogram","published":1,"updated":"2025-08-26T10:32:52.772Z","comments":1,"layout":"post","photos":[],"_id":"cmjbml2ig001wikup5otr5b3r","content":"<p>三周前，帮朋友拍证件照时差点吵起来 —— 他要白底一寸照，我用修图软件改背景，边缘总留着灰边，最后还是花 30 块去照相馆拍的。看着他吐槽 “拍个照还要跑一趟”，我突然冒了个念头：要不自己做个证件照小程序？当时也就随口一说，转头就打开电脑，真的开始琢磨起来了。</p>\n<h2 id=\"半路出家\"><a href=\"#半路出家\" class=\"headerlink\" title=\"半路出家\"></a>半路出家</h2><p>选方向没纠结，就定证件照制作。之前帮人改照片总出错，要么尺寸不对，要么背景色不标准；身边朋友也常说，临时要个证件照，找修图软件半天弄不明白，去照相馆又费时间。想着做个轻量化工具，核心功能就三个：标准化尺寸调整（覆盖一寸、二寸、社保照等常用规格）、背景色一键替换（白 &#x2F; 蓝 &#x2F; 红三色标准色值）、电子版保存，暂时不做复杂的美颜功能，先保证基础可用性。</p>\n<p>真正动手才知道难。我是个半路出家的，之前只跟着网课学过基础的微信小程序开发，真要搭项目框架时，对着微信开发者工具的文档发呆能发一下午。第一天晚上熬到两点，好不容易弄出个能上传照片的静态页面，结果点击 “确认上传” 按钮毫无反应，排查半天才发现绑定的事件函数名写错了；更糟的是保存代码时误删了 pages 目录，当时坐在电脑前盯着黑屏，差点把鼠标扔了。</p>\n<h2 id=\"这坑啊，真的一填一个不吱声\"><a href=\"#这坑啊，真的一填一个不吱声\" class=\"headerlink\" title=\"这坑啊，真的一填一个不吱声\"></a>这坑啊，真的一填一个不吱声</h2><p>中间那周简直是跟 bug 死磕。最头疼的先是<strong>背景替换功能</strong>，用户上传照片后，人物边缘总带着原背景的杂色，明明照着教程调了 mask 遮罩参数，到我这就变成 “大花脸”。凌晨三点蹲在开发者论坛发帖，有个匿名网友回了句 “试试把边缘羽化值从 5px 调至 7px，同时增加色彩容差阈值”，试完真的好了，盯着屏幕里干净的白底照片，傻笑到天边泛白。</p>\n<p>紧接着又遇到<strong>图片大小的问题</strong> —— 很多用户上传的照片是相机直出图，动辄 3-5M，远超小程序默认 1M 的上传限制，一上传就卡住闪退。一开始我试着用前端压缩插件，通过调整图片分辨率和质量参数（把 JPG 质量压缩到 80%，分辨率限制在 1080px 以内），但压缩后画质损失严重，证件照打印出来会模糊。后来查资料发现可以用云存储，对比了几家云服务后，选了有免费额度的腾讯云对象存储，花了一天时间学怎么调用 SDK 接口，把用户上传的原图先传到云服务器，再在云端完成压缩和处理，最后返回压缩后的标准图，这才解决了大小和画质的矛盾。</p>\n<p><strong>尺寸功能</strong>也踩过坑，一寸照（2.5cm×3.5cm）、二寸照（3.5cm×4.9cm）的像素比例总弄混，按公式换算后（1 英寸 &#x3D; 96 像素），打印出来要么头顶被截，要么两边留白太多。最后拿着尺子在纸上画实际尺寸，对着屏幕一点点校准像素值，还专门找了照相馆的标准模板对比，蹲在桌前调参数时，被蚊子叮了好几个包都没察觉。</p>\n<p>最崩溃的是上线前的流程。审核第一次被打回来，说 “涉及用户图像信息，缺少<strong>隐私保护声明</strong>”，我这纯工具类小程序，哪想到还要这个？打电话给微信客服，听着机器人语音转了八次人工，才搞懂要加弹窗式隐私协议，明确告知用户 “照片仅用于当前编辑，不存储服务器、编辑后自动删除”。</p>\n<p>改完隐私声明提交，又卡在了<strong>备案上</strong> —— 小程序要上线，必须先完成 ICP 备案。之前完全没接触过备案流程，只能跟着云服务商的指引填资料，各种证件扫描件反复改格式（要求小于 200KB 且背景纯白），负责人信息核验时因为身份证照片反光被打回两次，还得等管局审核，期间打了三次客服电话催进度，前前后后花了五天，比改 bug 还耗精力。等备案通过那天，整个人瘫在椅子上，外卖到了都没力气拆，闻着香味就睡着了。</p>\n<h2 id=\"幸福的眼泪-假的\"><a href=\"#幸福的眼泪-假的\" class=\"headerlink\" title=\"幸福的眼泪(假的)\"></a>幸福的眼泪(假的)</h2><p>今早收到小程序审核通过的短信时，我正在给绿萝浇水。手一抖，水洒了一地，赶紧擦干净去看手机。点开自己做的小程序，上传了张旧照片，点 “换蓝底”“调一寸”，几秒就生成了标准证件照，虽然按钮排版还有点歪，但核心功能全正常。刚才朋友发消息来，说用我的小程序做了社保照片，打印出来完全合格，省了去照相馆的钱，我跟他讲 “以后要证件照就用这个”，挂了电话眼泪就下来了。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>原来自己做的工具能真正帮到别人，是这么踏实的感觉。现在回头看，那些熬到凌晨的夜晚、反复调试的代码、流程里的磕磕绊绊，都成了最实在的收获。</p>\n<p>最后，给大家分享一下我做的小程序吧，直接扫码或者搜索“<strong>豆豆证照工坊</strong>”，如果你觉得能帮到你，不妨分享给你的朋友们，如果觉得有做得不好的地方，欢迎留言区提建议（轻喷）。</p>\n<p><img src=\"/../imgs/wxprogram/code.png\" alt=\"qrcode\"></p>\n","excerpt":"","more":"<p>三周前，帮朋友拍证件照时差点吵起来 —— 他要白底一寸照，我用修图软件改背景，边缘总留着灰边，最后还是花 30 块去照相馆拍的。看着他吐槽 “拍个照还要跑一趟”，我突然冒了个念头：要不自己做个证件照小程序？当时也就随口一说，转头就打开电脑，真的开始琢磨起来了。</p>\n<h2 id=\"半路出家\"><a href=\"#半路出家\" class=\"headerlink\" title=\"半路出家\"></a>半路出家</h2><p>选方向没纠结，就定证件照制作。之前帮人改照片总出错，要么尺寸不对，要么背景色不标准；身边朋友也常说，临时要个证件照，找修图软件半天弄不明白，去照相馆又费时间。想着做个轻量化工具，核心功能就三个：标准化尺寸调整（覆盖一寸、二寸、社保照等常用规格）、背景色一键替换（白 &#x2F; 蓝 &#x2F; 红三色标准色值）、电子版保存，暂时不做复杂的美颜功能，先保证基础可用性。</p>\n<p>真正动手才知道难。我是个半路出家的，之前只跟着网课学过基础的微信小程序开发，真要搭项目框架时，对着微信开发者工具的文档发呆能发一下午。第一天晚上熬到两点，好不容易弄出个能上传照片的静态页面，结果点击 “确认上传” 按钮毫无反应，排查半天才发现绑定的事件函数名写错了；更糟的是保存代码时误删了 pages 目录，当时坐在电脑前盯着黑屏，差点把鼠标扔了。</p>\n<h2 id=\"这坑啊，真的一填一个不吱声\"><a href=\"#这坑啊，真的一填一个不吱声\" class=\"headerlink\" title=\"这坑啊，真的一填一个不吱声\"></a>这坑啊，真的一填一个不吱声</h2><p>中间那周简直是跟 bug 死磕。最头疼的先是<strong>背景替换功能</strong>，用户上传照片后，人物边缘总带着原背景的杂色，明明照着教程调了 mask 遮罩参数，到我这就变成 “大花脸”。凌晨三点蹲在开发者论坛发帖，有个匿名网友回了句 “试试把边缘羽化值从 5px 调至 7px，同时增加色彩容差阈值”，试完真的好了，盯着屏幕里干净的白底照片，傻笑到天边泛白。</p>\n<p>紧接着又遇到<strong>图片大小的问题</strong> —— 很多用户上传的照片是相机直出图，动辄 3-5M，远超小程序默认 1M 的上传限制，一上传就卡住闪退。一开始我试着用前端压缩插件，通过调整图片分辨率和质量参数（把 JPG 质量压缩到 80%，分辨率限制在 1080px 以内），但压缩后画质损失严重，证件照打印出来会模糊。后来查资料发现可以用云存储，对比了几家云服务后，选了有免费额度的腾讯云对象存储，花了一天时间学怎么调用 SDK 接口，把用户上传的原图先传到云服务器，再在云端完成压缩和处理，最后返回压缩后的标准图，这才解决了大小和画质的矛盾。</p>\n<p><strong>尺寸功能</strong>也踩过坑，一寸照（2.5cm×3.5cm）、二寸照（3.5cm×4.9cm）的像素比例总弄混，按公式换算后（1 英寸 &#x3D; 96 像素），打印出来要么头顶被截，要么两边留白太多。最后拿着尺子在纸上画实际尺寸，对着屏幕一点点校准像素值，还专门找了照相馆的标准模板对比，蹲在桌前调参数时，被蚊子叮了好几个包都没察觉。</p>\n<p>最崩溃的是上线前的流程。审核第一次被打回来，说 “涉及用户图像信息，缺少<strong>隐私保护声明</strong>”，我这纯工具类小程序，哪想到还要这个？打电话给微信客服，听着机器人语音转了八次人工，才搞懂要加弹窗式隐私协议，明确告知用户 “照片仅用于当前编辑，不存储服务器、编辑后自动删除”。</p>\n<p>改完隐私声明提交，又卡在了<strong>备案上</strong> —— 小程序要上线，必须先完成 ICP 备案。之前完全没接触过备案流程，只能跟着云服务商的指引填资料，各种证件扫描件反复改格式（要求小于 200KB 且背景纯白），负责人信息核验时因为身份证照片反光被打回两次，还得等管局审核，期间打了三次客服电话催进度，前前后后花了五天，比改 bug 还耗精力。等备案通过那天，整个人瘫在椅子上，外卖到了都没力气拆，闻着香味就睡着了。</p>\n<h2 id=\"幸福的眼泪-假的\"><a href=\"#幸福的眼泪-假的\" class=\"headerlink\" title=\"幸福的眼泪(假的)\"></a>幸福的眼泪(假的)</h2><p>今早收到小程序审核通过的短信时，我正在给绿萝浇水。手一抖，水洒了一地，赶紧擦干净去看手机。点开自己做的小程序，上传了张旧照片，点 “换蓝底”“调一寸”，几秒就生成了标准证件照，虽然按钮排版还有点歪，但核心功能全正常。刚才朋友发消息来，说用我的小程序做了社保照片，打印出来完全合格，省了去照相馆的钱，我跟他讲 “以后要证件照就用这个”，挂了电话眼泪就下来了。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>原来自己做的工具能真正帮到别人，是这么踏实的感觉。现在回头看，那些熬到凌晨的夜晚、反复调试的代码、流程里的磕磕绊绊，都成了最实在的收获。</p>\n<p>最后，给大家分享一下我做的小程序吧，直接扫码或者搜索“<strong>豆豆证照工坊</strong>”，如果你觉得能帮到你，不妨分享给你的朋友们，如果觉得有做得不好的地方，欢迎留言区提建议（轻喷）。</p>\n<p><img src=\"/../imgs/wxprogram/code.png\" alt=\"qrcode\"></p>\n"},{"title":"JavaScript的\"数值计算困局\"：生态缺位下的破局之路","date":"2025-06-27T14:36:13.000Z","keywords":["Web开发","Node"],"banner_img":"/imgs/baners/numpy-in-node.jfif","index_img":"/imgs/baners/numpy-in-node.jfif","_content":"\n\n**背景**：最近在尝试使用Node折腾一下图像处理相关的操作，以往使用Python处理时常常都会搭配使用numpy库，它在数值和矩阵等计算方面的性能是不用多说的，但在Node生态下却很难找到类似的替代方案，又是有了此文。\n\n\n在Node.js的世界里，写一个矩阵乘法函数或许只需百行代码，但要构建一个能与NumPy媲美的科学计算库，却堪比在沙漠中种树——技术的种子早已埋下，缺乏的是滋养生态的绿洲。这不是语言能力的边界，而是一场关于开发者选择的博弈。\n\n## 一、被误解的\"技术原罪\"\n当开发者争论\"JS能否做科学计算\"时，往往忽略了一个事实：V8引擎的浮点运算性能早已超越多数脚本语言。**类型化数组**配合SIMD.js（通过WebAssembly实现），能让矩阵乘法达到C语言90%的效率；Node.js的N-API允许无缝绑定Fortran数值库，就像**stdlib项目**所展示的那样。ES6引入的类与模块系统，虽未直接赋能数值计算，却为构建复杂数据结构提供了基础设施。\n\n真正的技术瓶颈藏在细节里。比如，JS至今缺乏原生的64位整数数组，这让金融计算场景颇为棘手；复数类型的缺失，也让信号处理库的开发绕道而行。但这些都不是不可逾越的高墙——TypeScript可以通过类型声明模拟，原生插件能够补充底层能力。正如用JS实现FFT算法的开发者所言：\"不是不能写，而是写完后发现，愿意用的人太少。\"\n\n## 二、生态循环的\"死亡螺旋\"\n在Python社区，一个NumPy的bug可能引发百人协作修复；而在JS世界，即便写出性能媲美的ndarray库，也可能面临\"无人问津\"的尴尬。这种差距源于两个恶性循环：\n\n### 人才的\"用脚投票\"\n数据科学家更熟悉Python的SciPy生态，前端开发者擅长的DOM操作与数值计算需求错位。就像PHP开发者转向全栈时更易选择Node.js，数值计算领域的专家天然倾向于已有成熟工具的语言。某开源JS数学库维护者坦言：\"我花3个月优化的矩阵求逆算法，不如Python同行一个星期的Stack Overflow答疑获得的关注多。\"\n\n### 库作者的\"收益悖论\"\n优秀的数值计算库需要持续打磨——这既包括算法优化，也需要完善的文档和教程。但JS生态的\"快餐文化\"让深度投入变得稀缺：一个实现K-means聚类的NPM包可能有2000+下载，但愿意提交文档翻译的贡献者不到5人。这种\"用得多、养得少\"的现状，让库作者难以获得持续创作的动力。\n\n## 三、破局的\"星星之火\"\n转机正在边缘地带悄然发生。在边缘计算场景，Node.js的低延迟特性催生了实时数据处理需求：某物联网公司用JS编写的信号滤波算法，在边缘设备上实现了比Python快30%的处理速度；WebAssembly的普及，让TensorFlow.js能在浏览器中直接运行轻量化模型，这种\"计算可视化一体\"的体验，正是Python生态难以复制的优势。\n\n更值得关注的是工具链的进化。TypeScript的类型系统正在重塑JS的工程能力——某数值计算库通过严格的类型定义，让线性代数操作的错误率下降70%；Vite等构建工具的普及，让JS库的打包体积缩小60%，降低了科学计算库的集成成本。这些变化正在吸引跨界开发者：一位从Julia转投JS的计算生物学家表示：\"现在用JS写的分子动力学模拟，调试效率比编译型语言高5倍。\"\n\n## 四、未来的\"第三条路\"\nJS的数值计算生态不会重复Python的路径，而是走出自己的特色：在浏览器端，WebGPU与WebAssembly的结合，正在孕育\"可视化即计算\"的新范式——用户在Canvas上绘制的图表，背后可能运行着百万级的矩阵运算；在服务端，Node.js的分布式特性让大规模数值计算可以无缝融入微服务架构，某金融公司已用此方案实现了实时风控模型的动态部署。\n\n这场生态突围的关键，在于找到JS的\"不可替代性\"。当Python开发者还在为环境配置发愁时，JS开发者已经通过CDN让数值计算库秒级加载；当R语言的图表需要导出才能分享时，JS的D3.js正在浏览器中实现交互式数据分析。这些差异化体验，正在吸引越来越多\"非典型\"开发者——他们未必精通算法，但擅长将计算能力转化为用户可见的价值。\n\n在JS的世界里，数值计算的未来不是复刻NumPy，而是创造属于自己的\"计算原语\"。当某天，前端开发者能用熟悉的语法操作多维数组，后端工程师可以轻松将数值计算嵌入API，这场迟到的生态革命才算真正完成。而此刻，那些在荒芜中播种的开发者，正在书写着这段历史的序章。","source":"_posts/node-numpy.md","raw":"---\ntitle: JavaScript的\"数值计算困局\"：生态缺位下的破局之路\ndate: 2025-06-27 22:36:13\ntags: [Web开发, Node, packages]\nkeywords: [Web开发, Node]\nbanner_img: /imgs/baners/numpy-in-node.jfif\nindex_img: /imgs/baners/numpy-in-node.jfif\n---\n\n\n**背景**：最近在尝试使用Node折腾一下图像处理相关的操作，以往使用Python处理时常常都会搭配使用numpy库，它在数值和矩阵等计算方面的性能是不用多说的，但在Node生态下却很难找到类似的替代方案，又是有了此文。\n\n\n在Node.js的世界里，写一个矩阵乘法函数或许只需百行代码，但要构建一个能与NumPy媲美的科学计算库，却堪比在沙漠中种树——技术的种子早已埋下，缺乏的是滋养生态的绿洲。这不是语言能力的边界，而是一场关于开发者选择的博弈。\n\n## 一、被误解的\"技术原罪\"\n当开发者争论\"JS能否做科学计算\"时，往往忽略了一个事实：V8引擎的浮点运算性能早已超越多数脚本语言。**类型化数组**配合SIMD.js（通过WebAssembly实现），能让矩阵乘法达到C语言90%的效率；Node.js的N-API允许无缝绑定Fortran数值库，就像**stdlib项目**所展示的那样。ES6引入的类与模块系统，虽未直接赋能数值计算，却为构建复杂数据结构提供了基础设施。\n\n真正的技术瓶颈藏在细节里。比如，JS至今缺乏原生的64位整数数组，这让金融计算场景颇为棘手；复数类型的缺失，也让信号处理库的开发绕道而行。但这些都不是不可逾越的高墙——TypeScript可以通过类型声明模拟，原生插件能够补充底层能力。正如用JS实现FFT算法的开发者所言：\"不是不能写，而是写完后发现，愿意用的人太少。\"\n\n## 二、生态循环的\"死亡螺旋\"\n在Python社区，一个NumPy的bug可能引发百人协作修复；而在JS世界，即便写出性能媲美的ndarray库，也可能面临\"无人问津\"的尴尬。这种差距源于两个恶性循环：\n\n### 人才的\"用脚投票\"\n数据科学家更熟悉Python的SciPy生态，前端开发者擅长的DOM操作与数值计算需求错位。就像PHP开发者转向全栈时更易选择Node.js，数值计算领域的专家天然倾向于已有成熟工具的语言。某开源JS数学库维护者坦言：\"我花3个月优化的矩阵求逆算法，不如Python同行一个星期的Stack Overflow答疑获得的关注多。\"\n\n### 库作者的\"收益悖论\"\n优秀的数值计算库需要持续打磨——这既包括算法优化，也需要完善的文档和教程。但JS生态的\"快餐文化\"让深度投入变得稀缺：一个实现K-means聚类的NPM包可能有2000+下载，但愿意提交文档翻译的贡献者不到5人。这种\"用得多、养得少\"的现状，让库作者难以获得持续创作的动力。\n\n## 三、破局的\"星星之火\"\n转机正在边缘地带悄然发生。在边缘计算场景，Node.js的低延迟特性催生了实时数据处理需求：某物联网公司用JS编写的信号滤波算法，在边缘设备上实现了比Python快30%的处理速度；WebAssembly的普及，让TensorFlow.js能在浏览器中直接运行轻量化模型，这种\"计算可视化一体\"的体验，正是Python生态难以复制的优势。\n\n更值得关注的是工具链的进化。TypeScript的类型系统正在重塑JS的工程能力——某数值计算库通过严格的类型定义，让线性代数操作的错误率下降70%；Vite等构建工具的普及，让JS库的打包体积缩小60%，降低了科学计算库的集成成本。这些变化正在吸引跨界开发者：一位从Julia转投JS的计算生物学家表示：\"现在用JS写的分子动力学模拟，调试效率比编译型语言高5倍。\"\n\n## 四、未来的\"第三条路\"\nJS的数值计算生态不会重复Python的路径，而是走出自己的特色：在浏览器端，WebGPU与WebAssembly的结合，正在孕育\"可视化即计算\"的新范式——用户在Canvas上绘制的图表，背后可能运行着百万级的矩阵运算；在服务端，Node.js的分布式特性让大规模数值计算可以无缝融入微服务架构，某金融公司已用此方案实现了实时风控模型的动态部署。\n\n这场生态突围的关键，在于找到JS的\"不可替代性\"。当Python开发者还在为环境配置发愁时，JS开发者已经通过CDN让数值计算库秒级加载；当R语言的图表需要导出才能分享时，JS的D3.js正在浏览器中实现交互式数据分析。这些差异化体验，正在吸引越来越多\"非典型\"开发者——他们未必精通算法，但擅长将计算能力转化为用户可见的价值。\n\n在JS的世界里，数值计算的未来不是复刻NumPy，而是创造属于自己的\"计算原语\"。当某天，前端开发者能用熟悉的语法操作多维数组，后端工程师可以轻松将数值计算嵌入API，这场迟到的生态革命才算真正完成。而此刻，那些在荒芜中播种的开发者，正在书写着这段历史的序章。","slug":"node-numpy","published":1,"updated":"2025-08-26T10:48:43.926Z","comments":1,"layout":"post","photos":[],"_id":"cmjbml2is0042ikupab50a7y1","content":"<p><strong>背景</strong>：最近在尝试使用Node折腾一下图像处理相关的操作，以往使用Python处理时常常都会搭配使用numpy库，它在数值和矩阵等计算方面的性能是不用多说的，但在Node生态下却很难找到类似的替代方案，又是有了此文。</p>\n<p>在Node.js的世界里，写一个矩阵乘法函数或许只需百行代码，但要构建一个能与NumPy媲美的科学计算库，却堪比在沙漠中种树——技术的种子早已埋下，缺乏的是滋养生态的绿洲。这不是语言能力的边界，而是一场关于开发者选择的博弈。</p>\n<h2 id=\"一、被误解的”技术原罪”\"><a href=\"#一、被误解的”技术原罪”\" class=\"headerlink\" title=\"一、被误解的”技术原罪”\"></a>一、被误解的”技术原罪”</h2><p>当开发者争论”JS能否做科学计算”时，往往忽略了一个事实：V8引擎的浮点运算性能早已超越多数脚本语言。<strong>类型化数组</strong>配合SIMD.js（通过WebAssembly实现），能让矩阵乘法达到C语言90%的效率；Node.js的N-API允许无缝绑定Fortran数值库，就像<strong>stdlib项目</strong>所展示的那样。ES6引入的类与模块系统，虽未直接赋能数值计算，却为构建复杂数据结构提供了基础设施。</p>\n<p>真正的技术瓶颈藏在细节里。比如，JS至今缺乏原生的64位整数数组，这让金融计算场景颇为棘手；复数类型的缺失，也让信号处理库的开发绕道而行。但这些都不是不可逾越的高墙——TypeScript可以通过类型声明模拟，原生插件能够补充底层能力。正如用JS实现FFT算法的开发者所言：”不是不能写，而是写完后发现，愿意用的人太少。”</p>\n<h2 id=\"二、生态循环的”死亡螺旋”\"><a href=\"#二、生态循环的”死亡螺旋”\" class=\"headerlink\" title=\"二、生态循环的”死亡螺旋”\"></a>二、生态循环的”死亡螺旋”</h2><p>在Python社区，一个NumPy的bug可能引发百人协作修复；而在JS世界，即便写出性能媲美的ndarray库，也可能面临”无人问津”的尴尬。这种差距源于两个恶性循环：</p>\n<h3 id=\"人才的”用脚投票”\"><a href=\"#人才的”用脚投票”\" class=\"headerlink\" title=\"人才的”用脚投票”\"></a>人才的”用脚投票”</h3><p>数据科学家更熟悉Python的SciPy生态，前端开发者擅长的DOM操作与数值计算需求错位。就像PHP开发者转向全栈时更易选择Node.js，数值计算领域的专家天然倾向于已有成熟工具的语言。某开源JS数学库维护者坦言：”我花3个月优化的矩阵求逆算法，不如Python同行一个星期的Stack Overflow答疑获得的关注多。”</p>\n<h3 id=\"库作者的”收益悖论”\"><a href=\"#库作者的”收益悖论”\" class=\"headerlink\" title=\"库作者的”收益悖论”\"></a>库作者的”收益悖论”</h3><p>优秀的数值计算库需要持续打磨——这既包括算法优化，也需要完善的文档和教程。但JS生态的”快餐文化”让深度投入变得稀缺：一个实现K-means聚类的NPM包可能有2000+下载，但愿意提交文档翻译的贡献者不到5人。这种”用得多、养得少”的现状，让库作者难以获得持续创作的动力。</p>\n<h2 id=\"三、破局的”星星之火”\"><a href=\"#三、破局的”星星之火”\" class=\"headerlink\" title=\"三、破局的”星星之火”\"></a>三、破局的”星星之火”</h2><p>转机正在边缘地带悄然发生。在边缘计算场景，Node.js的低延迟特性催生了实时数据处理需求：某物联网公司用JS编写的信号滤波算法，在边缘设备上实现了比Python快30%的处理速度；WebAssembly的普及，让TensorFlow.js能在浏览器中直接运行轻量化模型，这种”计算可视化一体”的体验，正是Python生态难以复制的优势。</p>\n<p>更值得关注的是工具链的进化。TypeScript的类型系统正在重塑JS的工程能力——某数值计算库通过严格的类型定义，让线性代数操作的错误率下降70%；Vite等构建工具的普及，让JS库的打包体积缩小60%，降低了科学计算库的集成成本。这些变化正在吸引跨界开发者：一位从Julia转投JS的计算生物学家表示：”现在用JS写的分子动力学模拟，调试效率比编译型语言高5倍。”</p>\n<h2 id=\"四、未来的”第三条路”\"><a href=\"#四、未来的”第三条路”\" class=\"headerlink\" title=\"四、未来的”第三条路”\"></a>四、未来的”第三条路”</h2><p>JS的数值计算生态不会重复Python的路径，而是走出自己的特色：在浏览器端，WebGPU与WebAssembly的结合，正在孕育”可视化即计算”的新范式——用户在Canvas上绘制的图表，背后可能运行着百万级的矩阵运算；在服务端，Node.js的分布式特性让大规模数值计算可以无缝融入微服务架构，某金融公司已用此方案实现了实时风控模型的动态部署。</p>\n<p>这场生态突围的关键，在于找到JS的”不可替代性”。当Python开发者还在为环境配置发愁时，JS开发者已经通过CDN让数值计算库秒级加载；当R语言的图表需要导出才能分享时，JS的D3.js正在浏览器中实现交互式数据分析。这些差异化体验，正在吸引越来越多”非典型”开发者——他们未必精通算法，但擅长将计算能力转化为用户可见的价值。</p>\n<p>在JS的世界里，数值计算的未来不是复刻NumPy，而是创造属于自己的”计算原语”。当某天，前端开发者能用熟悉的语法操作多维数组，后端工程师可以轻松将数值计算嵌入API，这场迟到的生态革命才算真正完成。而此刻，那些在荒芜中播种的开发者，正在书写着这段历史的序章。</p>\n","excerpt":"","more":"<p><strong>背景</strong>：最近在尝试使用Node折腾一下图像处理相关的操作，以往使用Python处理时常常都会搭配使用numpy库，它在数值和矩阵等计算方面的性能是不用多说的，但在Node生态下却很难找到类似的替代方案，又是有了此文。</p>\n<p>在Node.js的世界里，写一个矩阵乘法函数或许只需百行代码，但要构建一个能与NumPy媲美的科学计算库，却堪比在沙漠中种树——技术的种子早已埋下，缺乏的是滋养生态的绿洲。这不是语言能力的边界，而是一场关于开发者选择的博弈。</p>\n<h2 id=\"一、被误解的”技术原罪”\"><a href=\"#一、被误解的”技术原罪”\" class=\"headerlink\" title=\"一、被误解的”技术原罪”\"></a>一、被误解的”技术原罪”</h2><p>当开发者争论”JS能否做科学计算”时，往往忽略了一个事实：V8引擎的浮点运算性能早已超越多数脚本语言。<strong>类型化数组</strong>配合SIMD.js（通过WebAssembly实现），能让矩阵乘法达到C语言90%的效率；Node.js的N-API允许无缝绑定Fortran数值库，就像<strong>stdlib项目</strong>所展示的那样。ES6引入的类与模块系统，虽未直接赋能数值计算，却为构建复杂数据结构提供了基础设施。</p>\n<p>真正的技术瓶颈藏在细节里。比如，JS至今缺乏原生的64位整数数组，这让金融计算场景颇为棘手；复数类型的缺失，也让信号处理库的开发绕道而行。但这些都不是不可逾越的高墙——TypeScript可以通过类型声明模拟，原生插件能够补充底层能力。正如用JS实现FFT算法的开发者所言：”不是不能写，而是写完后发现，愿意用的人太少。”</p>\n<h2 id=\"二、生态循环的”死亡螺旋”\"><a href=\"#二、生态循环的”死亡螺旋”\" class=\"headerlink\" title=\"二、生态循环的”死亡螺旋”\"></a>二、生态循环的”死亡螺旋”</h2><p>在Python社区，一个NumPy的bug可能引发百人协作修复；而在JS世界，即便写出性能媲美的ndarray库，也可能面临”无人问津”的尴尬。这种差距源于两个恶性循环：</p>\n<h3 id=\"人才的”用脚投票”\"><a href=\"#人才的”用脚投票”\" class=\"headerlink\" title=\"人才的”用脚投票”\"></a>人才的”用脚投票”</h3><p>数据科学家更熟悉Python的SciPy生态，前端开发者擅长的DOM操作与数值计算需求错位。就像PHP开发者转向全栈时更易选择Node.js，数值计算领域的专家天然倾向于已有成熟工具的语言。某开源JS数学库维护者坦言：”我花3个月优化的矩阵求逆算法，不如Python同行一个星期的Stack Overflow答疑获得的关注多。”</p>\n<h3 id=\"库作者的”收益悖论”\"><a href=\"#库作者的”收益悖论”\" class=\"headerlink\" title=\"库作者的”收益悖论”\"></a>库作者的”收益悖论”</h3><p>优秀的数值计算库需要持续打磨——这既包括算法优化，也需要完善的文档和教程。但JS生态的”快餐文化”让深度投入变得稀缺：一个实现K-means聚类的NPM包可能有2000+下载，但愿意提交文档翻译的贡献者不到5人。这种”用得多、养得少”的现状，让库作者难以获得持续创作的动力。</p>\n<h2 id=\"三、破局的”星星之火”\"><a href=\"#三、破局的”星星之火”\" class=\"headerlink\" title=\"三、破局的”星星之火”\"></a>三、破局的”星星之火”</h2><p>转机正在边缘地带悄然发生。在边缘计算场景，Node.js的低延迟特性催生了实时数据处理需求：某物联网公司用JS编写的信号滤波算法，在边缘设备上实现了比Python快30%的处理速度；WebAssembly的普及，让TensorFlow.js能在浏览器中直接运行轻量化模型，这种”计算可视化一体”的体验，正是Python生态难以复制的优势。</p>\n<p>更值得关注的是工具链的进化。TypeScript的类型系统正在重塑JS的工程能力——某数值计算库通过严格的类型定义，让线性代数操作的错误率下降70%；Vite等构建工具的普及，让JS库的打包体积缩小60%，降低了科学计算库的集成成本。这些变化正在吸引跨界开发者：一位从Julia转投JS的计算生物学家表示：”现在用JS写的分子动力学模拟，调试效率比编译型语言高5倍。”</p>\n<h2 id=\"四、未来的”第三条路”\"><a href=\"#四、未来的”第三条路”\" class=\"headerlink\" title=\"四、未来的”第三条路”\"></a>四、未来的”第三条路”</h2><p>JS的数值计算生态不会重复Python的路径，而是走出自己的特色：在浏览器端，WebGPU与WebAssembly的结合，正在孕育”可视化即计算”的新范式——用户在Canvas上绘制的图表，背后可能运行着百万级的矩阵运算；在服务端，Node.js的分布式特性让大规模数值计算可以无缝融入微服务架构，某金融公司已用此方案实现了实时风控模型的动态部署。</p>\n<p>这场生态突围的关键，在于找到JS的”不可替代性”。当Python开发者还在为环境配置发愁时，JS开发者已经通过CDN让数值计算库秒级加载；当R语言的图表需要导出才能分享时，JS的D3.js正在浏览器中实现交互式数据分析。这些差异化体验，正在吸引越来越多”非典型”开发者——他们未必精通算法，但擅长将计算能力转化为用户可见的价值。</p>\n<p>在JS的世界里，数值计算的未来不是复刻NumPy，而是创造属于自己的”计算原语”。当某天，前端开发者能用熟悉的语法操作多维数组，后端工程师可以轻松将数值计算嵌入API，这场迟到的生态革命才算真正完成。而此刻，那些在荒芜中播种的开发者，正在书写着这段历史的序章。</p>\n"},{"title":"说说JavaScript中ES6 module(模块化)的诞生背景、核心语法及应用场景","date":"2025-12-06T04:34:58.000Z","_content":"<!--# ES6 Module：重塑JavaScript模块化生态的基石 -->\n这是[JavaScript进阶系列文章](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU2MjU3MzI0MA==&action=getalbum&album_id=4120256678140837890#wechat_redirect)的第10篇文章, 今天我们要讲的是 JavaScript ES6中一个非常核心的概念，它的出现可以说是统一了JavaScript中模块化规范的三国时代，那么它是什么呢--`ES6 Module`\n\n## 诞生背景：终结混乱的模块化革命\n在ES6 Module出现之前，JavaScript长期缺乏官方模块化标准，前端开发深陷\"全局变量污染-命名冲突-依赖混乱\"的恶性循环。2010年前后崛起的三大方案各有局限：\n- **CommonJS**：为Node.js设计的同步加载方案，无法适配浏览器异步环境，`require('./module' + num)`的动态加载特性也埋下了依赖分析的隐患\n- **AMD**：以RequireJS为代表的异步方案，虽解决了浏览器加载问题，但`define`函数嵌套层级深，语法冗余度高\n- **UMD**：兼容多环境的妥协方案，通过大量条件判断实现跨平台，导致代码体积膨胀且维护困难\n\n2015年ES6正式引入Module规范，标志着JavaScript首次在语言层面确立模块化标准。其核心使命是：**打通前后端模块化壁垒，提供兼顾语法简洁性、加载高效性与工程可扩展性的统一方案**。\n\n截至2024年，主流浏览器对ES6 Module的支持率已达97.24%，Node.js自v12.17.0起实现原生支持，彻底改变了JavaScript的开发范式。\n\n## 核心语法：简洁而严谨的模块交互规则\nES6 Module通过`export`与`import`关键字构建模块体系，语法设计兼顾易用性与静态分析能力。\n\n### （一）导出语法：三种核心导出方式\n1. **命名导出**：支持单个、批量及重命名导出\n```javascript\n// utils.js\nexport const PI = 3.14; // 单个导出\nconst add = (a,b) => a+b;\nconst multiply = (a,b) => a*b;\nexport { add, multiply as mul }; // 批量+重命名导出\n```\n\n2. **默认导出**：每个模块唯一的默认出口，导入时可自定义名称\n```javascript\n// calculator.js\nexport default class Calculator { // 默认导出类\n  constructor() {}\n  sum(a,b) { return a+b; }\n}\n```\n\n3. **复合导出**：转发其他模块导出，适用于构建模块入口\n```javascript\n// index.js\nexport * from './utils.js'; // 转发所有命名导出\nexport { default as Calculator } from './calculator.js'; // 转发默认导出\n```\n\n### （二）导入语法：灵活适配使用场景\n```javascript\n// 1. 导入命名成员\nimport { PI, add, mul } from './utils.js';\n\n// 2. 导入默认成员（自定义名称）\nimport Calc from './calculator.js';\n\n// 3. 混合导入\nimport Calc, { PI } from './index.js';\n\n// 4. 重命名与整体导入\nimport { add as plus, mul as multiply } from './utils.js';\nimport * as utils from './utils.js'; // 命名空间对象\n\n// 5. 远程模块导入（浏览器原生支持）\nimport { createStore } from \"https://unpkg.com/redux@4.0.5/es/redux.mjs\";\n```\n\n### （三）语法铁律：保障静态特性\n`import`/`export`必须置于代码顶层，禁止嵌套在条件语句或函数中：\n```javascript\n// 错误示例\nif (true) {\n  import { add } from './utils.js'; // 语法报错\n}\n```\n\n## 本质差异：重新定义模块化能力\nES6 Module与传统方案的核心区别体现在加载机制、值传递方式等底层逻辑上。\n\n### （一）静态加载 vs 动态加载\n| 特性                | ES6 Module                  | CommonJS               |\n|---------------------|-----------------------------|------------------------|\n| 加载时机            | 编译期静态分析              | 运行时动态加载         |\n| 依赖分析            | 支持静态依赖树构建          | 依赖关系动态变化       |\n| 代码优化            | 原生支持Tree-shaking        | 无法实现死代码剔除     |\n| 动态加载能力        | 通过`import()`函数实现      | `require()`天然支持    |\n\nTree-shaking优化需配合`package.json`配置：\n```json\n// package.json 关键配置\n{ \"sideEffects\": false } // 标记无副作用模块\n```\n```javascript\n// 未使用的函数会被Tree-shaking剔除\nimport { usedFunc, unusedFunc } from './utils.js';\nusedFunc(); // 最终打包仅包含usedFunc\n```\n\n### （二）引用绑定 vs 值拷贝\nES6 Module采用实时引用绑定，导出值更新会同步影响导入方：\n```javascript\n// 模块A：moduleA.js\nexport let count = 0;\nexport const increment = () => count++;\n\n// 模块B：moduleB.js\nimport { count, increment } from './moduleA.js';\nconsole.log(count); // 0\nincrement();\nconsole.log(count); // 1（实时更新）\n```\n\nCommonJS则是值拷贝快照，后续更新不影响已导入值：\n```javascript\n// 模块A：moduleA.cjs\nlet count = 0;\nmodule.exports = {\n  count,\n  increment: () => count++\n};\n\n// 模块B：moduleB.cjs\nconst { count, increment } = require('./moduleA.cjs');\nconsole.log(count); // 0\nincrement();\nconsole.log(count); // 0（值未更新）\n```\n\n### （三）内置特性：提升开发规范性\n1. **默认严格模式**：模块内自动启用`'use strict'`，禁止未声明变量赋值\n2. **独立模块作用域**：内部变量不会泄漏到全局，解决命名冲突问题\n3. **单例特性**：模块仅执行一次，多次导入复用同一实例\n```javascript\n// 计数器模块：counter.js\nlet count = 0;\nexport const getCount = () => ++count;\n\n// 两次导入共享同一实例\nimport { getCount } from './counter.js';\nimport { getCount as getNewCount } from './counter.js';\nconsole.log(getCount()); // 1\nconsole.log(getNewCount()); // 2\n```\n\n## 场景落地：跨环境的模块化实践\nES6 Module已实现浏览器与Node.js双端覆盖，配合工具链可适配全场景需求。\n\n### （一）浏览器端应用\n1. **原生使用**：通过`type=\"module\"`启用\n```html\n<!-- 内联模块 -->\n<script type=\"module\">\n  import { add } from './utils.js';\n  console.log(add(2,3)); // 5\n</script>\n\n<!-- 外部模块 -->\n<script type=\"module\" src=\"./app.js\"></script>\n```\n\n2. **兼容性处理**：旧浏览器需通过Babel转译+Webpack打包，将ES6 Module转为ES5代码\n\n### （二）Node.js端应用\n1. **启用方式**：二选一即可\n   - 配置`package.json`: `\"type\": \"module\"`\n   - 文件后缀改为`.mjs`\n\n2. **与CommonJS互操作**：\n```javascript\n// ES6 Module中导入CommonJS模块\nimport fs from 'fs'; // 自动识别package.json的main字段\n\n// 复杂场景使用createRequire\nimport { createRequire } from 'module';\nconst require = createRequire(import.meta.url);\nconst cjsModule = require('./module.cjs');\n```\n\n### （三）高级场景：动态导入与性能优化\n`import()`函数返回Promise，支持按需加载与条件加载：\n```javascript\n// 按钮点击时加载模块（首屏性能优化）\nconst btn = document.getElementById('load-btn');\nbtn.addEventListener('click', async () => {\n  const { default: Chart } = await import('./chart.js');\n  new Chart('#canvas'); // 动态初始化图表\n});\n```\n该特性已成为前端路由懒加载的核心技术，如React的`React.lazy`本质就是对`import()`的封装。\n\n## 写在最后：一个老开发的个人看法\n\n如今，ES6 Module 已成为现代 JavaScript 开发的基础设施：`Webpack`、`Rollup` 等构建工具以其静态特性实现高效打包，`React`、`Vue` 等框架借助动态导入优化加载性能，Node.js 与浏览器的原生支持更让 \"一次编写、两端运行\" 成为现实。\n\n对于开发者而言，理解 ES6 Module 的本质不仅是掌握语法规则，更是把握 JavaScript 生态演进的核心逻辑 —— **从 \"解决当下问题\" 到 \"构建可持续生态\"，这正是模块化标准从混乱走向统一的根本意义**，也为 JavaScript 在大型应用与跨端开发领域的持续突破奠定了坚实基础。\n\n**【往期精彩】**\n- [一文说透ES6 Proxy: 从本质到应用场景](https://mp.weixin.qq.com/s/lYqBgS0GJgQMX5PAW_snnQ)\n- [JavaScript ES6中的生成器(Generator)是什么？有哪些应用场景？一文全说透](https://mp.weixin.qq.com/s/PtFtlNUH-UcLYU5h-xKiQw)\n- [聊聊ES6里的Promise：简单理解和实际用法](https://mp.weixin.qq.com/s/9pnvL5fTO5U9yT-1mPfeQw)\n- [一文搞懂 JavaScript 里 var、let、const 的区别\n](https://mp.weixin.qq.com/s/lqn_51NNxx50YgvWkxCtEg)\n- [为什么 ES6 要新增 Set 和 Map？看完这篇就懂了](https://mp.weixin.qq.com/s/UuJeSErftQY7ee1a54Pv4A)\n\n\n- [JavaScript ES6中Object的拓展，你了解几个？](https://mp.weixin.qq.com/s/PTI3HGsfpDz4-GvRx0i9ew)\n\n","source":"_posts/module-in-es6.md","raw":"---\ntitle: 说说JavaScript中ES6 module(模块化)的诞生背景、核心语法及应用场景\ndate: 2025-12-06 12:34:58\ntags: JavaScript进阶, ES6进阶\ncategory: ES6进阶\n---\n<!--# ES6 Module：重塑JavaScript模块化生态的基石 -->\n这是[JavaScript进阶系列文章](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU2MjU3MzI0MA==&action=getalbum&album_id=4120256678140837890#wechat_redirect)的第10篇文章, 今天我们要讲的是 JavaScript ES6中一个非常核心的概念，它的出现可以说是统一了JavaScript中模块化规范的三国时代，那么它是什么呢--`ES6 Module`\n\n## 诞生背景：终结混乱的模块化革命\n在ES6 Module出现之前，JavaScript长期缺乏官方模块化标准，前端开发深陷\"全局变量污染-命名冲突-依赖混乱\"的恶性循环。2010年前后崛起的三大方案各有局限：\n- **CommonJS**：为Node.js设计的同步加载方案，无法适配浏览器异步环境，`require('./module' + num)`的动态加载特性也埋下了依赖分析的隐患\n- **AMD**：以RequireJS为代表的异步方案，虽解决了浏览器加载问题，但`define`函数嵌套层级深，语法冗余度高\n- **UMD**：兼容多环境的妥协方案，通过大量条件判断实现跨平台，导致代码体积膨胀且维护困难\n\n2015年ES6正式引入Module规范，标志着JavaScript首次在语言层面确立模块化标准。其核心使命是：**打通前后端模块化壁垒，提供兼顾语法简洁性、加载高效性与工程可扩展性的统一方案**。\n\n截至2024年，主流浏览器对ES6 Module的支持率已达97.24%，Node.js自v12.17.0起实现原生支持，彻底改变了JavaScript的开发范式。\n\n## 核心语法：简洁而严谨的模块交互规则\nES6 Module通过`export`与`import`关键字构建模块体系，语法设计兼顾易用性与静态分析能力。\n\n### （一）导出语法：三种核心导出方式\n1. **命名导出**：支持单个、批量及重命名导出\n```javascript\n// utils.js\nexport const PI = 3.14; // 单个导出\nconst add = (a,b) => a+b;\nconst multiply = (a,b) => a*b;\nexport { add, multiply as mul }; // 批量+重命名导出\n```\n\n2. **默认导出**：每个模块唯一的默认出口，导入时可自定义名称\n```javascript\n// calculator.js\nexport default class Calculator { // 默认导出类\n  constructor() {}\n  sum(a,b) { return a+b; }\n}\n```\n\n3. **复合导出**：转发其他模块导出，适用于构建模块入口\n```javascript\n// index.js\nexport * from './utils.js'; // 转发所有命名导出\nexport { default as Calculator } from './calculator.js'; // 转发默认导出\n```\n\n### （二）导入语法：灵活适配使用场景\n```javascript\n// 1. 导入命名成员\nimport { PI, add, mul } from './utils.js';\n\n// 2. 导入默认成员（自定义名称）\nimport Calc from './calculator.js';\n\n// 3. 混合导入\nimport Calc, { PI } from './index.js';\n\n// 4. 重命名与整体导入\nimport { add as plus, mul as multiply } from './utils.js';\nimport * as utils from './utils.js'; // 命名空间对象\n\n// 5. 远程模块导入（浏览器原生支持）\nimport { createStore } from \"https://unpkg.com/redux@4.0.5/es/redux.mjs\";\n```\n\n### （三）语法铁律：保障静态特性\n`import`/`export`必须置于代码顶层，禁止嵌套在条件语句或函数中：\n```javascript\n// 错误示例\nif (true) {\n  import { add } from './utils.js'; // 语法报错\n}\n```\n\n## 本质差异：重新定义模块化能力\nES6 Module与传统方案的核心区别体现在加载机制、值传递方式等底层逻辑上。\n\n### （一）静态加载 vs 动态加载\n| 特性                | ES6 Module                  | CommonJS               |\n|---------------------|-----------------------------|------------------------|\n| 加载时机            | 编译期静态分析              | 运行时动态加载         |\n| 依赖分析            | 支持静态依赖树构建          | 依赖关系动态变化       |\n| 代码优化            | 原生支持Tree-shaking        | 无法实现死代码剔除     |\n| 动态加载能力        | 通过`import()`函数实现      | `require()`天然支持    |\n\nTree-shaking优化需配合`package.json`配置：\n```json\n// package.json 关键配置\n{ \"sideEffects\": false } // 标记无副作用模块\n```\n```javascript\n// 未使用的函数会被Tree-shaking剔除\nimport { usedFunc, unusedFunc } from './utils.js';\nusedFunc(); // 最终打包仅包含usedFunc\n```\n\n### （二）引用绑定 vs 值拷贝\nES6 Module采用实时引用绑定，导出值更新会同步影响导入方：\n```javascript\n// 模块A：moduleA.js\nexport let count = 0;\nexport const increment = () => count++;\n\n// 模块B：moduleB.js\nimport { count, increment } from './moduleA.js';\nconsole.log(count); // 0\nincrement();\nconsole.log(count); // 1（实时更新）\n```\n\nCommonJS则是值拷贝快照，后续更新不影响已导入值：\n```javascript\n// 模块A：moduleA.cjs\nlet count = 0;\nmodule.exports = {\n  count,\n  increment: () => count++\n};\n\n// 模块B：moduleB.cjs\nconst { count, increment } = require('./moduleA.cjs');\nconsole.log(count); // 0\nincrement();\nconsole.log(count); // 0（值未更新）\n```\n\n### （三）内置特性：提升开发规范性\n1. **默认严格模式**：模块内自动启用`'use strict'`，禁止未声明变量赋值\n2. **独立模块作用域**：内部变量不会泄漏到全局，解决命名冲突问题\n3. **单例特性**：模块仅执行一次，多次导入复用同一实例\n```javascript\n// 计数器模块：counter.js\nlet count = 0;\nexport const getCount = () => ++count;\n\n// 两次导入共享同一实例\nimport { getCount } from './counter.js';\nimport { getCount as getNewCount } from './counter.js';\nconsole.log(getCount()); // 1\nconsole.log(getNewCount()); // 2\n```\n\n## 场景落地：跨环境的模块化实践\nES6 Module已实现浏览器与Node.js双端覆盖，配合工具链可适配全场景需求。\n\n### （一）浏览器端应用\n1. **原生使用**：通过`type=\"module\"`启用\n```html\n<!-- 内联模块 -->\n<script type=\"module\">\n  import { add } from './utils.js';\n  console.log(add(2,3)); // 5\n</script>\n\n<!-- 外部模块 -->\n<script type=\"module\" src=\"./app.js\"></script>\n```\n\n2. **兼容性处理**：旧浏览器需通过Babel转译+Webpack打包，将ES6 Module转为ES5代码\n\n### （二）Node.js端应用\n1. **启用方式**：二选一即可\n   - 配置`package.json`: `\"type\": \"module\"`\n   - 文件后缀改为`.mjs`\n\n2. **与CommonJS互操作**：\n```javascript\n// ES6 Module中导入CommonJS模块\nimport fs from 'fs'; // 自动识别package.json的main字段\n\n// 复杂场景使用createRequire\nimport { createRequire } from 'module';\nconst require = createRequire(import.meta.url);\nconst cjsModule = require('./module.cjs');\n```\n\n### （三）高级场景：动态导入与性能优化\n`import()`函数返回Promise，支持按需加载与条件加载：\n```javascript\n// 按钮点击时加载模块（首屏性能优化）\nconst btn = document.getElementById('load-btn');\nbtn.addEventListener('click', async () => {\n  const { default: Chart } = await import('./chart.js');\n  new Chart('#canvas'); // 动态初始化图表\n});\n```\n该特性已成为前端路由懒加载的核心技术，如React的`React.lazy`本质就是对`import()`的封装。\n\n## 写在最后：一个老开发的个人看法\n\n如今，ES6 Module 已成为现代 JavaScript 开发的基础设施：`Webpack`、`Rollup` 等构建工具以其静态特性实现高效打包，`React`、`Vue` 等框架借助动态导入优化加载性能，Node.js 与浏览器的原生支持更让 \"一次编写、两端运行\" 成为现实。\n\n对于开发者而言，理解 ES6 Module 的本质不仅是掌握语法规则，更是把握 JavaScript 生态演进的核心逻辑 —— **从 \"解决当下问题\" 到 \"构建可持续生态\"，这正是模块化标准从混乱走向统一的根本意义**，也为 JavaScript 在大型应用与跨端开发领域的持续突破奠定了坚实基础。\n\n**【往期精彩】**\n- [一文说透ES6 Proxy: 从本质到应用场景](https://mp.weixin.qq.com/s/lYqBgS0GJgQMX5PAW_snnQ)\n- [JavaScript ES6中的生成器(Generator)是什么？有哪些应用场景？一文全说透](https://mp.weixin.qq.com/s/PtFtlNUH-UcLYU5h-xKiQw)\n- [聊聊ES6里的Promise：简单理解和实际用法](https://mp.weixin.qq.com/s/9pnvL5fTO5U9yT-1mPfeQw)\n- [一文搞懂 JavaScript 里 var、let、const 的区别\n](https://mp.weixin.qq.com/s/lqn_51NNxx50YgvWkxCtEg)\n- [为什么 ES6 要新增 Set 和 Map？看完这篇就懂了](https://mp.weixin.qq.com/s/UuJeSErftQY7ee1a54Pv4A)\n\n\n- [JavaScript ES6中Object的拓展，你了解几个？](https://mp.weixin.qq.com/s/PTI3HGsfpDz4-GvRx0i9ew)\n\n","slug":"module-in-es6","published":1,"updated":"2025-12-06T04:47:41.769Z","comments":1,"layout":"post","photos":[],"_id":"cmjbml2iu0043ikup5bjn4e6w","content":"<!--# ES6 Module：重塑JavaScript模块化生态的基石 -->\n<p>这是<a href=\"https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU2MjU3MzI0MA==&action=getalbum&album_id=4120256678140837890#wechat_redirect\">JavaScript进阶系列文章</a>的第10篇文章, 今天我们要讲的是 JavaScript ES6中一个非常核心的概念，它的出现可以说是统一了JavaScript中模块化规范的三国时代，那么它是什么呢–<code>ES6 Module</code></p>\n<h2 id=\"诞生背景：终结混乱的模块化革命\"><a href=\"#诞生背景：终结混乱的模块化革命\" class=\"headerlink\" title=\"诞生背景：终结混乱的模块化革命\"></a>诞生背景：终结混乱的模块化革命</h2><p>在ES6 Module出现之前，JavaScript长期缺乏官方模块化标准，前端开发深陷”全局变量污染-命名冲突-依赖混乱”的恶性循环。2010年前后崛起的三大方案各有局限：</p>\n<ul>\n<li><strong>CommonJS</strong>：为Node.js设计的同步加载方案，无法适配浏览器异步环境，<code>require(&#39;./module&#39; + num)</code>的动态加载特性也埋下了依赖分析的隐患</li>\n<li><strong>AMD</strong>：以RequireJS为代表的异步方案，虽解决了浏览器加载问题，但<code>define</code>函数嵌套层级深，语法冗余度高</li>\n<li><strong>UMD</strong>：兼容多环境的妥协方案，通过大量条件判断实现跨平台，导致代码体积膨胀且维护困难</li>\n</ul>\n<p>2015年ES6正式引入Module规范，标志着JavaScript首次在语言层面确立模块化标准。其核心使命是：<strong>打通前后端模块化壁垒，提供兼顾语法简洁性、加载高效性与工程可扩展性的统一方案</strong>。</p>\n<p>截至2024年，主流浏览器对ES6 Module的支持率已达97.24%，Node.js自v12.17.0起实现原生支持，彻底改变了JavaScript的开发范式。</p>\n<h2 id=\"核心语法：简洁而严谨的模块交互规则\"><a href=\"#核心语法：简洁而严谨的模块交互规则\" class=\"headerlink\" title=\"核心语法：简洁而严谨的模块交互规则\"></a>核心语法：简洁而严谨的模块交互规则</h2><p>ES6 Module通过<code>export</code>与<code>import</code>关键字构建模块体系，语法设计兼顾易用性与静态分析能力。</p>\n<h3 id=\"（一）导出语法：三种核心导出方式\"><a href=\"#（一）导出语法：三种核心导出方式\" class=\"headerlink\" title=\"（一）导出语法：三种核心导出方式\"></a>（一）导出语法：三种核心导出方式</h3><ol>\n<li><p><strong>命名导出</strong>：支持单个、批量及重命名导出</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// utils.js</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">PI</span> = <span class=\"hljs-number\">3.14</span>; <span class=\"hljs-comment\">// 单个导出</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">add</span> = (<span class=\"hljs-params\">a,b</span>) =&gt; a+b;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">multiply</span> = (<span class=\"hljs-params\">a,b</span>) =&gt; a*b;<br><span class=\"hljs-keyword\">export</span> &#123; add, multiply <span class=\"hljs-keyword\">as</span> mul &#125;; <span class=\"hljs-comment\">// 批量+重命名导出</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>默认导出</strong>：每个模块唯一的默认出口，导入时可自定义名称</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// calculator.js</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Calculator</span> &#123; <span class=\"hljs-comment\">// 默认导出类</span><br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;&#125;<br>  <span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-params\">a,b</span>) &#123; <span class=\"hljs-keyword\">return</span> a+b; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>复合导出</strong>：转发其他模块导出，适用于构建模块入口</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// index.js</span><br><span class=\"hljs-keyword\">export</span> * <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./utils.js&#x27;</span>; <span class=\"hljs-comment\">// 转发所有命名导出</span><br><span class=\"hljs-keyword\">export</span> &#123; <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">Calculator</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./calculator.js&#x27;</span>; <span class=\"hljs-comment\">// 转发默认导出</span><br></code></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"（二）导入语法：灵活适配使用场景\"><a href=\"#（二）导入语法：灵活适配使用场景\" class=\"headerlink\" title=\"（二）导入语法：灵活适配使用场景\"></a>（二）导入语法：灵活适配使用场景</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 1. 导入命名成员</span><br><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-variable constant_\">PI</span>, add, mul &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./utils.js&#x27;</span>;<br><br><span class=\"hljs-comment\">// 2. 导入默认成员（自定义名称）</span><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Calc</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./calculator.js&#x27;</span>;<br><br><span class=\"hljs-comment\">// 3. 混合导入</span><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Calc</span>, &#123; <span class=\"hljs-variable constant_\">PI</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./index.js&#x27;</span>;<br><br><span class=\"hljs-comment\">// 4. 重命名与整体导入</span><br><span class=\"hljs-keyword\">import</span> &#123; add <span class=\"hljs-keyword\">as</span> plus, mul <span class=\"hljs-keyword\">as</span> multiply &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./utils.js&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> utils <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./utils.js&#x27;</span>; <span class=\"hljs-comment\">// 命名空间对象</span><br><br><span class=\"hljs-comment\">// 5. 远程模块导入（浏览器原生支持）</span><br><span class=\"hljs-keyword\">import</span> &#123; createStore &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;https://unpkg.com/redux@4.0.5/es/redux.mjs&quot;</span>;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"（三）语法铁律：保障静态特性\"><a href=\"#（三）语法铁律：保障静态特性\" class=\"headerlink\" title=\"（三）语法铁律：保障静态特性\"></a>（三）语法铁律：保障静态特性</h3><p><code>import</code>&#x2F;<code>export</code>必须置于代码顶层，禁止嵌套在条件语句或函数中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 错误示例</span><br><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>  <span class=\"hljs-keyword\">import</span> &#123; add &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./utils.js&#x27;</span>; <span class=\"hljs-comment\">// 语法报错</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"本质差异：重新定义模块化能力\"><a href=\"#本质差异：重新定义模块化能力\" class=\"headerlink\" title=\"本质差异：重新定义模块化能力\"></a>本质差异：重新定义模块化能力</h2><p>ES6 Module与传统方案的核心区别体现在加载机制、值传递方式等底层逻辑上。</p>\n<h3 id=\"（一）静态加载-vs-动态加载\"><a href=\"#（一）静态加载-vs-动态加载\" class=\"headerlink\" title=\"（一）静态加载 vs 动态加载\"></a>（一）静态加载 vs 动态加载</h3><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>ES6 Module</th>\n<th>CommonJS</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>加载时机</td>\n<td>编译期静态分析</td>\n<td>运行时动态加载</td>\n</tr>\n<tr>\n<td>依赖分析</td>\n<td>支持静态依赖树构建</td>\n<td>依赖关系动态变化</td>\n</tr>\n<tr>\n<td>代码优化</td>\n<td>原生支持Tree-shaking</td>\n<td>无法实现死代码剔除</td>\n</tr>\n<tr>\n<td>动态加载能力</td>\n<td>通过<code>import()</code>函数实现</td>\n<td><code>require()</code>天然支持</td>\n</tr>\n</tbody></table>\n<p>Tree-shaking优化需配合<code>package.json</code>配置：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs json\"><span class=\"hljs-comment\">// package.json 关键配置</span><br><span class=\"hljs-punctuation\">&#123;</span> <span class=\"hljs-attr\">&quot;sideEffects&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-literal\"><span class=\"hljs-keyword\">false</span></span> <span class=\"hljs-punctuation\">&#125;</span> <span class=\"hljs-comment\">// 标记无副作用模块</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 未使用的函数会被Tree-shaking剔除</span><br><span class=\"hljs-keyword\">import</span> &#123; usedFunc, unusedFunc &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./utils.js&#x27;</span>;<br><span class=\"hljs-title function_\">usedFunc</span>(); <span class=\"hljs-comment\">// 最终打包仅包含usedFunc</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"（二）引用绑定-vs-值拷贝\"><a href=\"#（二）引用绑定-vs-值拷贝\" class=\"headerlink\" title=\"（二）引用绑定 vs 值拷贝\"></a>（二）引用绑定 vs 值拷贝</h3><p>ES6 Module采用实时引用绑定，导出值更新会同步影响导入方：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 模块A：moduleA.js</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">let</span> count = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">increment</span> = (<span class=\"hljs-params\"></span>) =&gt; count++;<br><br><span class=\"hljs-comment\">// 模块B：moduleB.js</span><br><span class=\"hljs-keyword\">import</span> &#123; count, increment &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./moduleA.js&#x27;</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(count); <span class=\"hljs-comment\">// 0</span><br><span class=\"hljs-title function_\">increment</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(count); <span class=\"hljs-comment\">// 1（实时更新）</span><br></code></pre></td></tr></table></figure>\n\n<p>CommonJS则是值拷贝快照，后续更新不影响已导入值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 模块A：moduleA.cjs</span><br><span class=\"hljs-keyword\">let</span> count = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = &#123;<br>  count,<br>  <span class=\"hljs-attr\">increment</span>: <span class=\"hljs-function\">() =&gt;</span> count++<br>&#125;;<br><br><span class=\"hljs-comment\">// 模块B：moduleB.cjs</span><br><span class=\"hljs-keyword\">const</span> &#123; count, increment &#125; = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;./moduleA.cjs&#x27;</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(count); <span class=\"hljs-comment\">// 0</span><br><span class=\"hljs-title function_\">increment</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(count); <span class=\"hljs-comment\">// 0（值未更新）</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"（三）内置特性：提升开发规范性\"><a href=\"#（三）内置特性：提升开发规范性\" class=\"headerlink\" title=\"（三）内置特性：提升开发规范性\"></a>（三）内置特性：提升开发规范性</h3><ol>\n<li><strong>默认严格模式</strong>：模块内自动启用<code>&#39;use strict&#39;</code>，禁止未声明变量赋值</li>\n<li><strong>独立模块作用域</strong>：内部变量不会泄漏到全局，解决命名冲突问题</li>\n<li><strong>单例特性</strong>：模块仅执行一次，多次导入复用同一实例<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 计数器模块：counter.js</span><br><span class=\"hljs-keyword\">let</span> count = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">getCount</span> = (<span class=\"hljs-params\"></span>) =&gt; ++count;<br><br><span class=\"hljs-comment\">// 两次导入共享同一实例</span><br><span class=\"hljs-keyword\">import</span> &#123; getCount &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./counter.js&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; getCount <span class=\"hljs-keyword\">as</span> getNewCount &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./counter.js&#x27;</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">getCount</span>()); <span class=\"hljs-comment\">// 1</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">getNewCount</span>()); <span class=\"hljs-comment\">// 2</span><br></code></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"场景落地：跨环境的模块化实践\"><a href=\"#场景落地：跨环境的模块化实践\" class=\"headerlink\" title=\"场景落地：跨环境的模块化实践\"></a>场景落地：跨环境的模块化实践</h2><p>ES6 Module已实现浏览器与Node.js双端覆盖，配合工具链可适配全场景需求。</p>\n<h3 id=\"（一）浏览器端应用\"><a href=\"#（一）浏览器端应用\" class=\"headerlink\" title=\"（一）浏览器端应用\"></a>（一）浏览器端应用</h3><ol>\n<li><p><strong>原生使用</strong>：通过<code>type=&quot;module&quot;</code>启用</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 内联模块 --&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;module&quot;</span>&gt;</span><span class=\"language-javascript\"></span><br><span class=\"language-javascript\">  <span class=\"hljs-keyword\">import</span> &#123; add &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./utils.js&#x27;</span>;</span><br><span class=\"language-javascript\">  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>)); <span class=\"hljs-comment\">// 5</span></span><br><span class=\"language-javascript\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><br><span class=\"hljs-comment\">&lt;!-- 外部模块 --&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;module&quot;</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;./app.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>兼容性处理</strong>：旧浏览器需通过Babel转译+Webpack打包，将ES6 Module转为ES5代码</p>\n</li>\n</ol>\n<h3 id=\"（二）Node-js端应用\"><a href=\"#（二）Node-js端应用\" class=\"headerlink\" title=\"（二）Node.js端应用\"></a>（二）Node.js端应用</h3><ol>\n<li><p><strong>启用方式</strong>：二选一即可</p>\n<ul>\n<li>配置<code>package.json</code>: <code>&quot;type&quot;: &quot;module&quot;</code></li>\n<li>文件后缀改为<code>.mjs</code></li>\n</ul>\n</li>\n<li><p><strong>与CommonJS互操作</strong>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// ES6 Module中导入CommonJS模块</span><br><span class=\"hljs-keyword\">import</span> fs <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;fs&#x27;</span>; <span class=\"hljs-comment\">// 自动识别package.json的main字段</span><br><br><span class=\"hljs-comment\">// 复杂场景使用createRequire</span><br><span class=\"hljs-keyword\">import</span> &#123; createRequire &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;module&#x27;</span>;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">require</span> = <span class=\"hljs-title function_\">createRequire</span>(<span class=\"hljs-keyword\">import</span>.<span class=\"hljs-property\">meta</span>.<span class=\"hljs-property\">url</span>);<br><span class=\"hljs-keyword\">const</span> cjsModule = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;./module.cjs&#x27;</span>);<br></code></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"（三）高级场景：动态导入与性能优化\"><a href=\"#（三）高级场景：动态导入与性能优化\" class=\"headerlink\" title=\"（三）高级场景：动态导入与性能优化\"></a>（三）高级场景：动态导入与性能优化</h3><p><code>import()</code>函数返回Promise，支持按需加载与条件加载：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 按钮点击时加载模块（首屏性能优化）</span><br><span class=\"hljs-keyword\">const</span> btn = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&#x27;load-btn&#x27;</span>);<br>btn.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;click&#x27;</span>, <span class=\"hljs-title function_\">async</span> () =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> &#123; <span class=\"hljs-attr\">default</span>: <span class=\"hljs-title class_\">Chart</span> &#125; = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">&#x27;./chart.js&#x27;</span>);<br>  <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Chart</span>(<span class=\"hljs-string\">&#x27;#canvas&#x27;</span>); <span class=\"hljs-comment\">// 动态初始化图表</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>该特性已成为前端路由懒加载的核心技术，如React的<code>React.lazy</code>本质就是对<code>import()</code>的封装。</p>\n<h2 id=\"写在最后：一个老开发的个人看法\"><a href=\"#写在最后：一个老开发的个人看法\" class=\"headerlink\" title=\"写在最后：一个老开发的个人看法\"></a>写在最后：一个老开发的个人看法</h2><p>如今，ES6 Module 已成为现代 JavaScript 开发的基础设施：<code>Webpack</code>、<code>Rollup</code> 等构建工具以其静态特性实现高效打包，<code>React</code>、<code>Vue</code> 等框架借助动态导入优化加载性能，Node.js 与浏览器的原生支持更让 “一次编写、两端运行” 成为现实。</p>\n<p>对于开发者而言，理解 ES6 Module 的本质不仅是掌握语法规则，更是把握 JavaScript 生态演进的核心逻辑 —— <strong>从 “解决当下问题” 到 “构建可持续生态”，这正是模块化标准从混乱走向统一的根本意义</strong>，也为 JavaScript 在大型应用与跨端开发领域的持续突破奠定了坚实基础。</p>\n<p><strong>【往期精彩】</strong></p>\n<ul>\n<li><p><a href=\"https://mp.weixin.qq.com/s/lYqBgS0GJgQMX5PAW_snnQ\">一文说透ES6 Proxy: 从本质到应用场景</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/PtFtlNUH-UcLYU5h-xKiQw\">JavaScript ES6中的生成器(Generator)是什么？有哪些应用场景？一文全说透</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/9pnvL5fTO5U9yT-1mPfeQw\">聊聊ES6里的Promise：简单理解和实际用法</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/lqn_51NNxx50YgvWkxCtEg\">一文搞懂 JavaScript 里 var、let、const 的区别\n</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/UuJeSErftQY7ee1a54Pv4A\">为什么 ES6 要新增 Set 和 Map？看完这篇就懂了</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/PTI3HGsfpDz4-GvRx0i9ew\">JavaScript ES6中Object的拓展，你了解几个？</a></p>\n</li>\n</ul>\n","excerpt":"","more":"<!--# ES6 Module：重塑JavaScript模块化生态的基石 -->\n<p>这是<a href=\"https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU2MjU3MzI0MA==&action=getalbum&album_id=4120256678140837890#wechat_redirect\">JavaScript进阶系列文章</a>的第10篇文章, 今天我们要讲的是 JavaScript ES6中一个非常核心的概念，它的出现可以说是统一了JavaScript中模块化规范的三国时代，那么它是什么呢–<code>ES6 Module</code></p>\n<h2 id=\"诞生背景：终结混乱的模块化革命\"><a href=\"#诞生背景：终结混乱的模块化革命\" class=\"headerlink\" title=\"诞生背景：终结混乱的模块化革命\"></a>诞生背景：终结混乱的模块化革命</h2><p>在ES6 Module出现之前，JavaScript长期缺乏官方模块化标准，前端开发深陷”全局变量污染-命名冲突-依赖混乱”的恶性循环。2010年前后崛起的三大方案各有局限：</p>\n<ul>\n<li><strong>CommonJS</strong>：为Node.js设计的同步加载方案，无法适配浏览器异步环境，<code>require(&#39;./module&#39; + num)</code>的动态加载特性也埋下了依赖分析的隐患</li>\n<li><strong>AMD</strong>：以RequireJS为代表的异步方案，虽解决了浏览器加载问题，但<code>define</code>函数嵌套层级深，语法冗余度高</li>\n<li><strong>UMD</strong>：兼容多环境的妥协方案，通过大量条件判断实现跨平台，导致代码体积膨胀且维护困难</li>\n</ul>\n<p>2015年ES6正式引入Module规范，标志着JavaScript首次在语言层面确立模块化标准。其核心使命是：<strong>打通前后端模块化壁垒，提供兼顾语法简洁性、加载高效性与工程可扩展性的统一方案</strong>。</p>\n<p>截至2024年，主流浏览器对ES6 Module的支持率已达97.24%，Node.js自v12.17.0起实现原生支持，彻底改变了JavaScript的开发范式。</p>\n<h2 id=\"核心语法：简洁而严谨的模块交互规则\"><a href=\"#核心语法：简洁而严谨的模块交互规则\" class=\"headerlink\" title=\"核心语法：简洁而严谨的模块交互规则\"></a>核心语法：简洁而严谨的模块交互规则</h2><p>ES6 Module通过<code>export</code>与<code>import</code>关键字构建模块体系，语法设计兼顾易用性与静态分析能力。</p>\n<h3 id=\"（一）导出语法：三种核心导出方式\"><a href=\"#（一）导出语法：三种核心导出方式\" class=\"headerlink\" title=\"（一）导出语法：三种核心导出方式\"></a>（一）导出语法：三种核心导出方式</h3><ol>\n<li><p><strong>命名导出</strong>：支持单个、批量及重命名导出</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// utils.js</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-variable constant_\">PI</span> = <span class=\"hljs-number\">3.14</span>; <span class=\"hljs-comment\">// 单个导出</span><br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">add</span> = (<span class=\"hljs-params\">a,b</span>) =&gt; a+b;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">multiply</span> = (<span class=\"hljs-params\">a,b</span>) =&gt; a*b;<br><span class=\"hljs-keyword\">export</span> &#123; add, multiply <span class=\"hljs-keyword\">as</span> mul &#125;; <span class=\"hljs-comment\">// 批量+重命名导出</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>默认导出</strong>：每个模块唯一的默认出口，导入时可自定义名称</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// calculator.js</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Calculator</span> &#123; <span class=\"hljs-comment\">// 默认导出类</span><br>  <span class=\"hljs-title function_\">constructor</span>(<span class=\"hljs-params\"></span>) &#123;&#125;<br>  <span class=\"hljs-title function_\">sum</span>(<span class=\"hljs-params\">a,b</span>) &#123; <span class=\"hljs-keyword\">return</span> a+b; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>复合导出</strong>：转发其他模块导出，适用于构建模块入口</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// index.js</span><br><span class=\"hljs-keyword\">export</span> * <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./utils.js&#x27;</span>; <span class=\"hljs-comment\">// 转发所有命名导出</span><br><span class=\"hljs-keyword\">export</span> &#123; <span class=\"hljs-keyword\">default</span> <span class=\"hljs-keyword\">as</span> <span class=\"hljs-title class_\">Calculator</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./calculator.js&#x27;</span>; <span class=\"hljs-comment\">// 转发默认导出</span><br></code></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"（二）导入语法：灵活适配使用场景\"><a href=\"#（二）导入语法：灵活适配使用场景\" class=\"headerlink\" title=\"（二）导入语法：灵活适配使用场景\"></a>（二）导入语法：灵活适配使用场景</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 1. 导入命名成员</span><br><span class=\"hljs-keyword\">import</span> &#123; <span class=\"hljs-variable constant_\">PI</span>, add, mul &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./utils.js&#x27;</span>;<br><br><span class=\"hljs-comment\">// 2. 导入默认成员（自定义名称）</span><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Calc</span> <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./calculator.js&#x27;</span>;<br><br><span class=\"hljs-comment\">// 3. 混合导入</span><br><span class=\"hljs-keyword\">import</span> <span class=\"hljs-title class_\">Calc</span>, &#123; <span class=\"hljs-variable constant_\">PI</span> &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./index.js&#x27;</span>;<br><br><span class=\"hljs-comment\">// 4. 重命名与整体导入</span><br><span class=\"hljs-keyword\">import</span> &#123; add <span class=\"hljs-keyword\">as</span> plus, mul <span class=\"hljs-keyword\">as</span> multiply &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./utils.js&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> * <span class=\"hljs-keyword\">as</span> utils <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./utils.js&#x27;</span>; <span class=\"hljs-comment\">// 命名空间对象</span><br><br><span class=\"hljs-comment\">// 5. 远程模块导入（浏览器原生支持）</span><br><span class=\"hljs-keyword\">import</span> &#123; createStore &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&quot;https://unpkg.com/redux@4.0.5/es/redux.mjs&quot;</span>;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"（三）语法铁律：保障静态特性\"><a href=\"#（三）语法铁律：保障静态特性\" class=\"headerlink\" title=\"（三）语法铁律：保障静态特性\"></a>（三）语法铁律：保障静态特性</h3><p><code>import</code>&#x2F;<code>export</code>必须置于代码顶层，禁止嵌套在条件语句或函数中：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 错误示例</span><br><span class=\"hljs-keyword\">if</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>  <span class=\"hljs-keyword\">import</span> &#123; add &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./utils.js&#x27;</span>; <span class=\"hljs-comment\">// 语法报错</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"本质差异：重新定义模块化能力\"><a href=\"#本质差异：重新定义模块化能力\" class=\"headerlink\" title=\"本质差异：重新定义模块化能力\"></a>本质差异：重新定义模块化能力</h2><p>ES6 Module与传统方案的核心区别体现在加载机制、值传递方式等底层逻辑上。</p>\n<h3 id=\"（一）静态加载-vs-动态加载\"><a href=\"#（一）静态加载-vs-动态加载\" class=\"headerlink\" title=\"（一）静态加载 vs 动态加载\"></a>（一）静态加载 vs 动态加载</h3><table>\n<thead>\n<tr>\n<th>特性</th>\n<th>ES6 Module</th>\n<th>CommonJS</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>加载时机</td>\n<td>编译期静态分析</td>\n<td>运行时动态加载</td>\n</tr>\n<tr>\n<td>依赖分析</td>\n<td>支持静态依赖树构建</td>\n<td>依赖关系动态变化</td>\n</tr>\n<tr>\n<td>代码优化</td>\n<td>原生支持Tree-shaking</td>\n<td>无法实现死代码剔除</td>\n</tr>\n<tr>\n<td>动态加载能力</td>\n<td>通过<code>import()</code>函数实现</td>\n<td><code>require()</code>天然支持</td>\n</tr>\n</tbody></table>\n<p>Tree-shaking优化需配合<code>package.json</code>配置：</p>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs json\"><span class=\"hljs-comment\">// package.json 关键配置</span><br><span class=\"hljs-punctuation\">&#123;</span> <span class=\"hljs-attr\">&quot;sideEffects&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-literal\"><span class=\"hljs-keyword\">false</span></span> <span class=\"hljs-punctuation\">&#125;</span> <span class=\"hljs-comment\">// 标记无副作用模块</span><br></code></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 未使用的函数会被Tree-shaking剔除</span><br><span class=\"hljs-keyword\">import</span> &#123; usedFunc, unusedFunc &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./utils.js&#x27;</span>;<br><span class=\"hljs-title function_\">usedFunc</span>(); <span class=\"hljs-comment\">// 最终打包仅包含usedFunc</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"（二）引用绑定-vs-值拷贝\"><a href=\"#（二）引用绑定-vs-值拷贝\" class=\"headerlink\" title=\"（二）引用绑定 vs 值拷贝\"></a>（二）引用绑定 vs 值拷贝</h3><p>ES6 Module采用实时引用绑定，导出值更新会同步影响导入方：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 模块A：moduleA.js</span><br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">let</span> count = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">increment</span> = (<span class=\"hljs-params\"></span>) =&gt; count++;<br><br><span class=\"hljs-comment\">// 模块B：moduleB.js</span><br><span class=\"hljs-keyword\">import</span> &#123; count, increment &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./moduleA.js&#x27;</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(count); <span class=\"hljs-comment\">// 0</span><br><span class=\"hljs-title function_\">increment</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(count); <span class=\"hljs-comment\">// 1（实时更新）</span><br></code></pre></td></tr></table></figure>\n\n<p>CommonJS则是值拷贝快照，后续更新不影响已导入值：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 模块A：moduleA.cjs</span><br><span class=\"hljs-keyword\">let</span> count = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-variable language_\">module</span>.<span class=\"hljs-property\">exports</span> = &#123;<br>  count,<br>  <span class=\"hljs-attr\">increment</span>: <span class=\"hljs-function\">() =&gt;</span> count++<br>&#125;;<br><br><span class=\"hljs-comment\">// 模块B：moduleB.cjs</span><br><span class=\"hljs-keyword\">const</span> &#123; count, increment &#125; = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;./moduleA.cjs&#x27;</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(count); <span class=\"hljs-comment\">// 0</span><br><span class=\"hljs-title function_\">increment</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(count); <span class=\"hljs-comment\">// 0（值未更新）</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"（三）内置特性：提升开发规范性\"><a href=\"#（三）内置特性：提升开发规范性\" class=\"headerlink\" title=\"（三）内置特性：提升开发规范性\"></a>（三）内置特性：提升开发规范性</h3><ol>\n<li><strong>默认严格模式</strong>：模块内自动启用<code>&#39;use strict&#39;</code>，禁止未声明变量赋值</li>\n<li><strong>独立模块作用域</strong>：内部变量不会泄漏到全局，解决命名冲突问题</li>\n<li><strong>单例特性</strong>：模块仅执行一次，多次导入复用同一实例<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 计数器模块：counter.js</span><br><span class=\"hljs-keyword\">let</span> count = <span class=\"hljs-number\">0</span>;<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">getCount</span> = (<span class=\"hljs-params\"></span>) =&gt; ++count;<br><br><span class=\"hljs-comment\">// 两次导入共享同一实例</span><br><span class=\"hljs-keyword\">import</span> &#123; getCount &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./counter.js&#x27;</span>;<br><span class=\"hljs-keyword\">import</span> &#123; getCount <span class=\"hljs-keyword\">as</span> getNewCount &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./counter.js&#x27;</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">getCount</span>()); <span class=\"hljs-comment\">// 1</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">getNewCount</span>()); <span class=\"hljs-comment\">// 2</span><br></code></pre></td></tr></table></figure></li>\n</ol>\n<h2 id=\"场景落地：跨环境的模块化实践\"><a href=\"#场景落地：跨环境的模块化实践\" class=\"headerlink\" title=\"场景落地：跨环境的模块化实践\"></a>场景落地：跨环境的模块化实践</h2><p>ES6 Module已实现浏览器与Node.js双端覆盖，配合工具链可适配全场景需求。</p>\n<h3 id=\"（一）浏览器端应用\"><a href=\"#（一）浏览器端应用\" class=\"headerlink\" title=\"（一）浏览器端应用\"></a>（一）浏览器端应用</h3><ol>\n<li><p><strong>原生使用</strong>：通过<code>type=&quot;module&quot;</code>启用</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-comment\">&lt;!-- 内联模块 --&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;module&quot;</span>&gt;</span><span class=\"language-javascript\"></span><br><span class=\"language-javascript\">  <span class=\"hljs-keyword\">import</span> &#123; add &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;./utils.js&#x27;</span>;</span><br><span class=\"language-javascript\">  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-number\">2</span>,<span class=\"hljs-number\">3</span>)); <span class=\"hljs-comment\">// 5</span></span><br><span class=\"language-javascript\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><br><span class=\"hljs-comment\">&lt;!-- 外部模块 --&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;module&quot;</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;./app.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>兼容性处理</strong>：旧浏览器需通过Babel转译+Webpack打包，将ES6 Module转为ES5代码</p>\n</li>\n</ol>\n<h3 id=\"（二）Node-js端应用\"><a href=\"#（二）Node-js端应用\" class=\"headerlink\" title=\"（二）Node.js端应用\"></a>（二）Node.js端应用</h3><ol>\n<li><p><strong>启用方式</strong>：二选一即可</p>\n<ul>\n<li>配置<code>package.json</code>: <code>&quot;type&quot;: &quot;module&quot;</code></li>\n<li>文件后缀改为<code>.mjs</code></li>\n</ul>\n</li>\n<li><p><strong>与CommonJS互操作</strong>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// ES6 Module中导入CommonJS模块</span><br><span class=\"hljs-keyword\">import</span> fs <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;fs&#x27;</span>; <span class=\"hljs-comment\">// 自动识别package.json的main字段</span><br><br><span class=\"hljs-comment\">// 复杂场景使用createRequire</span><br><span class=\"hljs-keyword\">import</span> &#123; createRequire &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;module&#x27;</span>;<br><span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">require</span> = <span class=\"hljs-title function_\">createRequire</span>(<span class=\"hljs-keyword\">import</span>.<span class=\"hljs-property\">meta</span>.<span class=\"hljs-property\">url</span>);<br><span class=\"hljs-keyword\">const</span> cjsModule = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&#x27;./module.cjs&#x27;</span>);<br></code></pre></td></tr></table></figure></li>\n</ol>\n<h3 id=\"（三）高级场景：动态导入与性能优化\"><a href=\"#（三）高级场景：动态导入与性能优化\" class=\"headerlink\" title=\"（三）高级场景：动态导入与性能优化\"></a>（三）高级场景：动态导入与性能优化</h3><p><code>import()</code>函数返回Promise，支持按需加载与条件加载：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 按钮点击时加载模块（首屏性能优化）</span><br><span class=\"hljs-keyword\">const</span> btn = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&#x27;load-btn&#x27;</span>);<br>btn.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;click&#x27;</span>, <span class=\"hljs-title function_\">async</span> () =&gt; &#123;<br>  <span class=\"hljs-keyword\">const</span> &#123; <span class=\"hljs-attr\">default</span>: <span class=\"hljs-title class_\">Chart</span> &#125; = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-keyword\">import</span>(<span class=\"hljs-string\">&#x27;./chart.js&#x27;</span>);<br>  <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Chart</span>(<span class=\"hljs-string\">&#x27;#canvas&#x27;</span>); <span class=\"hljs-comment\">// 动态初始化图表</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n<p>该特性已成为前端路由懒加载的核心技术，如React的<code>React.lazy</code>本质就是对<code>import()</code>的封装。</p>\n<h2 id=\"写在最后：一个老开发的个人看法\"><a href=\"#写在最后：一个老开发的个人看法\" class=\"headerlink\" title=\"写在最后：一个老开发的个人看法\"></a>写在最后：一个老开发的个人看法</h2><p>如今，ES6 Module 已成为现代 JavaScript 开发的基础设施：<code>Webpack</code>、<code>Rollup</code> 等构建工具以其静态特性实现高效打包，<code>React</code>、<code>Vue</code> 等框架借助动态导入优化加载性能，Node.js 与浏览器的原生支持更让 “一次编写、两端运行” 成为现实。</p>\n<p>对于开发者而言，理解 ES6 Module 的本质不仅是掌握语法规则，更是把握 JavaScript 生态演进的核心逻辑 —— <strong>从 “解决当下问题” 到 “构建可持续生态”，这正是模块化标准从混乱走向统一的根本意义</strong>，也为 JavaScript 在大型应用与跨端开发领域的持续突破奠定了坚实基础。</p>\n<p><strong>【往期精彩】</strong></p>\n<ul>\n<li><p><a href=\"https://mp.weixin.qq.com/s/lYqBgS0GJgQMX5PAW_snnQ\">一文说透ES6 Proxy: 从本质到应用场景</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/PtFtlNUH-UcLYU5h-xKiQw\">JavaScript ES6中的生成器(Generator)是什么？有哪些应用场景？一文全说透</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/9pnvL5fTO5U9yT-1mPfeQw\">聊聊ES6里的Promise：简单理解和实际用法</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/lqn_51NNxx50YgvWkxCtEg\">一文搞懂 JavaScript 里 var、let、const 的区别\n</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/UuJeSErftQY7ee1a54Pv4A\">为什么 ES6 要新增 Set 和 Map？看完这篇就懂了</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/PTI3HGsfpDz4-GvRx0i9ew\">JavaScript ES6中Object的拓展，你了解几个？</a></p>\n</li>\n</ul>\n"},{"title":"聊聊ES6里的Promise：简单理解和实际用法","date":"2025-12-06T04:33:46.000Z","_content":"\n在JavaScript里，经常会遇到“异步操作”——就是那些不会马上完成的事情，比如从服务器拿数据、读取文件、设置一个定时器等。\n\n以前处理这些事，全靠“回调函数”，但写多了就容易乱。Promise就是ES6里出来的一个工具，专门帮我们把这些异步操作理清楚。\n\n\n## 为啥需要Promise？\n\n假设我们要做三件事，而且得按顺序来：先烧水，水开了再泡茶叶，茶泡好了再倒出来喝。用以前的回调函数写法，大概是这样：\n\n```javascript\n烧开水(function(水) {\n  泡茶叶(水, function(茶) {\n    倒出来喝(茶, function(结果) {\n      console.log(结果);\n    });\n  });\n});\n```\n\n这看起来还好，但如果步骤再多一点呢？比如烧水前要先洗水壶，泡茶叶前要选茶叶，代码就会一层套一层，像叠罗汉一样，越叠越高。这就是常说的“回调地狱”——看着头晕，改起来也麻烦，哪一步出错了都得一层层找。\n\nPromise的作用，就是把这种“叠罗汉”的写法，变成“排队走”的样子，步骤清楚，出错了也能一起处理。\n\n\n##  Promise到底是个啥？\n\nPromise可以理解成一个“容器”，里面装着一个正在进行的异步操作。这个容器有三种“状态”，而且状态一旦确定，就再也改不了：\n\n- **pending（进行中）**：刚开始的状态，比如水刚放到炉子上，还没开。\n- **fulfilled（成功了）**：异步操作完成了，比如水烧开了，有结果了（水）。\n- **rejected（失败了）**：异步操作出问题了，比如水烧干了，出错了（原因）。\n\n状态只能从“进行中”变成“成功”，或者从“进行中”变成“失败”，变了就定死了。就像水烧开了就不能再变回没开的状态，烧干了也不能再变回去。\n\n\n## 怎么用Promise？简单三步\n\n### 1. 创建Promise\n用`new Promise()`就能创建一个，里面要传一个函数，这个函数有两个参数：`resolve`（成功时调用）和`reject`（失败时调用）。\n\n比如模拟一个“烧水”的异步操作：\n\n```javascript\n// 创建一个“烧水”的Promise\nconst 烧水 = new Promise((resolve, reject) => {\n  setTimeout(() => { // 用定时器模拟烧水需要时间\n    const 水开了 = Math.random() > 0.3; // 70%概率水烧开\n    if (水开了) {\n      resolve('水已经烧开了'); // 成功了，把结果传出去\n    } else {\n      reject(new Error('水没烧开，凉了')); // 失败了，把错误原因传出去\n    }\n  }, 2000); // 假设烧水需要2秒\n});\n```\n\n\n### 2. 处理结果：用then和catch\n创建好之后，用`then`处理成功的情况，用`catch`处理失败的情况：\n\n```javascript\n烧水\n  .then(结果 => { // 水烧开了会走这里\n    console.log(结果); // 输出：水已经烧开了\n  })\n  .catch(错误 => { // 水没烧开会走这里\n    console.log(错误.message); // 输出：水没烧开，凉了\n  });\n```\n\n这样写，成功和失败的处理是分开的，看着清楚。\n\n\n### 3. 链式调用：解决步骤多的问题\n最有用的是，`then`方法会返回一个新的Promise，所以可以“链式”调用，把多个步骤串起来。\n\n比如“烧水→泡茶叶→倒出来喝”这三步，用链式调用写：\n\n```javascript\n烧水\n  .then(水 => {\n    console.log(水);\n    return 泡茶叶(水); // 泡茶叶也是一个Promise，返回它\n  })\n  .then(茶 => {\n    console.log('茶叶泡好了');\n    return 倒出来喝(茶); // 倒出来喝也是一个Promise\n  })\n  .then(结果 => {\n    console.log(结果); // 输出：可以喝了\n  })\n  .catch(错误 => { // 任何一步出错，都会走到这里\n    console.log('出错了：', 错误.message);\n  });\n```\n\n这样一来，步骤是按顺序排的，不像以前那样嵌套，一目了然。\n\n\n## 几个常用的“批量操作”方法\n\n有时候需要同时处理多个异步操作，Promise提供了几个现成的方法：\n\n### Promise.all：等所有操作都完成\n比如同时煮米饭和炒菜，等两个都做好了再开饭：\n\n```javascript\n// 煮米饭和炒菜都是Promise\nconst 煮米饭 = new Promise(...);\nconst 炒菜 = new Promise(...);\n\n// 等两个都完成\nPromise.all([煮米饭, 炒菜])\n  .then(结果 => {\n    const [米饭, 菜] = 结果;\n    console.log('米饭和菜都好了，可以开饭了');\n  })\n  .catch(错误 => {\n    console.log('有一个没做好：', 错误.message); // 只要一个失败，就会走这里\n  });\n```\n\n\n###  Promise.race：比谁快\n比如同时调用两个接口获取数据，谁先返回就用谁的结果：\n\n```javascript\nconst 接口A = 调用接口('A');\nconst 接口B = 调用接口('B');\n\nPromise.race([接口A, 接口B])\n  .then(数据 => {\n    console.log('先返回的数据：', 数据);\n  })\n  .catch(错误 => {\n    console.log('先出错的：', 错误.message);\n  });\n```\n\n这个也常用在“超时控制”上，比如设置一个3秒的定时器，如果接口3秒内没返回，就提示超时。\n\n\n## 实际开发中，Promise都用在哪些地方？\n\n**网络请求**：现在前端调接口（比如用fetch、axios），返回的都是Promise。比如获取用户信息：\n   ```javascript\n   fetch('https://xxx.com/user')\n     .then(响应 => 响应.json()) // 解析数据\n     .then(用户信息 => {\n       console.log('用户信息：', 用户信息);\n     })\n     .catch(错误 => {\n       console.log('请求失败：', 错误);\n     });\n   ```\n\n**有顺序的异步操作**：比如先登录拿到token，再用token获取用户详情，链式调用很方便。\n\n**批量加载资源**：比如页面加载时，同时加载图片、样式、数据，用`Promise.all`等全部加载完再渲染页面。\n\n**处理超时**：比如接口请求怕太久没反应，用`Promise.race`和定时器结合，超过5秒就提示“加载超时”。\n\n\n## 总结一下\n\nPromise其实就是个帮我们管理异步操作的工具。它通过“状态”记录操作结果，用“链式调用”代替嵌套回调，让代码更清楚；还能批量处理多个异步操作，解决了以前写异步代码的很多麻烦。\n\n虽然它也有一些小缺点（比如一旦开始就不能停，没处理错误会默默失败），但现在几乎所有前端项目都会用到它，甚至后来的`async/await`也是基于它实现的。搞懂Promise，写异步代码会轻松很多。\n\n**【往期精彩内容】**\n- [为什么 ES6 要新增 Set 和 Map？看完这篇就懂了](https://mp.weixin.qq.com/s/UuJeSErftQY7ee1a54Pv4A)\n- [JavaScript进化论：ES6如何让函数编写更加简洁、高效？](https://mp.weixin.qq.com/s/haq8TFc_YJlPjeWdyXokQw)\n- [JavaScript ES6 中对象的拓展，你了解几个？](https://mp.weixin.qq.com/s/PTI3HGsfpDz4-GvRx0i9ew)\n- [Javascript高频面试点--ES6 数组新特性](https://mp.weixin.qq.com/s/qR65z8RbPFxW326UnogLqA)\n- [一文搞懂 JavaScript 里 var、let、const 的区别\n](https://mp.weixin.qq.com/s/lqn_51NNxx50YgvWkxCtEg)\n- [程序员如何打破职业瓶颈？先搬开这3块绊脚石。](https://mp.weixin.qq.com/s/DRpZXprnTndjKb1YMqsfjQ)\n","source":"_posts/promise-in-es6.md","raw":"---\ntitle: 聊聊ES6里的Promise：简单理解和实际用法\ndate: 2025-12-06 12:33:46\ntags: JavaScript进阶, ES6进阶\ncategory: ES6进阶\n---\n\n在JavaScript里，经常会遇到“异步操作”——就是那些不会马上完成的事情，比如从服务器拿数据、读取文件、设置一个定时器等。\n\n以前处理这些事，全靠“回调函数”，但写多了就容易乱。Promise就是ES6里出来的一个工具，专门帮我们把这些异步操作理清楚。\n\n\n## 为啥需要Promise？\n\n假设我们要做三件事，而且得按顺序来：先烧水，水开了再泡茶叶，茶泡好了再倒出来喝。用以前的回调函数写法，大概是这样：\n\n```javascript\n烧开水(function(水) {\n  泡茶叶(水, function(茶) {\n    倒出来喝(茶, function(结果) {\n      console.log(结果);\n    });\n  });\n});\n```\n\n这看起来还好，但如果步骤再多一点呢？比如烧水前要先洗水壶，泡茶叶前要选茶叶，代码就会一层套一层，像叠罗汉一样，越叠越高。这就是常说的“回调地狱”——看着头晕，改起来也麻烦，哪一步出错了都得一层层找。\n\nPromise的作用，就是把这种“叠罗汉”的写法，变成“排队走”的样子，步骤清楚，出错了也能一起处理。\n\n\n##  Promise到底是个啥？\n\nPromise可以理解成一个“容器”，里面装着一个正在进行的异步操作。这个容器有三种“状态”，而且状态一旦确定，就再也改不了：\n\n- **pending（进行中）**：刚开始的状态，比如水刚放到炉子上，还没开。\n- **fulfilled（成功了）**：异步操作完成了，比如水烧开了，有结果了（水）。\n- **rejected（失败了）**：异步操作出问题了，比如水烧干了，出错了（原因）。\n\n状态只能从“进行中”变成“成功”，或者从“进行中”变成“失败”，变了就定死了。就像水烧开了就不能再变回没开的状态，烧干了也不能再变回去。\n\n\n## 怎么用Promise？简单三步\n\n### 1. 创建Promise\n用`new Promise()`就能创建一个，里面要传一个函数，这个函数有两个参数：`resolve`（成功时调用）和`reject`（失败时调用）。\n\n比如模拟一个“烧水”的异步操作：\n\n```javascript\n// 创建一个“烧水”的Promise\nconst 烧水 = new Promise((resolve, reject) => {\n  setTimeout(() => { // 用定时器模拟烧水需要时间\n    const 水开了 = Math.random() > 0.3; // 70%概率水烧开\n    if (水开了) {\n      resolve('水已经烧开了'); // 成功了，把结果传出去\n    } else {\n      reject(new Error('水没烧开，凉了')); // 失败了，把错误原因传出去\n    }\n  }, 2000); // 假设烧水需要2秒\n});\n```\n\n\n### 2. 处理结果：用then和catch\n创建好之后，用`then`处理成功的情况，用`catch`处理失败的情况：\n\n```javascript\n烧水\n  .then(结果 => { // 水烧开了会走这里\n    console.log(结果); // 输出：水已经烧开了\n  })\n  .catch(错误 => { // 水没烧开会走这里\n    console.log(错误.message); // 输出：水没烧开，凉了\n  });\n```\n\n这样写，成功和失败的处理是分开的，看着清楚。\n\n\n### 3. 链式调用：解决步骤多的问题\n最有用的是，`then`方法会返回一个新的Promise，所以可以“链式”调用，把多个步骤串起来。\n\n比如“烧水→泡茶叶→倒出来喝”这三步，用链式调用写：\n\n```javascript\n烧水\n  .then(水 => {\n    console.log(水);\n    return 泡茶叶(水); // 泡茶叶也是一个Promise，返回它\n  })\n  .then(茶 => {\n    console.log('茶叶泡好了');\n    return 倒出来喝(茶); // 倒出来喝也是一个Promise\n  })\n  .then(结果 => {\n    console.log(结果); // 输出：可以喝了\n  })\n  .catch(错误 => { // 任何一步出错，都会走到这里\n    console.log('出错了：', 错误.message);\n  });\n```\n\n这样一来，步骤是按顺序排的，不像以前那样嵌套，一目了然。\n\n\n## 几个常用的“批量操作”方法\n\n有时候需要同时处理多个异步操作，Promise提供了几个现成的方法：\n\n### Promise.all：等所有操作都完成\n比如同时煮米饭和炒菜，等两个都做好了再开饭：\n\n```javascript\n// 煮米饭和炒菜都是Promise\nconst 煮米饭 = new Promise(...);\nconst 炒菜 = new Promise(...);\n\n// 等两个都完成\nPromise.all([煮米饭, 炒菜])\n  .then(结果 => {\n    const [米饭, 菜] = 结果;\n    console.log('米饭和菜都好了，可以开饭了');\n  })\n  .catch(错误 => {\n    console.log('有一个没做好：', 错误.message); // 只要一个失败，就会走这里\n  });\n```\n\n\n###  Promise.race：比谁快\n比如同时调用两个接口获取数据，谁先返回就用谁的结果：\n\n```javascript\nconst 接口A = 调用接口('A');\nconst 接口B = 调用接口('B');\n\nPromise.race([接口A, 接口B])\n  .then(数据 => {\n    console.log('先返回的数据：', 数据);\n  })\n  .catch(错误 => {\n    console.log('先出错的：', 错误.message);\n  });\n```\n\n这个也常用在“超时控制”上，比如设置一个3秒的定时器，如果接口3秒内没返回，就提示超时。\n\n\n## 实际开发中，Promise都用在哪些地方？\n\n**网络请求**：现在前端调接口（比如用fetch、axios），返回的都是Promise。比如获取用户信息：\n   ```javascript\n   fetch('https://xxx.com/user')\n     .then(响应 => 响应.json()) // 解析数据\n     .then(用户信息 => {\n       console.log('用户信息：', 用户信息);\n     })\n     .catch(错误 => {\n       console.log('请求失败：', 错误);\n     });\n   ```\n\n**有顺序的异步操作**：比如先登录拿到token，再用token获取用户详情，链式调用很方便。\n\n**批量加载资源**：比如页面加载时，同时加载图片、样式、数据，用`Promise.all`等全部加载完再渲染页面。\n\n**处理超时**：比如接口请求怕太久没反应，用`Promise.race`和定时器结合，超过5秒就提示“加载超时”。\n\n\n## 总结一下\n\nPromise其实就是个帮我们管理异步操作的工具。它通过“状态”记录操作结果，用“链式调用”代替嵌套回调，让代码更清楚；还能批量处理多个异步操作，解决了以前写异步代码的很多麻烦。\n\n虽然它也有一些小缺点（比如一旦开始就不能停，没处理错误会默默失败），但现在几乎所有前端项目都会用到它，甚至后来的`async/await`也是基于它实现的。搞懂Promise，写异步代码会轻松很多。\n\n**【往期精彩内容】**\n- [为什么 ES6 要新增 Set 和 Map？看完这篇就懂了](https://mp.weixin.qq.com/s/UuJeSErftQY7ee1a54Pv4A)\n- [JavaScript进化论：ES6如何让函数编写更加简洁、高效？](https://mp.weixin.qq.com/s/haq8TFc_YJlPjeWdyXokQw)\n- [JavaScript ES6 中对象的拓展，你了解几个？](https://mp.weixin.qq.com/s/PTI3HGsfpDz4-GvRx0i9ew)\n- [Javascript高频面试点--ES6 数组新特性](https://mp.weixin.qq.com/s/qR65z8RbPFxW326UnogLqA)\n- [一文搞懂 JavaScript 里 var、let、const 的区别\n](https://mp.weixin.qq.com/s/lqn_51NNxx50YgvWkxCtEg)\n- [程序员如何打破职业瓶颈？先搬开这3块绊脚石。](https://mp.weixin.qq.com/s/DRpZXprnTndjKb1YMqsfjQ)\n","slug":"promise-in-es6","published":1,"updated":"2025-12-06T04:47:41.768Z","comments":1,"layout":"post","photos":[],"_id":"cmjbml2iu0045ikup5j3qdq69","content":"<p>在JavaScript里，经常会遇到“异步操作”——就是那些不会马上完成的事情，比如从服务器拿数据、读取文件、设置一个定时器等。</p>\n<p>以前处理这些事，全靠“回调函数”，但写多了就容易乱。Promise就是ES6里出来的一个工具，专门帮我们把这些异步操作理清楚。</p>\n<h2 id=\"为啥需要Promise？\"><a href=\"#为啥需要Promise？\" class=\"headerlink\" title=\"为啥需要Promise？\"></a>为啥需要Promise？</h2><p>假设我们要做三件事，而且得按顺序来：先烧水，水开了再泡茶叶，茶泡好了再倒出来喝。用以前的回调函数写法，大概是这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">烧开水(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">水</span>) &#123;<br>  泡茶叶(水, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">茶</span>) &#123;<br>    倒出来喝(茶, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">结果</span>) &#123;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(结果);<br>    &#125;);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>这看起来还好，但如果步骤再多一点呢？比如烧水前要先洗水壶，泡茶叶前要选茶叶，代码就会一层套一层，像叠罗汉一样，越叠越高。这就是常说的“回调地狱”——看着头晕，改起来也麻烦，哪一步出错了都得一层层找。</p>\n<p>Promise的作用，就是把这种“叠罗汉”的写法，变成“排队走”的样子，步骤清楚，出错了也能一起处理。</p>\n<h2 id=\"Promise到底是个啥？\"><a href=\"#Promise到底是个啥？\" class=\"headerlink\" title=\"Promise到底是个啥？\"></a>Promise到底是个啥？</h2><p>Promise可以理解成一个“容器”，里面装着一个正在进行的异步操作。这个容器有三种“状态”，而且状态一旦确定，就再也改不了：</p>\n<ul>\n<li><strong>pending（进行中）</strong>：刚开始的状态，比如水刚放到炉子上，还没开。</li>\n<li><strong>fulfilled（成功了）</strong>：异步操作完成了，比如水烧开了，有结果了（水）。</li>\n<li><strong>rejected（失败了）</strong>：异步操作出问题了，比如水烧干了，出错了（原因）。</li>\n</ul>\n<p>状态只能从“进行中”变成“成功”，或者从“进行中”变成“失败”，变了就定死了。就像水烧开了就不能再变回没开的状态，烧干了也不能再变回去。</p>\n<h2 id=\"怎么用Promise？简单三步\"><a href=\"#怎么用Promise？简单三步\" class=\"headerlink\" title=\"怎么用Promise？简单三步\"></a>怎么用Promise？简单三步</h2><h3 id=\"1-创建Promise\"><a href=\"#1-创建Promise\" class=\"headerlink\" title=\"1. 创建Promise\"></a>1. 创建Promise</h3><p>用<code>new Promise()</code>就能创建一个，里面要传一个函数，这个函数有两个参数：<code>resolve</code>（成功时调用）和<code>reject</code>（失败时调用）。</p>\n<p>比如模拟一个“烧水”的异步操作：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 创建一个“烧水”的Promise</span><br><span class=\"hljs-keyword\">const</span> 烧水 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123; <span class=\"hljs-comment\">// 用定时器模拟烧水需要时间</span><br>    <span class=\"hljs-keyword\">const</span> 水开了 = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">random</span>() &gt; <span class=\"hljs-number\">0.3</span>; <span class=\"hljs-comment\">// 70%概率水烧开</span><br>    <span class=\"hljs-keyword\">if</span> (水开了) &#123;<br>      <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">&#x27;水已经烧开了&#x27;</span>); <span class=\"hljs-comment\">// 成功了，把结果传出去</span><br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      <span class=\"hljs-title function_\">reject</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;水没烧开，凉了&#x27;</span>)); <span class=\"hljs-comment\">// 失败了，把错误原因传出去</span><br>    &#125;<br>  &#125;, <span class=\"hljs-number\">2000</span>); <span class=\"hljs-comment\">// 假设烧水需要2秒</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"2-处理结果：用then和catch\"><a href=\"#2-处理结果：用then和catch\" class=\"headerlink\" title=\"2. 处理结果：用then和catch\"></a>2. 处理结果：用then和catch</h3><p>创建好之后，用<code>then</code>处理成功的情况，用<code>catch</code>处理失败的情况：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">烧水<br>  .<span class=\"hljs-title function_\">then</span>(结果 =&gt; &#123; <span class=\"hljs-comment\">// 水烧开了会走这里</span><br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(结果); <span class=\"hljs-comment\">// 输出：水已经烧开了</span><br>  &#125;)<br>  .<span class=\"hljs-title function_\">catch</span>(错误 =&gt; &#123; <span class=\"hljs-comment\">// 水没烧开会走这里</span><br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(错误.<span class=\"hljs-property\">message</span>); <span class=\"hljs-comment\">// 输出：水没烧开，凉了</span><br>  &#125;);<br></code></pre></td></tr></table></figure>\n\n<p>这样写，成功和失败的处理是分开的，看着清楚。</p>\n<h3 id=\"3-链式调用：解决步骤多的问题\"><a href=\"#3-链式调用：解决步骤多的问题\" class=\"headerlink\" title=\"3. 链式调用：解决步骤多的问题\"></a>3. 链式调用：解决步骤多的问题</h3><p>最有用的是，<code>then</code>方法会返回一个新的Promise，所以可以“链式”调用，把多个步骤串起来。</p>\n<p>比如“烧水→泡茶叶→倒出来喝”这三步，用链式调用写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">烧水<br>  .<span class=\"hljs-title function_\">then</span>(水 =&gt; &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(水);<br>    <span class=\"hljs-keyword\">return</span> 泡茶叶(水); <span class=\"hljs-comment\">// 泡茶叶也是一个Promise，返回它</span><br>  &#125;)<br>  .<span class=\"hljs-title function_\">then</span>(茶 =&gt; &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;茶叶泡好了&#x27;</span>);<br>    <span class=\"hljs-keyword\">return</span> 倒出来喝(茶); <span class=\"hljs-comment\">// 倒出来喝也是一个Promise</span><br>  &#125;)<br>  .<span class=\"hljs-title function_\">then</span>(结果 =&gt; &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(结果); <span class=\"hljs-comment\">// 输出：可以喝了</span><br>  &#125;)<br>  .<span class=\"hljs-title function_\">catch</span>(错误 =&gt; &#123; <span class=\"hljs-comment\">// 任何一步出错，都会走到这里</span><br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;出错了：&#x27;</span>, 错误.<span class=\"hljs-property\">message</span>);<br>  &#125;);<br></code></pre></td></tr></table></figure>\n\n<p>这样一来，步骤是按顺序排的，不像以前那样嵌套，一目了然。</p>\n<h2 id=\"几个常用的“批量操作”方法\"><a href=\"#几个常用的“批量操作”方法\" class=\"headerlink\" title=\"几个常用的“批量操作”方法\"></a>几个常用的“批量操作”方法</h2><p>有时候需要同时处理多个异步操作，Promise提供了几个现成的方法：</p>\n<h3 id=\"Promise-all：等所有操作都完成\"><a href=\"#Promise-all：等所有操作都完成\" class=\"headerlink\" title=\"Promise.all：等所有操作都完成\"></a>Promise.all：等所有操作都完成</h3><p>比如同时煮米饭和炒菜，等两个都做好了再开饭：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 煮米饭和炒菜都是Promise</span><br><span class=\"hljs-keyword\">const</span> 煮米饭 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(...);<br><span class=\"hljs-keyword\">const</span> 炒菜 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(...);<br><br><span class=\"hljs-comment\">// 等两个都完成</span><br><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">all</span>([煮米饭, 炒菜])<br>  .<span class=\"hljs-title function_\">then</span>(结果 =&gt; &#123;<br>    <span class=\"hljs-keyword\">const</span> [米饭, 菜] = 结果;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;米饭和菜都好了，可以开饭了&#x27;</span>);<br>  &#125;)<br>  .<span class=\"hljs-title function_\">catch</span>(错误 =&gt; &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;有一个没做好：&#x27;</span>, 错误.<span class=\"hljs-property\">message</span>); <span class=\"hljs-comment\">// 只要一个失败，就会走这里</span><br>  &#125;);<br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"Promise-race：比谁快\"><a href=\"#Promise-race：比谁快\" class=\"headerlink\" title=\"Promise.race：比谁快\"></a>Promise.race：比谁快</h3><p>比如同时调用两个接口获取数据，谁先返回就用谁的结果：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> 接口A = 调用接口(<span class=\"hljs-string\">&#x27;A&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> 接口B = 调用接口(<span class=\"hljs-string\">&#x27;B&#x27;</span>);<br><br><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">race</span>([接口A, 接口B])<br>  .<span class=\"hljs-title function_\">then</span>(数据 =&gt; &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;先返回的数据：&#x27;</span>, 数据);<br>  &#125;)<br>  .<span class=\"hljs-title function_\">catch</span>(错误 =&gt; &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;先出错的：&#x27;</span>, 错误.<span class=\"hljs-property\">message</span>);<br>  &#125;);<br></code></pre></td></tr></table></figure>\n\n<p>这个也常用在“超时控制”上，比如设置一个3秒的定时器，如果接口3秒内没返回，就提示超时。</p>\n<h2 id=\"实际开发中，Promise都用在哪些地方？\"><a href=\"#实际开发中，Promise都用在哪些地方？\" class=\"headerlink\" title=\"实际开发中，Promise都用在哪些地方？\"></a>实际开发中，Promise都用在哪些地方？</h2><p><strong>网络请求</strong>：现在前端调接口（比如用fetch、axios），返回的都是Promise。比如获取用户信息：<br>   <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&#x27;https://xxx.com/user&#x27;</span>)<br>  .<span class=\"hljs-title function_\">then</span>(响应 =&gt; 响应.<span class=\"hljs-title function_\">json</span>()) <span class=\"hljs-comment\">// 解析数据</span><br>  .<span class=\"hljs-title function_\">then</span>(用户信息 =&gt; &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;用户信息：&#x27;</span>, 用户信息);<br>  &#125;)<br>  .<span class=\"hljs-title function_\">catch</span>(错误 =&gt; &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;请求失败：&#x27;</span>, 错误);<br>  &#125;);<br></code></pre></td></tr></table></figure></p>\n<p><strong>有顺序的异步操作</strong>：比如先登录拿到token，再用token获取用户详情，链式调用很方便。</p>\n<p><strong>批量加载资源</strong>：比如页面加载时，同时加载图片、样式、数据，用<code>Promise.all</code>等全部加载完再渲染页面。</p>\n<p><strong>处理超时</strong>：比如接口请求怕太久没反应，用<code>Promise.race</code>和定时器结合，超过5秒就提示“加载超时”。</p>\n<h2 id=\"总结一下\"><a href=\"#总结一下\" class=\"headerlink\" title=\"总结一下\"></a>总结一下</h2><p>Promise其实就是个帮我们管理异步操作的工具。它通过“状态”记录操作结果，用“链式调用”代替嵌套回调，让代码更清楚；还能批量处理多个异步操作，解决了以前写异步代码的很多麻烦。</p>\n<p>虽然它也有一些小缺点（比如一旦开始就不能停，没处理错误会默默失败），但现在几乎所有前端项目都会用到它，甚至后来的<code>async/await</code>也是基于它实现的。搞懂Promise，写异步代码会轻松很多。</p>\n<p><strong>【往期精彩内容】</strong></p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/UuJeSErftQY7ee1a54Pv4A\">为什么 ES6 要新增 Set 和 Map？看完这篇就懂了</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/haq8TFc_YJlPjeWdyXokQw\">JavaScript进化论：ES6如何让函数编写更加简洁、高效？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/PTI3HGsfpDz4-GvRx0i9ew\">JavaScript ES6 中对象的拓展，你了解几个？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/qR65z8RbPFxW326UnogLqA\">Javascript高频面试点–ES6 数组新特性</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/lqn_51NNxx50YgvWkxCtEg\">一文搞懂 JavaScript 里 var、let、const 的区别\n</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/DRpZXprnTndjKb1YMqsfjQ\">程序员如何打破职业瓶颈？先搬开这3块绊脚石。</a></li>\n</ul>\n","excerpt":"","more":"<p>在JavaScript里，经常会遇到“异步操作”——就是那些不会马上完成的事情，比如从服务器拿数据、读取文件、设置一个定时器等。</p>\n<p>以前处理这些事，全靠“回调函数”，但写多了就容易乱。Promise就是ES6里出来的一个工具，专门帮我们把这些异步操作理清楚。</p>\n<h2 id=\"为啥需要Promise？\"><a href=\"#为啥需要Promise？\" class=\"headerlink\" title=\"为啥需要Promise？\"></a>为啥需要Promise？</h2><p>假设我们要做三件事，而且得按顺序来：先烧水，水开了再泡茶叶，茶泡好了再倒出来喝。用以前的回调函数写法，大概是这样：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">烧开水(<span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">水</span>) &#123;<br>  泡茶叶(水, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">茶</span>) &#123;<br>    倒出来喝(茶, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">结果</span>) &#123;<br>      <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(结果);<br>    &#125;);<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<p>这看起来还好，但如果步骤再多一点呢？比如烧水前要先洗水壶，泡茶叶前要选茶叶，代码就会一层套一层，像叠罗汉一样，越叠越高。这就是常说的“回调地狱”——看着头晕，改起来也麻烦，哪一步出错了都得一层层找。</p>\n<p>Promise的作用，就是把这种“叠罗汉”的写法，变成“排队走”的样子，步骤清楚，出错了也能一起处理。</p>\n<h2 id=\"Promise到底是个啥？\"><a href=\"#Promise到底是个啥？\" class=\"headerlink\" title=\"Promise到底是个啥？\"></a>Promise到底是个啥？</h2><p>Promise可以理解成一个“容器”，里面装着一个正在进行的异步操作。这个容器有三种“状态”，而且状态一旦确定，就再也改不了：</p>\n<ul>\n<li><strong>pending（进行中）</strong>：刚开始的状态，比如水刚放到炉子上，还没开。</li>\n<li><strong>fulfilled（成功了）</strong>：异步操作完成了，比如水烧开了，有结果了（水）。</li>\n<li><strong>rejected（失败了）</strong>：异步操作出问题了，比如水烧干了，出错了（原因）。</li>\n</ul>\n<p>状态只能从“进行中”变成“成功”，或者从“进行中”变成“失败”，变了就定死了。就像水烧开了就不能再变回没开的状态，烧干了也不能再变回去。</p>\n<h2 id=\"怎么用Promise？简单三步\"><a href=\"#怎么用Promise？简单三步\" class=\"headerlink\" title=\"怎么用Promise？简单三步\"></a>怎么用Promise？简单三步</h2><h3 id=\"1-创建Promise\"><a href=\"#1-创建Promise\" class=\"headerlink\" title=\"1. 创建Promise\"></a>1. 创建Promise</h3><p>用<code>new Promise()</code>就能创建一个，里面要传一个函数，这个函数有两个参数：<code>resolve</code>（成功时调用）和<code>reject</code>（失败时调用）。</p>\n<p>比如模拟一个“烧水”的异步操作：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 创建一个“烧水”的Promise</span><br><span class=\"hljs-keyword\">const</span> 烧水 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">setTimeout</span>(<span class=\"hljs-function\">() =&gt;</span> &#123; <span class=\"hljs-comment\">// 用定时器模拟烧水需要时间</span><br>    <span class=\"hljs-keyword\">const</span> 水开了 = <span class=\"hljs-title class_\">Math</span>.<span class=\"hljs-title function_\">random</span>() &gt; <span class=\"hljs-number\">0.3</span>; <span class=\"hljs-comment\">// 70%概率水烧开</span><br>    <span class=\"hljs-keyword\">if</span> (水开了) &#123;<br>      <span class=\"hljs-title function_\">resolve</span>(<span class=\"hljs-string\">&#x27;水已经烧开了&#x27;</span>); <span class=\"hljs-comment\">// 成功了，把结果传出去</span><br>    &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>      <span class=\"hljs-title function_\">reject</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Error</span>(<span class=\"hljs-string\">&#x27;水没烧开，凉了&#x27;</span>)); <span class=\"hljs-comment\">// 失败了，把错误原因传出去</span><br>    &#125;<br>  &#125;, <span class=\"hljs-number\">2000</span>); <span class=\"hljs-comment\">// 假设烧水需要2秒</span><br>&#125;);<br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"2-处理结果：用then和catch\"><a href=\"#2-处理结果：用then和catch\" class=\"headerlink\" title=\"2. 处理结果：用then和catch\"></a>2. 处理结果：用then和catch</h3><p>创建好之后，用<code>then</code>处理成功的情况，用<code>catch</code>处理失败的情况：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">烧水<br>  .<span class=\"hljs-title function_\">then</span>(结果 =&gt; &#123; <span class=\"hljs-comment\">// 水烧开了会走这里</span><br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(结果); <span class=\"hljs-comment\">// 输出：水已经烧开了</span><br>  &#125;)<br>  .<span class=\"hljs-title function_\">catch</span>(错误 =&gt; &#123; <span class=\"hljs-comment\">// 水没烧开会走这里</span><br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(错误.<span class=\"hljs-property\">message</span>); <span class=\"hljs-comment\">// 输出：水没烧开，凉了</span><br>  &#125;);<br></code></pre></td></tr></table></figure>\n\n<p>这样写，成功和失败的处理是分开的，看着清楚。</p>\n<h3 id=\"3-链式调用：解决步骤多的问题\"><a href=\"#3-链式调用：解决步骤多的问题\" class=\"headerlink\" title=\"3. 链式调用：解决步骤多的问题\"></a>3. 链式调用：解决步骤多的问题</h3><p>最有用的是，<code>then</code>方法会返回一个新的Promise，所以可以“链式”调用，把多个步骤串起来。</p>\n<p>比如“烧水→泡茶叶→倒出来喝”这三步，用链式调用写：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">烧水<br>  .<span class=\"hljs-title function_\">then</span>(水 =&gt; &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(水);<br>    <span class=\"hljs-keyword\">return</span> 泡茶叶(水); <span class=\"hljs-comment\">// 泡茶叶也是一个Promise，返回它</span><br>  &#125;)<br>  .<span class=\"hljs-title function_\">then</span>(茶 =&gt; &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;茶叶泡好了&#x27;</span>);<br>    <span class=\"hljs-keyword\">return</span> 倒出来喝(茶); <span class=\"hljs-comment\">// 倒出来喝也是一个Promise</span><br>  &#125;)<br>  .<span class=\"hljs-title function_\">then</span>(结果 =&gt; &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(结果); <span class=\"hljs-comment\">// 输出：可以喝了</span><br>  &#125;)<br>  .<span class=\"hljs-title function_\">catch</span>(错误 =&gt; &#123; <span class=\"hljs-comment\">// 任何一步出错，都会走到这里</span><br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;出错了：&#x27;</span>, 错误.<span class=\"hljs-property\">message</span>);<br>  &#125;);<br></code></pre></td></tr></table></figure>\n\n<p>这样一来，步骤是按顺序排的，不像以前那样嵌套，一目了然。</p>\n<h2 id=\"几个常用的“批量操作”方法\"><a href=\"#几个常用的“批量操作”方法\" class=\"headerlink\" title=\"几个常用的“批量操作”方法\"></a>几个常用的“批量操作”方法</h2><p>有时候需要同时处理多个异步操作，Promise提供了几个现成的方法：</p>\n<h3 id=\"Promise-all：等所有操作都完成\"><a href=\"#Promise-all：等所有操作都完成\" class=\"headerlink\" title=\"Promise.all：等所有操作都完成\"></a>Promise.all：等所有操作都完成</h3><p>比如同时煮米饭和炒菜，等两个都做好了再开饭：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 煮米饭和炒菜都是Promise</span><br><span class=\"hljs-keyword\">const</span> 煮米饭 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(...);<br><span class=\"hljs-keyword\">const</span> 炒菜 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Promise</span>(...);<br><br><span class=\"hljs-comment\">// 等两个都完成</span><br><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">all</span>([煮米饭, 炒菜])<br>  .<span class=\"hljs-title function_\">then</span>(结果 =&gt; &#123;<br>    <span class=\"hljs-keyword\">const</span> [米饭, 菜] = 结果;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;米饭和菜都好了，可以开饭了&#x27;</span>);<br>  &#125;)<br>  .<span class=\"hljs-title function_\">catch</span>(错误 =&gt; &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;有一个没做好：&#x27;</span>, 错误.<span class=\"hljs-property\">message</span>); <span class=\"hljs-comment\">// 只要一个失败，就会走这里</span><br>  &#125;);<br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"Promise-race：比谁快\"><a href=\"#Promise-race：比谁快\" class=\"headerlink\" title=\"Promise.race：比谁快\"></a>Promise.race：比谁快</h3><p>比如同时调用两个接口获取数据，谁先返回就用谁的结果：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> 接口A = 调用接口(<span class=\"hljs-string\">&#x27;A&#x27;</span>);<br><span class=\"hljs-keyword\">const</span> 接口B = 调用接口(<span class=\"hljs-string\">&#x27;B&#x27;</span>);<br><br><span class=\"hljs-title class_\">Promise</span>.<span class=\"hljs-title function_\">race</span>([接口A, 接口B])<br>  .<span class=\"hljs-title function_\">then</span>(数据 =&gt; &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;先返回的数据：&#x27;</span>, 数据);<br>  &#125;)<br>  .<span class=\"hljs-title function_\">catch</span>(错误 =&gt; &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;先出错的：&#x27;</span>, 错误.<span class=\"hljs-property\">message</span>);<br>  &#125;);<br></code></pre></td></tr></table></figure>\n\n<p>这个也常用在“超时控制”上，比如设置一个3秒的定时器，如果接口3秒内没返回，就提示超时。</p>\n<h2 id=\"实际开发中，Promise都用在哪些地方？\"><a href=\"#实际开发中，Promise都用在哪些地方？\" class=\"headerlink\" title=\"实际开发中，Promise都用在哪些地方？\"></a>实际开发中，Promise都用在哪些地方？</h2><p><strong>网络请求</strong>：现在前端调接口（比如用fetch、axios），返回的都是Promise。比如获取用户信息：<br>   <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&#x27;https://xxx.com/user&#x27;</span>)<br>  .<span class=\"hljs-title function_\">then</span>(响应 =&gt; 响应.<span class=\"hljs-title function_\">json</span>()) <span class=\"hljs-comment\">// 解析数据</span><br>  .<span class=\"hljs-title function_\">then</span>(用户信息 =&gt; &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;用户信息：&#x27;</span>, 用户信息);<br>  &#125;)<br>  .<span class=\"hljs-title function_\">catch</span>(错误 =&gt; &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&#x27;请求失败：&#x27;</span>, 错误);<br>  &#125;);<br></code></pre></td></tr></table></figure></p>\n<p><strong>有顺序的异步操作</strong>：比如先登录拿到token，再用token获取用户详情，链式调用很方便。</p>\n<p><strong>批量加载资源</strong>：比如页面加载时，同时加载图片、样式、数据，用<code>Promise.all</code>等全部加载完再渲染页面。</p>\n<p><strong>处理超时</strong>：比如接口请求怕太久没反应，用<code>Promise.race</code>和定时器结合，超过5秒就提示“加载超时”。</p>\n<h2 id=\"总结一下\"><a href=\"#总结一下\" class=\"headerlink\" title=\"总结一下\"></a>总结一下</h2><p>Promise其实就是个帮我们管理异步操作的工具。它通过“状态”记录操作结果，用“链式调用”代替嵌套回调，让代码更清楚；还能批量处理多个异步操作，解决了以前写异步代码的很多麻烦。</p>\n<p>虽然它也有一些小缺点（比如一旦开始就不能停，没处理错误会默默失败），但现在几乎所有前端项目都会用到它，甚至后来的<code>async/await</code>也是基于它实现的。搞懂Promise，写异步代码会轻松很多。</p>\n<p><strong>【往期精彩内容】</strong></p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/UuJeSErftQY7ee1a54Pv4A\">为什么 ES6 要新增 Set 和 Map？看完这篇就懂了</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/haq8TFc_YJlPjeWdyXokQw\">JavaScript进化论：ES6如何让函数编写更加简洁、高效？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/PTI3HGsfpDz4-GvRx0i9ew\">JavaScript ES6 中对象的拓展，你了解几个？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/qR65z8RbPFxW326UnogLqA\">Javascript高频面试点–ES6 数组新特性</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/lqn_51NNxx50YgvWkxCtEg\">一文搞懂 JavaScript 里 var、let、const 的区别\n</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/DRpZXprnTndjKb1YMqsfjQ\">程序员如何打破职业瓶颈？先搬开这3块绊脚石。</a></li>\n</ul>\n"},{"title":"JavaScript ES6 中对象的拓展，你了解几个？","date":"2025-12-06T04:31:10.000Z","_content":"\n\n## 引言\nES6（ECMAScript 2015）作为 JavaScript 语言发展的里程碑版本，对原生`Object`进行了全方位的升级优化。这些扩展不仅简化了对象的创建与操作语法，还补充了此前缺失的核心功能（如原型操作、属性遍历、深度复制支持等），彻底改变了 JavaScript 开发者的编码习惯。本文将系统拆解 ES6 对象的六大核心扩展特性，结合实战代码示例，让每个特性的应用场景一目了然。\n\n\n## 一、对象字面量的语法简化\nES6 大幅简化了对象字面量的声明语法，减少冗余代码，提升可读性。\n\n### 1.1 属性简写\n当对象属性名与变量名一致时，可省略冒号（`:`）和属性值，直接简写为属性名：\n```javascript\n// ES5写法\nconst name = \"张三\";\nconst age = 28;\nconst user = {\n  name: name,\n  age: age\n};\n\n// ES6简写\nconst user = { name, age }; // 等价于ES5写法\n```\n\n### 1.2 方法简写\n对象方法声明可省略`function`关键字和冒号，直接使用`方法名()`语法：\n```javascript\n// ES5写法\nconst obj = {\n  sayHi: function() {\n    console.log(\"Hello\");\n  }\n};\n\n// ES6简写\nconst obj = {\n  sayHi() {\n    console.log(\"Hello\"); // 无需function关键字\n  },\n  async fetchData() { // 支持async/await语法\n    const res = await fetch(\"/api\");\n  }\n};\n```\n\n### 1.3 计算属性名\n通过方括号（`[]`）包裹表达式，动态生成对象属性名，解决了 ES5 中无法直接声明动态属性的问题：\n```javascript\n// ES5动态属性名（需额外赋值）\nconst key = \"gender\";\nconst obj = {};\nobj[key] = \"male\"; // 只能在声明后添加\n\n// ES6计算属性名（声明时直接定义）\nconst obj = {\n  [key]: \"male\",\n  [`user_${10}`]: \"admin\" // 支持表达式拼接\n};\n```\n\n\n## 二、对象属性的遍历机制\nES6 新增了 3 个遍历对象属性的方法，配合`for...of`循环，实现更灵活的属性遍历。\n\n### 2.1 Object.keys ()：获取属性名数组\n返回对象**自身可枚举属性**的名称数组（不含原型链属性）：\n```javascript\nconst obj = { a: 1, b: 2, c: 3 };\nconsole.log(Object.keys(obj)); // [\"a\", \"b\", \"c\"]\n```\n\n### 2.2 Object.values ()：获取属性值数组\n返回对象**自身可枚举属性**的对应值数组：\n```javascript\nconsole.log(Object.values(obj)); // [1, 2, 3]\n```\n\n### 2.3 Object.entries ()：获取键值对数组\n返回对象**自身可枚举属性**的`[key, value]`二维数组，完美适配`for...of`循环：\n```javascript\nfor (const [key, value] of Object.entries(obj)) {\n  console.log(`${key}: ${value}`); // 输出 \"a: 1\" \"b: 2\" \"c: 3\"\n}\n\n// 快速转换为Map\nconst map = new Map(Object.entries(obj));\n```\n\n> 注意：以上三个方法均遵循 “自身可枚举” 规则，即忽略`enumerable: false`的属性和原型链上的属性。\n\n\n## 三、对象的合并与复制：Object.assign ()\nES6 新增`Object.assign()`方法，用于将多个**源对象**的属性复制到**目标对象**，实现对象合并或浅拷贝。\n\n### 3.1 基本用法\n```javascript\nconst target = { a: 1 };\nconst source1 = { b: 2 };\nconst source2 = { a: 3, c: 4 };\n\n// 合并：source1、source2的属性依次复制到target\nObject.assign(target, source1, source2);\nconsole.log(target); // { a: 3, b: 2, c: 4 }（同名属性被后续源对象覆盖）\n```\n\n### 3.2 核心特性\n1. **浅拷贝**：仅复制属性值，若属性值为引用类型（如对象、数组），则复制引用地址：\n```javascript\nconst source = { info: { age: 20 } };\nconst target = Object.assign({}, source);\ntarget.info.age = 30;\nconsole.log(source.info.age); // 30（源对象被修改，因为复制的是引用）\n```\n\n2. **仅复制可枚举属性**：忽略`enumerable: false`的属性：\n```javascript\nconst source = Object.defineProperty({}, \"hidden\", {\n  value: 10,\n  enumerable: false // 不可枚举属性\n});\nconst target = Object.assign({}, source);\nconsole.log(target.hidden); // undefined（未复制）\n```\n\n3. **支持多源对象**：可传入多个源对象，属性按顺序覆盖（后传入的源对象优先级更高）。\n\n\n## 四、原型操作的规范化\nES6 提供了直接操作对象原型的 API，替代了 ES5 中不规范的`__proto__`属性。\n\n### 4.1 Object.setPrototypeOf ()：设置原型\n用于指定对象的原型（即`[[Prototype]]`内部属性）：\n```javascript\nconst parent = { greet() { console.log(\"Hello\"); } };\nconst child = {};\n\n// 设置child的原型为parent\nObject.setPrototypeOf(child, parent);\nchild.greet(); // \"Hello\"（继承自parent）\n```\n\n### 4.2 Object.getPrototypeOf ()：获取原型\n返回对象的原型对象，替代`obj.__proto__`：\n```javascript\nconsole.log(Object.getPrototypeOf(child) === parent); // true\n```\n\n### 4.3 super 关键字：访问原型属性\n在对象方法中，`super`指向当前对象的原型，可直接调用原型的属性或方法：\n```javascript\nconst parent = { name: \"父对象\" };\nconst child = {\n  getParentName() {\n    return super.name; // 等价于 Object.getPrototypeOf(this).name\n  }\n};\nObject.setPrototypeOf(child, parent);\nconsole.log(child.getParentName()); // \"父对象\"\n```\n\n\n## 五、属性描述符的完整获取：Object.getOwnPropertyDescriptors ()\nES6 新增该方法，用于获取对象**所有自身属性**的完整描述符（包括`value`、`writable`、`enumerable`、`configurable`、`get`、`set`等），解决了`Object.getOwnPropertyDescriptor()`只能获取单个属性描述符的局限。\n\n### 5.1 基本用法\n```javascript\nconst obj = {\n  name: \"张三\",\n  get age() { return 28; }, // getter属性\n  set age(val) { console.log(val); } // setter属性\n};\n\n// 获取所有自身属性的描述符\nconst descriptors = Object.getOwnPropertyDescriptors(obj);\nconsole.log(descriptors.name.value); // \"张三\"\nconsole.log(descriptors.age.get); // 对应的getter函数\n```\n\n### 5.2 核心应用：深拷贝含 getter/setter 的对象\n`Object.assign()`无法复制`getter`/`setter`属性（仅复制其返回值），而结合`Object.getOwnPropertyDescriptors()`和`Object.create()`可实现完整复制：\n```javascript\nconst clone = Object.create(\n  Object.getPrototypeOf(obj), // 继承原型\n  Object.getOwnPropertyDescriptors(obj) // 复制所有属性描述符\n);\nconsole.log(clone.age); // 28（getter正常工作）\n```\n\n\n## 六、Symbol 作为对象属性名\nES6 新增`Symbol`原始类型，其生成的实例具有唯一性，可作为对象属性名，避免属性名冲突。\n\n### 6.1 基本用法\n```javascript\n// 创建Symbol实例（参数仅为描述，不影响唯一性）\nconst id = Symbol(\"id\");\nconst obj = {\n  [id]: 1001, // 作为属性名需用方括号\n  name: \"李四\"\n};\n\n// 访问Symbol属性\nconsole.log(obj[id]); // 1001（必须用Symbol实例访问）\n\n// 特性：无法通过for...in/Object.keys()遍历\nfor (const key in obj) {\n  console.log(key); // 仅输出 \"name\"，忽略Symbol属性\n}\n\n// 获取所有Symbol属性名\nconsole.log(Object.getOwnPropertySymbols(obj)); // [Symbol(id)]\n```\n\n### 6.2 应用场景：定义 “私有” 属性\n虽然 ES6 没有真正的私有属性，但`Symbol`属性无法被常规遍历方法获取，可模拟私有属性：\n```javascript\n// 模块内部定义Symbol，外部无法访问\nconst _private = Symbol(\"private\");\nexport const obj = {\n  [_private]: \"敏感数据\",\n  publicMethod() {\n    return this[_private]; // 内部可访问\n  }\n};\n\n// 外部无法通过常规方式获取_private属性\n```\n\n\n## 总结\nES6 对对象的扩展围绕 “简化语法、完善功能、提升安全性” 三大核心目标，其特性已成为现代 JavaScript 开发的基础：\n- 语法简化（属性 / 方法简写、计算属性名）减少冗余代码；\n- 遍历与合并（Object.keys/values/entries、Object.assign）提升操作效率；\n- 原型与描述符操作（setPrototypeOf、getOwnPropertyDescriptors）规范底层逻辑；\n- Symbol 属性名解决命名冲突问题。\n\n这些特性不仅让对象操作更直观、灵活，也为后续框架（如 Vue、React）的底层实现提供了语法支撑。掌握这些扩展，能显著提升代码质量与开发效率，是前端开发者的必备技能。\n\n\n**【往期精彩内容】**\n- [JavaScript ES6 中对象的拓展，你了解几个？](https://mp.weixin.qq.com/s/PTI3HGsfpDz4-GvRx0i9ew)\n- [Javascript高频面试点--ES6 数组新特性](https://mp.weixin.qq.com/s/qR65z8RbPFxW326UnogLqA)\n- [一文搞懂 JavaScript 里 var、let、const 的区别\n](https://mp.weixin.qq.com/s/lqn_51NNxx50YgvWkxCtEg)\n- [程序员如何打破职业瓶颈？先搬开这3块绊脚石。](https://mp.weixin.qq.com/s/DRpZXprnTndjKb1YMqsfjQ)\n- [深入理解 JavaScript 中的原型与原型链](https://mp.weixin.qq.com/s/2lcovAIzSptuidQNtlVPwg)\n","source":"_posts/object-in-es6.md","raw":"---\ntitle: JavaScript ES6 中对象的拓展，你了解几个？\ndate: 2025-12-06 12:31:10\ntags: JavaScript进阶, ES6进阶\ncategory: ES6进阶\n---\n\n\n## 引言\nES6（ECMAScript 2015）作为 JavaScript 语言发展的里程碑版本，对原生`Object`进行了全方位的升级优化。这些扩展不仅简化了对象的创建与操作语法，还补充了此前缺失的核心功能（如原型操作、属性遍历、深度复制支持等），彻底改变了 JavaScript 开发者的编码习惯。本文将系统拆解 ES6 对象的六大核心扩展特性，结合实战代码示例，让每个特性的应用场景一目了然。\n\n\n## 一、对象字面量的语法简化\nES6 大幅简化了对象字面量的声明语法，减少冗余代码，提升可读性。\n\n### 1.1 属性简写\n当对象属性名与变量名一致时，可省略冒号（`:`）和属性值，直接简写为属性名：\n```javascript\n// ES5写法\nconst name = \"张三\";\nconst age = 28;\nconst user = {\n  name: name,\n  age: age\n};\n\n// ES6简写\nconst user = { name, age }; // 等价于ES5写法\n```\n\n### 1.2 方法简写\n对象方法声明可省略`function`关键字和冒号，直接使用`方法名()`语法：\n```javascript\n// ES5写法\nconst obj = {\n  sayHi: function() {\n    console.log(\"Hello\");\n  }\n};\n\n// ES6简写\nconst obj = {\n  sayHi() {\n    console.log(\"Hello\"); // 无需function关键字\n  },\n  async fetchData() { // 支持async/await语法\n    const res = await fetch(\"/api\");\n  }\n};\n```\n\n### 1.3 计算属性名\n通过方括号（`[]`）包裹表达式，动态生成对象属性名，解决了 ES5 中无法直接声明动态属性的问题：\n```javascript\n// ES5动态属性名（需额外赋值）\nconst key = \"gender\";\nconst obj = {};\nobj[key] = \"male\"; // 只能在声明后添加\n\n// ES6计算属性名（声明时直接定义）\nconst obj = {\n  [key]: \"male\",\n  [`user_${10}`]: \"admin\" // 支持表达式拼接\n};\n```\n\n\n## 二、对象属性的遍历机制\nES6 新增了 3 个遍历对象属性的方法，配合`for...of`循环，实现更灵活的属性遍历。\n\n### 2.1 Object.keys ()：获取属性名数组\n返回对象**自身可枚举属性**的名称数组（不含原型链属性）：\n```javascript\nconst obj = { a: 1, b: 2, c: 3 };\nconsole.log(Object.keys(obj)); // [\"a\", \"b\", \"c\"]\n```\n\n### 2.2 Object.values ()：获取属性值数组\n返回对象**自身可枚举属性**的对应值数组：\n```javascript\nconsole.log(Object.values(obj)); // [1, 2, 3]\n```\n\n### 2.3 Object.entries ()：获取键值对数组\n返回对象**自身可枚举属性**的`[key, value]`二维数组，完美适配`for...of`循环：\n```javascript\nfor (const [key, value] of Object.entries(obj)) {\n  console.log(`${key}: ${value}`); // 输出 \"a: 1\" \"b: 2\" \"c: 3\"\n}\n\n// 快速转换为Map\nconst map = new Map(Object.entries(obj));\n```\n\n> 注意：以上三个方法均遵循 “自身可枚举” 规则，即忽略`enumerable: false`的属性和原型链上的属性。\n\n\n## 三、对象的合并与复制：Object.assign ()\nES6 新增`Object.assign()`方法，用于将多个**源对象**的属性复制到**目标对象**，实现对象合并或浅拷贝。\n\n### 3.1 基本用法\n```javascript\nconst target = { a: 1 };\nconst source1 = { b: 2 };\nconst source2 = { a: 3, c: 4 };\n\n// 合并：source1、source2的属性依次复制到target\nObject.assign(target, source1, source2);\nconsole.log(target); // { a: 3, b: 2, c: 4 }（同名属性被后续源对象覆盖）\n```\n\n### 3.2 核心特性\n1. **浅拷贝**：仅复制属性值，若属性值为引用类型（如对象、数组），则复制引用地址：\n```javascript\nconst source = { info: { age: 20 } };\nconst target = Object.assign({}, source);\ntarget.info.age = 30;\nconsole.log(source.info.age); // 30（源对象被修改，因为复制的是引用）\n```\n\n2. **仅复制可枚举属性**：忽略`enumerable: false`的属性：\n```javascript\nconst source = Object.defineProperty({}, \"hidden\", {\n  value: 10,\n  enumerable: false // 不可枚举属性\n});\nconst target = Object.assign({}, source);\nconsole.log(target.hidden); // undefined（未复制）\n```\n\n3. **支持多源对象**：可传入多个源对象，属性按顺序覆盖（后传入的源对象优先级更高）。\n\n\n## 四、原型操作的规范化\nES6 提供了直接操作对象原型的 API，替代了 ES5 中不规范的`__proto__`属性。\n\n### 4.1 Object.setPrototypeOf ()：设置原型\n用于指定对象的原型（即`[[Prototype]]`内部属性）：\n```javascript\nconst parent = { greet() { console.log(\"Hello\"); } };\nconst child = {};\n\n// 设置child的原型为parent\nObject.setPrototypeOf(child, parent);\nchild.greet(); // \"Hello\"（继承自parent）\n```\n\n### 4.2 Object.getPrototypeOf ()：获取原型\n返回对象的原型对象，替代`obj.__proto__`：\n```javascript\nconsole.log(Object.getPrototypeOf(child) === parent); // true\n```\n\n### 4.3 super 关键字：访问原型属性\n在对象方法中，`super`指向当前对象的原型，可直接调用原型的属性或方法：\n```javascript\nconst parent = { name: \"父对象\" };\nconst child = {\n  getParentName() {\n    return super.name; // 等价于 Object.getPrototypeOf(this).name\n  }\n};\nObject.setPrototypeOf(child, parent);\nconsole.log(child.getParentName()); // \"父对象\"\n```\n\n\n## 五、属性描述符的完整获取：Object.getOwnPropertyDescriptors ()\nES6 新增该方法，用于获取对象**所有自身属性**的完整描述符（包括`value`、`writable`、`enumerable`、`configurable`、`get`、`set`等），解决了`Object.getOwnPropertyDescriptor()`只能获取单个属性描述符的局限。\n\n### 5.1 基本用法\n```javascript\nconst obj = {\n  name: \"张三\",\n  get age() { return 28; }, // getter属性\n  set age(val) { console.log(val); } // setter属性\n};\n\n// 获取所有自身属性的描述符\nconst descriptors = Object.getOwnPropertyDescriptors(obj);\nconsole.log(descriptors.name.value); // \"张三\"\nconsole.log(descriptors.age.get); // 对应的getter函数\n```\n\n### 5.2 核心应用：深拷贝含 getter/setter 的对象\n`Object.assign()`无法复制`getter`/`setter`属性（仅复制其返回值），而结合`Object.getOwnPropertyDescriptors()`和`Object.create()`可实现完整复制：\n```javascript\nconst clone = Object.create(\n  Object.getPrototypeOf(obj), // 继承原型\n  Object.getOwnPropertyDescriptors(obj) // 复制所有属性描述符\n);\nconsole.log(clone.age); // 28（getter正常工作）\n```\n\n\n## 六、Symbol 作为对象属性名\nES6 新增`Symbol`原始类型，其生成的实例具有唯一性，可作为对象属性名，避免属性名冲突。\n\n### 6.1 基本用法\n```javascript\n// 创建Symbol实例（参数仅为描述，不影响唯一性）\nconst id = Symbol(\"id\");\nconst obj = {\n  [id]: 1001, // 作为属性名需用方括号\n  name: \"李四\"\n};\n\n// 访问Symbol属性\nconsole.log(obj[id]); // 1001（必须用Symbol实例访问）\n\n// 特性：无法通过for...in/Object.keys()遍历\nfor (const key in obj) {\n  console.log(key); // 仅输出 \"name\"，忽略Symbol属性\n}\n\n// 获取所有Symbol属性名\nconsole.log(Object.getOwnPropertySymbols(obj)); // [Symbol(id)]\n```\n\n### 6.2 应用场景：定义 “私有” 属性\n虽然 ES6 没有真正的私有属性，但`Symbol`属性无法被常规遍历方法获取，可模拟私有属性：\n```javascript\n// 模块内部定义Symbol，外部无法访问\nconst _private = Symbol(\"private\");\nexport const obj = {\n  [_private]: \"敏感数据\",\n  publicMethod() {\n    return this[_private]; // 内部可访问\n  }\n};\n\n// 外部无法通过常规方式获取_private属性\n```\n\n\n## 总结\nES6 对对象的扩展围绕 “简化语法、完善功能、提升安全性” 三大核心目标，其特性已成为现代 JavaScript 开发的基础：\n- 语法简化（属性 / 方法简写、计算属性名）减少冗余代码；\n- 遍历与合并（Object.keys/values/entries、Object.assign）提升操作效率；\n- 原型与描述符操作（setPrototypeOf、getOwnPropertyDescriptors）规范底层逻辑；\n- Symbol 属性名解决命名冲突问题。\n\n这些特性不仅让对象操作更直观、灵活，也为后续框架（如 Vue、React）的底层实现提供了语法支撑。掌握这些扩展，能显著提升代码质量与开发效率，是前端开发者的必备技能。\n\n\n**【往期精彩内容】**\n- [JavaScript ES6 中对象的拓展，你了解几个？](https://mp.weixin.qq.com/s/PTI3HGsfpDz4-GvRx0i9ew)\n- [Javascript高频面试点--ES6 数组新特性](https://mp.weixin.qq.com/s/qR65z8RbPFxW326UnogLqA)\n- [一文搞懂 JavaScript 里 var、let、const 的区别\n](https://mp.weixin.qq.com/s/lqn_51NNxx50YgvWkxCtEg)\n- [程序员如何打破职业瓶颈？先搬开这3块绊脚石。](https://mp.weixin.qq.com/s/DRpZXprnTndjKb1YMqsfjQ)\n- [深入理解 JavaScript 中的原型与原型链](https://mp.weixin.qq.com/s/2lcovAIzSptuidQNtlVPwg)\n","slug":"object-in-es6","published":1,"updated":"2025-12-06T04:47:41.765Z","comments":1,"layout":"post","photos":[],"_id":"cmjbml2iv0047ikupcka12zzu","content":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>ES6（ECMAScript 2015）作为 JavaScript 语言发展的里程碑版本，对原生<code>Object</code>进行了全方位的升级优化。这些扩展不仅简化了对象的创建与操作语法，还补充了此前缺失的核心功能（如原型操作、属性遍历、深度复制支持等），彻底改变了 JavaScript 开发者的编码习惯。本文将系统拆解 ES6 对象的六大核心扩展特性，结合实战代码示例，让每个特性的应用场景一目了然。</p>\n<h2 id=\"一、对象字面量的语法简化\"><a href=\"#一、对象字面量的语法简化\" class=\"headerlink\" title=\"一、对象字面量的语法简化\"></a>一、对象字面量的语法简化</h2><p>ES6 大幅简化了对象字面量的声明语法，减少冗余代码，提升可读性。</p>\n<h3 id=\"1-1-属性简写\"><a href=\"#1-1-属性简写\" class=\"headerlink\" title=\"1.1 属性简写\"></a>1.1 属性简写</h3><p>当对象属性名与变量名一致时，可省略冒号（<code>:</code>）和属性值，直接简写为属性名：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// ES5写法</span><br><span class=\"hljs-keyword\">const</span> name = <span class=\"hljs-string\">&quot;张三&quot;</span>;<br><span class=\"hljs-keyword\">const</span> age = <span class=\"hljs-number\">28</span>;<br><span class=\"hljs-keyword\">const</span> user = &#123;<br>  <span class=\"hljs-attr\">name</span>: name,<br>  <span class=\"hljs-attr\">age</span>: age<br>&#125;;<br><br><span class=\"hljs-comment\">// ES6简写</span><br><span class=\"hljs-keyword\">const</span> user = &#123; name, age &#125;; <span class=\"hljs-comment\">// 等价于ES5写法</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"1-2-方法简写\"><a href=\"#1-2-方法简写\" class=\"headerlink\" title=\"1.2 方法简写\"></a>1.2 方法简写</h3><p>对象方法声明可省略<code>function</code>关键字和冒号，直接使用<code>方法名()</code>语法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// ES5写法</span><br><span class=\"hljs-keyword\">const</span> obj = &#123;<br>  <span class=\"hljs-attr\">sayHi</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;Hello&quot;</span>);<br>  &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// ES6简写</span><br><span class=\"hljs-keyword\">const</span> obj = &#123;<br>  <span class=\"hljs-title function_\">sayHi</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;Hello&quot;</span>); <span class=\"hljs-comment\">// 无需function关键字</span><br>  &#125;,<br>  <span class=\"hljs-keyword\">async</span> <span class=\"hljs-title function_\">fetchData</span>(<span class=\"hljs-params\"></span>) &#123; <span class=\"hljs-comment\">// 支持async/await语法</span><br>    <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&quot;/api&quot;</span>);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-计算属性名\"><a href=\"#1-3-计算属性名\" class=\"headerlink\" title=\"1.3 计算属性名\"></a>1.3 计算属性名</h3><p>通过方括号（<code>[]</code>）包裹表达式，动态生成对象属性名，解决了 ES5 中无法直接声明动态属性的问题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// ES5动态属性名（需额外赋值）</span><br><span class=\"hljs-keyword\">const</span> key = <span class=\"hljs-string\">&quot;gender&quot;</span>;<br><span class=\"hljs-keyword\">const</span> obj = &#123;&#125;;<br>obj[key] = <span class=\"hljs-string\">&quot;male&quot;</span>; <span class=\"hljs-comment\">// 只能在声明后添加</span><br><br><span class=\"hljs-comment\">// ES6计算属性名（声明时直接定义）</span><br><span class=\"hljs-keyword\">const</span> obj = &#123;<br>  [key]: <span class=\"hljs-string\">&quot;male&quot;</span>,<br>  [<span class=\"hljs-string\">`user_<span class=\"hljs-subst\">$&#123;<span class=\"hljs-number\">10</span>&#125;</span>`</span>]: <span class=\"hljs-string\">&quot;admin&quot;</span> <span class=\"hljs-comment\">// 支持表达式拼接</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n\n\n<h2 id=\"二、对象属性的遍历机制\"><a href=\"#二、对象属性的遍历机制\" class=\"headerlink\" title=\"二、对象属性的遍历机制\"></a>二、对象属性的遍历机制</h2><p>ES6 新增了 3 个遍历对象属性的方法，配合<code>for...of</code>循环，实现更灵活的属性遍历。</p>\n<h3 id=\"2-1-Object-keys-：获取属性名数组\"><a href=\"#2-1-Object-keys-：获取属性名数组\" class=\"headerlink\" title=\"2.1 Object.keys ()：获取属性名数组\"></a>2.1 Object.keys ()：获取属性名数组</h3><p>返回对象<strong>自身可枚举属性</strong>的名称数组（不含原型链属性）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> obj = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">c</span>: <span class=\"hljs-number\">3</span> &#125;;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(obj)); <span class=\"hljs-comment\">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-Object-values-：获取属性值数组\"><a href=\"#2-2-Object-values-：获取属性值数组\" class=\"headerlink\" title=\"2.2 Object.values ()：获取属性值数组\"></a>2.2 Object.values ()：获取属性值数组</h3><p>返回对象<strong>自身可枚举属性</strong>的对应值数组：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">values</span>(obj)); <span class=\"hljs-comment\">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-Object-entries-：获取键值对数组\"><a href=\"#2-3-Object-entries-：获取键值对数组\" class=\"headerlink\" title=\"2.3 Object.entries ()：获取键值对数组\"></a>2.3 Object.entries ()：获取键值对数组</h3><p>返回对象<strong>自身可枚举属性</strong>的<code>[key, value]</code>二维数组，完美适配<code>for...of</code>循环：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> [key, value] <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">entries</span>(obj)) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;key&#125;</span>: <span class=\"hljs-subst\">$&#123;value&#125;</span>`</span>); <span class=\"hljs-comment\">// 输出 &quot;a: 1&quot; &quot;b: 2&quot; &quot;c: 3&quot;</span><br>&#125;<br><br><span class=\"hljs-comment\">// 快速转换为Map</span><br><span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">entries</span>(obj));<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：以上三个方法均遵循 “自身可枚举” 规则，即忽略<code>enumerable: false</code>的属性和原型链上的属性。</p>\n</blockquote>\n<h2 id=\"三、对象的合并与复制：Object-assign\"><a href=\"#三、对象的合并与复制：Object-assign\" class=\"headerlink\" title=\"三、对象的合并与复制：Object.assign ()\"></a>三、对象的合并与复制：Object.assign ()</h2><p>ES6 新增<code>Object.assign()</code>方法，用于将多个<strong>源对象</strong>的属性复制到<strong>目标对象</strong>，实现对象合并或浅拷贝。</p>\n<h3 id=\"3-1-基本用法\"><a href=\"#3-1-基本用法\" class=\"headerlink\" title=\"3.1 基本用法\"></a>3.1 基本用法</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> target = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span> &#125;;<br><span class=\"hljs-keyword\">const</span> source1 = &#123; <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">2</span> &#125;;<br><span class=\"hljs-keyword\">const</span> source2 = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">c</span>: <span class=\"hljs-number\">4</span> &#125;;<br><br><span class=\"hljs-comment\">// 合并：source1、source2的属性依次复制到target</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(target, source1, source2);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(target); <span class=\"hljs-comment\">// &#123; a: 3, b: 2, c: 4 &#125;（同名属性被后续源对象覆盖）</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-核心特性\"><a href=\"#3-2-核心特性\" class=\"headerlink\" title=\"3.2 核心特性\"></a>3.2 核心特性</h3><ol>\n<li><p><strong>浅拷贝</strong>：仅复制属性值，若属性值为引用类型（如对象、数组），则复制引用地址：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> source = &#123; <span class=\"hljs-attr\">info</span>: &#123; <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">20</span> &#125; &#125;;<br><span class=\"hljs-keyword\">const</span> target = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(&#123;&#125;, source);<br>target.<span class=\"hljs-property\">info</span>.<span class=\"hljs-property\">age</span> = <span class=\"hljs-number\">30</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(source.<span class=\"hljs-property\">info</span>.<span class=\"hljs-property\">age</span>); <span class=\"hljs-comment\">// 30（源对象被修改，因为复制的是引用）</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>仅复制可枚举属性</strong>：忽略<code>enumerable: false</code>的属性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> source = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">defineProperty</span>(&#123;&#125;, <span class=\"hljs-string\">&quot;hidden&quot;</span>, &#123;<br>  <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">10</span>,<br>  <span class=\"hljs-attr\">enumerable</span>: <span class=\"hljs-literal\">false</span> <span class=\"hljs-comment\">// 不可枚举属性</span><br>&#125;);<br><span class=\"hljs-keyword\">const</span> target = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(&#123;&#125;, source);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(target.<span class=\"hljs-property\">hidden</span>); <span class=\"hljs-comment\">// undefined（未复制）</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>支持多源对象</strong>：可传入多个源对象，属性按顺序覆盖（后传入的源对象优先级更高）。</p>\n</li>\n</ol>\n<h2 id=\"四、原型操作的规范化\"><a href=\"#四、原型操作的规范化\" class=\"headerlink\" title=\"四、原型操作的规范化\"></a>四、原型操作的规范化</h2><p>ES6 提供了直接操作对象原型的 API，替代了 ES5 中不规范的<code>__proto__</code>属性。</p>\n<h3 id=\"4-1-Object-setPrototypeOf-：设置原型\"><a href=\"#4-1-Object-setPrototypeOf-：设置原型\" class=\"headerlink\" title=\"4.1 Object.setPrototypeOf ()：设置原型\"></a>4.1 Object.setPrototypeOf ()：设置原型</h3><p>用于指定对象的原型（即<code>[[Prototype]]</code>内部属性）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> parent = &#123; <span class=\"hljs-title function_\">greet</span>(<span class=\"hljs-params\"></span>) &#123; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;Hello&quot;</span>); &#125; &#125;;<br><span class=\"hljs-keyword\">const</span> child = &#123;&#125;;<br><br><span class=\"hljs-comment\">// 设置child的原型为parent</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">setPrototypeOf</span>(child, parent);<br>child.<span class=\"hljs-title function_\">greet</span>(); <span class=\"hljs-comment\">// &quot;Hello&quot;（继承自parent）</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"4-2-Object-getPrototypeOf-：获取原型\"><a href=\"#4-2-Object-getPrototypeOf-：获取原型\" class=\"headerlink\" title=\"4.2 Object.getPrototypeOf ()：获取原型\"></a>4.2 Object.getPrototypeOf ()：获取原型</h3><p>返回对象的原型对象，替代<code>obj.__proto__</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getPrototypeOf</span>(child) === parent); <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"4-3-super-关键字：访问原型属性\"><a href=\"#4-3-super-关键字：访问原型属性\" class=\"headerlink\" title=\"4.3 super 关键字：访问原型属性\"></a>4.3 super 关键字：访问原型属性</h3><p>在对象方法中，<code>super</code>指向当前对象的原型，可直接调用原型的属性或方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> parent = &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;父对象&quot;</span> &#125;;<br><span class=\"hljs-keyword\">const</span> child = &#123;<br>  <span class=\"hljs-title function_\">getParentName</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">super</span>.<span class=\"hljs-property\">name</span>; <span class=\"hljs-comment\">// 等价于 Object.getPrototypeOf(this).name</span><br>  &#125;<br>&#125;;<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">setPrototypeOf</span>(child, parent);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(child.<span class=\"hljs-title function_\">getParentName</span>()); <span class=\"hljs-comment\">// &quot;父对象&quot;</span><br></code></pre></td></tr></table></figure>\n\n\n<h2 id=\"五、属性描述符的完整获取：Object-getOwnPropertyDescriptors\"><a href=\"#五、属性描述符的完整获取：Object-getOwnPropertyDescriptors\" class=\"headerlink\" title=\"五、属性描述符的完整获取：Object.getOwnPropertyDescriptors ()\"></a>五、属性描述符的完整获取：Object.getOwnPropertyDescriptors ()</h2><p>ES6 新增该方法，用于获取对象<strong>所有自身属性</strong>的完整描述符（包括<code>value</code>、<code>writable</code>、<code>enumerable</code>、<code>configurable</code>、<code>get</code>、<code>set</code>等），解决了<code>Object.getOwnPropertyDescriptor()</code>只能获取单个属性描述符的局限。</p>\n<h3 id=\"5-1-基本用法\"><a href=\"#5-1-基本用法\" class=\"headerlink\" title=\"5.1 基本用法\"></a>5.1 基本用法</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> obj = &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;张三&quot;</span>,<br>  <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title function_\">age</span>() &#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">28</span>; &#125;, <span class=\"hljs-comment\">// getter属性</span><br>  <span class=\"hljs-keyword\">set</span> <span class=\"hljs-title function_\">age</span>(<span class=\"hljs-params\">val</span>) &#123; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(val); &#125; <span class=\"hljs-comment\">// setter属性</span><br>&#125;;<br><br><span class=\"hljs-comment\">// 获取所有自身属性的描述符</span><br><span class=\"hljs-keyword\">const</span> descriptors = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptors</span>(obj);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(descriptors.<span class=\"hljs-property\">name</span>.<span class=\"hljs-property\">value</span>); <span class=\"hljs-comment\">// &quot;张三&quot;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(descriptors.<span class=\"hljs-property\">age</span>.<span class=\"hljs-property\">get</span>); <span class=\"hljs-comment\">// 对应的getter函数</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"5-2-核心应用：深拷贝含-getter-setter-的对象\"><a href=\"#5-2-核心应用：深拷贝含-getter-setter-的对象\" class=\"headerlink\" title=\"5.2 核心应用：深拷贝含 getter&#x2F;setter 的对象\"></a>5.2 核心应用：深拷贝含 getter&#x2F;setter 的对象</h3><p><code>Object.assign()</code>无法复制<code>getter</code>&#x2F;<code>setter</code>属性（仅复制其返回值），而结合<code>Object.getOwnPropertyDescriptors()</code>和<code>Object.create()</code>可实现完整复制：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> clone = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(<br>  <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getPrototypeOf</span>(obj), <span class=\"hljs-comment\">// 继承原型</span><br>  <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptors</span>(obj) <span class=\"hljs-comment\">// 复制所有属性描述符</span><br>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(clone.<span class=\"hljs-property\">age</span>); <span class=\"hljs-comment\">// 28（getter正常工作）</span><br></code></pre></td></tr></table></figure>\n\n\n<h2 id=\"六、Symbol-作为对象属性名\"><a href=\"#六、Symbol-作为对象属性名\" class=\"headerlink\" title=\"六、Symbol 作为对象属性名\"></a>六、Symbol 作为对象属性名</h2><p>ES6 新增<code>Symbol</code>原始类型，其生成的实例具有唯一性，可作为对象属性名，避免属性名冲突。</p>\n<h3 id=\"6-1-基本用法\"><a href=\"#6-1-基本用法\" class=\"headerlink\" title=\"6.1 基本用法\"></a>6.1 基本用法</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 创建Symbol实例（参数仅为描述，不影响唯一性）</span><br><span class=\"hljs-keyword\">const</span> id = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&quot;id&quot;</span>);<br><span class=\"hljs-keyword\">const</span> obj = &#123;<br>  [id]: <span class=\"hljs-number\">1001</span>, <span class=\"hljs-comment\">// 作为属性名需用方括号</span><br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;李四&quot;</span><br>&#125;;<br><br><span class=\"hljs-comment\">// 访问Symbol属性</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj[id]); <span class=\"hljs-comment\">// 1001（必须用Symbol实例访问）</span><br><br><span class=\"hljs-comment\">// 特性：无法通过for...in/Object.keys()遍历</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> key <span class=\"hljs-keyword\">in</span> obj) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(key); <span class=\"hljs-comment\">// 仅输出 &quot;name&quot;，忽略Symbol属性</span><br>&#125;<br><br><span class=\"hljs-comment\">// 获取所有Symbol属性名</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertySymbols</span>(obj)); <span class=\"hljs-comment\">// [Symbol(id)]</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"6-2-应用场景：定义-“私有”-属性\"><a href=\"#6-2-应用场景：定义-“私有”-属性\" class=\"headerlink\" title=\"6.2 应用场景：定义 “私有” 属性\"></a>6.2 应用场景：定义 “私有” 属性</h3><p>虽然 ES6 没有真正的私有属性，但<code>Symbol</code>属性无法被常规遍历方法获取，可模拟私有属性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 模块内部定义Symbol，外部无法访问</span><br><span class=\"hljs-keyword\">const</span> _private = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&quot;private&quot;</span>);<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> obj = &#123;<br>  [_private]: <span class=\"hljs-string\">&quot;敏感数据&quot;</span>,<br>  <span class=\"hljs-title function_\">publicMethod</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>[_private]; <span class=\"hljs-comment\">// 内部可访问</span><br>  &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 外部无法通过常规方式获取_private属性</span><br></code></pre></td></tr></table></figure>\n\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>ES6 对对象的扩展围绕 “简化语法、完善功能、提升安全性” 三大核心目标，其特性已成为现代 JavaScript 开发的基础：</p>\n<ul>\n<li>语法简化（属性 &#x2F; 方法简写、计算属性名）减少冗余代码；</li>\n<li>遍历与合并（Object.keys&#x2F;values&#x2F;entries、Object.assign）提升操作效率；</li>\n<li>原型与描述符操作（setPrototypeOf、getOwnPropertyDescriptors）规范底层逻辑；</li>\n<li>Symbol 属性名解决命名冲突问题。</li>\n</ul>\n<p>这些特性不仅让对象操作更直观、灵活，也为后续框架（如 Vue、React）的底层实现提供了语法支撑。掌握这些扩展，能显著提升代码质量与开发效率，是前端开发者的必备技能。</p>\n<p><strong>【往期精彩内容】</strong></p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/PTI3HGsfpDz4-GvRx0i9ew\">JavaScript ES6 中对象的拓展，你了解几个？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/qR65z8RbPFxW326UnogLqA\">Javascript高频面试点–ES6 数组新特性</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/lqn_51NNxx50YgvWkxCtEg\">一文搞懂 JavaScript 里 var、let、const 的区别\n</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/DRpZXprnTndjKb1YMqsfjQ\">程序员如何打破职业瓶颈？先搬开这3块绊脚石。</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/2lcovAIzSptuidQNtlVPwg\">深入理解 JavaScript 中的原型与原型链</a></li>\n</ul>\n","excerpt":"","more":"<h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>ES6（ECMAScript 2015）作为 JavaScript 语言发展的里程碑版本，对原生<code>Object</code>进行了全方位的升级优化。这些扩展不仅简化了对象的创建与操作语法，还补充了此前缺失的核心功能（如原型操作、属性遍历、深度复制支持等），彻底改变了 JavaScript 开发者的编码习惯。本文将系统拆解 ES6 对象的六大核心扩展特性，结合实战代码示例，让每个特性的应用场景一目了然。</p>\n<h2 id=\"一、对象字面量的语法简化\"><a href=\"#一、对象字面量的语法简化\" class=\"headerlink\" title=\"一、对象字面量的语法简化\"></a>一、对象字面量的语法简化</h2><p>ES6 大幅简化了对象字面量的声明语法，减少冗余代码，提升可读性。</p>\n<h3 id=\"1-1-属性简写\"><a href=\"#1-1-属性简写\" class=\"headerlink\" title=\"1.1 属性简写\"></a>1.1 属性简写</h3><p>当对象属性名与变量名一致时，可省略冒号（<code>:</code>）和属性值，直接简写为属性名：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// ES5写法</span><br><span class=\"hljs-keyword\">const</span> name = <span class=\"hljs-string\">&quot;张三&quot;</span>;<br><span class=\"hljs-keyword\">const</span> age = <span class=\"hljs-number\">28</span>;<br><span class=\"hljs-keyword\">const</span> user = &#123;<br>  <span class=\"hljs-attr\">name</span>: name,<br>  <span class=\"hljs-attr\">age</span>: age<br>&#125;;<br><br><span class=\"hljs-comment\">// ES6简写</span><br><span class=\"hljs-keyword\">const</span> user = &#123; name, age &#125;; <span class=\"hljs-comment\">// 等价于ES5写法</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"1-2-方法简写\"><a href=\"#1-2-方法简写\" class=\"headerlink\" title=\"1.2 方法简写\"></a>1.2 方法简写</h3><p>对象方法声明可省略<code>function</code>关键字和冒号，直接使用<code>方法名()</code>语法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// ES5写法</span><br><span class=\"hljs-keyword\">const</span> obj = &#123;<br>  <span class=\"hljs-attr\">sayHi</span>: <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;Hello&quot;</span>);<br>  &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// ES6简写</span><br><span class=\"hljs-keyword\">const</span> obj = &#123;<br>  <span class=\"hljs-title function_\">sayHi</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;Hello&quot;</span>); <span class=\"hljs-comment\">// 无需function关键字</span><br>  &#125;,<br>  <span class=\"hljs-keyword\">async</span> <span class=\"hljs-title function_\">fetchData</span>(<span class=\"hljs-params\"></span>) &#123; <span class=\"hljs-comment\">// 支持async/await语法</span><br>    <span class=\"hljs-keyword\">const</span> res = <span class=\"hljs-keyword\">await</span> <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&quot;/api&quot;</span>);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"1-3-计算属性名\"><a href=\"#1-3-计算属性名\" class=\"headerlink\" title=\"1.3 计算属性名\"></a>1.3 计算属性名</h3><p>通过方括号（<code>[]</code>）包裹表达式，动态生成对象属性名，解决了 ES5 中无法直接声明动态属性的问题：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// ES5动态属性名（需额外赋值）</span><br><span class=\"hljs-keyword\">const</span> key = <span class=\"hljs-string\">&quot;gender&quot;</span>;<br><span class=\"hljs-keyword\">const</span> obj = &#123;&#125;;<br>obj[key] = <span class=\"hljs-string\">&quot;male&quot;</span>; <span class=\"hljs-comment\">// 只能在声明后添加</span><br><br><span class=\"hljs-comment\">// ES6计算属性名（声明时直接定义）</span><br><span class=\"hljs-keyword\">const</span> obj = &#123;<br>  [key]: <span class=\"hljs-string\">&quot;male&quot;</span>,<br>  [<span class=\"hljs-string\">`user_<span class=\"hljs-subst\">$&#123;<span class=\"hljs-number\">10</span>&#125;</span>`</span>]: <span class=\"hljs-string\">&quot;admin&quot;</span> <span class=\"hljs-comment\">// 支持表达式拼接</span><br>&#125;;<br></code></pre></td></tr></table></figure>\n\n\n<h2 id=\"二、对象属性的遍历机制\"><a href=\"#二、对象属性的遍历机制\" class=\"headerlink\" title=\"二、对象属性的遍历机制\"></a>二、对象属性的遍历机制</h2><p>ES6 新增了 3 个遍历对象属性的方法，配合<code>for...of</code>循环，实现更灵活的属性遍历。</p>\n<h3 id=\"2-1-Object-keys-：获取属性名数组\"><a href=\"#2-1-Object-keys-：获取属性名数组\" class=\"headerlink\" title=\"2.1 Object.keys ()：获取属性名数组\"></a>2.1 Object.keys ()：获取属性名数组</h3><p>返回对象<strong>自身可枚举属性</strong>的名称数组（不含原型链属性）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> obj = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span>, <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">2</span>, <span class=\"hljs-attr\">c</span>: <span class=\"hljs-number\">3</span> &#125;;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">keys</span>(obj)); <span class=\"hljs-comment\">// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-2-Object-values-：获取属性值数组\"><a href=\"#2-2-Object-values-：获取属性值数组\" class=\"headerlink\" title=\"2.2 Object.values ()：获取属性值数组\"></a>2.2 Object.values ()：获取属性值数组</h3><p>返回对象<strong>自身可枚举属性</strong>的对应值数组：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">values</span>(obj)); <span class=\"hljs-comment\">// [1, 2, 3]</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-3-Object-entries-：获取键值对数组\"><a href=\"#2-3-Object-entries-：获取键值对数组\" class=\"headerlink\" title=\"2.3 Object.entries ()：获取键值对数组\"></a>2.3 Object.entries ()：获取键值对数组</h3><p>返回对象<strong>自身可枚举属性</strong>的<code>[key, value]</code>二维数组，完美适配<code>for...of</code>循环：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> [key, value] <span class=\"hljs-keyword\">of</span> <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">entries</span>(obj)) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;key&#125;</span>: <span class=\"hljs-subst\">$&#123;value&#125;</span>`</span>); <span class=\"hljs-comment\">// 输出 &quot;a: 1&quot; &quot;b: 2&quot; &quot;c: 3&quot;</span><br>&#125;<br><br><span class=\"hljs-comment\">// 快速转换为Map</span><br><span class=\"hljs-keyword\">const</span> map = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">entries</span>(obj));<br></code></pre></td></tr></table></figure>\n\n<blockquote>\n<p>注意：以上三个方法均遵循 “自身可枚举” 规则，即忽略<code>enumerable: false</code>的属性和原型链上的属性。</p>\n</blockquote>\n<h2 id=\"三、对象的合并与复制：Object-assign\"><a href=\"#三、对象的合并与复制：Object-assign\" class=\"headerlink\" title=\"三、对象的合并与复制：Object.assign ()\"></a>三、对象的合并与复制：Object.assign ()</h2><p>ES6 新增<code>Object.assign()</code>方法，用于将多个<strong>源对象</strong>的属性复制到<strong>目标对象</strong>，实现对象合并或浅拷贝。</p>\n<h3 id=\"3-1-基本用法\"><a href=\"#3-1-基本用法\" class=\"headerlink\" title=\"3.1 基本用法\"></a>3.1 基本用法</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> target = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">1</span> &#125;;<br><span class=\"hljs-keyword\">const</span> source1 = &#123; <span class=\"hljs-attr\">b</span>: <span class=\"hljs-number\">2</span> &#125;;<br><span class=\"hljs-keyword\">const</span> source2 = &#123; <span class=\"hljs-attr\">a</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-attr\">c</span>: <span class=\"hljs-number\">4</span> &#125;;<br><br><span class=\"hljs-comment\">// 合并：source1、source2的属性依次复制到target</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(target, source1, source2);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(target); <span class=\"hljs-comment\">// &#123; a: 3, b: 2, c: 4 &#125;（同名属性被后续源对象覆盖）</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-核心特性\"><a href=\"#3-2-核心特性\" class=\"headerlink\" title=\"3.2 核心特性\"></a>3.2 核心特性</h3><ol>\n<li><p><strong>浅拷贝</strong>：仅复制属性值，若属性值为引用类型（如对象、数组），则复制引用地址：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> source = &#123; <span class=\"hljs-attr\">info</span>: &#123; <span class=\"hljs-attr\">age</span>: <span class=\"hljs-number\">20</span> &#125; &#125;;<br><span class=\"hljs-keyword\">const</span> target = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(&#123;&#125;, source);<br>target.<span class=\"hljs-property\">info</span>.<span class=\"hljs-property\">age</span> = <span class=\"hljs-number\">30</span>;<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(source.<span class=\"hljs-property\">info</span>.<span class=\"hljs-property\">age</span>); <span class=\"hljs-comment\">// 30（源对象被修改，因为复制的是引用）</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>仅复制可枚举属性</strong>：忽略<code>enumerable: false</code>的属性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> source = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">defineProperty</span>(&#123;&#125;, <span class=\"hljs-string\">&quot;hidden&quot;</span>, &#123;<br>  <span class=\"hljs-attr\">value</span>: <span class=\"hljs-number\">10</span>,<br>  <span class=\"hljs-attr\">enumerable</span>: <span class=\"hljs-literal\">false</span> <span class=\"hljs-comment\">// 不可枚举属性</span><br>&#125;);<br><span class=\"hljs-keyword\">const</span> target = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">assign</span>(&#123;&#125;, source);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(target.<span class=\"hljs-property\">hidden</span>); <span class=\"hljs-comment\">// undefined（未复制）</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>支持多源对象</strong>：可传入多个源对象，属性按顺序覆盖（后传入的源对象优先级更高）。</p>\n</li>\n</ol>\n<h2 id=\"四、原型操作的规范化\"><a href=\"#四、原型操作的规范化\" class=\"headerlink\" title=\"四、原型操作的规范化\"></a>四、原型操作的规范化</h2><p>ES6 提供了直接操作对象原型的 API，替代了 ES5 中不规范的<code>__proto__</code>属性。</p>\n<h3 id=\"4-1-Object-setPrototypeOf-：设置原型\"><a href=\"#4-1-Object-setPrototypeOf-：设置原型\" class=\"headerlink\" title=\"4.1 Object.setPrototypeOf ()：设置原型\"></a>4.1 Object.setPrototypeOf ()：设置原型</h3><p>用于指定对象的原型（即<code>[[Prototype]]</code>内部属性）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> parent = &#123; <span class=\"hljs-title function_\">greet</span>(<span class=\"hljs-params\"></span>) &#123; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">&quot;Hello&quot;</span>); &#125; &#125;;<br><span class=\"hljs-keyword\">const</span> child = &#123;&#125;;<br><br><span class=\"hljs-comment\">// 设置child的原型为parent</span><br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">setPrototypeOf</span>(child, parent);<br>child.<span class=\"hljs-title function_\">greet</span>(); <span class=\"hljs-comment\">// &quot;Hello&quot;（继承自parent）</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"4-2-Object-getPrototypeOf-：获取原型\"><a href=\"#4-2-Object-getPrototypeOf-：获取原型\" class=\"headerlink\" title=\"4.2 Object.getPrototypeOf ()：获取原型\"></a>4.2 Object.getPrototypeOf ()：获取原型</h3><p>返回对象的原型对象，替代<code>obj.__proto__</code>：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getPrototypeOf</span>(child) === parent); <span class=\"hljs-comment\">// true</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"4-3-super-关键字：访问原型属性\"><a href=\"#4-3-super-关键字：访问原型属性\" class=\"headerlink\" title=\"4.3 super 关键字：访问原型属性\"></a>4.3 super 关键字：访问原型属性</h3><p>在对象方法中，<code>super</code>指向当前对象的原型，可直接调用原型的属性或方法：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> parent = &#123; <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;父对象&quot;</span> &#125;;<br><span class=\"hljs-keyword\">const</span> child = &#123;<br>  <span class=\"hljs-title function_\">getParentName</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">super</span>.<span class=\"hljs-property\">name</span>; <span class=\"hljs-comment\">// 等价于 Object.getPrototypeOf(this).name</span><br>  &#125;<br>&#125;;<br><span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">setPrototypeOf</span>(child, parent);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(child.<span class=\"hljs-title function_\">getParentName</span>()); <span class=\"hljs-comment\">// &quot;父对象&quot;</span><br></code></pre></td></tr></table></figure>\n\n\n<h2 id=\"五、属性描述符的完整获取：Object-getOwnPropertyDescriptors\"><a href=\"#五、属性描述符的完整获取：Object-getOwnPropertyDescriptors\" class=\"headerlink\" title=\"五、属性描述符的完整获取：Object.getOwnPropertyDescriptors ()\"></a>五、属性描述符的完整获取：Object.getOwnPropertyDescriptors ()</h2><p>ES6 新增该方法，用于获取对象<strong>所有自身属性</strong>的完整描述符（包括<code>value</code>、<code>writable</code>、<code>enumerable</code>、<code>configurable</code>、<code>get</code>、<code>set</code>等），解决了<code>Object.getOwnPropertyDescriptor()</code>只能获取单个属性描述符的局限。</p>\n<h3 id=\"5-1-基本用法\"><a href=\"#5-1-基本用法\" class=\"headerlink\" title=\"5.1 基本用法\"></a>5.1 基本用法</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> obj = &#123;<br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;张三&quot;</span>,<br>  <span class=\"hljs-keyword\">get</span> <span class=\"hljs-title function_\">age</span>() &#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">28</span>; &#125;, <span class=\"hljs-comment\">// getter属性</span><br>  <span class=\"hljs-keyword\">set</span> <span class=\"hljs-title function_\">age</span>(<span class=\"hljs-params\">val</span>) &#123; <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(val); &#125; <span class=\"hljs-comment\">// setter属性</span><br>&#125;;<br><br><span class=\"hljs-comment\">// 获取所有自身属性的描述符</span><br><span class=\"hljs-keyword\">const</span> descriptors = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptors</span>(obj);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(descriptors.<span class=\"hljs-property\">name</span>.<span class=\"hljs-property\">value</span>); <span class=\"hljs-comment\">// &quot;张三&quot;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(descriptors.<span class=\"hljs-property\">age</span>.<span class=\"hljs-property\">get</span>); <span class=\"hljs-comment\">// 对应的getter函数</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"5-2-核心应用：深拷贝含-getter-setter-的对象\"><a href=\"#5-2-核心应用：深拷贝含-getter-setter-的对象\" class=\"headerlink\" title=\"5.2 核心应用：深拷贝含 getter&#x2F;setter 的对象\"></a>5.2 核心应用：深拷贝含 getter&#x2F;setter 的对象</h3><p><code>Object.assign()</code>无法复制<code>getter</code>&#x2F;<code>setter</code>属性（仅复制其返回值），而结合<code>Object.getOwnPropertyDescriptors()</code>和<code>Object.create()</code>可实现完整复制：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> clone = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(<br>  <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getPrototypeOf</span>(obj), <span class=\"hljs-comment\">// 继承原型</span><br>  <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertyDescriptors</span>(obj) <span class=\"hljs-comment\">// 复制所有属性描述符</span><br>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(clone.<span class=\"hljs-property\">age</span>); <span class=\"hljs-comment\">// 28（getter正常工作）</span><br></code></pre></td></tr></table></figure>\n\n\n<h2 id=\"六、Symbol-作为对象属性名\"><a href=\"#六、Symbol-作为对象属性名\" class=\"headerlink\" title=\"六、Symbol 作为对象属性名\"></a>六、Symbol 作为对象属性名</h2><p>ES6 新增<code>Symbol</code>原始类型，其生成的实例具有唯一性，可作为对象属性名，避免属性名冲突。</p>\n<h3 id=\"6-1-基本用法\"><a href=\"#6-1-基本用法\" class=\"headerlink\" title=\"6.1 基本用法\"></a>6.1 基本用法</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 创建Symbol实例（参数仅为描述，不影响唯一性）</span><br><span class=\"hljs-keyword\">const</span> id = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&quot;id&quot;</span>);<br><span class=\"hljs-keyword\">const</span> obj = &#123;<br>  [id]: <span class=\"hljs-number\">1001</span>, <span class=\"hljs-comment\">// 作为属性名需用方括号</span><br>  <span class=\"hljs-attr\">name</span>: <span class=\"hljs-string\">&quot;李四&quot;</span><br>&#125;;<br><br><span class=\"hljs-comment\">// 访问Symbol属性</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(obj[id]); <span class=\"hljs-comment\">// 1001（必须用Symbol实例访问）</span><br><br><span class=\"hljs-comment\">// 特性：无法通过for...in/Object.keys()遍历</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> key <span class=\"hljs-keyword\">in</span> obj) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(key); <span class=\"hljs-comment\">// 仅输出 &quot;name&quot;，忽略Symbol属性</span><br>&#125;<br><br><span class=\"hljs-comment\">// 获取所有Symbol属性名</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">getOwnPropertySymbols</span>(obj)); <span class=\"hljs-comment\">// [Symbol(id)]</span><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"6-2-应用场景：定义-“私有”-属性\"><a href=\"#6-2-应用场景：定义-“私有”-属性\" class=\"headerlink\" title=\"6.2 应用场景：定义 “私有” 属性\"></a>6.2 应用场景：定义 “私有” 属性</h3><p>虽然 ES6 没有真正的私有属性，但<code>Symbol</code>属性无法被常规遍历方法获取，可模拟私有属性：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 模块内部定义Symbol，外部无法访问</span><br><span class=\"hljs-keyword\">const</span> _private = <span class=\"hljs-title class_\">Symbol</span>(<span class=\"hljs-string\">&quot;private&quot;</span>);<br><span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">const</span> obj = &#123;<br>  [_private]: <span class=\"hljs-string\">&quot;敏感数据&quot;</span>,<br>  <span class=\"hljs-title function_\">publicMethod</span>(<span class=\"hljs-params\"></span>) &#123;<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>[_private]; <span class=\"hljs-comment\">// 内部可访问</span><br>  &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 外部无法通过常规方式获取_private属性</span><br></code></pre></td></tr></table></figure>\n\n\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>ES6 对对象的扩展围绕 “简化语法、完善功能、提升安全性” 三大核心目标，其特性已成为现代 JavaScript 开发的基础：</p>\n<ul>\n<li>语法简化（属性 &#x2F; 方法简写、计算属性名）减少冗余代码；</li>\n<li>遍历与合并（Object.keys&#x2F;values&#x2F;entries、Object.assign）提升操作效率；</li>\n<li>原型与描述符操作（setPrototypeOf、getOwnPropertyDescriptors）规范底层逻辑；</li>\n<li>Symbol 属性名解决命名冲突问题。</li>\n</ul>\n<p>这些特性不仅让对象操作更直观、灵活，也为后续框架（如 Vue、React）的底层实现提供了语法支撑。掌握这些扩展，能显著提升代码质量与开发效率，是前端开发者的必备技能。</p>\n<p><strong>【往期精彩内容】</strong></p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/PTI3HGsfpDz4-GvRx0i9ew\">JavaScript ES6 中对象的拓展，你了解几个？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/qR65z8RbPFxW326UnogLqA\">Javascript高频面试点–ES6 数组新特性</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/lqn_51NNxx50YgvWkxCtEg\">一文搞懂 JavaScript 里 var、let、const 的区别\n</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/DRpZXprnTndjKb1YMqsfjQ\">程序员如何打破职业瓶颈？先搬开这3块绊脚石。</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/2lcovAIzSptuidQNtlVPwg\">深入理解 JavaScript 中的原型与原型链</a></li>\n</ul>\n"},{"title":"深入理解 JavaScript 中的原型与原型链","date":"2025-08-25T13:37:57.000Z","index_img":"imgs/prototype/banner.png","banner_img":"imgs/prototype/banner.png","_content":"\n\n在 JavaScript 的世界里，原型和原型链是绕不开的核心概念，它们构建了 JS 独特的继承机制，也让许多开发者既好奇又头疼。今天我们就从几个关键角度，一起揭开它们的神秘面纱。\n\n## 基于类与基于原型：两种不同的编程范式\n在传统的面向对象编程语言中，比如 Java、C++，**基于类（Class-based）** 是主流的编程思想。在这种范式里，类就像是一个模具，它定义了对象所具有的属性和方法，而对象则是类的实例。我们必须先定义好类，然后通过new关键字来创建该类的对象，对象之间的关系是通过类的继承来确立的。\n\n而 JavaScript 则不同，它采用的是**基于原型（Prototype-based）** 的编程范式。在这种模式下，并没有严格意义上的类的概念（虽然 ES6 引入了class语法，但这只是语法糖，底层依然是基于原型实现的）。对象可以直接从其他对象继承属性和方法，我们可以把原型看作是一个模板对象，新创建的对象会以这个模板为基础，共享它的属性和方法。\n\n举个简单的例子，在基于类的编程中，我们先定义一个 “动物” 类，规定动物有 “名字” 属性和 “移动” 方法，然后 “猫” 类继承 “动物” 类，再创建 “猫” 类的实例。而在基于原型的 JavaScript 中，我们可以先创建一个 “动物” 对象作为原型，然后创建 “猫” 对象时，让它的原型指向 “动物” 对象，“猫” 对象就自然拥有了 “动物” 对象的属性和方法。\n\n## 原型是啥，对象是如何产生的\n原型（Prototype） 其实就是一个普通的对象，它是其他对象的模板，被用于共享属性和方法。在 JavaScript 中，每个对象（除了null和undefined）都有一个与之关联的原型对象。\n\n那么对象是如何产生的呢？\n\n当我们使用new关键字调用构造函数时，会创建一个新的对象。这个新对象的原型会指向构造函数的prototype属性所指向的对象。\n\n例如，我们定义一个Person构造函数：\n\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\n```\n\n当我们通过 `new Person(\"张三\")` 创建一个对象时，这个新对象的原型就是 *Person.prototype*。\n\n此外，我们还可以使用 `Object.create()` 方法来创建对象，这个方法会以传入的对象为原型来创建新的对象。比如 `Object.create(prototypeObj)`  创建的新对象，其原型就是 prototypeObj。\n\n## 原型链的用处\n原型链（Prototype Chain） 是由对象的原型串联起来形成的链式结构。当我们访问一个对象的属性或方法时，如果该对象本身没有这个属性或方法，JavaScript 就会沿着原型链向上查找，直到找到该属性或方法，或者到达原型链的顶端（null）。\n\n原型链的用处和好处主要有以下几点：\n\n**实现继承**：这是原型链最主要的作用。通过原型链，一个对象可以继承多个原型对象的属性和方法，实现了代码的复用。比如，子对象的原型指向父对象，子对象就可以使用父对象的属性和方法，当父对象的原型又指向其他对象时，就形成了更长的继承链。\n\n**节省内存空间**：由于多个对象可以共享同一个原型对象的属性和方法，不需要为每个对象都重复定义这些属性和方法，大大节省了内存。例如，所有通过同一个构造函数创建的对象，都会共享该构造函数prototype对象中的方法，而不是每个对象都拥有一份独立的方法副本。\n\n**动态扩展属性和方法**：我们可以在原型对象上动态地添加属性和方法，这些添加的属性和方法会立即被所有依赖该原型的对象所共享。比如，给 `Person.prototype` 添加一个 `sayHello` 方法，那么所有通过 *Person* 构造函数创建的对象都能立即使用这个 sayHello 方法。\n\n\n## 写在最后\n原型和原型链是 JavaScript 实现面向对象编程的核心机制，理解它们对于掌握 JavaScript 有着至关重要的意义。\n\n对于开发者而言，理解它们不仅是掌握 “继承”“内存优化” 等基础能力的关键，更是后续学习闭包、原型继承实战、甚至框架源码（如 Vue、React 中部分组件复用逻辑）的前提。","source":"_posts/prototype-in-js.md","raw":"---\ntitle: 深入理解 JavaScript 中的原型与原型链\ndate: 2025-08-25 21:37:57\ntags: [JavaScript, 前端进阶]\nindex_img: imgs/prototype/banner.png\nbanner_img: imgs/prototype/banner.png\n---\n\n\n在 JavaScript 的世界里，原型和原型链是绕不开的核心概念，它们构建了 JS 独特的继承机制，也让许多开发者既好奇又头疼。今天我们就从几个关键角度，一起揭开它们的神秘面纱。\n\n## 基于类与基于原型：两种不同的编程范式\n在传统的面向对象编程语言中，比如 Java、C++，**基于类（Class-based）** 是主流的编程思想。在这种范式里，类就像是一个模具，它定义了对象所具有的属性和方法，而对象则是类的实例。我们必须先定义好类，然后通过new关键字来创建该类的对象，对象之间的关系是通过类的继承来确立的。\n\n而 JavaScript 则不同，它采用的是**基于原型（Prototype-based）** 的编程范式。在这种模式下，并没有严格意义上的类的概念（虽然 ES6 引入了class语法，但这只是语法糖，底层依然是基于原型实现的）。对象可以直接从其他对象继承属性和方法，我们可以把原型看作是一个模板对象，新创建的对象会以这个模板为基础，共享它的属性和方法。\n\n举个简单的例子，在基于类的编程中，我们先定义一个 “动物” 类，规定动物有 “名字” 属性和 “移动” 方法，然后 “猫” 类继承 “动物” 类，再创建 “猫” 类的实例。而在基于原型的 JavaScript 中，我们可以先创建一个 “动物” 对象作为原型，然后创建 “猫” 对象时，让它的原型指向 “动物” 对象，“猫” 对象就自然拥有了 “动物” 对象的属性和方法。\n\n## 原型是啥，对象是如何产生的\n原型（Prototype） 其实就是一个普通的对象，它是其他对象的模板，被用于共享属性和方法。在 JavaScript 中，每个对象（除了null和undefined）都有一个与之关联的原型对象。\n\n那么对象是如何产生的呢？\n\n当我们使用new关键字调用构造函数时，会创建一个新的对象。这个新对象的原型会指向构造函数的prototype属性所指向的对象。\n\n例如，我们定义一个Person构造函数：\n\n```javascript\nfunction Person(name) {\n  this.name = name;\n}\n```\n\n当我们通过 `new Person(\"张三\")` 创建一个对象时，这个新对象的原型就是 *Person.prototype*。\n\n此外，我们还可以使用 `Object.create()` 方法来创建对象，这个方法会以传入的对象为原型来创建新的对象。比如 `Object.create(prototypeObj)`  创建的新对象，其原型就是 prototypeObj。\n\n## 原型链的用处\n原型链（Prototype Chain） 是由对象的原型串联起来形成的链式结构。当我们访问一个对象的属性或方法时，如果该对象本身没有这个属性或方法，JavaScript 就会沿着原型链向上查找，直到找到该属性或方法，或者到达原型链的顶端（null）。\n\n原型链的用处和好处主要有以下几点：\n\n**实现继承**：这是原型链最主要的作用。通过原型链，一个对象可以继承多个原型对象的属性和方法，实现了代码的复用。比如，子对象的原型指向父对象，子对象就可以使用父对象的属性和方法，当父对象的原型又指向其他对象时，就形成了更长的继承链。\n\n**节省内存空间**：由于多个对象可以共享同一个原型对象的属性和方法，不需要为每个对象都重复定义这些属性和方法，大大节省了内存。例如，所有通过同一个构造函数创建的对象，都会共享该构造函数prototype对象中的方法，而不是每个对象都拥有一份独立的方法副本。\n\n**动态扩展属性和方法**：我们可以在原型对象上动态地添加属性和方法，这些添加的属性和方法会立即被所有依赖该原型的对象所共享。比如，给 `Person.prototype` 添加一个 `sayHello` 方法，那么所有通过 *Person* 构造函数创建的对象都能立即使用这个 sayHello 方法。\n\n\n## 写在最后\n原型和原型链是 JavaScript 实现面向对象编程的核心机制，理解它们对于掌握 JavaScript 有着至关重要的意义。\n\n对于开发者而言，理解它们不仅是掌握 “继承”“内存优化” 等基础能力的关键，更是后续学习闭包、原型继承实战、甚至框架源码（如 Vue、React 中部分组件复用逻辑）的前提。","slug":"prototype-in-js","published":1,"updated":"2025-08-26T10:20:59.250Z","comments":1,"layout":"post","photos":[],"_id":"cmjbml2iv0049ikupbkyycq6o","content":"<p>在 JavaScript 的世界里，原型和原型链是绕不开的核心概念，它们构建了 JS 独特的继承机制，也让许多开发者既好奇又头疼。今天我们就从几个关键角度，一起揭开它们的神秘面纱。</p>\n<h2 id=\"基于类与基于原型：两种不同的编程范式\"><a href=\"#基于类与基于原型：两种不同的编程范式\" class=\"headerlink\" title=\"基于类与基于原型：两种不同的编程范式\"></a>基于类与基于原型：两种不同的编程范式</h2><p>在传统的面向对象编程语言中，比如 Java、C++，<strong>基于类（Class-based）</strong> 是主流的编程思想。在这种范式里，类就像是一个模具，它定义了对象所具有的属性和方法，而对象则是类的实例。我们必须先定义好类，然后通过new关键字来创建该类的对象，对象之间的关系是通过类的继承来确立的。</p>\n<p>而 JavaScript 则不同，它采用的是<strong>基于原型（Prototype-based）</strong> 的编程范式。在这种模式下，并没有严格意义上的类的概念（虽然 ES6 引入了class语法，但这只是语法糖，底层依然是基于原型实现的）。对象可以直接从其他对象继承属性和方法，我们可以把原型看作是一个模板对象，新创建的对象会以这个模板为基础，共享它的属性和方法。</p>\n<p>举个简单的例子，在基于类的编程中，我们先定义一个 “动物” 类，规定动物有 “名字” 属性和 “移动” 方法，然后 “猫” 类继承 “动物” 类，再创建 “猫” 类的实例。而在基于原型的 JavaScript 中，我们可以先创建一个 “动物” 对象作为原型，然后创建 “猫” 对象时，让它的原型指向 “动物” 对象，“猫” 对象就自然拥有了 “动物” 对象的属性和方法。</p>\n<h2 id=\"原型是啥，对象是如何产生的\"><a href=\"#原型是啥，对象是如何产生的\" class=\"headerlink\" title=\"原型是啥，对象是如何产生的\"></a>原型是啥，对象是如何产生的</h2><p>原型（Prototype） 其实就是一个普通的对象，它是其他对象的模板，被用于共享属性和方法。在 JavaScript 中，每个对象（除了null和undefined）都有一个与之关联的原型对象。</p>\n<p>那么对象是如何产生的呢？</p>\n<p>当我们使用new关键字调用构造函数时，会创建一个新的对象。这个新对象的原型会指向构造函数的prototype属性所指向的对象。</p>\n<p>例如，我们定义一个Person构造函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Person</span>(<span class=\"hljs-params\">name</span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>当我们通过 <code>new Person(&quot;张三&quot;)</code> 创建一个对象时，这个新对象的原型就是 <em>Person.prototype</em>。</p>\n<p>此外，我们还可以使用 <code>Object.create()</code> 方法来创建对象，这个方法会以传入的对象为原型来创建新的对象。比如 <code>Object.create(prototypeObj)</code>  创建的新对象，其原型就是 prototypeObj。</p>\n<h2 id=\"原型链的用处\"><a href=\"#原型链的用处\" class=\"headerlink\" title=\"原型链的用处\"></a>原型链的用处</h2><p>原型链（Prototype Chain） 是由对象的原型串联起来形成的链式结构。当我们访问一个对象的属性或方法时，如果该对象本身没有这个属性或方法，JavaScript 就会沿着原型链向上查找，直到找到该属性或方法，或者到达原型链的顶端（null）。</p>\n<p>原型链的用处和好处主要有以下几点：</p>\n<p><strong>实现继承</strong>：这是原型链最主要的作用。通过原型链，一个对象可以继承多个原型对象的属性和方法，实现了代码的复用。比如，子对象的原型指向父对象，子对象就可以使用父对象的属性和方法，当父对象的原型又指向其他对象时，就形成了更长的继承链。</p>\n<p><strong>节省内存空间</strong>：由于多个对象可以共享同一个原型对象的属性和方法，不需要为每个对象都重复定义这些属性和方法，大大节省了内存。例如，所有通过同一个构造函数创建的对象，都会共享该构造函数prototype对象中的方法，而不是每个对象都拥有一份独立的方法副本。</p>\n<p><strong>动态扩展属性和方法</strong>：我们可以在原型对象上动态地添加属性和方法，这些添加的属性和方法会立即被所有依赖该原型的对象所共享。比如，给 <code>Person.prototype</code> 添加一个 <code>sayHello</code> 方法，那么所有通过 <em>Person</em> 构造函数创建的对象都能立即使用这个 sayHello 方法。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>原型和原型链是 JavaScript 实现面向对象编程的核心机制，理解它们对于掌握 JavaScript 有着至关重要的意义。</p>\n<p>对于开发者而言，理解它们不仅是掌握 “继承”“内存优化” 等基础能力的关键，更是后续学习闭包、原型继承实战、甚至框架源码（如 Vue、React 中部分组件复用逻辑）的前提。</p>\n","excerpt":"","more":"<p>在 JavaScript 的世界里，原型和原型链是绕不开的核心概念，它们构建了 JS 独特的继承机制，也让许多开发者既好奇又头疼。今天我们就从几个关键角度，一起揭开它们的神秘面纱。</p>\n<h2 id=\"基于类与基于原型：两种不同的编程范式\"><a href=\"#基于类与基于原型：两种不同的编程范式\" class=\"headerlink\" title=\"基于类与基于原型：两种不同的编程范式\"></a>基于类与基于原型：两种不同的编程范式</h2><p>在传统的面向对象编程语言中，比如 Java、C++，<strong>基于类（Class-based）</strong> 是主流的编程思想。在这种范式里，类就像是一个模具，它定义了对象所具有的属性和方法，而对象则是类的实例。我们必须先定义好类，然后通过new关键字来创建该类的对象，对象之间的关系是通过类的继承来确立的。</p>\n<p>而 JavaScript 则不同，它采用的是<strong>基于原型（Prototype-based）</strong> 的编程范式。在这种模式下，并没有严格意义上的类的概念（虽然 ES6 引入了class语法，但这只是语法糖，底层依然是基于原型实现的）。对象可以直接从其他对象继承属性和方法，我们可以把原型看作是一个模板对象，新创建的对象会以这个模板为基础，共享它的属性和方法。</p>\n<p>举个简单的例子，在基于类的编程中，我们先定义一个 “动物” 类，规定动物有 “名字” 属性和 “移动” 方法，然后 “猫” 类继承 “动物” 类，再创建 “猫” 类的实例。而在基于原型的 JavaScript 中，我们可以先创建一个 “动物” 对象作为原型，然后创建 “猫” 对象时，让它的原型指向 “动物” 对象，“猫” 对象就自然拥有了 “动物” 对象的属性和方法。</p>\n<h2 id=\"原型是啥，对象是如何产生的\"><a href=\"#原型是啥，对象是如何产生的\" class=\"headerlink\" title=\"原型是啥，对象是如何产生的\"></a>原型是啥，对象是如何产生的</h2><p>原型（Prototype） 其实就是一个普通的对象，它是其他对象的模板，被用于共享属性和方法。在 JavaScript 中，每个对象（除了null和undefined）都有一个与之关联的原型对象。</p>\n<p>那么对象是如何产生的呢？</p>\n<p>当我们使用new关键字调用构造函数时，会创建一个新的对象。这个新对象的原型会指向构造函数的prototype属性所指向的对象。</p>\n<p>例如，我们定义一个Person构造函数：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">Person</span>(<span class=\"hljs-params\">name</span>) &#123;<br>  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">name</span> = name;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>当我们通过 <code>new Person(&quot;张三&quot;)</code> 创建一个对象时，这个新对象的原型就是 <em>Person.prototype</em>。</p>\n<p>此外，我们还可以使用 <code>Object.create()</code> 方法来创建对象，这个方法会以传入的对象为原型来创建新的对象。比如 <code>Object.create(prototypeObj)</code>  创建的新对象，其原型就是 prototypeObj。</p>\n<h2 id=\"原型链的用处\"><a href=\"#原型链的用处\" class=\"headerlink\" title=\"原型链的用处\"></a>原型链的用处</h2><p>原型链（Prototype Chain） 是由对象的原型串联起来形成的链式结构。当我们访问一个对象的属性或方法时，如果该对象本身没有这个属性或方法，JavaScript 就会沿着原型链向上查找，直到找到该属性或方法，或者到达原型链的顶端（null）。</p>\n<p>原型链的用处和好处主要有以下几点：</p>\n<p><strong>实现继承</strong>：这是原型链最主要的作用。通过原型链，一个对象可以继承多个原型对象的属性和方法，实现了代码的复用。比如，子对象的原型指向父对象，子对象就可以使用父对象的属性和方法，当父对象的原型又指向其他对象时，就形成了更长的继承链。</p>\n<p><strong>节省内存空间</strong>：由于多个对象可以共享同一个原型对象的属性和方法，不需要为每个对象都重复定义这些属性和方法，大大节省了内存。例如，所有通过同一个构造函数创建的对象，都会共享该构造函数prototype对象中的方法，而不是每个对象都拥有一份独立的方法副本。</p>\n<p><strong>动态扩展属性和方法</strong>：我们可以在原型对象上动态地添加属性和方法，这些添加的属性和方法会立即被所有依赖该原型的对象所共享。比如，给 <code>Person.prototype</code> 添加一个 <code>sayHello</code> 方法，那么所有通过 <em>Person</em> 构造函数创建的对象都能立即使用这个 sayHello 方法。</p>\n<h2 id=\"写在最后\"><a href=\"#写在最后\" class=\"headerlink\" title=\"写在最后\"></a>写在最后</h2><p>原型和原型链是 JavaScript 实现面向对象编程的核心机制，理解它们对于掌握 JavaScript 有着至关重要的意义。</p>\n<p>对于开发者而言，理解它们不仅是掌握 “继承”“内存优化” 等基础能力的关键，更是后续学习闭包、原型继承实战、甚至框架源码（如 Vue、React 中部分组件复用逻辑）的前提。</p>\n"},{"title":"Web开发这些年：从“小油条”到“老油条”的成长之路。","date":"2025-10-15T10:14:30.000Z","banner_img":"/imgs/baners/coding.jfif","index_img":"/imgs/baners/coding.jfif","_content":"做 Web 开发有些年头了，目前头发还算茂密，只是人已不再少年。​\n\n当年上班摸鱼都有负罪感的 “小油条”，如今也成了佛系的 “老油条”。​\n\n相似的业务代码写得越多，那种难以压抑的枯燥感就越强烈 —— 写这坨代码有什么用？像极了一个渣男，经历过一次次短暂的感情后，最终丢掉了最初初见佳人时的心动。​\n\n今天想简单聊聊个人能力提升那点事，以及自己是如何从 “小油条” 走到 “老油条” 这条路上的。​\n\n## 能力提升的两个关键期\n\n对于靠互联网开发谋生的程序员来说，我觉得有两个时期是个人能力提升的关键期。​\n\n### 初遇编程的 “热恋期”\n第一个关键期，自然是刚接触编程那会儿。对新事物的好奇，还有靠自己编程实现功能的喜悦，像磁石一样深深地吸引着你。\n\n想起自己刚开始做 Web 开发时，常常因为一些问题折腾到凌晨三四点。分析问题、上网查解决方案、修改验证，一遍又一遍。没有因一次次失败而沮丧，只有对一次次接近成功的欣喜。现在回想起来，都忍不住夸自己一句 “好小子”。​\n\n### 独挑项目的 “破茧期”\n第二个关键期，是需要独自负责一个项目开发的时候。2021 年去北京出差时，当时 Web 开发还处于 “炼气期” 的我，直接被甲方推上去负责一个项目的开发。那时候每天都特别焦虑 —— 没有外援帮忙，总怕把项目搞砸。所以白天赶业务进度，遇到问题先记下来，晚上再偷偷琢磨解决。那时候的状态，是既上进又心虚，总怕别人发现自己其实很 “菜”。​\n\n但随着项目慢慢进入收尾阶段，我不知不觉有了种顿悟的感觉 —— 人不焦虑了，遇到问题也不慌了，一股说不出的自信和踏实感涌上心头。​\n\n最意外的是，那个耗时两个多月的项目不仅如期交付，还在交付评估里拿了 A 评级。那天晚上甲方的庆功宴上，他们的一个测试领导大概是喝多了，搂着我脖子感慨：“多亏了你们啊！这项目总算过了，之前搞了两轮都没成……” 从那天起，我才算明白，这世界其实是个 “草台班子”。​\n\n## 成长的双重维度：能力与心态\n\n一个程序员的成长，主要体现在两个层面：能力和心态。​\n### 能力成长\n能力上的成长，能通过自学或参与项目开发获得 —— 只要人不懒、脑子还灵光，靠自己的努力，短时间内就能快速提升。关键是在学习和工作后要记录、思考、总结，形成自己的一套方法论，这样学新知识时才有方向，解决问题时也有思路。​\n\n### 心态成长\n心态上的成长，一方面依赖能力的提升，另一方面也受自身认知的影响。自己能力必须过硬，能完成开发任务、解决过程中遇到的问题，这是基本要求。要是能在技术上有点突破，那就更好了 —— 手里有 “刷子”，心里才踏实。​\n\n## 认知觉醒：走向 “老油条” 的起点\n至于认知，这一点老程序员比新手更有发言权。这世界真就是个 “草台班子”：你可以把一件事做得很完美，但没必要非追求完美。你觉得做得很烂的东西，别人说不定用得挺开心；你觉得自己做得很棒的东西，别人反倒觉得浮夸、没必要。​\n\n所以你会发现：公司里那些有想法、特别上进的，往往是想证明自己的新人；而老油条们，大多在一旁观望，盼着出点笑话。​\n\n而当你意识到这一点时，你就已经走在成为老油条的路上了。","source":"_posts/self-improve.md","raw":"---\ntitle: Web开发这些年：从“小油条”到“老油条”的成长之路。\ndate: 2025-10-15 18:14:30\ntags: 程序人生\nbanner_img: /imgs/baners/coding.jfif\nindex_img: /imgs/baners/coding.jfif\n---\n做 Web 开发有些年头了，目前头发还算茂密，只是人已不再少年。​\n\n当年上班摸鱼都有负罪感的 “小油条”，如今也成了佛系的 “老油条”。​\n\n相似的业务代码写得越多，那种难以压抑的枯燥感就越强烈 —— 写这坨代码有什么用？像极了一个渣男，经历过一次次短暂的感情后，最终丢掉了最初初见佳人时的心动。​\n\n今天想简单聊聊个人能力提升那点事，以及自己是如何从 “小油条” 走到 “老油条” 这条路上的。​\n\n## 能力提升的两个关键期\n\n对于靠互联网开发谋生的程序员来说，我觉得有两个时期是个人能力提升的关键期。​\n\n### 初遇编程的 “热恋期”\n第一个关键期，自然是刚接触编程那会儿。对新事物的好奇，还有靠自己编程实现功能的喜悦，像磁石一样深深地吸引着你。\n\n想起自己刚开始做 Web 开发时，常常因为一些问题折腾到凌晨三四点。分析问题、上网查解决方案、修改验证，一遍又一遍。没有因一次次失败而沮丧，只有对一次次接近成功的欣喜。现在回想起来，都忍不住夸自己一句 “好小子”。​\n\n### 独挑项目的 “破茧期”\n第二个关键期，是需要独自负责一个项目开发的时候。2021 年去北京出差时，当时 Web 开发还处于 “炼气期” 的我，直接被甲方推上去负责一个项目的开发。那时候每天都特别焦虑 —— 没有外援帮忙，总怕把项目搞砸。所以白天赶业务进度，遇到问题先记下来，晚上再偷偷琢磨解决。那时候的状态，是既上进又心虚，总怕别人发现自己其实很 “菜”。​\n\n但随着项目慢慢进入收尾阶段，我不知不觉有了种顿悟的感觉 —— 人不焦虑了，遇到问题也不慌了，一股说不出的自信和踏实感涌上心头。​\n\n最意外的是，那个耗时两个多月的项目不仅如期交付，还在交付评估里拿了 A 评级。那天晚上甲方的庆功宴上，他们的一个测试领导大概是喝多了，搂着我脖子感慨：“多亏了你们啊！这项目总算过了，之前搞了两轮都没成……” 从那天起，我才算明白，这世界其实是个 “草台班子”。​\n\n## 成长的双重维度：能力与心态\n\n一个程序员的成长，主要体现在两个层面：能力和心态。​\n### 能力成长\n能力上的成长，能通过自学或参与项目开发获得 —— 只要人不懒、脑子还灵光，靠自己的努力，短时间内就能快速提升。关键是在学习和工作后要记录、思考、总结，形成自己的一套方法论，这样学新知识时才有方向，解决问题时也有思路。​\n\n### 心态成长\n心态上的成长，一方面依赖能力的提升，另一方面也受自身认知的影响。自己能力必须过硬，能完成开发任务、解决过程中遇到的问题，这是基本要求。要是能在技术上有点突破，那就更好了 —— 手里有 “刷子”，心里才踏实。​\n\n## 认知觉醒：走向 “老油条” 的起点\n至于认知，这一点老程序员比新手更有发言权。这世界真就是个 “草台班子”：你可以把一件事做得很完美，但没必要非追求完美。你觉得做得很烂的东西，别人说不定用得挺开心；你觉得自己做得很棒的东西，别人反倒觉得浮夸、没必要。​\n\n所以你会发现：公司里那些有想法、特别上进的，往往是想证明自己的新人；而老油条们，大多在一旁观望，盼着出点笑话。​\n\n而当你意识到这一点时，你就已经走在成为老油条的路上了。","slug":"self-improve","published":1,"updated":"2025-10-28T13:41:40.182Z","comments":1,"layout":"post","photos":[],"_id":"cmjbml2iw004dikup86jd9uhd","content":"<p>做 Web 开发有些年头了，目前头发还算茂密，只是人已不再少年。​</p>\n<p>当年上班摸鱼都有负罪感的 “小油条”，如今也成了佛系的 “老油条”。​</p>\n<p>相似的业务代码写得越多，那种难以压抑的枯燥感就越强烈 —— 写这坨代码有什么用？像极了一个渣男，经历过一次次短暂的感情后，最终丢掉了最初初见佳人时的心动。​</p>\n<p>今天想简单聊聊个人能力提升那点事，以及自己是如何从 “小油条” 走到 “老油条” 这条路上的。​</p>\n<h2 id=\"能力提升的两个关键期\"><a href=\"#能力提升的两个关键期\" class=\"headerlink\" title=\"能力提升的两个关键期\"></a>能力提升的两个关键期</h2><p>对于靠互联网开发谋生的程序员来说，我觉得有两个时期是个人能力提升的关键期。​</p>\n<h3 id=\"初遇编程的-“热恋期”\"><a href=\"#初遇编程的-“热恋期”\" class=\"headerlink\" title=\"初遇编程的 “热恋期”\"></a>初遇编程的 “热恋期”</h3><p>第一个关键期，自然是刚接触编程那会儿。对新事物的好奇，还有靠自己编程实现功能的喜悦，像磁石一样深深地吸引着你。</p>\n<p>想起自己刚开始做 Web 开发时，常常因为一些问题折腾到凌晨三四点。分析问题、上网查解决方案、修改验证，一遍又一遍。没有因一次次失败而沮丧，只有对一次次接近成功的欣喜。现在回想起来，都忍不住夸自己一句 “好小子”。​</p>\n<h3 id=\"独挑项目的-“破茧期”\"><a href=\"#独挑项目的-“破茧期”\" class=\"headerlink\" title=\"独挑项目的 “破茧期”\"></a>独挑项目的 “破茧期”</h3><p>第二个关键期，是需要独自负责一个项目开发的时候。2021 年去北京出差时，当时 Web 开发还处于 “炼气期” 的我，直接被甲方推上去负责一个项目的开发。那时候每天都特别焦虑 —— 没有外援帮忙，总怕把项目搞砸。所以白天赶业务进度，遇到问题先记下来，晚上再偷偷琢磨解决。那时候的状态，是既上进又心虚，总怕别人发现自己其实很 “菜”。​</p>\n<p>但随着项目慢慢进入收尾阶段，我不知不觉有了种顿悟的感觉 —— 人不焦虑了，遇到问题也不慌了，一股说不出的自信和踏实感涌上心头。​</p>\n<p>最意外的是，那个耗时两个多月的项目不仅如期交付，还在交付评估里拿了 A 评级。那天晚上甲方的庆功宴上，他们的一个测试领导大概是喝多了，搂着我脖子感慨：“多亏了你们啊！这项目总算过了，之前搞了两轮都没成……” 从那天起，我才算明白，这世界其实是个 “草台班子”。​</p>\n<h2 id=\"成长的双重维度：能力与心态\"><a href=\"#成长的双重维度：能力与心态\" class=\"headerlink\" title=\"成长的双重维度：能力与心态\"></a>成长的双重维度：能力与心态</h2><p>一个程序员的成长，主要体现在两个层面：能力和心态。​</p>\n<h3 id=\"能力成长\"><a href=\"#能力成长\" class=\"headerlink\" title=\"能力成长\"></a>能力成长</h3><p>能力上的成长，能通过自学或参与项目开发获得 —— 只要人不懒、脑子还灵光，靠自己的努力，短时间内就能快速提升。关键是在学习和工作后要记录、思考、总结，形成自己的一套方法论，这样学新知识时才有方向，解决问题时也有思路。​</p>\n<h3 id=\"心态成长\"><a href=\"#心态成长\" class=\"headerlink\" title=\"心态成长\"></a>心态成长</h3><p>心态上的成长，一方面依赖能力的提升，另一方面也受自身认知的影响。自己能力必须过硬，能完成开发任务、解决过程中遇到的问题，这是基本要求。要是能在技术上有点突破，那就更好了 —— 手里有 “刷子”，心里才踏实。​</p>\n<h2 id=\"认知觉醒：走向-“老油条”-的起点\"><a href=\"#认知觉醒：走向-“老油条”-的起点\" class=\"headerlink\" title=\"认知觉醒：走向 “老油条” 的起点\"></a>认知觉醒：走向 “老油条” 的起点</h2><p>至于认知，这一点老程序员比新手更有发言权。这世界真就是个 “草台班子”：你可以把一件事做得很完美，但没必要非追求完美。你觉得做得很烂的东西，别人说不定用得挺开心；你觉得自己做得很棒的东西，别人反倒觉得浮夸、没必要。​</p>\n<p>所以你会发现：公司里那些有想法、特别上进的，往往是想证明自己的新人；而老油条们，大多在一旁观望，盼着出点笑话。​</p>\n<p>而当你意识到这一点时，你就已经走在成为老油条的路上了。</p>\n","excerpt":"","more":"<p>做 Web 开发有些年头了，目前头发还算茂密，只是人已不再少年。​</p>\n<p>当年上班摸鱼都有负罪感的 “小油条”，如今也成了佛系的 “老油条”。​</p>\n<p>相似的业务代码写得越多，那种难以压抑的枯燥感就越强烈 —— 写这坨代码有什么用？像极了一个渣男，经历过一次次短暂的感情后，最终丢掉了最初初见佳人时的心动。​</p>\n<p>今天想简单聊聊个人能力提升那点事，以及自己是如何从 “小油条” 走到 “老油条” 这条路上的。​</p>\n<h2 id=\"能力提升的两个关键期\"><a href=\"#能力提升的两个关键期\" class=\"headerlink\" title=\"能力提升的两个关键期\"></a>能力提升的两个关键期</h2><p>对于靠互联网开发谋生的程序员来说，我觉得有两个时期是个人能力提升的关键期。​</p>\n<h3 id=\"初遇编程的-“热恋期”\"><a href=\"#初遇编程的-“热恋期”\" class=\"headerlink\" title=\"初遇编程的 “热恋期”\"></a>初遇编程的 “热恋期”</h3><p>第一个关键期，自然是刚接触编程那会儿。对新事物的好奇，还有靠自己编程实现功能的喜悦，像磁石一样深深地吸引着你。</p>\n<p>想起自己刚开始做 Web 开发时，常常因为一些问题折腾到凌晨三四点。分析问题、上网查解决方案、修改验证，一遍又一遍。没有因一次次失败而沮丧，只有对一次次接近成功的欣喜。现在回想起来，都忍不住夸自己一句 “好小子”。​</p>\n<h3 id=\"独挑项目的-“破茧期”\"><a href=\"#独挑项目的-“破茧期”\" class=\"headerlink\" title=\"独挑项目的 “破茧期”\"></a>独挑项目的 “破茧期”</h3><p>第二个关键期，是需要独自负责一个项目开发的时候。2021 年去北京出差时，当时 Web 开发还处于 “炼气期” 的我，直接被甲方推上去负责一个项目的开发。那时候每天都特别焦虑 —— 没有外援帮忙，总怕把项目搞砸。所以白天赶业务进度，遇到问题先记下来，晚上再偷偷琢磨解决。那时候的状态，是既上进又心虚，总怕别人发现自己其实很 “菜”。​</p>\n<p>但随着项目慢慢进入收尾阶段，我不知不觉有了种顿悟的感觉 —— 人不焦虑了，遇到问题也不慌了，一股说不出的自信和踏实感涌上心头。​</p>\n<p>最意外的是，那个耗时两个多月的项目不仅如期交付，还在交付评估里拿了 A 评级。那天晚上甲方的庆功宴上，他们的一个测试领导大概是喝多了，搂着我脖子感慨：“多亏了你们啊！这项目总算过了，之前搞了两轮都没成……” 从那天起，我才算明白，这世界其实是个 “草台班子”。​</p>\n<h2 id=\"成长的双重维度：能力与心态\"><a href=\"#成长的双重维度：能力与心态\" class=\"headerlink\" title=\"成长的双重维度：能力与心态\"></a>成长的双重维度：能力与心态</h2><p>一个程序员的成长，主要体现在两个层面：能力和心态。​</p>\n<h3 id=\"能力成长\"><a href=\"#能力成长\" class=\"headerlink\" title=\"能力成长\"></a>能力成长</h3><p>能力上的成长，能通过自学或参与项目开发获得 —— 只要人不懒、脑子还灵光，靠自己的努力，短时间内就能快速提升。关键是在学习和工作后要记录、思考、总结，形成自己的一套方法论，这样学新知识时才有方向，解决问题时也有思路。​</p>\n<h3 id=\"心态成长\"><a href=\"#心态成长\" class=\"headerlink\" title=\"心态成长\"></a>心态成长</h3><p>心态上的成长，一方面依赖能力的提升，另一方面也受自身认知的影响。自己能力必须过硬，能完成开发任务、解决过程中遇到的问题，这是基本要求。要是能在技术上有点突破，那就更好了 —— 手里有 “刷子”，心里才踏实。​</p>\n<h2 id=\"认知觉醒：走向-“老油条”-的起点\"><a href=\"#认知觉醒：走向-“老油条”-的起点\" class=\"headerlink\" title=\"认知觉醒：走向 “老油条” 的起点\"></a>认知觉醒：走向 “老油条” 的起点</h2><p>至于认知，这一点老程序员比新手更有发言权。这世界真就是个 “草台班子”：你可以把一件事做得很完美，但没必要非追求完美。你觉得做得很烂的东西，别人说不定用得挺开心；你觉得自己做得很棒的东西，别人反倒觉得浮夸、没必要。​</p>\n<p>所以你会发现：公司里那些有想法、特别上进的，往往是想证明自己的新人；而老油条们，大多在一旁观望，盼着出点笑话。​</p>\n<p>而当你意识到这一点时，你就已经走在成为老油条的路上了。</p>\n"},{"title":"为什么 ES6 要新增 Set 和 Map？看完这篇就懂了","date":"2025-12-06T04:33:14.000Z","_content":"\n在ES6（ECMAScript 2015）的众多特性中，Set和Map两种新数据结构的引入，为JavaScript开发者提供了更灵活、高效的数据存储与处理方式。它们弥补了传统数组与对象的局限性，在处理唯一值、复杂键值对场景时展现出独特优势。\n\n今天我将从概念、特性、用法到实际应用，全面解析一下`Set`与`Map`。\n\n\n## Set：无重复值的集合\n\nSet是一种**无序的集合**，其核心特性是**成员唯一**——不会存储重复的值。这一特性使其在需要去重、判断存在性等场景中大放异彩。\n\n\n###  基本特性与创建方式\n\n- **创建Set**：通过`new Set()`构造函数创建，可接收一个**可迭代对象**（如数组、字符串）作为初始数据。\n- **核心属性**：`size`用于获取集合中成员的数量（类似数组的`length`）。\n\n```javascript\n// 空Set\nconst emptySet = new Set();\n\n// 从数组创建（自动去重）\nconst numSet = new Set([1, 2, 2, 3]); \nconsole.log(numSet.size); // 输出：3（重复的2被移除）\n\n// 从字符串创建（字符串是可迭代对象）\nconst strSet = new Set('hello'); \nconsole.log(strSet); // 输出：Set(4) { 'h', 'e', 'l', 'o' }（重复的'l'被移除）\n```\n\n\n###  核心方法\n\nSet提供了一套简洁的方法用于操作成员：\n\n- `add(value)`：添加成员，返回Set本身（可链式调用）。\n- `delete(value)`：删除指定成员，返回布尔值表示是否删除成功。\n- `has(value)`：判断是否包含指定成员，返回布尔值。\n- `clear()`：清空所有成员，无返回值。\n\n```javascript\nconst fruits = new Set();\n\n// 添加成员\nfruits.add('apple').add('banana').add('apple'); \nconsole.log(fruits); // 输出：Set(2) { 'apple', 'banana' }\n\n// 判断存在性\nconsole.log(fruits.has('banana')); // 输出：true\n\n// 删除成员\nconsole.log(fruits.delete('apple')); // 输出：true（删除成功）\nconsole.log(fruits); // 输出：Set(1) { 'banana' }\n\n// 清空\nfruits.clear();\nconsole.log(fruits.size); // 输出：0\n```\n\n\n### 遍历与值的比较规则\n\nSet是**可迭代对象**，支持多种遍历方式：\n\n- `forEach(callback)`：按插入顺序遍历，回调参数为`(value, key, set)`（注意：Set中`value`与`key`相同）。\n- `keys()`/`values()`：返回键/值的迭代器（因键值相同，两者行为一致）。\n- `entries()`：返回`[value, value]`形式的迭代器。\n\n```javascript\nconst colorSet = new Set(['red', 'green', 'blue']);\n\n// forEach遍历\ncolorSet.forEach((value, key) => {\n  console.log(`${key}: ${value}`); // 输出：red: red、green: green、blue: blue\n});\n\n// for...of遍历\nfor (const color of colorSet) {\n  console.log(color); // 输出：red、green、blue\n}\n```\n\n需要注意Set的**值比较规则**：与`===`类似，但有一个例外——`NaN`被视为与自身相等（而`===`中`NaN !== NaN`）。\n\n```javascript\nconst specialSet = new Set([NaN, NaN, 1, '1']);\nconsole.log(specialSet.size); // 输出：3（两个NaN被视为重复，1与'1'是不同值）\n```\n\n\n### 典型应用场景\n\n- **数组去重**：利用Set的唯一性，配合扩展运算符快速去重。\n\n```javascript\n  const arr = [1, 2, 2, 3, 3, 3];\n  const uniqueArr = [...new Set(arr)]; // 输出：[1, 2, 3]\n ```\n\n- **集合运算**：实现交集、并集、差集等数学集合操作。\n ```javascript\n  const setA = new Set([1, 2, 3]);\n  const setB = new Set([2, 3, 4]);\n\n  // 并集：A∪B\n  const union = new Set([...setA, ...setB]); // {1,2,3,4}\n\n  // 交集：A∩B\n  const intersection = new Set([...setA].filter(x => setB.has(x))); // {2,3}\n\n  // 差集：A-B\n  const difference = new Set([...setA].filter(x => !setB.has(x))); // {1}\n  ```\n\n- **存储唯一标识**：如用户ID、DOM节点等需要唯一存储的数据。\n\n\n## Map：键值对的高级实现\n\nMap是一种**有序的键值对集合**，与对象（Object）类似，但解决了对象作为键值对容器的诸多限制，尤其在键的类型灵活性上表现突出。\n\n\n###  基本特性与创建方式\n\n- **创建Map**：通过`new Map()`构造函数创建，可接收一个**二维数组**（每个子数组为`[key, value]`）作为初始数据。\n- **核心属性**：`size`用于获取键值对的数量。\n\n```javascript\n// 空Map\nconst emptyMap = new Map();\n\n// 从二维数组创建\nconst userMap = new Map([\n  ['name', 'Alice'],\n  [18, 'age'], // 键可以是数字\n  [() => {}, 'method'] // 键可以是函数\n]);\nconsole.log(userMap.size); // 输出：3\n```\n\n\n### 核心方法\n\nMap的方法围绕键值对的操作设计：\n\n- `set(key, value)`：添加键值对，返回Map本身（可链式调用）。\n- `get(key)`：获取指定键对应的值，若不存在返回`undefined`。\n- `delete(key)`：删除指定键值对，返回布尔值表示是否删除成功。\n- `has(key)`：判断是否包含指定键，返回布尔值。\n- `clear()`：清空所有键值对，无返回值。\n\n```javascript\nconst bookMap = new Map();\n\n// 添加键值对（键可以是任意类型）\nbookMap\n  .set('title', 'ES6 Guide')\n  .set(2023, 'publishYear')\n  .set({ author: 'Bob' }, 'info');\n\n// 获取值\nconsole.log(bookMap.get('title')); // 输出：'ES6 Guide'\nconsole.log(bookMap.get({ author: 'Bob' })); // 输出：undefined（对象引用不同）\n\n// 判断键是否存在\nconsole.log(bookMap.has(2023)); // 输出：true\n\n// 删除键值对\nbookMap.delete('title');\nconsole.log(bookMap.size); // 输出：2\n```\n\n\n### 遍历与键的比较规则\n\nMap同样是**可迭代对象**，且**按插入顺序遍历**，遍历方式包括：\n\n- `forEach(callback)`：回调参数为`(value, key, map)`。\n- `keys()`：返回键的迭代器。\n- `values()`：返回值的迭代器。\n- `entries()`：返回`[key, value]`形式的迭代器（默认迭代器）。\n\n```javascript\nconst langMap = new Map([['js', 'JavaScript'], ['py', 'Python']]);\n\n// forEach遍历\nlangMap.forEach((value, key) => {\n  console.log(`${key}: ${value}`); // 输出：js: JavaScript、py: Python\n});\n\n// 默认迭代器（entries()）\nfor (const [key, value] of langMap) {\n  console.log(`${key} → ${value}`); // 输出：js → JavaScript、py → Python\n}\n```\n\nMap的**键比较规则**与Set一致：`NaN`视为相等，对象键通过引用比较（不同引用的对象视为不同键）。\n\n\n### 典型应用场景\n\n- **复杂键值存储**：当键需要是对象、函数等非字符串类型时，Map是唯一选择。\n\n ```javascript\n  // 用DOM元素作为键存储数据（避免污染DOM属性）\n  const domMap = new Map();\n  const button = document.querySelector('button');\n  domMap.set(button, { clickCount: 0 });\n\n  // 点击时更新数据\n  button.addEventListener('click', () => {\n    const data = domMap.get(button);\n    data.clickCount++;\n    console.log(`点击次数：${data.clickCount}`);\n  });\n  ```\n\n- **需要保持键顺序的场景**：如配置项、有序缓存等（依赖插入顺序时更可靠）。\n\n- **频繁增删键值对**：相比对象，Map在动态修改时性能更稳定。\n\n\n## 总结：何时选择Set与Map？\n\nSet和Map作为ES6新增的数据结构，为JavaScript开发提供了更精准的工具：\n\n- **选择Set**：当需要存储**唯一值**，且重点关注“值是否存在”而非“键值关联”时（如去重、集合运算）。\n- **选择Map**：当需要**键值对映射**，且键的类型复杂（非字符串）、需要保持顺序或频繁修改时（如复杂状态管理、缓存）。\n\n**【往期精彩内容】**\n- [JavaScript进化论：ES6如何让函数编写更加简洁、高效？](https://mp.weixin.qq.com/s/haq8TFc_YJlPjeWdyXokQw)\n- [JavaScript ES6 中对象的拓展，你了解几个？](https://mp.weixin.qq.com/s/PTI3HGsfpDz4-GvRx0i9ew)\n- [Javascript高频面试点--ES6 数组新特性](https://mp.weixin.qq.com/s/qR65z8RbPFxW326UnogLqA)\n- [一文搞懂 JavaScript 里 var、let、const 的区别\n](https://mp.weixin.qq.com/s/lqn_51NNxx50YgvWkxCtEg)\n- [程序员如何打破职业瓶颈？先搬开这3块绊脚石。](https://mp.weixin.qq.com/s/DRpZXprnTndjKb1YMqsfjQ)\n\n\n","source":"_posts/set-map.md","raw":"---\ntitle: 为什么 ES6 要新增 Set 和 Map？看完这篇就懂了\ndate: 2025-12-06 12:33:14\ntags: JavaScript进阶, ES6进阶\ncategory: ES6进阶\n---\n\n在ES6（ECMAScript 2015）的众多特性中，Set和Map两种新数据结构的引入，为JavaScript开发者提供了更灵活、高效的数据存储与处理方式。它们弥补了传统数组与对象的局限性，在处理唯一值、复杂键值对场景时展现出独特优势。\n\n今天我将从概念、特性、用法到实际应用，全面解析一下`Set`与`Map`。\n\n\n## Set：无重复值的集合\n\nSet是一种**无序的集合**，其核心特性是**成员唯一**——不会存储重复的值。这一特性使其在需要去重、判断存在性等场景中大放异彩。\n\n\n###  基本特性与创建方式\n\n- **创建Set**：通过`new Set()`构造函数创建，可接收一个**可迭代对象**（如数组、字符串）作为初始数据。\n- **核心属性**：`size`用于获取集合中成员的数量（类似数组的`length`）。\n\n```javascript\n// 空Set\nconst emptySet = new Set();\n\n// 从数组创建（自动去重）\nconst numSet = new Set([1, 2, 2, 3]); \nconsole.log(numSet.size); // 输出：3（重复的2被移除）\n\n// 从字符串创建（字符串是可迭代对象）\nconst strSet = new Set('hello'); \nconsole.log(strSet); // 输出：Set(4) { 'h', 'e', 'l', 'o' }（重复的'l'被移除）\n```\n\n\n###  核心方法\n\nSet提供了一套简洁的方法用于操作成员：\n\n- `add(value)`：添加成员，返回Set本身（可链式调用）。\n- `delete(value)`：删除指定成员，返回布尔值表示是否删除成功。\n- `has(value)`：判断是否包含指定成员，返回布尔值。\n- `clear()`：清空所有成员，无返回值。\n\n```javascript\nconst fruits = new Set();\n\n// 添加成员\nfruits.add('apple').add('banana').add('apple'); \nconsole.log(fruits); // 输出：Set(2) { 'apple', 'banana' }\n\n// 判断存在性\nconsole.log(fruits.has('banana')); // 输出：true\n\n// 删除成员\nconsole.log(fruits.delete('apple')); // 输出：true（删除成功）\nconsole.log(fruits); // 输出：Set(1) { 'banana' }\n\n// 清空\nfruits.clear();\nconsole.log(fruits.size); // 输出：0\n```\n\n\n### 遍历与值的比较规则\n\nSet是**可迭代对象**，支持多种遍历方式：\n\n- `forEach(callback)`：按插入顺序遍历，回调参数为`(value, key, set)`（注意：Set中`value`与`key`相同）。\n- `keys()`/`values()`：返回键/值的迭代器（因键值相同，两者行为一致）。\n- `entries()`：返回`[value, value]`形式的迭代器。\n\n```javascript\nconst colorSet = new Set(['red', 'green', 'blue']);\n\n// forEach遍历\ncolorSet.forEach((value, key) => {\n  console.log(`${key}: ${value}`); // 输出：red: red、green: green、blue: blue\n});\n\n// for...of遍历\nfor (const color of colorSet) {\n  console.log(color); // 输出：red、green、blue\n}\n```\n\n需要注意Set的**值比较规则**：与`===`类似，但有一个例外——`NaN`被视为与自身相等（而`===`中`NaN !== NaN`）。\n\n```javascript\nconst specialSet = new Set([NaN, NaN, 1, '1']);\nconsole.log(specialSet.size); // 输出：3（两个NaN被视为重复，1与'1'是不同值）\n```\n\n\n### 典型应用场景\n\n- **数组去重**：利用Set的唯一性，配合扩展运算符快速去重。\n\n```javascript\n  const arr = [1, 2, 2, 3, 3, 3];\n  const uniqueArr = [...new Set(arr)]; // 输出：[1, 2, 3]\n ```\n\n- **集合运算**：实现交集、并集、差集等数学集合操作。\n ```javascript\n  const setA = new Set([1, 2, 3]);\n  const setB = new Set([2, 3, 4]);\n\n  // 并集：A∪B\n  const union = new Set([...setA, ...setB]); // {1,2,3,4}\n\n  // 交集：A∩B\n  const intersection = new Set([...setA].filter(x => setB.has(x))); // {2,3}\n\n  // 差集：A-B\n  const difference = new Set([...setA].filter(x => !setB.has(x))); // {1}\n  ```\n\n- **存储唯一标识**：如用户ID、DOM节点等需要唯一存储的数据。\n\n\n## Map：键值对的高级实现\n\nMap是一种**有序的键值对集合**，与对象（Object）类似，但解决了对象作为键值对容器的诸多限制，尤其在键的类型灵活性上表现突出。\n\n\n###  基本特性与创建方式\n\n- **创建Map**：通过`new Map()`构造函数创建，可接收一个**二维数组**（每个子数组为`[key, value]`）作为初始数据。\n- **核心属性**：`size`用于获取键值对的数量。\n\n```javascript\n// 空Map\nconst emptyMap = new Map();\n\n// 从二维数组创建\nconst userMap = new Map([\n  ['name', 'Alice'],\n  [18, 'age'], // 键可以是数字\n  [() => {}, 'method'] // 键可以是函数\n]);\nconsole.log(userMap.size); // 输出：3\n```\n\n\n### 核心方法\n\nMap的方法围绕键值对的操作设计：\n\n- `set(key, value)`：添加键值对，返回Map本身（可链式调用）。\n- `get(key)`：获取指定键对应的值，若不存在返回`undefined`。\n- `delete(key)`：删除指定键值对，返回布尔值表示是否删除成功。\n- `has(key)`：判断是否包含指定键，返回布尔值。\n- `clear()`：清空所有键值对，无返回值。\n\n```javascript\nconst bookMap = new Map();\n\n// 添加键值对（键可以是任意类型）\nbookMap\n  .set('title', 'ES6 Guide')\n  .set(2023, 'publishYear')\n  .set({ author: 'Bob' }, 'info');\n\n// 获取值\nconsole.log(bookMap.get('title')); // 输出：'ES6 Guide'\nconsole.log(bookMap.get({ author: 'Bob' })); // 输出：undefined（对象引用不同）\n\n// 判断键是否存在\nconsole.log(bookMap.has(2023)); // 输出：true\n\n// 删除键值对\nbookMap.delete('title');\nconsole.log(bookMap.size); // 输出：2\n```\n\n\n### 遍历与键的比较规则\n\nMap同样是**可迭代对象**，且**按插入顺序遍历**，遍历方式包括：\n\n- `forEach(callback)`：回调参数为`(value, key, map)`。\n- `keys()`：返回键的迭代器。\n- `values()`：返回值的迭代器。\n- `entries()`：返回`[key, value]`形式的迭代器（默认迭代器）。\n\n```javascript\nconst langMap = new Map([['js', 'JavaScript'], ['py', 'Python']]);\n\n// forEach遍历\nlangMap.forEach((value, key) => {\n  console.log(`${key}: ${value}`); // 输出：js: JavaScript、py: Python\n});\n\n// 默认迭代器（entries()）\nfor (const [key, value] of langMap) {\n  console.log(`${key} → ${value}`); // 输出：js → JavaScript、py → Python\n}\n```\n\nMap的**键比较规则**与Set一致：`NaN`视为相等，对象键通过引用比较（不同引用的对象视为不同键）。\n\n\n### 典型应用场景\n\n- **复杂键值存储**：当键需要是对象、函数等非字符串类型时，Map是唯一选择。\n\n ```javascript\n  // 用DOM元素作为键存储数据（避免污染DOM属性）\n  const domMap = new Map();\n  const button = document.querySelector('button');\n  domMap.set(button, { clickCount: 0 });\n\n  // 点击时更新数据\n  button.addEventListener('click', () => {\n    const data = domMap.get(button);\n    data.clickCount++;\n    console.log(`点击次数：${data.clickCount}`);\n  });\n  ```\n\n- **需要保持键顺序的场景**：如配置项、有序缓存等（依赖插入顺序时更可靠）。\n\n- **频繁增删键值对**：相比对象，Map在动态修改时性能更稳定。\n\n\n## 总结：何时选择Set与Map？\n\nSet和Map作为ES6新增的数据结构，为JavaScript开发提供了更精准的工具：\n\n- **选择Set**：当需要存储**唯一值**，且重点关注“值是否存在”而非“键值关联”时（如去重、集合运算）。\n- **选择Map**：当需要**键值对映射**，且键的类型复杂（非字符串）、需要保持顺序或频繁修改时（如复杂状态管理、缓存）。\n\n**【往期精彩内容】**\n- [JavaScript进化论：ES6如何让函数编写更加简洁、高效？](https://mp.weixin.qq.com/s/haq8TFc_YJlPjeWdyXokQw)\n- [JavaScript ES6 中对象的拓展，你了解几个？](https://mp.weixin.qq.com/s/PTI3HGsfpDz4-GvRx0i9ew)\n- [Javascript高频面试点--ES6 数组新特性](https://mp.weixin.qq.com/s/qR65z8RbPFxW326UnogLqA)\n- [一文搞懂 JavaScript 里 var、let、const 的区别\n](https://mp.weixin.qq.com/s/lqn_51NNxx50YgvWkxCtEg)\n- [程序员如何打破职业瓶颈？先搬开这3块绊脚石。](https://mp.weixin.qq.com/s/DRpZXprnTndjKb1YMqsfjQ)\n\n\n","slug":"set-map","published":1,"updated":"2025-12-06T04:47:41.766Z","comments":1,"layout":"post","photos":[],"_id":"cmjbml2iw004fikupbtna035n","content":"<p>在ES6（ECMAScript 2015）的众多特性中，Set和Map两种新数据结构的引入，为JavaScript开发者提供了更灵活、高效的数据存储与处理方式。它们弥补了传统数组与对象的局限性，在处理唯一值、复杂键值对场景时展现出独特优势。</p>\n<p>今天我将从概念、特性、用法到实际应用，全面解析一下<code>Set</code>与<code>Map</code>。</p>\n<h2 id=\"Set：无重复值的集合\"><a href=\"#Set：无重复值的集合\" class=\"headerlink\" title=\"Set：无重复值的集合\"></a>Set：无重复值的集合</h2><p>Set是一种<strong>无序的集合</strong>，其核心特性是<strong>成员唯一</strong>——不会存储重复的值。这一特性使其在需要去重、判断存在性等场景中大放异彩。</p>\n<h3 id=\"基本特性与创建方式\"><a href=\"#基本特性与创建方式\" class=\"headerlink\" title=\"基本特性与创建方式\"></a>基本特性与创建方式</h3><ul>\n<li><strong>创建Set</strong>：通过<code>new Set()</code>构造函数创建，可接收一个<strong>可迭代对象</strong>（如数组、字符串）作为初始数据。</li>\n<li><strong>核心属性</strong>：<code>size</code>用于获取集合中成员的数量（类似数组的<code>length</code>）。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 空Set</span><br><span class=\"hljs-keyword\">const</span> emptySet = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>();<br><br><span class=\"hljs-comment\">// 从数组创建（自动去重）</span><br><span class=\"hljs-keyword\">const</span> numSet = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]); <br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(numSet.<span class=\"hljs-property\">size</span>); <span class=\"hljs-comment\">// 输出：3（重复的2被移除）</span><br><br><span class=\"hljs-comment\">// 从字符串创建（字符串是可迭代对象）</span><br><span class=\"hljs-keyword\">const</span> strSet = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>(<span class=\"hljs-string\">&#x27;hello&#x27;</span>); <br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(strSet); <span class=\"hljs-comment\">// 输出：Set(4) &#123; &#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;o&#x27; &#125;（重复的&#x27;l&#x27;被移除）</span><br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"核心方法\"><a href=\"#核心方法\" class=\"headerlink\" title=\"核心方法\"></a>核心方法</h3><p>Set提供了一套简洁的方法用于操作成员：</p>\n<ul>\n<li><code>add(value)</code>：添加成员，返回Set本身（可链式调用）。</li>\n<li><code>delete(value)</code>：删除指定成员，返回布尔值表示是否删除成功。</li>\n<li><code>has(value)</code>：判断是否包含指定成员，返回布尔值。</li>\n<li><code>clear()</code>：清空所有成员，无返回值。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> fruits = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>();<br><br><span class=\"hljs-comment\">// 添加成员</span><br>fruits.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-string\">&#x27;apple&#x27;</span>).<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-string\">&#x27;banana&#x27;</span>).<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-string\">&#x27;apple&#x27;</span>); <br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(fruits); <span class=\"hljs-comment\">// 输出：Set(2) &#123; &#x27;apple&#x27;, &#x27;banana&#x27; &#125;</span><br><br><span class=\"hljs-comment\">// 判断存在性</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(fruits.<span class=\"hljs-title function_\">has</span>(<span class=\"hljs-string\">&#x27;banana&#x27;</span>)); <span class=\"hljs-comment\">// 输出：true</span><br><br><span class=\"hljs-comment\">// 删除成员</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(fruits.<span class=\"hljs-title function_\">delete</span>(<span class=\"hljs-string\">&#x27;apple&#x27;</span>)); <span class=\"hljs-comment\">// 输出：true（删除成功）</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(fruits); <span class=\"hljs-comment\">// 输出：Set(1) &#123; &#x27;banana&#x27; &#125;</span><br><br><span class=\"hljs-comment\">// 清空</span><br>fruits.<span class=\"hljs-title function_\">clear</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(fruits.<span class=\"hljs-property\">size</span>); <span class=\"hljs-comment\">// 输出：0</span><br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"遍历与值的比较规则\"><a href=\"#遍历与值的比较规则\" class=\"headerlink\" title=\"遍历与值的比较规则\"></a>遍历与值的比较规则</h3><p>Set是<strong>可迭代对象</strong>，支持多种遍历方式：</p>\n<ul>\n<li><code>forEach(callback)</code>：按插入顺序遍历，回调参数为<code>(value, key, set)</code>（注意：Set中<code>value</code>与<code>key</code>相同）。</li>\n<li><code>keys()</code>&#x2F;<code>values()</code>：返回键&#x2F;值的迭代器（因键值相同，两者行为一致）。</li>\n<li><code>entries()</code>：返回<code>[value, value]</code>形式的迭代器。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> colorSet = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-string\">&#x27;red&#x27;</span>, <span class=\"hljs-string\">&#x27;green&#x27;</span>, <span class=\"hljs-string\">&#x27;blue&#x27;</span>]);<br><br><span class=\"hljs-comment\">// forEach遍历</span><br>colorSet.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">value, key</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;key&#125;</span>: <span class=\"hljs-subst\">$&#123;value&#125;</span>`</span>); <span class=\"hljs-comment\">// 输出：red: red、green: green、blue: blue</span><br>&#125;);<br><br><span class=\"hljs-comment\">// for...of遍历</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> color <span class=\"hljs-keyword\">of</span> colorSet) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(color); <span class=\"hljs-comment\">// 输出：red、green、blue</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>需要注意Set的<strong>值比较规则</strong>：与<code>===</code>类似，但有一个例外——<code>NaN</code>被视为与自身相等（而<code>===</code>中<code>NaN !== NaN</code>）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> specialSet = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-title class_\">NaN</span>, <span class=\"hljs-title class_\">NaN</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&#x27;1&#x27;</span>]);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(specialSet.<span class=\"hljs-property\">size</span>); <span class=\"hljs-comment\">// 输出：3（两个NaN被视为重复，1与&#x27;1&#x27;是不同值）</span><br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"典型应用场景\"><a href=\"#典型应用场景\" class=\"headerlink\" title=\"典型应用场景\"></a>典型应用场景</h3><ul>\n<li><strong>数组去重</strong>：利用Set的唯一性，配合扩展运算符快速去重。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">3</span>];<br><span class=\"hljs-keyword\">const</span> uniqueArr = [...<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>(arr)]; <span class=\"hljs-comment\">// 输出：[1, 2, 3]</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong>集合运算</strong>：实现交集、并集、差集等数学集合操作。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> setA = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]);<br><span class=\"hljs-keyword\">const</span> setB = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>]);<br><br><span class=\"hljs-comment\">// 并集：A∪B</span><br><span class=\"hljs-keyword\">const</span> union = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([...setA, ...setB]); <span class=\"hljs-comment\">// &#123;1,2,3,4&#125;</span><br><br><span class=\"hljs-comment\">// 交集：A∩B</span><br><span class=\"hljs-keyword\">const</span> intersection = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([...setA].<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> setB.<span class=\"hljs-title function_\">has</span>(x))); <span class=\"hljs-comment\">// &#123;2,3&#125;</span><br><br><span class=\"hljs-comment\">// 差集：A-B</span><br><span class=\"hljs-keyword\">const</span> difference = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([...setA].<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> !setB.<span class=\"hljs-title function_\">has</span>(x))); <span class=\"hljs-comment\">// &#123;1&#125;</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>存储唯一标识</strong>：如用户ID、DOM节点等需要唯一存储的数据。</p>\n</li>\n</ul>\n<h2 id=\"Map：键值对的高级实现\"><a href=\"#Map：键值对的高级实现\" class=\"headerlink\" title=\"Map：键值对的高级实现\"></a>Map：键值对的高级实现</h2><p>Map是一种<strong>有序的键值对集合</strong>，与对象（Object）类似，但解决了对象作为键值对容器的诸多限制，尤其在键的类型灵活性上表现突出。</p>\n<h3 id=\"基本特性与创建方式-1\"><a href=\"#基本特性与创建方式-1\" class=\"headerlink\" title=\"基本特性与创建方式\"></a>基本特性与创建方式</h3><ul>\n<li><strong>创建Map</strong>：通过<code>new Map()</code>构造函数创建，可接收一个<strong>二维数组</strong>（每个子数组为<code>[key, value]</code>）作为初始数据。</li>\n<li><strong>核心属性</strong>：<code>size</code>用于获取键值对的数量。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 空Map</span><br><span class=\"hljs-keyword\">const</span> emptyMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();<br><br><span class=\"hljs-comment\">// 从二维数组创建</span><br><span class=\"hljs-keyword\">const</span> userMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([<br>  [<span class=\"hljs-string\">&#x27;name&#x27;</span>, <span class=\"hljs-string\">&#x27;Alice&#x27;</span>],<br>  [<span class=\"hljs-number\">18</span>, <span class=\"hljs-string\">&#x27;age&#x27;</span>], <span class=\"hljs-comment\">// 键可以是数字</span><br>  [<span class=\"hljs-function\">() =&gt;</span> &#123;&#125;, <span class=\"hljs-string\">&#x27;method&#x27;</span>] <span class=\"hljs-comment\">// 键可以是函数</span><br>]);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(userMap.<span class=\"hljs-property\">size</span>); <span class=\"hljs-comment\">// 输出：3</span><br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"核心方法-1\"><a href=\"#核心方法-1\" class=\"headerlink\" title=\"核心方法\"></a>核心方法</h3><p>Map的方法围绕键值对的操作设计：</p>\n<ul>\n<li><code>set(key, value)</code>：添加键值对，返回Map本身（可链式调用）。</li>\n<li><code>get(key)</code>：获取指定键对应的值，若不存在返回<code>undefined</code>。</li>\n<li><code>delete(key)</code>：删除指定键值对，返回布尔值表示是否删除成功。</li>\n<li><code>has(key)</code>：判断是否包含指定键，返回布尔值。</li>\n<li><code>clear()</code>：清空所有键值对，无返回值。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> bookMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();<br><br><span class=\"hljs-comment\">// 添加键值对（键可以是任意类型）</span><br>bookMap<br>  .<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;title&#x27;</span>, <span class=\"hljs-string\">&#x27;ES6 Guide&#x27;</span>)<br>  .<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-number\">2023</span>, <span class=\"hljs-string\">&#x27;publishYear&#x27;</span>)<br>  .<span class=\"hljs-title function_\">set</span>(&#123; <span class=\"hljs-attr\">author</span>: <span class=\"hljs-string\">&#x27;Bob&#x27;</span> &#125;, <span class=\"hljs-string\">&#x27;info&#x27;</span>);<br><br><span class=\"hljs-comment\">// 获取值</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(bookMap.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;title&#x27;</span>)); <span class=\"hljs-comment\">// 输出：&#x27;ES6 Guide&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(bookMap.<span class=\"hljs-title function_\">get</span>(&#123; <span class=\"hljs-attr\">author</span>: <span class=\"hljs-string\">&#x27;Bob&#x27;</span> &#125;)); <span class=\"hljs-comment\">// 输出：undefined（对象引用不同）</span><br><br><span class=\"hljs-comment\">// 判断键是否存在</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(bookMap.<span class=\"hljs-title function_\">has</span>(<span class=\"hljs-number\">2023</span>)); <span class=\"hljs-comment\">// 输出：true</span><br><br><span class=\"hljs-comment\">// 删除键值对</span><br>bookMap.<span class=\"hljs-title function_\">delete</span>(<span class=\"hljs-string\">&#x27;title&#x27;</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(bookMap.<span class=\"hljs-property\">size</span>); <span class=\"hljs-comment\">// 输出：2</span><br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"遍历与键的比较规则\"><a href=\"#遍历与键的比较规则\" class=\"headerlink\" title=\"遍历与键的比较规则\"></a>遍历与键的比较规则</h3><p>Map同样是<strong>可迭代对象</strong>，且<strong>按插入顺序遍历</strong>，遍历方式包括：</p>\n<ul>\n<li><code>forEach(callback)</code>：回调参数为<code>(value, key, map)</code>。</li>\n<li><code>keys()</code>：返回键的迭代器。</li>\n<li><code>values()</code>：返回值的迭代器。</li>\n<li><code>entries()</code>：返回<code>[key, value]</code>形式的迭代器（默认迭代器）。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> langMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([[<span class=\"hljs-string\">&#x27;js&#x27;</span>, <span class=\"hljs-string\">&#x27;JavaScript&#x27;</span>], [<span class=\"hljs-string\">&#x27;py&#x27;</span>, <span class=\"hljs-string\">&#x27;Python&#x27;</span>]]);<br><br><span class=\"hljs-comment\">// forEach遍历</span><br>langMap.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">value, key</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;key&#125;</span>: <span class=\"hljs-subst\">$&#123;value&#125;</span>`</span>); <span class=\"hljs-comment\">// 输出：js: JavaScript、py: Python</span><br>&#125;);<br><br><span class=\"hljs-comment\">// 默认迭代器（entries()）</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> [key, value] <span class=\"hljs-keyword\">of</span> langMap) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;key&#125;</span> → <span class=\"hljs-subst\">$&#123;value&#125;</span>`</span>); <span class=\"hljs-comment\">// 输出：js → JavaScript、py → Python</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>Map的<strong>键比较规则</strong>与Set一致：<code>NaN</code>视为相等，对象键通过引用比较（不同引用的对象视为不同键）。</p>\n<h3 id=\"典型应用场景-1\"><a href=\"#典型应用场景-1\" class=\"headerlink\" title=\"典型应用场景\"></a>典型应用场景</h3><ul>\n<li><strong>复杂键值存储</strong>：当键需要是对象、函数等非字符串类型时，Map是唯一选择。</li>\n</ul>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 用DOM元素作为键存储数据（避免污染DOM属性）</span><br><span class=\"hljs-keyword\">const</span> domMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();<br><span class=\"hljs-keyword\">const</span> button = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;button&#x27;</span>);<br>domMap.<span class=\"hljs-title function_\">set</span>(button, &#123; <span class=\"hljs-attr\">clickCount</span>: <span class=\"hljs-number\">0</span> &#125;);<br><br><span class=\"hljs-comment\">// 点击时更新数据</span><br>button.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;click&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> data = domMap.<span class=\"hljs-title function_\">get</span>(button);<br>  data.<span class=\"hljs-property\">clickCount</span>++;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`点击次数：<span class=\"hljs-subst\">$&#123;data.clickCount&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong>需要保持键顺序的场景</strong>：如配置项、有序缓存等（依赖插入顺序时更可靠）。</p>\n</li>\n<li><p><strong>频繁增删键值对</strong>：相比对象，Map在动态修改时性能更稳定。</p>\n</li>\n</ul>\n<h2 id=\"总结：何时选择Set与Map？\"><a href=\"#总结：何时选择Set与Map？\" class=\"headerlink\" title=\"总结：何时选择Set与Map？\"></a>总结：何时选择Set与Map？</h2><p>Set和Map作为ES6新增的数据结构，为JavaScript开发提供了更精准的工具：</p>\n<ul>\n<li><strong>选择Set</strong>：当需要存储<strong>唯一值</strong>，且重点关注“值是否存在”而非“键值关联”时（如去重、集合运算）。</li>\n<li><strong>选择Map</strong>：当需要<strong>键值对映射</strong>，且键的类型复杂（非字符串）、需要保持顺序或频繁修改时（如复杂状态管理、缓存）。</li>\n</ul>\n<p><strong>【往期精彩内容】</strong></p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/haq8TFc_YJlPjeWdyXokQw\">JavaScript进化论：ES6如何让函数编写更加简洁、高效？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/PTI3HGsfpDz4-GvRx0i9ew\">JavaScript ES6 中对象的拓展，你了解几个？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/qR65z8RbPFxW326UnogLqA\">Javascript高频面试点–ES6 数组新特性</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/lqn_51NNxx50YgvWkxCtEg\">一文搞懂 JavaScript 里 var、let、const 的区别\n</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/DRpZXprnTndjKb1YMqsfjQ\">程序员如何打破职业瓶颈？先搬开这3块绊脚石。</a></li>\n</ul>\n","excerpt":"","more":"<p>在ES6（ECMAScript 2015）的众多特性中，Set和Map两种新数据结构的引入，为JavaScript开发者提供了更灵活、高效的数据存储与处理方式。它们弥补了传统数组与对象的局限性，在处理唯一值、复杂键值对场景时展现出独特优势。</p>\n<p>今天我将从概念、特性、用法到实际应用，全面解析一下<code>Set</code>与<code>Map</code>。</p>\n<h2 id=\"Set：无重复值的集合\"><a href=\"#Set：无重复值的集合\" class=\"headerlink\" title=\"Set：无重复值的集合\"></a>Set：无重复值的集合</h2><p>Set是一种<strong>无序的集合</strong>，其核心特性是<strong>成员唯一</strong>——不会存储重复的值。这一特性使其在需要去重、判断存在性等场景中大放异彩。</p>\n<h3 id=\"基本特性与创建方式\"><a href=\"#基本特性与创建方式\" class=\"headerlink\" title=\"基本特性与创建方式\"></a>基本特性与创建方式</h3><ul>\n<li><strong>创建Set</strong>：通过<code>new Set()</code>构造函数创建，可接收一个<strong>可迭代对象</strong>（如数组、字符串）作为初始数据。</li>\n<li><strong>核心属性</strong>：<code>size</code>用于获取集合中成员的数量（类似数组的<code>length</code>）。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 空Set</span><br><span class=\"hljs-keyword\">const</span> emptySet = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>();<br><br><span class=\"hljs-comment\">// 从数组创建（自动去重）</span><br><span class=\"hljs-keyword\">const</span> numSet = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]); <br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(numSet.<span class=\"hljs-property\">size</span>); <span class=\"hljs-comment\">// 输出：3（重复的2被移除）</span><br><br><span class=\"hljs-comment\">// 从字符串创建（字符串是可迭代对象）</span><br><span class=\"hljs-keyword\">const</span> strSet = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>(<span class=\"hljs-string\">&#x27;hello&#x27;</span>); <br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(strSet); <span class=\"hljs-comment\">// 输出：Set(4) &#123; &#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;o&#x27; &#125;（重复的&#x27;l&#x27;被移除）</span><br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"核心方法\"><a href=\"#核心方法\" class=\"headerlink\" title=\"核心方法\"></a>核心方法</h3><p>Set提供了一套简洁的方法用于操作成员：</p>\n<ul>\n<li><code>add(value)</code>：添加成员，返回Set本身（可链式调用）。</li>\n<li><code>delete(value)</code>：删除指定成员，返回布尔值表示是否删除成功。</li>\n<li><code>has(value)</code>：判断是否包含指定成员，返回布尔值。</li>\n<li><code>clear()</code>：清空所有成员，无返回值。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> fruits = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>();<br><br><span class=\"hljs-comment\">// 添加成员</span><br>fruits.<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-string\">&#x27;apple&#x27;</span>).<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-string\">&#x27;banana&#x27;</span>).<span class=\"hljs-title function_\">add</span>(<span class=\"hljs-string\">&#x27;apple&#x27;</span>); <br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(fruits); <span class=\"hljs-comment\">// 输出：Set(2) &#123; &#x27;apple&#x27;, &#x27;banana&#x27; &#125;</span><br><br><span class=\"hljs-comment\">// 判断存在性</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(fruits.<span class=\"hljs-title function_\">has</span>(<span class=\"hljs-string\">&#x27;banana&#x27;</span>)); <span class=\"hljs-comment\">// 输出：true</span><br><br><span class=\"hljs-comment\">// 删除成员</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(fruits.<span class=\"hljs-title function_\">delete</span>(<span class=\"hljs-string\">&#x27;apple&#x27;</span>)); <span class=\"hljs-comment\">// 输出：true（删除成功）</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(fruits); <span class=\"hljs-comment\">// 输出：Set(1) &#123; &#x27;banana&#x27; &#125;</span><br><br><span class=\"hljs-comment\">// 清空</span><br>fruits.<span class=\"hljs-title function_\">clear</span>();<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(fruits.<span class=\"hljs-property\">size</span>); <span class=\"hljs-comment\">// 输出：0</span><br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"遍历与值的比较规则\"><a href=\"#遍历与值的比较规则\" class=\"headerlink\" title=\"遍历与值的比较规则\"></a>遍历与值的比较规则</h3><p>Set是<strong>可迭代对象</strong>，支持多种遍历方式：</p>\n<ul>\n<li><code>forEach(callback)</code>：按插入顺序遍历，回调参数为<code>(value, key, set)</code>（注意：Set中<code>value</code>与<code>key</code>相同）。</li>\n<li><code>keys()</code>&#x2F;<code>values()</code>：返回键&#x2F;值的迭代器（因键值相同，两者行为一致）。</li>\n<li><code>entries()</code>：返回<code>[value, value]</code>形式的迭代器。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> colorSet = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-string\">&#x27;red&#x27;</span>, <span class=\"hljs-string\">&#x27;green&#x27;</span>, <span class=\"hljs-string\">&#x27;blue&#x27;</span>]);<br><br><span class=\"hljs-comment\">// forEach遍历</span><br>colorSet.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">value, key</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;key&#125;</span>: <span class=\"hljs-subst\">$&#123;value&#125;</span>`</span>); <span class=\"hljs-comment\">// 输出：red: red、green: green、blue: blue</span><br>&#125;);<br><br><span class=\"hljs-comment\">// for...of遍历</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> color <span class=\"hljs-keyword\">of</span> colorSet) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(color); <span class=\"hljs-comment\">// 输出：red、green、blue</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>需要注意Set的<strong>值比较规则</strong>：与<code>===</code>类似，但有一个例外——<code>NaN</code>被视为与自身相等（而<code>===</code>中<code>NaN !== NaN</code>）。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> specialSet = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-title class_\">NaN</span>, <span class=\"hljs-title class_\">NaN</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&#x27;1&#x27;</span>]);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(specialSet.<span class=\"hljs-property\">size</span>); <span class=\"hljs-comment\">// 输出：3（两个NaN被视为重复，1与&#x27;1&#x27;是不同值）</span><br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"典型应用场景\"><a href=\"#典型应用场景\" class=\"headerlink\" title=\"典型应用场景\"></a>典型应用场景</h3><ul>\n<li><strong>数组去重</strong>：利用Set的唯一性，配合扩展运算符快速去重。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> arr = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">3</span>];<br><span class=\"hljs-keyword\">const</span> uniqueArr = [...<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>(arr)]; <span class=\"hljs-comment\">// 输出：[1, 2, 3]</span><br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong>集合运算</strong>：实现交集、并集、差集等数学集合操作。</p>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> setA = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]);<br><span class=\"hljs-keyword\">const</span> setB = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>]);<br><br><span class=\"hljs-comment\">// 并集：A∪B</span><br><span class=\"hljs-keyword\">const</span> union = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([...setA, ...setB]); <span class=\"hljs-comment\">// &#123;1,2,3,4&#125;</span><br><br><span class=\"hljs-comment\">// 交集：A∩B</span><br><span class=\"hljs-keyword\">const</span> intersection = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([...setA].<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> setB.<span class=\"hljs-title function_\">has</span>(x))); <span class=\"hljs-comment\">// &#123;2,3&#125;</span><br><br><span class=\"hljs-comment\">// 差集：A-B</span><br><span class=\"hljs-keyword\">const</span> difference = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>([...setA].<span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">x</span> =&gt;</span> !setB.<span class=\"hljs-title function_\">has</span>(x))); <span class=\"hljs-comment\">// &#123;1&#125;</span><br></code></pre></td></tr></table></figure>\n</li>\n<li><p><strong>存储唯一标识</strong>：如用户ID、DOM节点等需要唯一存储的数据。</p>\n</li>\n</ul>\n<h2 id=\"Map：键值对的高级实现\"><a href=\"#Map：键值对的高级实现\" class=\"headerlink\" title=\"Map：键值对的高级实现\"></a>Map：键值对的高级实现</h2><p>Map是一种<strong>有序的键值对集合</strong>，与对象（Object）类似，但解决了对象作为键值对容器的诸多限制，尤其在键的类型灵活性上表现突出。</p>\n<h3 id=\"基本特性与创建方式-1\"><a href=\"#基本特性与创建方式-1\" class=\"headerlink\" title=\"基本特性与创建方式\"></a>基本特性与创建方式</h3><ul>\n<li><strong>创建Map</strong>：通过<code>new Map()</code>构造函数创建，可接收一个<strong>二维数组</strong>（每个子数组为<code>[key, value]</code>）作为初始数据。</li>\n<li><strong>核心属性</strong>：<code>size</code>用于获取键值对的数量。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 空Map</span><br><span class=\"hljs-keyword\">const</span> emptyMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();<br><br><span class=\"hljs-comment\">// 从二维数组创建</span><br><span class=\"hljs-keyword\">const</span> userMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([<br>  [<span class=\"hljs-string\">&#x27;name&#x27;</span>, <span class=\"hljs-string\">&#x27;Alice&#x27;</span>],<br>  [<span class=\"hljs-number\">18</span>, <span class=\"hljs-string\">&#x27;age&#x27;</span>], <span class=\"hljs-comment\">// 键可以是数字</span><br>  [<span class=\"hljs-function\">() =&gt;</span> &#123;&#125;, <span class=\"hljs-string\">&#x27;method&#x27;</span>] <span class=\"hljs-comment\">// 键可以是函数</span><br>]);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(userMap.<span class=\"hljs-property\">size</span>); <span class=\"hljs-comment\">// 输出：3</span><br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"核心方法-1\"><a href=\"#核心方法-1\" class=\"headerlink\" title=\"核心方法\"></a>核心方法</h3><p>Map的方法围绕键值对的操作设计：</p>\n<ul>\n<li><code>set(key, value)</code>：添加键值对，返回Map本身（可链式调用）。</li>\n<li><code>get(key)</code>：获取指定键对应的值，若不存在返回<code>undefined</code>。</li>\n<li><code>delete(key)</code>：删除指定键值对，返回布尔值表示是否删除成功。</li>\n<li><code>has(key)</code>：判断是否包含指定键，返回布尔值。</li>\n<li><code>clear()</code>：清空所有键值对，无返回值。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> bookMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();<br><br><span class=\"hljs-comment\">// 添加键值对（键可以是任意类型）</span><br>bookMap<br>  .<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-string\">&#x27;title&#x27;</span>, <span class=\"hljs-string\">&#x27;ES6 Guide&#x27;</span>)<br>  .<span class=\"hljs-title function_\">set</span>(<span class=\"hljs-number\">2023</span>, <span class=\"hljs-string\">&#x27;publishYear&#x27;</span>)<br>  .<span class=\"hljs-title function_\">set</span>(&#123; <span class=\"hljs-attr\">author</span>: <span class=\"hljs-string\">&#x27;Bob&#x27;</span> &#125;, <span class=\"hljs-string\">&#x27;info&#x27;</span>);<br><br><span class=\"hljs-comment\">// 获取值</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(bookMap.<span class=\"hljs-title function_\">get</span>(<span class=\"hljs-string\">&#x27;title&#x27;</span>)); <span class=\"hljs-comment\">// 输出：&#x27;ES6 Guide&#x27;</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(bookMap.<span class=\"hljs-title function_\">get</span>(&#123; <span class=\"hljs-attr\">author</span>: <span class=\"hljs-string\">&#x27;Bob&#x27;</span> &#125;)); <span class=\"hljs-comment\">// 输出：undefined（对象引用不同）</span><br><br><span class=\"hljs-comment\">// 判断键是否存在</span><br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(bookMap.<span class=\"hljs-title function_\">has</span>(<span class=\"hljs-number\">2023</span>)); <span class=\"hljs-comment\">// 输出：true</span><br><br><span class=\"hljs-comment\">// 删除键值对</span><br>bookMap.<span class=\"hljs-title function_\">delete</span>(<span class=\"hljs-string\">&#x27;title&#x27;</span>);<br><span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(bookMap.<span class=\"hljs-property\">size</span>); <span class=\"hljs-comment\">// 输出：2</span><br></code></pre></td></tr></table></figure>\n\n\n<h3 id=\"遍历与键的比较规则\"><a href=\"#遍历与键的比较规则\" class=\"headerlink\" title=\"遍历与键的比较规则\"></a>遍历与键的比较规则</h3><p>Map同样是<strong>可迭代对象</strong>，且<strong>按插入顺序遍历</strong>，遍历方式包括：</p>\n<ul>\n<li><code>forEach(callback)</code>：回调参数为<code>(value, key, map)</code>。</li>\n<li><code>keys()</code>：返回键的迭代器。</li>\n<li><code>values()</code>：返回值的迭代器。</li>\n<li><code>entries()</code>：返回<code>[key, value]</code>形式的迭代器（默认迭代器）。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">const</span> langMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>([[<span class=\"hljs-string\">&#x27;js&#x27;</span>, <span class=\"hljs-string\">&#x27;JavaScript&#x27;</span>], [<span class=\"hljs-string\">&#x27;py&#x27;</span>, <span class=\"hljs-string\">&#x27;Python&#x27;</span>]]);<br><br><span class=\"hljs-comment\">// forEach遍历</span><br>langMap.<span class=\"hljs-title function_\">forEach</span>(<span class=\"hljs-function\">(<span class=\"hljs-params\">value, key</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;key&#125;</span>: <span class=\"hljs-subst\">$&#123;value&#125;</span>`</span>); <span class=\"hljs-comment\">// 输出：js: JavaScript、py: Python</span><br>&#125;);<br><br><span class=\"hljs-comment\">// 默认迭代器（entries()）</span><br><span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> [key, value] <span class=\"hljs-keyword\">of</span> langMap) &#123;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`<span class=\"hljs-subst\">$&#123;key&#125;</span> → <span class=\"hljs-subst\">$&#123;value&#125;</span>`</span>); <span class=\"hljs-comment\">// 输出：js → JavaScript、py → Python</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>Map的<strong>键比较规则</strong>与Set一致：<code>NaN</code>视为相等，对象键通过引用比较（不同引用的对象视为不同键）。</p>\n<h3 id=\"典型应用场景-1\"><a href=\"#典型应用场景-1\" class=\"headerlink\" title=\"典型应用场景\"></a>典型应用场景</h3><ul>\n<li><strong>复杂键值存储</strong>：当键需要是对象、函数等非字符串类型时，Map是唯一选择。</li>\n</ul>\n <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-comment\">// 用DOM元素作为键存储数据（避免污染DOM属性）</span><br><span class=\"hljs-keyword\">const</span> domMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Map</span>();<br><span class=\"hljs-keyword\">const</span> button = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;button&#x27;</span>);<br>domMap.<span class=\"hljs-title function_\">set</span>(button, &#123; <span class=\"hljs-attr\">clickCount</span>: <span class=\"hljs-number\">0</span> &#125;);<br><br><span class=\"hljs-comment\">// 点击时更新数据</span><br>button.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;click&#x27;</span>, <span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-keyword\">const</span> data = domMap.<span class=\"hljs-title function_\">get</span>(button);<br>  data.<span class=\"hljs-property\">clickCount</span>++;<br>  <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-string\">`点击次数：<span class=\"hljs-subst\">$&#123;data.clickCount&#125;</span>`</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li><p><strong>需要保持键顺序的场景</strong>：如配置项、有序缓存等（依赖插入顺序时更可靠）。</p>\n</li>\n<li><p><strong>频繁增删键值对</strong>：相比对象，Map在动态修改时性能更稳定。</p>\n</li>\n</ul>\n<h2 id=\"总结：何时选择Set与Map？\"><a href=\"#总结：何时选择Set与Map？\" class=\"headerlink\" title=\"总结：何时选择Set与Map？\"></a>总结：何时选择Set与Map？</h2><p>Set和Map作为ES6新增的数据结构，为JavaScript开发提供了更精准的工具：</p>\n<ul>\n<li><strong>选择Set</strong>：当需要存储<strong>唯一值</strong>，且重点关注“值是否存在”而非“键值关联”时（如去重、集合运算）。</li>\n<li><strong>选择Map</strong>：当需要<strong>键值对映射</strong>，且键的类型复杂（非字符串）、需要保持顺序或频繁修改时（如复杂状态管理、缓存）。</li>\n</ul>\n<p><strong>【往期精彩内容】</strong></p>\n<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/haq8TFc_YJlPjeWdyXokQw\">JavaScript进化论：ES6如何让函数编写更加简洁、高效？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/PTI3HGsfpDz4-GvRx0i9ew\">JavaScript ES6 中对象的拓展，你了解几个？</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/qR65z8RbPFxW326UnogLqA\">Javascript高频面试点–ES6 数组新特性</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/lqn_51NNxx50YgvWkxCtEg\">一文搞懂 JavaScript 里 var、let、const 的区别\n</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/DRpZXprnTndjKb1YMqsfjQ\">程序员如何打破职业瓶颈？先搬开这3块绊脚石。</a></li>\n</ul>\n"},{"title":"Vue vs React 多维度剖析: 哪一个更适合大型项目？","date":"2025-08-08T00:05:44.000Z","keywords":["Vue","React"],"banner_img":"/imgs/react-vs-vue/react-vs-vue.png","index_img":"/imgs/react-vs-vue/react-vs-vue.png","_content":"\nVue 和 React 作为前端开发框架中的两个扛把子，在日常的开发工作中我们需要频繁的与它们打交道。Vue 和 React 都是成熟的前端框架，都能胜任大型项目开发，但它们的设计理念、生态特点和适用场景存在差异。\n\n今天让我们先抛开写 React 更高级这种莫名奇妙的优越感，来唠一唠哪一个更适合大型项目。\n\n\n## 架构设计与可维护性\n\n大型项目的核心挑战之一是代码组织的可维护性，尤其是随着团队规模和代码量增长，需要清晰的架构规范，否则逃不过屎山代码的命运。\n\nReact采用了 `函数式组件 + JSX`的设计，强调 `组件化` 和 `单向数据流`, 灵活性极高。对于一些复杂逻辑，它可以使用 `Hooks` （如 `useState`、`useReducer`, `useContext`）或自定义 Hooks 来拆分代码。\n\n\n它本身并不强制特定架构，所以使用 React 开发需要开发团队自行制定规范（如目录结构，状态管理方案），因此更适合有经验的团队灵活设计符合项目需求的架构。\n\n![vue sfc](https://www.jvxiao.cn/imgs/react-vs-vue/vue-sfc.png)\n\n\nVue 采用的是 `模板 + 脚本 + 样式`的单文件组件（SFC），说白了就是这么写我定好了，你们按照我这个格式来写就 OK 了。不要问为什么，问就是海龟的屁股-龟腚。\n\nVue3 的 Composition Api 解决了 Vue2 中 Options Api 在大型项目中逻辑复用的痛点，支持按功能拆分，有点类似 React Hooks。\n\n\n## 状态管理与复杂逻辑\n\n大型项目往往涉及复杂的全局状态管理（如用户信息、权限、多模块数据交互）。\n\nReact 本身不内置状态管理方案，依赖生态中的第三方库，复杂场景可选择 Redux，Zustand（轻量灵活）、Recoil（专注原子化状态）等。\n\n![vue state](https://www.jvxiao.cn/imgs/react-vs-vue/state.png)\n\n\nVue 在这一块官方提供了完整的状态管理方案，Vue 2 中常用 Vuex，Vue 3 中已升级为 Pinia，集成和使用起来都很方便。\n\n从个人过往编程体验上来说，Vue 的状态管理在开发过程中会比 React 舒服很多。\n\n## 类型支持与工程化\n\n无论是主动升级还是被动升级，现在越来越多的项目都在使用 Typescript 来替代 JavaScript, 同时还配备工程化工具链，以减少运行时错误和提升开发效率。\n\nReact 与 TypeScript 集成极为成熟，从框架到生态库（如 React Router、Redux）都有完善的类型定义。函数式组件和 Hooks 天然适合 TypeScript 的类型推断，复杂场景下的类型定义更直观。\n\n![react-typescript](https://www.jvxiao.cn/imgs/react-vs-vue/react-typescript.png)\n\n\n此外， React 的工程化工具链也很丰富。如 Create React App、Next.js 等，适合复杂项目的工程化需求。\n\nVue 的话 Vue3 版本是使用 Typescript重写的，在类型支持大幅提升，但完善度略逊于 React。\n\n它的官方工具链Vite、Vue Router、Pinia）的类型集成无缝，且 Vite 的开发体验（热更新速度）在大型项目中优势明显。\n\n## 团队与学习成本\n\n大型项目通常由多团队协作，框架的学习曲线和团队熟悉度会直接影响开发效率。\n\n就目前开发者对两者的评价来说，React 的学习曲线还是比较陡峭的，尤其是JSX 语法、函数式编程思想（纯函数、不可变数据）对新手有一定门槛，但掌握后灵活性极高。\n\n![learning-curves](https://www.jvxiao.cn/imgs/react-vs-vue/learning-curves.jpg)\n\n\nVue 在学习曲线上对新手算是非常友好的，学习曲线平缓，模板语法接近 HTML。 其官方文档被称为 “前端最佳文档”，降低了团队培训成本，适合成员技术背景多样的大型团队。\n\n\n## 写在最后：如何选择？\n\n虽然很多时候，使用哪一个框架的选择权不在自己手上，但是，你得懂怎么选不是？\n\n如果说一个团队中有较多新手，或者团队整体水平差距较大，亦或者项目追求开发效率和低决策成本，那么 Vue 自然是首选了。\n\n如果项目需要高度定制化架构、强 TypeScript 集成、跨平台开发（Web + 移动端），或团队有丰富的 JavaScript / 函数式编程经验, 那么 选择 React 优先于 Vue。\n\n用一句很有哲理的话作为结束语吧：无论你怎么选，你都会遗憾。\n\n","source":"_posts/vue-vs-react.md","raw":"---\ntitle: 'Vue vs React 多维度剖析: 哪一个更适合大型项目？'\ndate: 2025-08-08 08:05:44\ntags: [Vue, React]\nkeywords: [Vue, React]\nbanner_img: /imgs/react-vs-vue/react-vs-vue.png\nindex_img: /imgs/react-vs-vue/react-vs-vue.png\n---\n\nVue 和 React 作为前端开发框架中的两个扛把子，在日常的开发工作中我们需要频繁的与它们打交道。Vue 和 React 都是成熟的前端框架，都能胜任大型项目开发，但它们的设计理念、生态特点和适用场景存在差异。\n\n今天让我们先抛开写 React 更高级这种莫名奇妙的优越感，来唠一唠哪一个更适合大型项目。\n\n\n## 架构设计与可维护性\n\n大型项目的核心挑战之一是代码组织的可维护性，尤其是随着团队规模和代码量增长，需要清晰的架构规范，否则逃不过屎山代码的命运。\n\nReact采用了 `函数式组件 + JSX`的设计，强调 `组件化` 和 `单向数据流`, 灵活性极高。对于一些复杂逻辑，它可以使用 `Hooks` （如 `useState`、`useReducer`, `useContext`）或自定义 Hooks 来拆分代码。\n\n\n它本身并不强制特定架构，所以使用 React 开发需要开发团队自行制定规范（如目录结构，状态管理方案），因此更适合有经验的团队灵活设计符合项目需求的架构。\n\n![vue sfc](https://www.jvxiao.cn/imgs/react-vs-vue/vue-sfc.png)\n\n\nVue 采用的是 `模板 + 脚本 + 样式`的单文件组件（SFC），说白了就是这么写我定好了，你们按照我这个格式来写就 OK 了。不要问为什么，问就是海龟的屁股-龟腚。\n\nVue3 的 Composition Api 解决了 Vue2 中 Options Api 在大型项目中逻辑复用的痛点，支持按功能拆分，有点类似 React Hooks。\n\n\n## 状态管理与复杂逻辑\n\n大型项目往往涉及复杂的全局状态管理（如用户信息、权限、多模块数据交互）。\n\nReact 本身不内置状态管理方案，依赖生态中的第三方库，复杂场景可选择 Redux，Zustand（轻量灵活）、Recoil（专注原子化状态）等。\n\n![vue state](https://www.jvxiao.cn/imgs/react-vs-vue/state.png)\n\n\nVue 在这一块官方提供了完整的状态管理方案，Vue 2 中常用 Vuex，Vue 3 中已升级为 Pinia，集成和使用起来都很方便。\n\n从个人过往编程体验上来说，Vue 的状态管理在开发过程中会比 React 舒服很多。\n\n## 类型支持与工程化\n\n无论是主动升级还是被动升级，现在越来越多的项目都在使用 Typescript 来替代 JavaScript, 同时还配备工程化工具链，以减少运行时错误和提升开发效率。\n\nReact 与 TypeScript 集成极为成熟，从框架到生态库（如 React Router、Redux）都有完善的类型定义。函数式组件和 Hooks 天然适合 TypeScript 的类型推断，复杂场景下的类型定义更直观。\n\n![react-typescript](https://www.jvxiao.cn/imgs/react-vs-vue/react-typescript.png)\n\n\n此外， React 的工程化工具链也很丰富。如 Create React App、Next.js 等，适合复杂项目的工程化需求。\n\nVue 的话 Vue3 版本是使用 Typescript重写的，在类型支持大幅提升，但完善度略逊于 React。\n\n它的官方工具链Vite、Vue Router、Pinia）的类型集成无缝，且 Vite 的开发体验（热更新速度）在大型项目中优势明显。\n\n## 团队与学习成本\n\n大型项目通常由多团队协作，框架的学习曲线和团队熟悉度会直接影响开发效率。\n\n就目前开发者对两者的评价来说，React 的学习曲线还是比较陡峭的，尤其是JSX 语法、函数式编程思想（纯函数、不可变数据）对新手有一定门槛，但掌握后灵活性极高。\n\n![learning-curves](https://www.jvxiao.cn/imgs/react-vs-vue/learning-curves.jpg)\n\n\nVue 在学习曲线上对新手算是非常友好的，学习曲线平缓，模板语法接近 HTML。 其官方文档被称为 “前端最佳文档”，降低了团队培训成本，适合成员技术背景多样的大型团队。\n\n\n## 写在最后：如何选择？\n\n虽然很多时候，使用哪一个框架的选择权不在自己手上，但是，你得懂怎么选不是？\n\n如果说一个团队中有较多新手，或者团队整体水平差距较大，亦或者项目追求开发效率和低决策成本，那么 Vue 自然是首选了。\n\n如果项目需要高度定制化架构、强 TypeScript 集成、跨平台开发（Web + 移动端），或团队有丰富的 JavaScript / 函数式编程经验, 那么 选择 React 优先于 Vue。\n\n用一句很有哲理的话作为结束语吧：无论你怎么选，你都会遗憾。\n\n","slug":"vue-vs-react","published":1,"updated":"2025-08-26T10:34:44.957Z","comments":1,"layout":"post","photos":[],"_id":"cmjbml2ix004jikup8j8qhcjo","content":"<p>Vue 和 React 作为前端开发框架中的两个扛把子，在日常的开发工作中我们需要频繁的与它们打交道。Vue 和 React 都是成熟的前端框架，都能胜任大型项目开发，但它们的设计理念、生态特点和适用场景存在差异。</p>\n<p>今天让我们先抛开写 React 更高级这种莫名奇妙的优越感，来唠一唠哪一个更适合大型项目。</p>\n<h2 id=\"架构设计与可维护性\"><a href=\"#架构设计与可维护性\" class=\"headerlink\" title=\"架构设计与可维护性\"></a>架构设计与可维护性</h2><p>大型项目的核心挑战之一是代码组织的可维护性，尤其是随着团队规模和代码量增长，需要清晰的架构规范，否则逃不过屎山代码的命运。</p>\n<p>React采用了 <code>函数式组件 + JSX</code>的设计，强调 <code>组件化</code> 和 <code>单向数据流</code>, 灵活性极高。对于一些复杂逻辑，它可以使用 <code>Hooks</code> （如 <code>useState</code>、<code>useReducer</code>, <code>useContext</code>）或自定义 Hooks 来拆分代码。</p>\n<p>它本身并不强制特定架构，所以使用 React 开发需要开发团队自行制定规范（如目录结构，状态管理方案），因此更适合有经验的团队灵活设计符合项目需求的架构。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/react-vs-vue/vue-sfc.png\" alt=\"vue sfc\"></p>\n<p>Vue 采用的是 <code>模板 + 脚本 + 样式</code>的单文件组件（SFC），说白了就是这么写我定好了，你们按照我这个格式来写就 OK 了。不要问为什么，问就是海龟的屁股-龟腚。</p>\n<p>Vue3 的 Composition Api 解决了 Vue2 中 Options Api 在大型项目中逻辑复用的痛点，支持按功能拆分，有点类似 React Hooks。</p>\n<h2 id=\"状态管理与复杂逻辑\"><a href=\"#状态管理与复杂逻辑\" class=\"headerlink\" title=\"状态管理与复杂逻辑\"></a>状态管理与复杂逻辑</h2><p>大型项目往往涉及复杂的全局状态管理（如用户信息、权限、多模块数据交互）。</p>\n<p>React 本身不内置状态管理方案，依赖生态中的第三方库，复杂场景可选择 Redux，Zustand（轻量灵活）、Recoil（专注原子化状态）等。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/react-vs-vue/state.png\" alt=\"vue state\"></p>\n<p>Vue 在这一块官方提供了完整的状态管理方案，Vue 2 中常用 Vuex，Vue 3 中已升级为 Pinia，集成和使用起来都很方便。</p>\n<p>从个人过往编程体验上来说，Vue 的状态管理在开发过程中会比 React 舒服很多。</p>\n<h2 id=\"类型支持与工程化\"><a href=\"#类型支持与工程化\" class=\"headerlink\" title=\"类型支持与工程化\"></a>类型支持与工程化</h2><p>无论是主动升级还是被动升级，现在越来越多的项目都在使用 Typescript 来替代 JavaScript, 同时还配备工程化工具链，以减少运行时错误和提升开发效率。</p>\n<p>React 与 TypeScript 集成极为成熟，从框架到生态库（如 React Router、Redux）都有完善的类型定义。函数式组件和 Hooks 天然适合 TypeScript 的类型推断，复杂场景下的类型定义更直观。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/react-vs-vue/react-typescript.png\" alt=\"react-typescript\"></p>\n<p>此外， React 的工程化工具链也很丰富。如 Create React App、Next.js 等，适合复杂项目的工程化需求。</p>\n<p>Vue 的话 Vue3 版本是使用 Typescript重写的，在类型支持大幅提升，但完善度略逊于 React。</p>\n<p>它的官方工具链Vite、Vue Router、Pinia）的类型集成无缝，且 Vite 的开发体验（热更新速度）在大型项目中优势明显。</p>\n<h2 id=\"团队与学习成本\"><a href=\"#团队与学习成本\" class=\"headerlink\" title=\"团队与学习成本\"></a>团队与学习成本</h2><p>大型项目通常由多团队协作，框架的学习曲线和团队熟悉度会直接影响开发效率。</p>\n<p>就目前开发者对两者的评价来说，React 的学习曲线还是比较陡峭的，尤其是JSX 语法、函数式编程思想（纯函数、不可变数据）对新手有一定门槛，但掌握后灵活性极高。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/react-vs-vue/learning-curves.jpg\" alt=\"learning-curves\"></p>\n<p>Vue 在学习曲线上对新手算是非常友好的，学习曲线平缓，模板语法接近 HTML。 其官方文档被称为 “前端最佳文档”，降低了团队培训成本，适合成员技术背景多样的大型团队。</p>\n<h2 id=\"写在最后：如何选择？\"><a href=\"#写在最后：如何选择？\" class=\"headerlink\" title=\"写在最后：如何选择？\"></a>写在最后：如何选择？</h2><p>虽然很多时候，使用哪一个框架的选择权不在自己手上，但是，你得懂怎么选不是？</p>\n<p>如果说一个团队中有较多新手，或者团队整体水平差距较大，亦或者项目追求开发效率和低决策成本，那么 Vue 自然是首选了。</p>\n<p>如果项目需要高度定制化架构、强 TypeScript 集成、跨平台开发（Web + 移动端），或团队有丰富的 JavaScript &#x2F; 函数式编程经验, 那么 选择 React 优先于 Vue。</p>\n<p>用一句很有哲理的话作为结束语吧：无论你怎么选，你都会遗憾。</p>\n","excerpt":"","more":"<p>Vue 和 React 作为前端开发框架中的两个扛把子，在日常的开发工作中我们需要频繁的与它们打交道。Vue 和 React 都是成熟的前端框架，都能胜任大型项目开发，但它们的设计理念、生态特点和适用场景存在差异。</p>\n<p>今天让我们先抛开写 React 更高级这种莫名奇妙的优越感，来唠一唠哪一个更适合大型项目。</p>\n<h2 id=\"架构设计与可维护性\"><a href=\"#架构设计与可维护性\" class=\"headerlink\" title=\"架构设计与可维护性\"></a>架构设计与可维护性</h2><p>大型项目的核心挑战之一是代码组织的可维护性，尤其是随着团队规模和代码量增长，需要清晰的架构规范，否则逃不过屎山代码的命运。</p>\n<p>React采用了 <code>函数式组件 + JSX</code>的设计，强调 <code>组件化</code> 和 <code>单向数据流</code>, 灵活性极高。对于一些复杂逻辑，它可以使用 <code>Hooks</code> （如 <code>useState</code>、<code>useReducer</code>, <code>useContext</code>）或自定义 Hooks 来拆分代码。</p>\n<p>它本身并不强制特定架构，所以使用 React 开发需要开发团队自行制定规范（如目录结构，状态管理方案），因此更适合有经验的团队灵活设计符合项目需求的架构。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/react-vs-vue/vue-sfc.png\" alt=\"vue sfc\"></p>\n<p>Vue 采用的是 <code>模板 + 脚本 + 样式</code>的单文件组件（SFC），说白了就是这么写我定好了，你们按照我这个格式来写就 OK 了。不要问为什么，问就是海龟的屁股-龟腚。</p>\n<p>Vue3 的 Composition Api 解决了 Vue2 中 Options Api 在大型项目中逻辑复用的痛点，支持按功能拆分，有点类似 React Hooks。</p>\n<h2 id=\"状态管理与复杂逻辑\"><a href=\"#状态管理与复杂逻辑\" class=\"headerlink\" title=\"状态管理与复杂逻辑\"></a>状态管理与复杂逻辑</h2><p>大型项目往往涉及复杂的全局状态管理（如用户信息、权限、多模块数据交互）。</p>\n<p>React 本身不内置状态管理方案，依赖生态中的第三方库，复杂场景可选择 Redux，Zustand（轻量灵活）、Recoil（专注原子化状态）等。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/react-vs-vue/state.png\" alt=\"vue state\"></p>\n<p>Vue 在这一块官方提供了完整的状态管理方案，Vue 2 中常用 Vuex，Vue 3 中已升级为 Pinia，集成和使用起来都很方便。</p>\n<p>从个人过往编程体验上来说，Vue 的状态管理在开发过程中会比 React 舒服很多。</p>\n<h2 id=\"类型支持与工程化\"><a href=\"#类型支持与工程化\" class=\"headerlink\" title=\"类型支持与工程化\"></a>类型支持与工程化</h2><p>无论是主动升级还是被动升级，现在越来越多的项目都在使用 Typescript 来替代 JavaScript, 同时还配备工程化工具链，以减少运行时错误和提升开发效率。</p>\n<p>React 与 TypeScript 集成极为成熟，从框架到生态库（如 React Router、Redux）都有完善的类型定义。函数式组件和 Hooks 天然适合 TypeScript 的类型推断，复杂场景下的类型定义更直观。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/react-vs-vue/react-typescript.png\" alt=\"react-typescript\"></p>\n<p>此外， React 的工程化工具链也很丰富。如 Create React App、Next.js 等，适合复杂项目的工程化需求。</p>\n<p>Vue 的话 Vue3 版本是使用 Typescript重写的，在类型支持大幅提升，但完善度略逊于 React。</p>\n<p>它的官方工具链Vite、Vue Router、Pinia）的类型集成无缝，且 Vite 的开发体验（热更新速度）在大型项目中优势明显。</p>\n<h2 id=\"团队与学习成本\"><a href=\"#团队与学习成本\" class=\"headerlink\" title=\"团队与学习成本\"></a>团队与学习成本</h2><p>大型项目通常由多团队协作，框架的学习曲线和团队熟悉度会直接影响开发效率。</p>\n<p>就目前开发者对两者的评价来说，React 的学习曲线还是比较陡峭的，尤其是JSX 语法、函数式编程思想（纯函数、不可变数据）对新手有一定门槛，但掌握后灵活性极高。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/react-vs-vue/learning-curves.jpg\" alt=\"learning-curves\"></p>\n<p>Vue 在学习曲线上对新手算是非常友好的，学习曲线平缓，模板语法接近 HTML。 其官方文档被称为 “前端最佳文档”，降低了团队培训成本，适合成员技术背景多样的大型团队。</p>\n<h2 id=\"写在最后：如何选择？\"><a href=\"#写在最后：如何选择？\" class=\"headerlink\" title=\"写在最后：如何选择？\"></a>写在最后：如何选择？</h2><p>虽然很多时候，使用哪一个框架的选择权不在自己手上，但是，你得懂怎么选不是？</p>\n<p>如果说一个团队中有较多新手，或者团队整体水平差距较大，亦或者项目追求开发效率和低决策成本，那么 Vue 自然是首选了。</p>\n<p>如果项目需要高度定制化架构、强 TypeScript 集成、跨平台开发（Web + 移动端），或团队有丰富的 JavaScript &#x2F; 函数式编程经验, 那么 选择 React 优先于 Vue。</p>\n<p>用一句很有哲理的话作为结束语吧：无论你怎么选，你都会遗憾。</p>\n"},{"title":"从第一个静态网页到 Vue：Web 技术的 “逆袭史”","date":"2025-07-10T04:51:16.000Z","keywords":["Web开发，JQuery","Vue","MVVM"],"banner_img":"/imgs/web-history/first-web.jpg","index_img":"/imgs/web-history/first-web.jpg","_content":"\n**1991年**，有个叫蒂姆・博纳斯・李的英国科学家，写了世界上第一个静态网页。这个牛人不仅创造了超文本标记语言（HTML），而且还开发出世界上第一个网页浏览器，同时也由此发明了万维网(World Wide Web), 因此他也被称为万维网之父。\n\n![蒂姆・博纳斯・李](https://www.jvxiao.cn/imgs/web-history/TIM.png)\n\n早期的网页是静态的，当时的HTML标签并不丰富，当时的内容除了直接链接条状之外，没有任何的交互。到了**1994年**的时候，当时有一家有名的浏览器公司，大家应该也都听说过，叫网景(Netscape)， 它觉得页面缺少交互太单调了。脑袋一拍，Mocha出来了--也就是后来的JavaScript, JavaScript 的交互能力为网页广告弹窗(~~真讨厌~~)提供了技术基础。\n\n![Javascript](https://www.jvxiao.cn/imgs/web-history/Javascript.png)\n\n页面是可以动了，但是样式还是单调了些，而且还完全取决于浏览器开发商。页面缺少布局和美化手段，太粗糙了点。在**1994年**的时候，一个叫Hkon Wiumlie的开发者提出了CSS (层叠样式表)的想法，通过编写样式实现对页面内容的布局和美化。因为后来各大浏览器厂商对CSS的支持与差异，直到两年后的1996 年，W3才推出CSS规范的第一版本。 虽然CSS因此遗留了很多历史的BUG, 但终究还是统一了战线，不读不说这是个奇迹。\n\n![CSS](https://www.jvxiao.cn/imgs/web-history/CSS.png)\n\n到了**1995年**，网页迎来了一个巨大的转折，因为一门编程界的老梗编程语言诞生了--PHP(~~PHP是世界上最好的语言，不介绍反驳~~，不，JavaScript才是)。\n\nPHP的出现，让页面可以访问数据内容了，不再是单一静态页面加简单的动态交互了。通过把数据从数据库中取出来，然后塞到页面里，然后再返回给浏览器，从而实现了内容上的更新。\n\n![PHP](https://www.jvxiao.cn/imgs/web-history/PHP.png)\n\n但是这种前后端耦合的方式也带来了一个问题，就是页面需要频繁的刷新。页面中很小的变动，都会导致页面刷新，速度慢和流量消耗是个大问题。\n\n三步之内，必有解药，不行就三年。到了**1998年**，Ajax（Asynchronous JavaScript and XML）技术概念被提出，它大喊一声，学着点。Ajax通过动态加载数据，然后通过DOM操作将数据更新到页面的方式，完美的解决了页面频繁刷新的问题。\n\n![Jquery](https://www.jvxiao.cn/imgs/web-history/Jquery.png)\n\n想必后面的事情，大家都知道了，或者多少都有耳闻。 **2006年**，JQuery1.0 发布了，然后就是在Web开发中10年漫长的统治期，根据估计，到2010年，全球约90%的网站使用了JQuery。直到诸如Angular，React以及Vue等前端框架的崛起，这个Web界的王，才依依不舍离开曾经的宝座。\n\n## 传统Web技术的痛点\n\n类似JQuery这样封装了Ajax, DOM操作和时间处理的JS库，在很长一段时间里都是Web开发的主流技术，功能强大而且还简单易用。世界上总是没有免费的午餐的，对与JQuery来说，也是如此，它也存在着一定的不足之处。\n\n  - 性能问题\n    **DOM操作**： JQuery在处理大量DOM元素的时候可能不如原生JavaScript高效，因为其方法通常涉及遍历元素，增加了计算的开销\n    **选择器**: 岁让选择器方便，但复杂的选择器可能不如现在浏览器原生方法高效，影响性能。\n\n  - 体积问题\n    它的功能很强大，代码量自然也不会少，包的体积自然光也大。在弱网或移动端情况下，影响性能。\n\n  - 依赖性问题\n   项目可能仅使用部分功能却加载整个库，造成资源浪费。与其他库的冲突可能需要额外的处理，如使用noConflict模式。\n\n此外，2010年代，AngularJS, React和Vue.js等框架的出现，对JQuery的统治地位也构成了调账。新的MVC/MVVM模式，让用户更加方便的更新视图，在性能方面，采用虚拟DOM比传统的直接操作DOM消耗更少，更具优势。\n\n## MVVM技术框架\n\n- 定义：\n  - `Model: 数据层`，与MVC的Model类似。\n  - `View: 视图层`，负责数据展示。\n  - `ViewModel`: 将Model转化为View的友好格式，并处理用户交互。\n\n- 特点：\n  - `双向数据绑定`：ViewModel和View之间通过数据绑定自动同步数据。\n  - `简化逻辑`： ViewModel承担了部分Controller的职责，简化了View和Model的交换。\n  - `适用于声明编程`：适合使用声明式语法（如HTML）构建视图。\n\n![MVVM](https://www.jvxiao.cn/imgs/web-history/mvvm.jpg)\n\nMVVM通过数据双向绑定，分离关注点，简化视图逻辑、提高可测试性、支持响应式涉及和组件化开发等优势，极大地提升了前端开发的效率和代码质量。它特别适合需要复杂交互和动态数据的应用场景，如单页面应用和富客户端应用。选择MVVM模式能够帮助开发者构建更高效、更易于维护的前端应用。\n\n## 说回 Vue\n\n\n讲了那么多，终于回到我们的主题Vue了。之所以啰嗦，是希望你能够明白，无论是多么新的技术，都是有其发展历程和背景的。同时呢，无论看着多牛的技术框架，也是会有这样那样的问题的--人在挑毛病这块是无题的，而这也是技术不断往前发展的原因之一。\n\n![Vue](https://www.jvxiao.cn/imgs/web-history/Vue.png)\n\n技术的更新发展，往往都是对前一项主流技术上进行突破或者颠覆。比如，Vue这样的JS框架，解决的不就是视图渲染问题嘛，不再需要用户去操作DOM, 用户可以更加关注数据流和用户交互。从JavaScript刚刚实现用户交互直接跨越到Vue框架，一般我们称之为神话或者穿越...\n\n也许有一天 Vue 也被新的框架替代，但Web的故事还在继续，而我们，既是这段历史的见证者，也是下一章的书写人\n","source":"_posts/web-history.md","raw":"---\ntitle: 从第一个静态网页到 Vue：Web 技术的 “逆袭史”\ndate: 2025-07-10 12:51:16\ntags: [Web开发，JQuery, Vue, MVVM]\nkeywords: [Web开发，JQuery, Vue, MVVM]\ncategory: Web开发\nbanner_img: /imgs/web-history/first-web.jpg\nindex_img: /imgs/web-history/first-web.jpg\n\n---\n\n**1991年**，有个叫蒂姆・博纳斯・李的英国科学家，写了世界上第一个静态网页。这个牛人不仅创造了超文本标记语言（HTML），而且还开发出世界上第一个网页浏览器，同时也由此发明了万维网(World Wide Web), 因此他也被称为万维网之父。\n\n![蒂姆・博纳斯・李](https://www.jvxiao.cn/imgs/web-history/TIM.png)\n\n早期的网页是静态的，当时的HTML标签并不丰富，当时的内容除了直接链接条状之外，没有任何的交互。到了**1994年**的时候，当时有一家有名的浏览器公司，大家应该也都听说过，叫网景(Netscape)， 它觉得页面缺少交互太单调了。脑袋一拍，Mocha出来了--也就是后来的JavaScript, JavaScript 的交互能力为网页广告弹窗(~~真讨厌~~)提供了技术基础。\n\n![Javascript](https://www.jvxiao.cn/imgs/web-history/Javascript.png)\n\n页面是可以动了，但是样式还是单调了些，而且还完全取决于浏览器开发商。页面缺少布局和美化手段，太粗糙了点。在**1994年**的时候，一个叫Hkon Wiumlie的开发者提出了CSS (层叠样式表)的想法，通过编写样式实现对页面内容的布局和美化。因为后来各大浏览器厂商对CSS的支持与差异，直到两年后的1996 年，W3才推出CSS规范的第一版本。 虽然CSS因此遗留了很多历史的BUG, 但终究还是统一了战线，不读不说这是个奇迹。\n\n![CSS](https://www.jvxiao.cn/imgs/web-history/CSS.png)\n\n到了**1995年**，网页迎来了一个巨大的转折，因为一门编程界的老梗编程语言诞生了--PHP(~~PHP是世界上最好的语言，不介绍反驳~~，不，JavaScript才是)。\n\nPHP的出现，让页面可以访问数据内容了，不再是单一静态页面加简单的动态交互了。通过把数据从数据库中取出来，然后塞到页面里，然后再返回给浏览器，从而实现了内容上的更新。\n\n![PHP](https://www.jvxiao.cn/imgs/web-history/PHP.png)\n\n但是这种前后端耦合的方式也带来了一个问题，就是页面需要频繁的刷新。页面中很小的变动，都会导致页面刷新，速度慢和流量消耗是个大问题。\n\n三步之内，必有解药，不行就三年。到了**1998年**，Ajax（Asynchronous JavaScript and XML）技术概念被提出，它大喊一声，学着点。Ajax通过动态加载数据，然后通过DOM操作将数据更新到页面的方式，完美的解决了页面频繁刷新的问题。\n\n![Jquery](https://www.jvxiao.cn/imgs/web-history/Jquery.png)\n\n想必后面的事情，大家都知道了，或者多少都有耳闻。 **2006年**，JQuery1.0 发布了，然后就是在Web开发中10年漫长的统治期，根据估计，到2010年，全球约90%的网站使用了JQuery。直到诸如Angular，React以及Vue等前端框架的崛起，这个Web界的王，才依依不舍离开曾经的宝座。\n\n## 传统Web技术的痛点\n\n类似JQuery这样封装了Ajax, DOM操作和时间处理的JS库，在很长一段时间里都是Web开发的主流技术，功能强大而且还简单易用。世界上总是没有免费的午餐的，对与JQuery来说，也是如此，它也存在着一定的不足之处。\n\n  - 性能问题\n    **DOM操作**： JQuery在处理大量DOM元素的时候可能不如原生JavaScript高效，因为其方法通常涉及遍历元素，增加了计算的开销\n    **选择器**: 岁让选择器方便，但复杂的选择器可能不如现在浏览器原生方法高效，影响性能。\n\n  - 体积问题\n    它的功能很强大，代码量自然也不会少，包的体积自然光也大。在弱网或移动端情况下，影响性能。\n\n  - 依赖性问题\n   项目可能仅使用部分功能却加载整个库，造成资源浪费。与其他库的冲突可能需要额外的处理，如使用noConflict模式。\n\n此外，2010年代，AngularJS, React和Vue.js等框架的出现，对JQuery的统治地位也构成了调账。新的MVC/MVVM模式，让用户更加方便的更新视图，在性能方面，采用虚拟DOM比传统的直接操作DOM消耗更少，更具优势。\n\n## MVVM技术框架\n\n- 定义：\n  - `Model: 数据层`，与MVC的Model类似。\n  - `View: 视图层`，负责数据展示。\n  - `ViewModel`: 将Model转化为View的友好格式，并处理用户交互。\n\n- 特点：\n  - `双向数据绑定`：ViewModel和View之间通过数据绑定自动同步数据。\n  - `简化逻辑`： ViewModel承担了部分Controller的职责，简化了View和Model的交换。\n  - `适用于声明编程`：适合使用声明式语法（如HTML）构建视图。\n\n![MVVM](https://www.jvxiao.cn/imgs/web-history/mvvm.jpg)\n\nMVVM通过数据双向绑定，分离关注点，简化视图逻辑、提高可测试性、支持响应式涉及和组件化开发等优势，极大地提升了前端开发的效率和代码质量。它特别适合需要复杂交互和动态数据的应用场景，如单页面应用和富客户端应用。选择MVVM模式能够帮助开发者构建更高效、更易于维护的前端应用。\n\n## 说回 Vue\n\n\n讲了那么多，终于回到我们的主题Vue了。之所以啰嗦，是希望你能够明白，无论是多么新的技术，都是有其发展历程和背景的。同时呢，无论看着多牛的技术框架，也是会有这样那样的问题的--人在挑毛病这块是无题的，而这也是技术不断往前发展的原因之一。\n\n![Vue](https://www.jvxiao.cn/imgs/web-history/Vue.png)\n\n技术的更新发展，往往都是对前一项主流技术上进行突破或者颠覆。比如，Vue这样的JS框架，解决的不就是视图渲染问题嘛，不再需要用户去操作DOM, 用户可以更加关注数据流和用户交互。从JavaScript刚刚实现用户交互直接跨越到Vue框架，一般我们称之为神话或者穿越...\n\n也许有一天 Vue 也被新的框架替代，但Web的故事还在继续，而我们，既是这段历史的见证者，也是下一章的书写人\n","slug":"web-history","published":1,"updated":"2025-08-26T10:42:59.644Z","comments":1,"layout":"post","photos":[],"_id":"cmjbml2ix004likup7zy139vd","content":"<p><strong>1991年</strong>，有个叫蒂姆・博纳斯・李的英国科学家，写了世界上第一个静态网页。这个牛人不仅创造了超文本标记语言（HTML），而且还开发出世界上第一个网页浏览器，同时也由此发明了万维网(World Wide Web), 因此他也被称为万维网之父。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/web-history/TIM.png\" alt=\"蒂姆・博纳斯・李\"></p>\n<p>早期的网页是静态的，当时的HTML标签并不丰富，当时的内容除了直接链接条状之外，没有任何的交互。到了<strong>1994年</strong>的时候，当时有一家有名的浏览器公司，大家应该也都听说过，叫网景(Netscape)， 它觉得页面缺少交互太单调了。脑袋一拍，Mocha出来了–也就是后来的JavaScript, JavaScript 的交互能力为网页广告弹窗(<del>真讨厌</del>)提供了技术基础。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/web-history/Javascript.png\" alt=\"Javascript\"></p>\n<p>页面是可以动了，但是样式还是单调了些，而且还完全取决于浏览器开发商。页面缺少布局和美化手段，太粗糙了点。在<strong>1994年</strong>的时候，一个叫Hkon Wiumlie的开发者提出了CSS (层叠样式表)的想法，通过编写样式实现对页面内容的布局和美化。因为后来各大浏览器厂商对CSS的支持与差异，直到两年后的1996 年，W3才推出CSS规范的第一版本。 虽然CSS因此遗留了很多历史的BUG, 但终究还是统一了战线，不读不说这是个奇迹。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/web-history/CSS.png\" alt=\"CSS\"></p>\n<p>到了<strong>1995年</strong>，网页迎来了一个巨大的转折，因为一门编程界的老梗编程语言诞生了–PHP(<del>PHP是世界上最好的语言，不介绍反驳</del>，不，JavaScript才是)。</p>\n<p>PHP的出现，让页面可以访问数据内容了，不再是单一静态页面加简单的动态交互了。通过把数据从数据库中取出来，然后塞到页面里，然后再返回给浏览器，从而实现了内容上的更新。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/web-history/PHP.png\" alt=\"PHP\"></p>\n<p>但是这种前后端耦合的方式也带来了一个问题，就是页面需要频繁的刷新。页面中很小的变动，都会导致页面刷新，速度慢和流量消耗是个大问题。</p>\n<p>三步之内，必有解药，不行就三年。到了<strong>1998年</strong>，Ajax（Asynchronous JavaScript and XML）技术概念被提出，它大喊一声，学着点。Ajax通过动态加载数据，然后通过DOM操作将数据更新到页面的方式，完美的解决了页面频繁刷新的问题。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/web-history/Jquery.png\" alt=\"Jquery\"></p>\n<p>想必后面的事情，大家都知道了，或者多少都有耳闻。 <strong>2006年</strong>，JQuery1.0 发布了，然后就是在Web开发中10年漫长的统治期，根据估计，到2010年，全球约90%的网站使用了JQuery。直到诸如Angular，React以及Vue等前端框架的崛起，这个Web界的王，才依依不舍离开曾经的宝座。</p>\n<h2 id=\"传统Web技术的痛点\"><a href=\"#传统Web技术的痛点\" class=\"headerlink\" title=\"传统Web技术的痛点\"></a>传统Web技术的痛点</h2><p>类似JQuery这样封装了Ajax, DOM操作和时间处理的JS库，在很长一段时间里都是Web开发的主流技术，功能强大而且还简单易用。世界上总是没有免费的午餐的，对与JQuery来说，也是如此，它也存在着一定的不足之处。</p>\n<ul>\n<li><p>性能问题<br><strong>DOM操作</strong>： JQuery在处理大量DOM元素的时候可能不如原生JavaScript高效，因为其方法通常涉及遍历元素，增加了计算的开销<br><strong>选择器</strong>: 岁让选择器方便，但复杂的选择器可能不如现在浏览器原生方法高效，影响性能。</p>\n</li>\n<li><p>体积问题<br>它的功能很强大，代码量自然也不会少，包的体积自然光也大。在弱网或移动端情况下，影响性能。</p>\n</li>\n<li><p>依赖性问题<br>   项目可能仅使用部分功能却加载整个库，造成资源浪费。与其他库的冲突可能需要额外的处理，如使用noConflict模式。</p>\n</li>\n</ul>\n<p>此外，2010年代，AngularJS, React和Vue.js等框架的出现，对JQuery的统治地位也构成了调账。新的MVC&#x2F;MVVM模式，让用户更加方便的更新视图，在性能方面，采用虚拟DOM比传统的直接操作DOM消耗更少，更具优势。</p>\n<h2 id=\"MVVM技术框架\"><a href=\"#MVVM技术框架\" class=\"headerlink\" title=\"MVVM技术框架\"></a>MVVM技术框架</h2><ul>\n<li><p>定义：</p>\n<ul>\n<li><code>Model: 数据层</code>，与MVC的Model类似。</li>\n<li><code>View: 视图层</code>，负责数据展示。</li>\n<li><code>ViewModel</code>: 将Model转化为View的友好格式，并处理用户交互。</li>\n</ul>\n</li>\n<li><p>特点：</p>\n<ul>\n<li><code>双向数据绑定</code>：ViewModel和View之间通过数据绑定自动同步数据。</li>\n<li><code>简化逻辑</code>： ViewModel承担了部分Controller的职责，简化了View和Model的交换。</li>\n<li><code>适用于声明编程</code>：适合使用声明式语法（如HTML）构建视图。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://www.jvxiao.cn/imgs/web-history/mvvm.jpg\" alt=\"MVVM\"></p>\n<p>MVVM通过数据双向绑定，分离关注点，简化视图逻辑、提高可测试性、支持响应式涉及和组件化开发等优势，极大地提升了前端开发的效率和代码质量。它特别适合需要复杂交互和动态数据的应用场景，如单页面应用和富客户端应用。选择MVVM模式能够帮助开发者构建更高效、更易于维护的前端应用。</p>\n<h2 id=\"说回-Vue\"><a href=\"#说回-Vue\" class=\"headerlink\" title=\"说回 Vue\"></a>说回 Vue</h2><p>讲了那么多，终于回到我们的主题Vue了。之所以啰嗦，是希望你能够明白，无论是多么新的技术，都是有其发展历程和背景的。同时呢，无论看着多牛的技术框架，也是会有这样那样的问题的–人在挑毛病这块是无题的，而这也是技术不断往前发展的原因之一。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/web-history/Vue.png\" alt=\"Vue\"></p>\n<p>技术的更新发展，往往都是对前一项主流技术上进行突破或者颠覆。比如，Vue这样的JS框架，解决的不就是视图渲染问题嘛，不再需要用户去操作DOM, 用户可以更加关注数据流和用户交互。从JavaScript刚刚实现用户交互直接跨越到Vue框架，一般我们称之为神话或者穿越…</p>\n<p>也许有一天 Vue 也被新的框架替代，但Web的故事还在继续，而我们，既是这段历史的见证者，也是下一章的书写人</p>\n","excerpt":"","more":"<p><strong>1991年</strong>，有个叫蒂姆・博纳斯・李的英国科学家，写了世界上第一个静态网页。这个牛人不仅创造了超文本标记语言（HTML），而且还开发出世界上第一个网页浏览器，同时也由此发明了万维网(World Wide Web), 因此他也被称为万维网之父。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/web-history/TIM.png\" alt=\"蒂姆・博纳斯・李\"></p>\n<p>早期的网页是静态的，当时的HTML标签并不丰富，当时的内容除了直接链接条状之外，没有任何的交互。到了<strong>1994年</strong>的时候，当时有一家有名的浏览器公司，大家应该也都听说过，叫网景(Netscape)， 它觉得页面缺少交互太单调了。脑袋一拍，Mocha出来了–也就是后来的JavaScript, JavaScript 的交互能力为网页广告弹窗(<del>真讨厌</del>)提供了技术基础。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/web-history/Javascript.png\" alt=\"Javascript\"></p>\n<p>页面是可以动了，但是样式还是单调了些，而且还完全取决于浏览器开发商。页面缺少布局和美化手段，太粗糙了点。在<strong>1994年</strong>的时候，一个叫Hkon Wiumlie的开发者提出了CSS (层叠样式表)的想法，通过编写样式实现对页面内容的布局和美化。因为后来各大浏览器厂商对CSS的支持与差异，直到两年后的1996 年，W3才推出CSS规范的第一版本。 虽然CSS因此遗留了很多历史的BUG, 但终究还是统一了战线，不读不说这是个奇迹。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/web-history/CSS.png\" alt=\"CSS\"></p>\n<p>到了<strong>1995年</strong>，网页迎来了一个巨大的转折，因为一门编程界的老梗编程语言诞生了–PHP(<del>PHP是世界上最好的语言，不介绍反驳</del>，不，JavaScript才是)。</p>\n<p>PHP的出现，让页面可以访问数据内容了，不再是单一静态页面加简单的动态交互了。通过把数据从数据库中取出来，然后塞到页面里，然后再返回给浏览器，从而实现了内容上的更新。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/web-history/PHP.png\" alt=\"PHP\"></p>\n<p>但是这种前后端耦合的方式也带来了一个问题，就是页面需要频繁的刷新。页面中很小的变动，都会导致页面刷新，速度慢和流量消耗是个大问题。</p>\n<p>三步之内，必有解药，不行就三年。到了<strong>1998年</strong>，Ajax（Asynchronous JavaScript and XML）技术概念被提出，它大喊一声，学着点。Ajax通过动态加载数据，然后通过DOM操作将数据更新到页面的方式，完美的解决了页面频繁刷新的问题。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/web-history/Jquery.png\" alt=\"Jquery\"></p>\n<p>想必后面的事情，大家都知道了，或者多少都有耳闻。 <strong>2006年</strong>，JQuery1.0 发布了，然后就是在Web开发中10年漫长的统治期，根据估计，到2010年，全球约90%的网站使用了JQuery。直到诸如Angular，React以及Vue等前端框架的崛起，这个Web界的王，才依依不舍离开曾经的宝座。</p>\n<h2 id=\"传统Web技术的痛点\"><a href=\"#传统Web技术的痛点\" class=\"headerlink\" title=\"传统Web技术的痛点\"></a>传统Web技术的痛点</h2><p>类似JQuery这样封装了Ajax, DOM操作和时间处理的JS库，在很长一段时间里都是Web开发的主流技术，功能强大而且还简单易用。世界上总是没有免费的午餐的，对与JQuery来说，也是如此，它也存在着一定的不足之处。</p>\n<ul>\n<li><p>性能问题<br><strong>DOM操作</strong>： JQuery在处理大量DOM元素的时候可能不如原生JavaScript高效，因为其方法通常涉及遍历元素，增加了计算的开销<br><strong>选择器</strong>: 岁让选择器方便，但复杂的选择器可能不如现在浏览器原生方法高效，影响性能。</p>\n</li>\n<li><p>体积问题<br>它的功能很强大，代码量自然也不会少，包的体积自然光也大。在弱网或移动端情况下，影响性能。</p>\n</li>\n<li><p>依赖性问题<br>   项目可能仅使用部分功能却加载整个库，造成资源浪费。与其他库的冲突可能需要额外的处理，如使用noConflict模式。</p>\n</li>\n</ul>\n<p>此外，2010年代，AngularJS, React和Vue.js等框架的出现，对JQuery的统治地位也构成了调账。新的MVC&#x2F;MVVM模式，让用户更加方便的更新视图，在性能方面，采用虚拟DOM比传统的直接操作DOM消耗更少，更具优势。</p>\n<h2 id=\"MVVM技术框架\"><a href=\"#MVVM技术框架\" class=\"headerlink\" title=\"MVVM技术框架\"></a>MVVM技术框架</h2><ul>\n<li><p>定义：</p>\n<ul>\n<li><code>Model: 数据层</code>，与MVC的Model类似。</li>\n<li><code>View: 视图层</code>，负责数据展示。</li>\n<li><code>ViewModel</code>: 将Model转化为View的友好格式，并处理用户交互。</li>\n</ul>\n</li>\n<li><p>特点：</p>\n<ul>\n<li><code>双向数据绑定</code>：ViewModel和View之间通过数据绑定自动同步数据。</li>\n<li><code>简化逻辑</code>： ViewModel承担了部分Controller的职责，简化了View和Model的交换。</li>\n<li><code>适用于声明编程</code>：适合使用声明式语法（如HTML）构建视图。</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://www.jvxiao.cn/imgs/web-history/mvvm.jpg\" alt=\"MVVM\"></p>\n<p>MVVM通过数据双向绑定，分离关注点，简化视图逻辑、提高可测试性、支持响应式涉及和组件化开发等优势，极大地提升了前端开发的效率和代码质量。它特别适合需要复杂交互和动态数据的应用场景，如单页面应用和富客户端应用。选择MVVM模式能够帮助开发者构建更高效、更易于维护的前端应用。</p>\n<h2 id=\"说回-Vue\"><a href=\"#说回-Vue\" class=\"headerlink\" title=\"说回 Vue\"></a>说回 Vue</h2><p>讲了那么多，终于回到我们的主题Vue了。之所以啰嗦，是希望你能够明白，无论是多么新的技术，都是有其发展历程和背景的。同时呢，无论看着多牛的技术框架，也是会有这样那样的问题的–人在挑毛病这块是无题的，而这也是技术不断往前发展的原因之一。</p>\n<p><img src=\"https://www.jvxiao.cn/imgs/web-history/Vue.png\" alt=\"Vue\"></p>\n<p>技术的更新发展，往往都是对前一项主流技术上进行突破或者颠覆。比如，Vue这样的JS框架，解决的不就是视图渲染问题嘛，不再需要用户去操作DOM, 用户可以更加关注数据流和用户交互。从JavaScript刚刚实现用户交互直接跨越到Vue框架，一般我们称之为神话或者穿越…</p>\n<p>也许有一天 Vue 也被新的框架替代，但Web的故事还在继续，而我们，既是这段历史的见证者，也是下一章的书写人</p>\n"},{"title":"Vue进阶系列第1篇：说说对Vue的理解，Vue是什么，有什么作用","date":"2025-12-06T04:36:16.000Z","_content":"\n\n大家好，我是jvxiao。\n\n在上一个[JavaScript ES6进阶系列文章](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU2MjU3MzI0MA==&action=getalbum&album_id=4120256678140837890#wechat_redirect)从简单的let, const一路讲到了日常开发较少使用的Decorator，很多文章也收到了很多各位读者喜欢和推荐，在这里感谢各位读者朋友的支持。\n\n在过去一周中，没有更新新的文章，这是因为我在准备一个新的文章系列--[Vue从入门到精通](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU2MjU3MzI0MA==&action=getalbum&album_id=4276738695946223617#wechat_redirect)。这一系列文章大概在30篇左右，将涵盖Vue框架中众多核心知识，并会进行适当的源码解读，希望大家喜欢并持续关注。\n\n今天是该系列的第1篇文章，我们来讲讲`Vue是什么？`\n\n在前端开发日新月异的浪潮中，Vue.js（简称Vue）凭借其简洁的语法、灵活的架构和友好的学习曲线，成为无数开发者构建Web应用的首选框架。要真正掌握Vue，我们需要从Web开发的历史脉络出发，逐步剖析其本质、核心特性，并通过与传统开发及React的对比，明确其定位与优势。\n\n\n## 一、Web开发的历史演进：框架为何应运而生？\n前端技术的发展始终围绕“提升开发效率”与“应对复杂场景”两大核心，Vue的出现是历史演进的必然结果，我们可将其分为三个关键阶段：\n\n### 1. 静态Web时代（1990s-2000s初）\n早期Web以“信息展示”为核心，页面由纯HTML（结构）+ CSS（样式）构成，交互逻辑仅依赖简单的JavaScript（如表单验证、弹窗）。此时无需框架——页面逻辑简单，DOM操作极少，开发者直接通过原生API修改元素即可。\n\n### 2. 动态交互萌芽（2000s中-2010s初）\n随着AJAX技术（2005年谷歌地图普及）的出现，Web应用从“页面跳转式”升级为“局部刷新式”，开发者开始面临新挑战：  \n- 手动管理DOM与数据的同步（如表单提交后更新列表），代码充斥`document.getElementById`、`innerHTML`等命令式操作；  \n- 项目复杂度提升后，jQuery（2006年诞生）成为主流工具，但仍需手动维护“数据- DOM”映射关系，代码耦合度高、可维护性差。\n\n### 3. 前端框架崛起（2010s至今）\n2010年后，单页应用（SPA）成为主流（如微信网页版、在线文档），传统开发模式彻底无法满足需求：  \n- 数据与DOM同步混乱（如一个数据变更需修改多个DOM节点）；  \n- 代码复用困难（如导航栏、弹窗需重复编写）；  \n- 团队协作效率低（无统一代码规范）。  \n\n此时，**以数据驱动、组件化为核心的前端框架**应运而生，Vue（2014年由Evan You发布）与Angular、React共同构成了“前端三大框架”，彻底改变了前端开发模式。\n\n\n## 二、Vue是什么：渐进式的前端框架\nVue官方定义为“一套用于构建用户界面的渐进式框架”，这句话精准概括了其核心特质：\n\n### 1. 核心定位：渐进式与易用性\n“渐进式”意味着Vue不强制开发者使用其所有功能——可根据项目需求灵活引入：  \n- 小型项目：仅用Vue核心库（数据绑定+指令），无需额外依赖；  \n- 中型项目：引入Vue Router（路由）、Pinia（状态管理）；  \n- 大型项目：结合Vite（构建工具）、TypeScript（类型检查），形成完整工程化方案。  \n\n这种“按需使用”的设计，让Vue既能满足个人小项目的快速开发，也能支撑企业级应用的复杂需求。\n\n### 2. 版本演进：从Vue 2到Vue 3\nVue的发展历经两次关键迭代，核心能力持续升级：  \n- **Vue 2（2016年）**：奠定基础，通过`Object.defineProperty`实现响应式，支持单文件组件（.vue），生态快速完善（Vue Router 3、Vuex 3）；  \n- **Vue 3（2020年）**：全面重构，解决Vue 2的性能瓶颈与扩展性问题：  \n  - 用`Proxy`替代`Object.defineProperty`，支持数组索引、对象新增属性的响应式监听；  \n  - 引入Composition API（组合式API），解决大型组件中Options API（选项式API）的逻辑分散问题；  \n  - 支持Tree-Shaking（按需打包），减少生产环境体积。\n\n\n## 三、Vue的核心特性：为何它能简化开发？\nVue的强大源于其精心设计的核心特性，这些特性围绕“让开发者专注于数据与逻辑，而非DOM操作”展开：\n\n### 1. 数据驱动：响应式与双向绑定\n这是Vue的灵魂特性，核心逻辑是“数据变化时，DOM自动更新”，无需手动操作DOM：  \n- **响应式原理**：Vue 3通过`Proxy`监听数据对象的读写，数据变更时自动触发依赖更新（如重新渲染组件）；  \n- **双向绑定（v-model）**：简化表单交互，例如：  \n  ```html\n  <template>\n    <input v-model=\"username\" />\n    <p>你输入的用户名：{{ username }}</p>\n  </template>\n  <script setup>\n    import { ref } from 'vue'\n    const username = ref('') // 响应式数据\n  </script>\n  ```\n  输入框内容变化时，`username`自动更新，页面也随之刷新——开发者无需编写`oninput`事件。\n\n### 2. 组件化：复用与解耦\n组件是Vue应用的基本单元，将页面拆分为独立、可复用的模块（如导航栏、卡片、按钮），实现“一次编写，多处使用”：  \n- **单文件组件（SFC）**：以`.vue`文件整合模板（template）、逻辑（script）、样式（style），结构清晰：  \n  ```html\n  <template><!-- 组件UI结构 --></template>\n  <script setup><!-- 组件逻辑 --></script>\n  <style scoped><!-- 组件样式（仅作用于当前组件） --></style>\n  ```\n- **组件通信**：提供灵活的通信方式，如`props`（父传子）、`emit`（子传父）、`provide/inject`（跨层级）、Pinia（全局状态）。\n\n### 3. 指令系统：简化DOM操作\nVue提供内置指令（以`v-`开头），将常见DOM操作封装为声明式语法，开发者无需关注“如何操作DOM”，只需关注“要实现什么效果”：  \n- `v-if`/`v-else`：条件渲染（根据数据决定是否显示DOM）；  \n- `v-for`：列表渲染（根据数组自动生成DOM列表）；  \n- `v-bind`：属性绑定（将数据与DOM属性关联，简写为`:`）；  \n- `v-on`：事件绑定（监听DOM事件，简写为`@`）。\n\n### 4. 生命周期：控制组件运行时机\nVue为组件提供完整的生命周期钩子，允许开发者在特定阶段执行逻辑（如初始化数据、发起请求、清理资源）：  \n- Vue 3组合式API中，常用钩子如`onMounted`（组件挂载后）、`onUpdated`（组件更新后）、`onUnmounted`（组件卸载前）：  \n  ```javascript\n  import { onMounted } from 'vue'\n  onMounted(() => {\n    // 组件挂载后发起AJAX请求，获取数据\n    fetch('/api/data').then(res => res.json())\n  })\n  ```\n\n### 5. Vue 3新增特性：更强大的扩展性\nVue 3在核心特性外，新增了多个实用功能：  \n- **Teleport**：将组件DOM渲染到指定位置（如弹窗渲染到`body`下，避免样式嵌套问题）；  \n- **Suspense**：异步组件加载时显示占位内容（如loading），提升用户体验；  \n- **TypeScript支持**：原生支持TypeScript，提供类型提示，减少运行时错误。\n\n\n## 四、Vue与传统开发的区别：效率的质变\n传统开发（以jQuery为代表）与Vue的核心差异，本质是“命令式”与“声明式”的区别，具体体现在以下维度：\n\n| 对比维度         | 传统开发（jQuery）                | Vue开发                          |\n|------------------|-----------------------------------|----------------------------------|\n| DOM操作方式      | 命令式：手动查找、修改DOM（如`$('#box').text('hello')`） | 声明式：仅关注数据，DOM自动更新  |\n| 代码组织         | 逻辑与DOM操作混合，耦合度高        | 组件化拆分，逻辑、UI、样式分离    |\n| 数据与DOM同步    | 手动维护（数据变后需手动更新DOM）  | 响应式自动同步（数据变→DOM变）   |\n| 复用性           | 需通过函数封装，复用成本高        | 组件可直接复用，支持跨项目导入    |\n| 工程化支持       | 依赖第三方工具（如Gulp），配置复杂 | 内置Vue CLI/Vite，一键搭建工程化环境 |\n| 维护成本         | 项目越大，代码越混乱，维护难度指数级上升 | 组件化+响应式，维护成本线性增长  |\n\n举个简单例子：实现“点击按钮修改文本”功能  \n- 传统jQuery方式：  \n  ```html\n  <div id=\"text\">原始文本</div>\n  <button id=\"btn\">点击修改</button>\n  <script src=\"jquery.js\"></script>\n  <script>\n    // 手动查找DOM，绑定事件，修改内容\n    $('#btn').click(() => {\n      $('#text').text('修改后的文本')\n    })\n  </script>\n  ```\n- Vue方式：  \n  ```html\n  <template>\n    <div>{{ text }}</div>\n    <button @click=\"changeText\">点击修改</button>\n  </template>\n  <script setup>\n    import { ref } from 'vue'\n    const text = ref('原始文本')\n    // 仅关注逻辑，无需操作DOM\n    const changeText = () => {\n      text.value = '修改后的文本'\n    }\n  </script>\n  ```\n可见，Vue彻底解放了DOM操作，让开发者聚焦于业务逻辑。\n\n\n## 五、Vue与React的对比：各有所长的框架选择\nVue与React作为当前最流行的两大前端框架，各有设计理念与适用场景，不存在“绝对优劣”，仅需根据项目需求选择：\n\n| 对比维度         | Vue                              | React                            |\n|------------------|----------------------------------|----------------------------------|\n| 设计理念         | 渐进式框架，追求“易用性”与“开箱即用” | 函数式编程思想，追求“灵活性”与“可扩展性” |\n| 模板与UI语法     | 支持HTML模板（更贴近传统前端开发），也支持JSX | 仅支持JSX（将HTML嵌入JS，需适应“JS中写UI”） |\n| 响应式原理       | Vue 3用`Proxy`，自动响应式（无需手动触发更新） | 用`setState`/`useState`手动触发更新（需理解“状态不可变”） |\n| 状态管理         | 官方推荐Pinia（轻量、简洁，集成Vue DevTools） | 生态丰富：Redux（严谨）、MobX（灵活）、Zustand（轻量） |\n| 虚拟DOM与性能    | Vue 3虚拟DOM采用“块状更新”，性能优秀；且支持“编译时优化”（如静态节点提升） | 虚拟DOM采用Fiber架构，支持“时间切片”（避免长任务阻塞UI）；需手动优化（如`memo`、`useMemo`） |\n| 学习曲线         | 低：HTML模板+简单API，新手易上手 | 中：需理解JSX、函数式编程、Hooks规则（如依赖数组） |\n| 生态与社区       | 生态完善（Vue Router、Pinia、Vite），中文文档丰富 | 生态极丰富（React Router、Redux、Next.js），社区贡献活跃 |\n| 适用场景         | 中小型项目快速开发、团队中前端新手较多、偏好HTML模板的场景 | 大型复杂应用（如电商、中台）、需要高度定制化UI、团队熟悉函数式编程的场景 |\n\n简单来说：若追求“快速上手、开箱即用”，Vue是更好选择；若需“高度灵活、应对复杂场景”，React更具优势。\n\n\n## 六、总结与展望\nVue作为渐进式前端框架，以“数据驱动”和“组件化”为核心，解决了传统开发的效率痛点，同时通过Vue 3的迭代持续提升性能与扩展性。它既不是“最复杂的框架”，也不是“功能最全的框架”，却是“平衡了易用性与强大性”的优秀选择——无论是个人开发者的小项目，还是企业级的大型应用，Vue都能提供高效的解决方案。\n\n对于学习者而言，掌握Vue不仅是掌握一门框架，更是理解“数据驱动”“组件化”等前端核心思想的关键路径。\n\n**【往期精彩】**\n- [JavaScript ES6中的生成器(Decorator)是什么？有哪些应用场景？](https://mp.weixin.qq.com/s/c7IwODBilcxSyozJvjjHRw)\n\n- [说说JavaScript中ES6 module(模块化)的诞生背景、核心语法及应用场景](https://mp.weixin.qq.com/s/pe4fywIh7WdigHuwRiqDlQ)\n- [一文说透ES6 Proxy: 从本质到应用场景](https://mp.weixin.qq.com/s/lYqBgS0GJgQMX5PAW_snnQ)\n- [JavaScript ES6中的生成器(Generator)是什么？有哪些应用场景？一文全说透](https://mp.weixin.qq.com/s/PtFtlNUH-UcLYU5h-xKiQw)\n- [聊聊ES6里的Promise：简单理解和实际用法](https://mp.weixin.qq.com/s/9pnvL5fTO5U9yT-1mPfeQw)\n- [一文搞懂 JavaScript 里 var、let、const 的区别\n](https://mp.weixin.qq.com/s/lqn_51NNxx50YgvWkxCtEg)\n","source":"_posts/what-is-vue.md","raw":"---\ntitle: Vue进阶系列第1篇：说说对Vue的理解，Vue是什么，有什么作用\ndate: 2025-12-06 12:36:16\ntags: JavaScript进阶, ES6进阶\ncategory: ES6进阶\n---\n\n\n大家好，我是jvxiao。\n\n在上一个[JavaScript ES6进阶系列文章](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU2MjU3MzI0MA==&action=getalbum&album_id=4120256678140837890#wechat_redirect)从简单的let, const一路讲到了日常开发较少使用的Decorator，很多文章也收到了很多各位读者喜欢和推荐，在这里感谢各位读者朋友的支持。\n\n在过去一周中，没有更新新的文章，这是因为我在准备一个新的文章系列--[Vue从入门到精通](https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU2MjU3MzI0MA==&action=getalbum&album_id=4276738695946223617#wechat_redirect)。这一系列文章大概在30篇左右，将涵盖Vue框架中众多核心知识，并会进行适当的源码解读，希望大家喜欢并持续关注。\n\n今天是该系列的第1篇文章，我们来讲讲`Vue是什么？`\n\n在前端开发日新月异的浪潮中，Vue.js（简称Vue）凭借其简洁的语法、灵活的架构和友好的学习曲线，成为无数开发者构建Web应用的首选框架。要真正掌握Vue，我们需要从Web开发的历史脉络出发，逐步剖析其本质、核心特性，并通过与传统开发及React的对比，明确其定位与优势。\n\n\n## 一、Web开发的历史演进：框架为何应运而生？\n前端技术的发展始终围绕“提升开发效率”与“应对复杂场景”两大核心，Vue的出现是历史演进的必然结果，我们可将其分为三个关键阶段：\n\n### 1. 静态Web时代（1990s-2000s初）\n早期Web以“信息展示”为核心，页面由纯HTML（结构）+ CSS（样式）构成，交互逻辑仅依赖简单的JavaScript（如表单验证、弹窗）。此时无需框架——页面逻辑简单，DOM操作极少，开发者直接通过原生API修改元素即可。\n\n### 2. 动态交互萌芽（2000s中-2010s初）\n随着AJAX技术（2005年谷歌地图普及）的出现，Web应用从“页面跳转式”升级为“局部刷新式”，开发者开始面临新挑战：  \n- 手动管理DOM与数据的同步（如表单提交后更新列表），代码充斥`document.getElementById`、`innerHTML`等命令式操作；  \n- 项目复杂度提升后，jQuery（2006年诞生）成为主流工具，但仍需手动维护“数据- DOM”映射关系，代码耦合度高、可维护性差。\n\n### 3. 前端框架崛起（2010s至今）\n2010年后，单页应用（SPA）成为主流（如微信网页版、在线文档），传统开发模式彻底无法满足需求：  \n- 数据与DOM同步混乱（如一个数据变更需修改多个DOM节点）；  \n- 代码复用困难（如导航栏、弹窗需重复编写）；  \n- 团队协作效率低（无统一代码规范）。  \n\n此时，**以数据驱动、组件化为核心的前端框架**应运而生，Vue（2014年由Evan You发布）与Angular、React共同构成了“前端三大框架”，彻底改变了前端开发模式。\n\n\n## 二、Vue是什么：渐进式的前端框架\nVue官方定义为“一套用于构建用户界面的渐进式框架”，这句话精准概括了其核心特质：\n\n### 1. 核心定位：渐进式与易用性\n“渐进式”意味着Vue不强制开发者使用其所有功能——可根据项目需求灵活引入：  \n- 小型项目：仅用Vue核心库（数据绑定+指令），无需额外依赖；  \n- 中型项目：引入Vue Router（路由）、Pinia（状态管理）；  \n- 大型项目：结合Vite（构建工具）、TypeScript（类型检查），形成完整工程化方案。  \n\n这种“按需使用”的设计，让Vue既能满足个人小项目的快速开发，也能支撑企业级应用的复杂需求。\n\n### 2. 版本演进：从Vue 2到Vue 3\nVue的发展历经两次关键迭代，核心能力持续升级：  \n- **Vue 2（2016年）**：奠定基础，通过`Object.defineProperty`实现响应式，支持单文件组件（.vue），生态快速完善（Vue Router 3、Vuex 3）；  \n- **Vue 3（2020年）**：全面重构，解决Vue 2的性能瓶颈与扩展性问题：  \n  - 用`Proxy`替代`Object.defineProperty`，支持数组索引、对象新增属性的响应式监听；  \n  - 引入Composition API（组合式API），解决大型组件中Options API（选项式API）的逻辑分散问题；  \n  - 支持Tree-Shaking（按需打包），减少生产环境体积。\n\n\n## 三、Vue的核心特性：为何它能简化开发？\nVue的强大源于其精心设计的核心特性，这些特性围绕“让开发者专注于数据与逻辑，而非DOM操作”展开：\n\n### 1. 数据驱动：响应式与双向绑定\n这是Vue的灵魂特性，核心逻辑是“数据变化时，DOM自动更新”，无需手动操作DOM：  \n- **响应式原理**：Vue 3通过`Proxy`监听数据对象的读写，数据变更时自动触发依赖更新（如重新渲染组件）；  \n- **双向绑定（v-model）**：简化表单交互，例如：  \n  ```html\n  <template>\n    <input v-model=\"username\" />\n    <p>你输入的用户名：{{ username }}</p>\n  </template>\n  <script setup>\n    import { ref } from 'vue'\n    const username = ref('') // 响应式数据\n  </script>\n  ```\n  输入框内容变化时，`username`自动更新，页面也随之刷新——开发者无需编写`oninput`事件。\n\n### 2. 组件化：复用与解耦\n组件是Vue应用的基本单元，将页面拆分为独立、可复用的模块（如导航栏、卡片、按钮），实现“一次编写，多处使用”：  \n- **单文件组件（SFC）**：以`.vue`文件整合模板（template）、逻辑（script）、样式（style），结构清晰：  \n  ```html\n  <template><!-- 组件UI结构 --></template>\n  <script setup><!-- 组件逻辑 --></script>\n  <style scoped><!-- 组件样式（仅作用于当前组件） --></style>\n  ```\n- **组件通信**：提供灵活的通信方式，如`props`（父传子）、`emit`（子传父）、`provide/inject`（跨层级）、Pinia（全局状态）。\n\n### 3. 指令系统：简化DOM操作\nVue提供内置指令（以`v-`开头），将常见DOM操作封装为声明式语法，开发者无需关注“如何操作DOM”，只需关注“要实现什么效果”：  \n- `v-if`/`v-else`：条件渲染（根据数据决定是否显示DOM）；  \n- `v-for`：列表渲染（根据数组自动生成DOM列表）；  \n- `v-bind`：属性绑定（将数据与DOM属性关联，简写为`:`）；  \n- `v-on`：事件绑定（监听DOM事件，简写为`@`）。\n\n### 4. 生命周期：控制组件运行时机\nVue为组件提供完整的生命周期钩子，允许开发者在特定阶段执行逻辑（如初始化数据、发起请求、清理资源）：  \n- Vue 3组合式API中，常用钩子如`onMounted`（组件挂载后）、`onUpdated`（组件更新后）、`onUnmounted`（组件卸载前）：  \n  ```javascript\n  import { onMounted } from 'vue'\n  onMounted(() => {\n    // 组件挂载后发起AJAX请求，获取数据\n    fetch('/api/data').then(res => res.json())\n  })\n  ```\n\n### 5. Vue 3新增特性：更强大的扩展性\nVue 3在核心特性外，新增了多个实用功能：  \n- **Teleport**：将组件DOM渲染到指定位置（如弹窗渲染到`body`下，避免样式嵌套问题）；  \n- **Suspense**：异步组件加载时显示占位内容（如loading），提升用户体验；  \n- **TypeScript支持**：原生支持TypeScript，提供类型提示，减少运行时错误。\n\n\n## 四、Vue与传统开发的区别：效率的质变\n传统开发（以jQuery为代表）与Vue的核心差异，本质是“命令式”与“声明式”的区别，具体体现在以下维度：\n\n| 对比维度         | 传统开发（jQuery）                | Vue开发                          |\n|------------------|-----------------------------------|----------------------------------|\n| DOM操作方式      | 命令式：手动查找、修改DOM（如`$('#box').text('hello')`） | 声明式：仅关注数据，DOM自动更新  |\n| 代码组织         | 逻辑与DOM操作混合，耦合度高        | 组件化拆分，逻辑、UI、样式分离    |\n| 数据与DOM同步    | 手动维护（数据变后需手动更新DOM）  | 响应式自动同步（数据变→DOM变）   |\n| 复用性           | 需通过函数封装，复用成本高        | 组件可直接复用，支持跨项目导入    |\n| 工程化支持       | 依赖第三方工具（如Gulp），配置复杂 | 内置Vue CLI/Vite，一键搭建工程化环境 |\n| 维护成本         | 项目越大，代码越混乱，维护难度指数级上升 | 组件化+响应式，维护成本线性增长  |\n\n举个简单例子：实现“点击按钮修改文本”功能  \n- 传统jQuery方式：  \n  ```html\n  <div id=\"text\">原始文本</div>\n  <button id=\"btn\">点击修改</button>\n  <script src=\"jquery.js\"></script>\n  <script>\n    // 手动查找DOM，绑定事件，修改内容\n    $('#btn').click(() => {\n      $('#text').text('修改后的文本')\n    })\n  </script>\n  ```\n- Vue方式：  \n  ```html\n  <template>\n    <div>{{ text }}</div>\n    <button @click=\"changeText\">点击修改</button>\n  </template>\n  <script setup>\n    import { ref } from 'vue'\n    const text = ref('原始文本')\n    // 仅关注逻辑，无需操作DOM\n    const changeText = () => {\n      text.value = '修改后的文本'\n    }\n  </script>\n  ```\n可见，Vue彻底解放了DOM操作，让开发者聚焦于业务逻辑。\n\n\n## 五、Vue与React的对比：各有所长的框架选择\nVue与React作为当前最流行的两大前端框架，各有设计理念与适用场景，不存在“绝对优劣”，仅需根据项目需求选择：\n\n| 对比维度         | Vue                              | React                            |\n|------------------|----------------------------------|----------------------------------|\n| 设计理念         | 渐进式框架，追求“易用性”与“开箱即用” | 函数式编程思想，追求“灵活性”与“可扩展性” |\n| 模板与UI语法     | 支持HTML模板（更贴近传统前端开发），也支持JSX | 仅支持JSX（将HTML嵌入JS，需适应“JS中写UI”） |\n| 响应式原理       | Vue 3用`Proxy`，自动响应式（无需手动触发更新） | 用`setState`/`useState`手动触发更新（需理解“状态不可变”） |\n| 状态管理         | 官方推荐Pinia（轻量、简洁，集成Vue DevTools） | 生态丰富：Redux（严谨）、MobX（灵活）、Zustand（轻量） |\n| 虚拟DOM与性能    | Vue 3虚拟DOM采用“块状更新”，性能优秀；且支持“编译时优化”（如静态节点提升） | 虚拟DOM采用Fiber架构，支持“时间切片”（避免长任务阻塞UI）；需手动优化（如`memo`、`useMemo`） |\n| 学习曲线         | 低：HTML模板+简单API，新手易上手 | 中：需理解JSX、函数式编程、Hooks规则（如依赖数组） |\n| 生态与社区       | 生态完善（Vue Router、Pinia、Vite），中文文档丰富 | 生态极丰富（React Router、Redux、Next.js），社区贡献活跃 |\n| 适用场景         | 中小型项目快速开发、团队中前端新手较多、偏好HTML模板的场景 | 大型复杂应用（如电商、中台）、需要高度定制化UI、团队熟悉函数式编程的场景 |\n\n简单来说：若追求“快速上手、开箱即用”，Vue是更好选择；若需“高度灵活、应对复杂场景”，React更具优势。\n\n\n## 六、总结与展望\nVue作为渐进式前端框架，以“数据驱动”和“组件化”为核心，解决了传统开发的效率痛点，同时通过Vue 3的迭代持续提升性能与扩展性。它既不是“最复杂的框架”，也不是“功能最全的框架”，却是“平衡了易用性与强大性”的优秀选择——无论是个人开发者的小项目，还是企业级的大型应用，Vue都能提供高效的解决方案。\n\n对于学习者而言，掌握Vue不仅是掌握一门框架，更是理解“数据驱动”“组件化”等前端核心思想的关键路径。\n\n**【往期精彩】**\n- [JavaScript ES6中的生成器(Decorator)是什么？有哪些应用场景？](https://mp.weixin.qq.com/s/c7IwODBilcxSyozJvjjHRw)\n\n- [说说JavaScript中ES6 module(模块化)的诞生背景、核心语法及应用场景](https://mp.weixin.qq.com/s/pe4fywIh7WdigHuwRiqDlQ)\n- [一文说透ES6 Proxy: 从本质到应用场景](https://mp.weixin.qq.com/s/lYqBgS0GJgQMX5PAW_snnQ)\n- [JavaScript ES6中的生成器(Generator)是什么？有哪些应用场景？一文全说透](https://mp.weixin.qq.com/s/PtFtlNUH-UcLYU5h-xKiQw)\n- [聊聊ES6里的Promise：简单理解和实际用法](https://mp.weixin.qq.com/s/9pnvL5fTO5U9yT-1mPfeQw)\n- [一文搞懂 JavaScript 里 var、let、const 的区别\n](https://mp.weixin.qq.com/s/lqn_51NNxx50YgvWkxCtEg)\n","slug":"what-is-vue","published":1,"updated":"2025-12-06T04:47:22.735Z","comments":1,"layout":"post","photos":[],"_id":"cmjbml2iy004oikupegy9eqmt","content":"<p>大家好，我是jvxiao。</p>\n<p>在上一个<a href=\"https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU2MjU3MzI0MA==&action=getalbum&album_id=4120256678140837890#wechat_redirect\">JavaScript ES6进阶系列文章</a>从简单的let, const一路讲到了日常开发较少使用的Decorator，很多文章也收到了很多各位读者喜欢和推荐，在这里感谢各位读者朋友的支持。</p>\n<p>在过去一周中，没有更新新的文章，这是因为我在准备一个新的文章系列–<a href=\"https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU2MjU3MzI0MA==&action=getalbum&album_id=4276738695946223617#wechat_redirect\">Vue从入门到精通</a>。这一系列文章大概在30篇左右，将涵盖Vue框架中众多核心知识，并会进行适当的源码解读，希望大家喜欢并持续关注。</p>\n<p>今天是该系列的第1篇文章，我们来讲讲<code>Vue是什么？</code></p>\n<p>在前端开发日新月异的浪潮中，Vue.js（简称Vue）凭借其简洁的语法、灵活的架构和友好的学习曲线，成为无数开发者构建Web应用的首选框架。要真正掌握Vue，我们需要从Web开发的历史脉络出发，逐步剖析其本质、核心特性，并通过与传统开发及React的对比，明确其定位与优势。</p>\n<h2 id=\"一、Web开发的历史演进：框架为何应运而生？\"><a href=\"#一、Web开发的历史演进：框架为何应运而生？\" class=\"headerlink\" title=\"一、Web开发的历史演进：框架为何应运而生？\"></a>一、Web开发的历史演进：框架为何应运而生？</h2><p>前端技术的发展始终围绕“提升开发效率”与“应对复杂场景”两大核心，Vue的出现是历史演进的必然结果，我们可将其分为三个关键阶段：</p>\n<h3 id=\"1-静态Web时代（1990s-2000s初）\"><a href=\"#1-静态Web时代（1990s-2000s初）\" class=\"headerlink\" title=\"1. 静态Web时代（1990s-2000s初）\"></a>1. 静态Web时代（1990s-2000s初）</h3><p>早期Web以“信息展示”为核心，页面由纯HTML（结构）+ CSS（样式）构成，交互逻辑仅依赖简单的JavaScript（如表单验证、弹窗）。此时无需框架——页面逻辑简单，DOM操作极少，开发者直接通过原生API修改元素即可。</p>\n<h3 id=\"2-动态交互萌芽（2000s中-2010s初）\"><a href=\"#2-动态交互萌芽（2000s中-2010s初）\" class=\"headerlink\" title=\"2. 动态交互萌芽（2000s中-2010s初）\"></a>2. 动态交互萌芽（2000s中-2010s初）</h3><p>随着AJAX技术（2005年谷歌地图普及）的出现，Web应用从“页面跳转式”升级为“局部刷新式”，开发者开始面临新挑战：  </p>\n<ul>\n<li>手动管理DOM与数据的同步（如表单提交后更新列表），代码充斥<code>document.getElementById</code>、<code>innerHTML</code>等命令式操作；  </li>\n<li>项目复杂度提升后，jQuery（2006年诞生）成为主流工具，但仍需手动维护“数据- DOM”映射关系，代码耦合度高、可维护性差。</li>\n</ul>\n<h3 id=\"3-前端框架崛起（2010s至今）\"><a href=\"#3-前端框架崛起（2010s至今）\" class=\"headerlink\" title=\"3. 前端框架崛起（2010s至今）\"></a>3. 前端框架崛起（2010s至今）</h3><p>2010年后，单页应用（SPA）成为主流（如微信网页版、在线文档），传统开发模式彻底无法满足需求：  </p>\n<ul>\n<li>数据与DOM同步混乱（如一个数据变更需修改多个DOM节点）；  </li>\n<li>代码复用困难（如导航栏、弹窗需重复编写）；  </li>\n<li>团队协作效率低（无统一代码规范）。</li>\n</ul>\n<p>此时，<strong>以数据驱动、组件化为核心的前端框架</strong>应运而生，Vue（2014年由Evan You发布）与Angular、React共同构成了“前端三大框架”，彻底改变了前端开发模式。</p>\n<h2 id=\"二、Vue是什么：渐进式的前端框架\"><a href=\"#二、Vue是什么：渐进式的前端框架\" class=\"headerlink\" title=\"二、Vue是什么：渐进式的前端框架\"></a>二、Vue是什么：渐进式的前端框架</h2><p>Vue官方定义为“一套用于构建用户界面的渐进式框架”，这句话精准概括了其核心特质：</p>\n<h3 id=\"1-核心定位：渐进式与易用性\"><a href=\"#1-核心定位：渐进式与易用性\" class=\"headerlink\" title=\"1. 核心定位：渐进式与易用性\"></a>1. 核心定位：渐进式与易用性</h3><p>“渐进式”意味着Vue不强制开发者使用其所有功能——可根据项目需求灵活引入：  </p>\n<ul>\n<li>小型项目：仅用Vue核心库（数据绑定+指令），无需额外依赖；  </li>\n<li>中型项目：引入Vue Router（路由）、Pinia（状态管理）；  </li>\n<li>大型项目：结合Vite（构建工具）、TypeScript（类型检查），形成完整工程化方案。</li>\n</ul>\n<p>这种“按需使用”的设计，让Vue既能满足个人小项目的快速开发，也能支撑企业级应用的复杂需求。</p>\n<h3 id=\"2-版本演进：从Vue-2到Vue-3\"><a href=\"#2-版本演进：从Vue-2到Vue-3\" class=\"headerlink\" title=\"2. 版本演进：从Vue 2到Vue 3\"></a>2. 版本演进：从Vue 2到Vue 3</h3><p>Vue的发展历经两次关键迭代，核心能力持续升级：  </p>\n<ul>\n<li><strong>Vue 2（2016年）</strong>：奠定基础，通过<code>Object.defineProperty</code>实现响应式，支持单文件组件（.vue），生态快速完善（Vue Router 3、Vuex 3）；  </li>\n<li><strong>Vue 3（2020年）</strong>：全面重构，解决Vue 2的性能瓶颈与扩展性问题：  <ul>\n<li>用<code>Proxy</code>替代<code>Object.defineProperty</code>，支持数组索引、对象新增属性的响应式监听；  </li>\n<li>引入Composition API（组合式API），解决大型组件中Options API（选项式API）的逻辑分散问题；  </li>\n<li>支持Tree-Shaking（按需打包），减少生产环境体积。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"三、Vue的核心特性：为何它能简化开发？\"><a href=\"#三、Vue的核心特性：为何它能简化开发？\" class=\"headerlink\" title=\"三、Vue的核心特性：为何它能简化开发？\"></a>三、Vue的核心特性：为何它能简化开发？</h2><p>Vue的强大源于其精心设计的核心特性，这些特性围绕“让开发者专注于数据与逻辑，而非DOM操作”展开：</p>\n<h3 id=\"1-数据驱动：响应式与双向绑定\"><a href=\"#1-数据驱动：响应式与双向绑定\" class=\"headerlink\" title=\"1. 数据驱动：响应式与双向绑定\"></a>1. 数据驱动：响应式与双向绑定</h3><p>这是Vue的灵魂特性，核心逻辑是“数据变化时，DOM自动更新”，无需手动操作DOM：  </p>\n<ul>\n<li><strong>响应式原理</strong>：Vue 3通过<code>Proxy</code>监听数据对象的读写，数据变更时自动触发依赖更新（如重新渲染组件）；  </li>\n<li><strong>双向绑定（v-model）</strong>：简化表单交互，例如：  <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">&quot;username&quot;</span> /&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>你输入的用户名：&#123;&#123; username &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">setup</span>&gt;</span><span class=\"language-javascript\"></span><br><span class=\"language-javascript\">  <span class=\"hljs-keyword\">import</span> &#123; ref &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;vue&#x27;</span></span><br><span class=\"language-javascript\">  <span class=\"hljs-keyword\">const</span> username = <span class=\"hljs-title function_\">ref</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>) <span class=\"hljs-comment\">// 响应式数据</span></span><br><span class=\"language-javascript\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br></code></pre></td></tr></table></figure>\n输入框内容变化时，<code>username</code>自动更新，页面也随之刷新——开发者无需编写<code>oninput</code>事件。</li>\n</ul>\n<h3 id=\"2-组件化：复用与解耦\"><a href=\"#2-组件化：复用与解耦\" class=\"headerlink\" title=\"2. 组件化：复用与解耦\"></a>2. 组件化：复用与解耦</h3><p>组件是Vue应用的基本单元，将页面拆分为独立、可复用的模块（如导航栏、卡片、按钮），实现“一次编写，多处使用”：  </p>\n<ul>\n<li><strong>单文件组件（SFC）</strong>：以<code>.vue</code>文件整合模板（template）、逻辑（script）、样式（style），结构清晰：  <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span><span class=\"hljs-comment\">&lt;!-- 组件UI结构 --&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">setup</span>&gt;</span><span class=\"language-handlebars\"><span class=\"language-xml\"><span class=\"hljs-comment\">&lt;!-- 组件逻辑 --&gt;</span></span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">scoped</span>&gt;</span><span class=\"language-xml\"><span class=\"hljs-comment\">&lt;!-- 组件样式（仅作用于当前组件） --&gt;</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br></code></pre></td></tr></table></figure></li>\n<li><strong>组件通信</strong>：提供灵活的通信方式，如<code>props</code>（父传子）、<code>emit</code>（子传父）、<code>provide/inject</code>（跨层级）、Pinia（全局状态）。</li>\n</ul>\n<h3 id=\"3-指令系统：简化DOM操作\"><a href=\"#3-指令系统：简化DOM操作\" class=\"headerlink\" title=\"3. 指令系统：简化DOM操作\"></a>3. 指令系统：简化DOM操作</h3><p>Vue提供内置指令（以<code>v-</code>开头），将常见DOM操作封装为声明式语法，开发者无需关注“如何操作DOM”，只需关注“要实现什么效果”：  </p>\n<ul>\n<li><code>v-if</code>&#x2F;<code>v-else</code>：条件渲染（根据数据决定是否显示DOM）；  </li>\n<li><code>v-for</code>：列表渲染（根据数组自动生成DOM列表）；  </li>\n<li><code>v-bind</code>：属性绑定（将数据与DOM属性关联，简写为<code>:</code>）；  </li>\n<li><code>v-on</code>：事件绑定（监听DOM事件，简写为<code>@</code>）。</li>\n</ul>\n<h3 id=\"4-生命周期：控制组件运行时机\"><a href=\"#4-生命周期：控制组件运行时机\" class=\"headerlink\" title=\"4. 生命周期：控制组件运行时机\"></a>4. 生命周期：控制组件运行时机</h3><p>Vue为组件提供完整的生命周期钩子，允许开发者在特定阶段执行逻辑（如初始化数据、发起请求、清理资源）：  </p>\n<ul>\n<li>Vue 3组合式API中，常用钩子如<code>onMounted</code>（组件挂载后）、<code>onUpdated</code>（组件更新后）、<code>onUnmounted</code>（组件卸载前）：  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> &#123; onMounted &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;vue&#x27;</span><br><span class=\"hljs-title function_\">onMounted</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-comment\">// 组件挂载后发起AJAX请求，获取数据</span><br>  <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&#x27;/api/data&#x27;</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> res.<span class=\"hljs-title function_\">json</span>())<br>&#125;)<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"5-Vue-3新增特性：更强大的扩展性\"><a href=\"#5-Vue-3新增特性：更强大的扩展性\" class=\"headerlink\" title=\"5. Vue 3新增特性：更强大的扩展性\"></a>5. Vue 3新增特性：更强大的扩展性</h3><p>Vue 3在核心特性外，新增了多个实用功能：  </p>\n<ul>\n<li><strong>Teleport</strong>：将组件DOM渲染到指定位置（如弹窗渲染到<code>body</code>下，避免样式嵌套问题）；  </li>\n<li><strong>Suspense</strong>：异步组件加载时显示占位内容（如loading），提升用户体验；  </li>\n<li><strong>TypeScript支持</strong>：原生支持TypeScript，提供类型提示，减少运行时错误。</li>\n</ul>\n<h2 id=\"四、Vue与传统开发的区别：效率的质变\"><a href=\"#四、Vue与传统开发的区别：效率的质变\" class=\"headerlink\" title=\"四、Vue与传统开发的区别：效率的质变\"></a>四、Vue与传统开发的区别：效率的质变</h2><p>传统开发（以jQuery为代表）与Vue的核心差异，本质是“命令式”与“声明式”的区别，具体体现在以下维度：</p>\n<table>\n<thead>\n<tr>\n<th>对比维度</th>\n<th>传统开发（jQuery）</th>\n<th>Vue开发</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DOM操作方式</td>\n<td>命令式：手动查找、修改DOM（如<code>$(&#39;#box&#39;).text(&#39;hello&#39;)</code>）</td>\n<td>声明式：仅关注数据，DOM自动更新</td>\n</tr>\n<tr>\n<td>代码组织</td>\n<td>逻辑与DOM操作混合，耦合度高</td>\n<td>组件化拆分，逻辑、UI、样式分离</td>\n</tr>\n<tr>\n<td>数据与DOM同步</td>\n<td>手动维护（数据变后需手动更新DOM）</td>\n<td>响应式自动同步（数据变→DOM变）</td>\n</tr>\n<tr>\n<td>复用性</td>\n<td>需通过函数封装，复用成本高</td>\n<td>组件可直接复用，支持跨项目导入</td>\n</tr>\n<tr>\n<td>工程化支持</td>\n<td>依赖第三方工具（如Gulp），配置复杂</td>\n<td>内置Vue CLI&#x2F;Vite，一键搭建工程化环境</td>\n</tr>\n<tr>\n<td>维护成本</td>\n<td>项目越大，代码越混乱，维护难度指数级上升</td>\n<td>组件化+响应式，维护成本线性增长</td>\n</tr>\n</tbody></table>\n<p>举个简单例子：实现“点击按钮修改文本”功能  </p>\n<ul>\n<li>传统jQuery方式：  <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;text&quot;</span>&gt;</span>原始文本<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;btn&quot;</span>&gt;</span>点击修改<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;jquery.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\"></span><br><span class=\"language-javascript\">  <span class=\"hljs-comment\">// 手动查找DOM，绑定事件，修改内容</span></span><br><span class=\"language-javascript\">  $(<span class=\"hljs-string\">&#x27;#btn&#x27;</span>).<span class=\"hljs-title function_\">click</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;</span><br><span class=\"language-javascript\">    $(<span class=\"hljs-string\">&#x27;#text&#x27;</span>).<span class=\"hljs-title function_\">text</span>(<span class=\"hljs-string\">&#x27;修改后的文本&#x27;</span>)</span><br><span class=\"language-javascript\">  &#125;)</span><br><span class=\"language-javascript\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li>\n<li>Vue方式：  <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">&quot;changeText&quot;</span>&gt;</span>点击修改<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">setup</span>&gt;</span><span class=\"language-javascript\"></span><br><span class=\"language-javascript\">  <span class=\"hljs-keyword\">import</span> &#123; ref &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;vue&#x27;</span></span><br><span class=\"language-javascript\">  <span class=\"hljs-keyword\">const</span> text = <span class=\"hljs-title function_\">ref</span>(<span class=\"hljs-string\">&#x27;原始文本&#x27;</span>)</span><br><span class=\"language-javascript\">  <span class=\"hljs-comment\">// 仅关注逻辑，无需操作DOM</span></span><br><span class=\"language-javascript\">  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">changeText</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;</span><br><span class=\"language-javascript\">    text.<span class=\"hljs-property\">value</span> = <span class=\"hljs-string\">&#x27;修改后的文本&#x27;</span></span><br><span class=\"language-javascript\">  &#125;</span><br><span class=\"language-javascript\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br></code></pre></td></tr></table></figure>\n可见，Vue彻底解放了DOM操作，让开发者聚焦于业务逻辑。</li>\n</ul>\n<h2 id=\"五、Vue与React的对比：各有所长的框架选择\"><a href=\"#五、Vue与React的对比：各有所长的框架选择\" class=\"headerlink\" title=\"五、Vue与React的对比：各有所长的框架选择\"></a>五、Vue与React的对比：各有所长的框架选择</h2><p>Vue与React作为当前最流行的两大前端框架，各有设计理念与适用场景，不存在“绝对优劣”，仅需根据项目需求选择：</p>\n<table>\n<thead>\n<tr>\n<th>对比维度</th>\n<th>Vue</th>\n<th>React</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>设计理念</td>\n<td>渐进式框架，追求“易用性”与“开箱即用”</td>\n<td>函数式编程思想，追求“灵活性”与“可扩展性”</td>\n</tr>\n<tr>\n<td>模板与UI语法</td>\n<td>支持HTML模板（更贴近传统前端开发），也支持JSX</td>\n<td>仅支持JSX（将HTML嵌入JS，需适应“JS中写UI”）</td>\n</tr>\n<tr>\n<td>响应式原理</td>\n<td>Vue 3用<code>Proxy</code>，自动响应式（无需手动触发更新）</td>\n<td>用<code>setState</code>&#x2F;<code>useState</code>手动触发更新（需理解“状态不可变”）</td>\n</tr>\n<tr>\n<td>状态管理</td>\n<td>官方推荐Pinia（轻量、简洁，集成Vue DevTools）</td>\n<td>生态丰富：Redux（严谨）、MobX（灵活）、Zustand（轻量）</td>\n</tr>\n<tr>\n<td>虚拟DOM与性能</td>\n<td>Vue 3虚拟DOM采用“块状更新”，性能优秀；且支持“编译时优化”（如静态节点提升）</td>\n<td>虚拟DOM采用Fiber架构，支持“时间切片”（避免长任务阻塞UI）；需手动优化（如<code>memo</code>、<code>useMemo</code>）</td>\n</tr>\n<tr>\n<td>学习曲线</td>\n<td>低：HTML模板+简单API，新手易上手</td>\n<td>中：需理解JSX、函数式编程、Hooks规则（如依赖数组）</td>\n</tr>\n<tr>\n<td>生态与社区</td>\n<td>生态完善（Vue Router、Pinia、Vite），中文文档丰富</td>\n<td>生态极丰富（React Router、Redux、Next.js），社区贡献活跃</td>\n</tr>\n<tr>\n<td>适用场景</td>\n<td>中小型项目快速开发、团队中前端新手较多、偏好HTML模板的场景</td>\n<td>大型复杂应用（如电商、中台）、需要高度定制化UI、团队熟悉函数式编程的场景</td>\n</tr>\n</tbody></table>\n<p>简单来说：若追求“快速上手、开箱即用”，Vue是更好选择；若需“高度灵活、应对复杂场景”，React更具优势。</p>\n<h2 id=\"六、总结与展望\"><a href=\"#六、总结与展望\" class=\"headerlink\" title=\"六、总结与展望\"></a>六、总结与展望</h2><p>Vue作为渐进式前端框架，以“数据驱动”和“组件化”为核心，解决了传统开发的效率痛点，同时通过Vue 3的迭代持续提升性能与扩展性。它既不是“最复杂的框架”，也不是“功能最全的框架”，却是“平衡了易用性与强大性”的优秀选择——无论是个人开发者的小项目，还是企业级的大型应用，Vue都能提供高效的解决方案。</p>\n<p>对于学习者而言，掌握Vue不仅是掌握一门框架，更是理解“数据驱动”“组件化”等前端核心思想的关键路径。</p>\n<p><strong>【往期精彩】</strong></p>\n<ul>\n<li><p><a href=\"https://mp.weixin.qq.com/s/c7IwODBilcxSyozJvjjHRw\">JavaScript ES6中的生成器(Decorator)是什么？有哪些应用场景？</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/pe4fywIh7WdigHuwRiqDlQ\">说说JavaScript中ES6 module(模块化)的诞生背景、核心语法及应用场景</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/lYqBgS0GJgQMX5PAW_snnQ\">一文说透ES6 Proxy: 从本质到应用场景</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/PtFtlNUH-UcLYU5h-xKiQw\">JavaScript ES6中的生成器(Generator)是什么？有哪些应用场景？一文全说透</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/9pnvL5fTO5U9yT-1mPfeQw\">聊聊ES6里的Promise：简单理解和实际用法</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/lqn_51NNxx50YgvWkxCtEg\">一文搞懂 JavaScript 里 var、let、const 的区别\n</a></p>\n</li>\n</ul>\n","excerpt":"","more":"<p>大家好，我是jvxiao。</p>\n<p>在上一个<a href=\"https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU2MjU3MzI0MA==&action=getalbum&album_id=4120256678140837890#wechat_redirect\">JavaScript ES6进阶系列文章</a>从简单的let, const一路讲到了日常开发较少使用的Decorator，很多文章也收到了很多各位读者喜欢和推荐，在这里感谢各位读者朋友的支持。</p>\n<p>在过去一周中，没有更新新的文章，这是因为我在准备一个新的文章系列–<a href=\"https://mp.weixin.qq.com/mp/appmsgalbum?__biz=MzU2MjU3MzI0MA==&action=getalbum&album_id=4276738695946223617#wechat_redirect\">Vue从入门到精通</a>。这一系列文章大概在30篇左右，将涵盖Vue框架中众多核心知识，并会进行适当的源码解读，希望大家喜欢并持续关注。</p>\n<p>今天是该系列的第1篇文章，我们来讲讲<code>Vue是什么？</code></p>\n<p>在前端开发日新月异的浪潮中，Vue.js（简称Vue）凭借其简洁的语法、灵活的架构和友好的学习曲线，成为无数开发者构建Web应用的首选框架。要真正掌握Vue，我们需要从Web开发的历史脉络出发，逐步剖析其本质、核心特性，并通过与传统开发及React的对比，明确其定位与优势。</p>\n<h2 id=\"一、Web开发的历史演进：框架为何应运而生？\"><a href=\"#一、Web开发的历史演进：框架为何应运而生？\" class=\"headerlink\" title=\"一、Web开发的历史演进：框架为何应运而生？\"></a>一、Web开发的历史演进：框架为何应运而生？</h2><p>前端技术的发展始终围绕“提升开发效率”与“应对复杂场景”两大核心，Vue的出现是历史演进的必然结果，我们可将其分为三个关键阶段：</p>\n<h3 id=\"1-静态Web时代（1990s-2000s初）\"><a href=\"#1-静态Web时代（1990s-2000s初）\" class=\"headerlink\" title=\"1. 静态Web时代（1990s-2000s初）\"></a>1. 静态Web时代（1990s-2000s初）</h3><p>早期Web以“信息展示”为核心，页面由纯HTML（结构）+ CSS（样式）构成，交互逻辑仅依赖简单的JavaScript（如表单验证、弹窗）。此时无需框架——页面逻辑简单，DOM操作极少，开发者直接通过原生API修改元素即可。</p>\n<h3 id=\"2-动态交互萌芽（2000s中-2010s初）\"><a href=\"#2-动态交互萌芽（2000s中-2010s初）\" class=\"headerlink\" title=\"2. 动态交互萌芽（2000s中-2010s初）\"></a>2. 动态交互萌芽（2000s中-2010s初）</h3><p>随着AJAX技术（2005年谷歌地图普及）的出现，Web应用从“页面跳转式”升级为“局部刷新式”，开发者开始面临新挑战：  </p>\n<ul>\n<li>手动管理DOM与数据的同步（如表单提交后更新列表），代码充斥<code>document.getElementById</code>、<code>innerHTML</code>等命令式操作；  </li>\n<li>项目复杂度提升后，jQuery（2006年诞生）成为主流工具，但仍需手动维护“数据- DOM”映射关系，代码耦合度高、可维护性差。</li>\n</ul>\n<h3 id=\"3-前端框架崛起（2010s至今）\"><a href=\"#3-前端框架崛起（2010s至今）\" class=\"headerlink\" title=\"3. 前端框架崛起（2010s至今）\"></a>3. 前端框架崛起（2010s至今）</h3><p>2010年后，单页应用（SPA）成为主流（如微信网页版、在线文档），传统开发模式彻底无法满足需求：  </p>\n<ul>\n<li>数据与DOM同步混乱（如一个数据变更需修改多个DOM节点）；  </li>\n<li>代码复用困难（如导航栏、弹窗需重复编写）；  </li>\n<li>团队协作效率低（无统一代码规范）。</li>\n</ul>\n<p>此时，<strong>以数据驱动、组件化为核心的前端框架</strong>应运而生，Vue（2014年由Evan You发布）与Angular、React共同构成了“前端三大框架”，彻底改变了前端开发模式。</p>\n<h2 id=\"二、Vue是什么：渐进式的前端框架\"><a href=\"#二、Vue是什么：渐进式的前端框架\" class=\"headerlink\" title=\"二、Vue是什么：渐进式的前端框架\"></a>二、Vue是什么：渐进式的前端框架</h2><p>Vue官方定义为“一套用于构建用户界面的渐进式框架”，这句话精准概括了其核心特质：</p>\n<h3 id=\"1-核心定位：渐进式与易用性\"><a href=\"#1-核心定位：渐进式与易用性\" class=\"headerlink\" title=\"1. 核心定位：渐进式与易用性\"></a>1. 核心定位：渐进式与易用性</h3><p>“渐进式”意味着Vue不强制开发者使用其所有功能——可根据项目需求灵活引入：  </p>\n<ul>\n<li>小型项目：仅用Vue核心库（数据绑定+指令），无需额外依赖；  </li>\n<li>中型项目：引入Vue Router（路由）、Pinia（状态管理）；  </li>\n<li>大型项目：结合Vite（构建工具）、TypeScript（类型检查），形成完整工程化方案。</li>\n</ul>\n<p>这种“按需使用”的设计，让Vue既能满足个人小项目的快速开发，也能支撑企业级应用的复杂需求。</p>\n<h3 id=\"2-版本演进：从Vue-2到Vue-3\"><a href=\"#2-版本演进：从Vue-2到Vue-3\" class=\"headerlink\" title=\"2. 版本演进：从Vue 2到Vue 3\"></a>2. 版本演进：从Vue 2到Vue 3</h3><p>Vue的发展历经两次关键迭代，核心能力持续升级：  </p>\n<ul>\n<li><strong>Vue 2（2016年）</strong>：奠定基础，通过<code>Object.defineProperty</code>实现响应式，支持单文件组件（.vue），生态快速完善（Vue Router 3、Vuex 3）；  </li>\n<li><strong>Vue 3（2020年）</strong>：全面重构，解决Vue 2的性能瓶颈与扩展性问题：  <ul>\n<li>用<code>Proxy</code>替代<code>Object.defineProperty</code>，支持数组索引、对象新增属性的响应式监听；  </li>\n<li>引入Composition API（组合式API），解决大型组件中Options API（选项式API）的逻辑分散问题；  </li>\n<li>支持Tree-Shaking（按需打包），减少生产环境体积。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"三、Vue的核心特性：为何它能简化开发？\"><a href=\"#三、Vue的核心特性：为何它能简化开发？\" class=\"headerlink\" title=\"三、Vue的核心特性：为何它能简化开发？\"></a>三、Vue的核心特性：为何它能简化开发？</h2><p>Vue的强大源于其精心设计的核心特性，这些特性围绕“让开发者专注于数据与逻辑，而非DOM操作”展开：</p>\n<h3 id=\"1-数据驱动：响应式与双向绑定\"><a href=\"#1-数据驱动：响应式与双向绑定\" class=\"headerlink\" title=\"1. 数据驱动：响应式与双向绑定\"></a>1. 数据驱动：响应式与双向绑定</h3><p>这是Vue的灵魂特性，核心逻辑是“数据变化时，DOM自动更新”，无需手动操作DOM：  </p>\n<ul>\n<li><strong>响应式原理</strong>：Vue 3通过<code>Proxy</code>监听数据对象的读写，数据变更时自动触发依赖更新（如重新渲染组件）；  </li>\n<li><strong>双向绑定（v-model）</strong>：简化表单交互，例如：  <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">v-model</span>=<span class=\"hljs-string\">&quot;username&quot;</span> /&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>你输入的用户名：&#123;&#123; username &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">setup</span>&gt;</span><span class=\"language-javascript\"></span><br><span class=\"language-javascript\">  <span class=\"hljs-keyword\">import</span> &#123; ref &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;vue&#x27;</span></span><br><span class=\"language-javascript\">  <span class=\"hljs-keyword\">const</span> username = <span class=\"hljs-title function_\">ref</span>(<span class=\"hljs-string\">&#x27;&#x27;</span>) <span class=\"hljs-comment\">// 响应式数据</span></span><br><span class=\"language-javascript\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br></code></pre></td></tr></table></figure>\n输入框内容变化时，<code>username</code>自动更新，页面也随之刷新——开发者无需编写<code>oninput</code>事件。</li>\n</ul>\n<h3 id=\"2-组件化：复用与解耦\"><a href=\"#2-组件化：复用与解耦\" class=\"headerlink\" title=\"2. 组件化：复用与解耦\"></a>2. 组件化：复用与解耦</h3><p>组件是Vue应用的基本单元，将页面拆分为独立、可复用的模块（如导航栏、卡片、按钮），实现“一次编写，多处使用”：  </p>\n<ul>\n<li><strong>单文件组件（SFC）</strong>：以<code>.vue</code>文件整合模板（template）、逻辑（script）、样式（style），结构清晰：  <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span><span class=\"hljs-comment\">&lt;!-- 组件UI结构 --&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">setup</span>&gt;</span><span class=\"language-handlebars\"><span class=\"language-xml\"><span class=\"hljs-comment\">&lt;!-- 组件逻辑 --&gt;</span></span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span> <span class=\"hljs-attr\">scoped</span>&gt;</span><span class=\"language-xml\"><span class=\"hljs-comment\">&lt;!-- 组件样式（仅作用于当前组件） --&gt;</span></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span><br></code></pre></td></tr></table></figure></li>\n<li><strong>组件通信</strong>：提供灵活的通信方式，如<code>props</code>（父传子）、<code>emit</code>（子传父）、<code>provide/inject</code>（跨层级）、Pinia（全局状态）。</li>\n</ul>\n<h3 id=\"3-指令系统：简化DOM操作\"><a href=\"#3-指令系统：简化DOM操作\" class=\"headerlink\" title=\"3. 指令系统：简化DOM操作\"></a>3. 指令系统：简化DOM操作</h3><p>Vue提供内置指令（以<code>v-</code>开头），将常见DOM操作封装为声明式语法，开发者无需关注“如何操作DOM”，只需关注“要实现什么效果”：  </p>\n<ul>\n<li><code>v-if</code>&#x2F;<code>v-else</code>：条件渲染（根据数据决定是否显示DOM）；  </li>\n<li><code>v-for</code>：列表渲染（根据数组自动生成DOM列表）；  </li>\n<li><code>v-bind</code>：属性绑定（将数据与DOM属性关联，简写为<code>:</code>）；  </li>\n<li><code>v-on</code>：事件绑定（监听DOM事件，简写为<code>@</code>）。</li>\n</ul>\n<h3 id=\"4-生命周期：控制组件运行时机\"><a href=\"#4-生命周期：控制组件运行时机\" class=\"headerlink\" title=\"4. 生命周期：控制组件运行时机\"></a>4. 生命周期：控制组件运行时机</h3><p>Vue为组件提供完整的生命周期钩子，允许开发者在特定阶段执行逻辑（如初始化数据、发起请求、清理资源）：  </p>\n<ul>\n<li>Vue 3组合式API中，常用钩子如<code>onMounted</code>（组件挂载后）、<code>onUpdated</code>（组件更新后）、<code>onUnmounted</code>（组件卸载前）：  <figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\"><span class=\"hljs-keyword\">import</span> &#123; onMounted &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;vue&#x27;</span><br><span class=\"hljs-title function_\">onMounted</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;<br>  <span class=\"hljs-comment\">// 组件挂载后发起AJAX请求，获取数据</span><br>  <span class=\"hljs-title function_\">fetch</span>(<span class=\"hljs-string\">&#x27;/api/data&#x27;</span>).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">res</span> =&gt;</span> res.<span class=\"hljs-title function_\">json</span>())<br>&#125;)<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h3 id=\"5-Vue-3新增特性：更强大的扩展性\"><a href=\"#5-Vue-3新增特性：更强大的扩展性\" class=\"headerlink\" title=\"5. Vue 3新增特性：更强大的扩展性\"></a>5. Vue 3新增特性：更强大的扩展性</h3><p>Vue 3在核心特性外，新增了多个实用功能：  </p>\n<ul>\n<li><strong>Teleport</strong>：将组件DOM渲染到指定位置（如弹窗渲染到<code>body</code>下，避免样式嵌套问题）；  </li>\n<li><strong>Suspense</strong>：异步组件加载时显示占位内容（如loading），提升用户体验；  </li>\n<li><strong>TypeScript支持</strong>：原生支持TypeScript，提供类型提示，减少运行时错误。</li>\n</ul>\n<h2 id=\"四、Vue与传统开发的区别：效率的质变\"><a href=\"#四、Vue与传统开发的区别：效率的质变\" class=\"headerlink\" title=\"四、Vue与传统开发的区别：效率的质变\"></a>四、Vue与传统开发的区别：效率的质变</h2><p>传统开发（以jQuery为代表）与Vue的核心差异，本质是“命令式”与“声明式”的区别，具体体现在以下维度：</p>\n<table>\n<thead>\n<tr>\n<th>对比维度</th>\n<th>传统开发（jQuery）</th>\n<th>Vue开发</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DOM操作方式</td>\n<td>命令式：手动查找、修改DOM（如<code>$(&#39;#box&#39;).text(&#39;hello&#39;)</code>）</td>\n<td>声明式：仅关注数据，DOM自动更新</td>\n</tr>\n<tr>\n<td>代码组织</td>\n<td>逻辑与DOM操作混合，耦合度高</td>\n<td>组件化拆分，逻辑、UI、样式分离</td>\n</tr>\n<tr>\n<td>数据与DOM同步</td>\n<td>手动维护（数据变后需手动更新DOM）</td>\n<td>响应式自动同步（数据变→DOM变）</td>\n</tr>\n<tr>\n<td>复用性</td>\n<td>需通过函数封装，复用成本高</td>\n<td>组件可直接复用，支持跨项目导入</td>\n</tr>\n<tr>\n<td>工程化支持</td>\n<td>依赖第三方工具（如Gulp），配置复杂</td>\n<td>内置Vue CLI&#x2F;Vite，一键搭建工程化环境</td>\n</tr>\n<tr>\n<td>维护成本</td>\n<td>项目越大，代码越混乱，维护难度指数级上升</td>\n<td>组件化+响应式，维护成本线性增长</td>\n</tr>\n</tbody></table>\n<p>举个简单例子：实现“点击按钮修改文本”功能  </p>\n<ul>\n<li>传统jQuery方式：  <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;text&quot;</span>&gt;</span>原始文本<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;btn&quot;</span>&gt;</span>点击修改<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;jquery.js&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\"></span><br><span class=\"language-javascript\">  <span class=\"hljs-comment\">// 手动查找DOM，绑定事件，修改内容</span></span><br><span class=\"language-javascript\">  $(<span class=\"hljs-string\">&#x27;#btn&#x27;</span>).<span class=\"hljs-title function_\">click</span>(<span class=\"hljs-function\">() =&gt;</span> &#123;</span><br><span class=\"language-javascript\">    $(<span class=\"hljs-string\">&#x27;#text&#x27;</span>).<span class=\"hljs-title function_\">text</span>(<span class=\"hljs-string\">&#x27;修改后的文本&#x27;</span>)</span><br><span class=\"language-javascript\">  &#125;)</span><br><span class=\"language-javascript\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li>\n<li>Vue方式：  <figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">template</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span><br>  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> @<span class=\"hljs-attr\">click</span>=<span class=\"hljs-string\">&quot;changeText&quot;</span>&gt;</span>点击修改<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">template</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span> <span class=\"hljs-attr\">setup</span>&gt;</span><span class=\"language-javascript\"></span><br><span class=\"language-javascript\">  <span class=\"hljs-keyword\">import</span> &#123; ref &#125; <span class=\"hljs-keyword\">from</span> <span class=\"hljs-string\">&#x27;vue&#x27;</span></span><br><span class=\"language-javascript\">  <span class=\"hljs-keyword\">const</span> text = <span class=\"hljs-title function_\">ref</span>(<span class=\"hljs-string\">&#x27;原始文本&#x27;</span>)</span><br><span class=\"language-javascript\">  <span class=\"hljs-comment\">// 仅关注逻辑，无需操作DOM</span></span><br><span class=\"language-javascript\">  <span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">changeText</span> = (<span class=\"hljs-params\"></span>) =&gt; &#123;</span><br><span class=\"language-javascript\">    text.<span class=\"hljs-property\">value</span> = <span class=\"hljs-string\">&#x27;修改后的文本&#x27;</span></span><br><span class=\"language-javascript\">  &#125;</span><br><span class=\"language-javascript\"></span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span><br></code></pre></td></tr></table></figure>\n可见，Vue彻底解放了DOM操作，让开发者聚焦于业务逻辑。</li>\n</ul>\n<h2 id=\"五、Vue与React的对比：各有所长的框架选择\"><a href=\"#五、Vue与React的对比：各有所长的框架选择\" class=\"headerlink\" title=\"五、Vue与React的对比：各有所长的框架选择\"></a>五、Vue与React的对比：各有所长的框架选择</h2><p>Vue与React作为当前最流行的两大前端框架，各有设计理念与适用场景，不存在“绝对优劣”，仅需根据项目需求选择：</p>\n<table>\n<thead>\n<tr>\n<th>对比维度</th>\n<th>Vue</th>\n<th>React</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>设计理念</td>\n<td>渐进式框架，追求“易用性”与“开箱即用”</td>\n<td>函数式编程思想，追求“灵活性”与“可扩展性”</td>\n</tr>\n<tr>\n<td>模板与UI语法</td>\n<td>支持HTML模板（更贴近传统前端开发），也支持JSX</td>\n<td>仅支持JSX（将HTML嵌入JS，需适应“JS中写UI”）</td>\n</tr>\n<tr>\n<td>响应式原理</td>\n<td>Vue 3用<code>Proxy</code>，自动响应式（无需手动触发更新）</td>\n<td>用<code>setState</code>&#x2F;<code>useState</code>手动触发更新（需理解“状态不可变”）</td>\n</tr>\n<tr>\n<td>状态管理</td>\n<td>官方推荐Pinia（轻量、简洁，集成Vue DevTools）</td>\n<td>生态丰富：Redux（严谨）、MobX（灵活）、Zustand（轻量）</td>\n</tr>\n<tr>\n<td>虚拟DOM与性能</td>\n<td>Vue 3虚拟DOM采用“块状更新”，性能优秀；且支持“编译时优化”（如静态节点提升）</td>\n<td>虚拟DOM采用Fiber架构，支持“时间切片”（避免长任务阻塞UI）；需手动优化（如<code>memo</code>、<code>useMemo</code>）</td>\n</tr>\n<tr>\n<td>学习曲线</td>\n<td>低：HTML模板+简单API，新手易上手</td>\n<td>中：需理解JSX、函数式编程、Hooks规则（如依赖数组）</td>\n</tr>\n<tr>\n<td>生态与社区</td>\n<td>生态完善（Vue Router、Pinia、Vite），中文文档丰富</td>\n<td>生态极丰富（React Router、Redux、Next.js），社区贡献活跃</td>\n</tr>\n<tr>\n<td>适用场景</td>\n<td>中小型项目快速开发、团队中前端新手较多、偏好HTML模板的场景</td>\n<td>大型复杂应用（如电商、中台）、需要高度定制化UI、团队熟悉函数式编程的场景</td>\n</tr>\n</tbody></table>\n<p>简单来说：若追求“快速上手、开箱即用”，Vue是更好选择；若需“高度灵活、应对复杂场景”，React更具优势。</p>\n<h2 id=\"六、总结与展望\"><a href=\"#六、总结与展望\" class=\"headerlink\" title=\"六、总结与展望\"></a>六、总结与展望</h2><p>Vue作为渐进式前端框架，以“数据驱动”和“组件化”为核心，解决了传统开发的效率痛点，同时通过Vue 3的迭代持续提升性能与扩展性。它既不是“最复杂的框架”，也不是“功能最全的框架”，却是“平衡了易用性与强大性”的优秀选择——无论是个人开发者的小项目，还是企业级的大型应用，Vue都能提供高效的解决方案。</p>\n<p>对于学习者而言，掌握Vue不仅是掌握一门框架，更是理解“数据驱动”“组件化”等前端核心思想的关键路径。</p>\n<p><strong>【往期精彩】</strong></p>\n<ul>\n<li><p><a href=\"https://mp.weixin.qq.com/s/c7IwODBilcxSyozJvjjHRw\">JavaScript ES6中的生成器(Decorator)是什么？有哪些应用场景？</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/pe4fywIh7WdigHuwRiqDlQ\">说说JavaScript中ES6 module(模块化)的诞生背景、核心语法及应用场景</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/lYqBgS0GJgQMX5PAW_snnQ\">一文说透ES6 Proxy: 从本质到应用场景</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/PtFtlNUH-UcLYU5h-xKiQw\">JavaScript ES6中的生成器(Generator)是什么？有哪些应用场景？一文全说透</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/9pnvL5fTO5U9yT-1mPfeQw\">聊聊ES6里的Promise：简单理解和实际用法</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/lqn_51NNxx50YgvWkxCtEg\">一文搞懂 JavaScript 里 var、let、const 的区别\n</a></p>\n</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cmjbml2hv0002ikupdcai5v7e","category_id":"cmjbml2hy0005ikup88n32osy","_id":"cmjbml2i2000eikup0s9ghpnu"},{"post_id":"cmjbml2hy0004ikupg0cw8qei","category_id":"cmjbml2i1000aikup469q63du","_id":"cmjbml2i4000jikup91ed7kpu"},{"post_id":"cmjbml2hz0006ikup2m470vsb","category_id":"cmjbml2i2000fikup70r54rcz","_id":"cmjbml2i6000pikupdbpde6q1"},{"post_id":"cmjbml2hz0007ikupbp9ja8sk","category_id":"cmjbml2i2000fikup70r54rcz","_id":"cmjbml2i8000vikup400843os"},{"post_id":"cmjbml2i1000bikupap4zb25k","category_id":"cmjbml2i6000oikup1c2z77l5","_id":"cmjbml2i90013ikupafqs8rcd"},{"post_id":"cmjbml2i2000dikupelwgcm3g","category_id":"cmjbml2i6000oikup1c2z77l5","_id":"cmjbml2ia0017ikup85qva2ho"},{"post_id":"cmjbml2i80010ikupck7rgh18","category_id":"cmjbml2i2000fikup70r54rcz","_id":"cmjbml2ib001bikup93bagbhs"},{"post_id":"cmjbml2i90014ikup0vnces7x","category_id":"cmjbml2i2000fikup70r54rcz","_id":"cmjbml2ic001eikupeznrc49s"},{"post_id":"cmjbml2i5000likup3zhi9y11","category_id":"cmjbml2i90012ikup75r7b4et","_id":"cmjbml2id001jikupe3whhibz"},{"post_id":"cmjbml2ia0018ikupad3vdtx1","category_id":"cmjbml2i6000oikup1c2z77l5","_id":"cmjbml2id001likup83ipfyp2"},{"post_id":"cmjbml2ib001cikupdgd6706c","category_id":"cmjbml2i6000oikup1c2z77l5","_id":"cmjbml2ie001pikup57ruc61d"},{"post_id":"cmjbml2i6000nikup2po69taq","category_id":"cmjbml2i90012ikup75r7b4et","_id":"cmjbml2if001rikup96zldfei"},{"post_id":"cmjbml2ic001gikup3bt80b06","category_id":"cmjbml2i2000fikup70r54rcz","_id":"cmjbml2ig001vikupb7ul0lvf"},{"post_id":"cmjbml2id001kikup5hz0dp7x","category_id":"cmjbml2i2000fikup70r54rcz","_id":"cmjbml2ig001yikup2frv3fat"},{"post_id":"cmjbml2i6000rikup0jja6guf","category_id":"cmjbml2i90012ikup75r7b4et","_id":"cmjbml2ih0021ikup1q7c4bn1"},{"post_id":"cmjbml2id001mikup7p874pb1","category_id":"cmjbml2i6000oikup1c2z77l5","_id":"cmjbml2ih0023ikup16t6g4c3"},{"post_id":"cmjbml2i7000tikuphdhmg2gc","category_id":"cmjbml2i90012ikup75r7b4et","_id":"cmjbml2ih0024ikupab6oes1l"},{"post_id":"cmjbml2if001sikup5e1naudq","category_id":"cmjbml2i2000fikup70r54rcz","_id":"cmjbml2ih0026ikup01qf5qsv"},{"post_id":"cmjbml2ia0015ikupfme23rqd","category_id":"cmjbml2i2000fikup70r54rcz","_id":"cmjbml2ih0027ikup4pxlddv4"},{"post_id":"cmjbml2ia0015ikupfme23rqd","category_id":"cmjbml2if001tikup46l0dgpx","_id":"cmjbml2ih0029ikuphmgx36ux"},{"post_id":"cmjbml2iu0043ikup5bjn4e6w","category_id":"cmjbml2i6000oikup1c2z77l5","_id":"cmjbml2iw004aikup2rnf9068"},{"post_id":"cmjbml2iu0045ikup5j3qdq69","category_id":"cmjbml2i6000oikup1c2z77l5","_id":"cmjbml2iw004eikupfwit40ql"},{"post_id":"cmjbml2iv0047ikupcka12zzu","category_id":"cmjbml2i6000oikup1c2z77l5","_id":"cmjbml2ix004gikuphfvn9eqh"},{"post_id":"cmjbml2iw004fikupbtna035n","category_id":"cmjbml2i6000oikup1c2z77l5","_id":"cmjbml2iy004pikupcorthgpo"},{"post_id":"cmjbml2ix004likup7zy139vd","category_id":"cmjbml2i2000fikup70r54rcz","_id":"cmjbml2iy004tikupft0kap41"},{"post_id":"cmjbml2iy004oikupegy9eqmt","category_id":"cmjbml2i6000oikup1c2z77l5","_id":"cmjbml2iz004vikup8uz5b7wi"}],"PostTag":[{"post_id":"cmjbml2hr0000ikup4du97din","tag_id":"cmjbml2hw0003ikup5vp13jba","_id":"cmjbml2i6000qikup4i4y9m4u"},{"post_id":"cmjbml2hr0000ikup4du97din","tag_id":"cmjbml2i00008ikup4qleh2u9","_id":"cmjbml2i7000sikup1pafhz8i"},{"post_id":"cmjbml2hr0000ikup4du97din","tag_id":"cmjbml2i2000cikup7syf7tu1","_id":"cmjbml2i8000wikupag6q655f"},{"post_id":"cmjbml2hr0000ikup4du97din","tag_id":"cmjbml2i3000hikup99t0aiyu","_id":"cmjbml2i8000zikupbwra93w2"},{"post_id":"cmjbml2hv0002ikupdcai5v7e","tag_id":"cmjbml2i5000mikup6jrsgjjo","_id":"cmjbml2ib001aikup02gm652i"},{"post_id":"cmjbml2hv0002ikupdcai5v7e","tag_id":"cmjbml2i7000uikup7prk1wp3","_id":"cmjbml2ib001dikupe6ji7fkl"},{"post_id":"cmjbml2hv0002ikupdcai5v7e","tag_id":"cmjbml2i90011ikup231w71yy","_id":"cmjbml2ic001iikup8lpp1kjc"},{"post_id":"cmjbml2hy0004ikupg0cw8qei","tag_id":"cmjbml2ia0016ikup7bdj8p82","_id":"cmjbml2ig001xikup9skiccx3"},{"post_id":"cmjbml2hy0004ikupg0cw8qei","tag_id":"cmjbml2ic001fikup3lylbrs7","_id":"cmjbml2ig001zikup55imdwnu"},{"post_id":"cmjbml2hy0004ikupg0cw8qei","tag_id":"cmjbml2ie001oikupbe7cdiwg","_id":"cmjbml2ih0022ikup1m4xezng"},{"post_id":"cmjbml2hz0006ikup2m470vsb","tag_id":"cmjbml2ig001uikuph2yt29zn","_id":"cmjbml2ih002aikupakyl1f8p"},{"post_id":"cmjbml2hz0006ikup2m470vsb","tag_id":"cmjbml2ig0020ikup9hos7xml","_id":"cmjbml2ih002bikup0tcvd84k"},{"post_id":"cmjbml2hz0006ikup2m470vsb","tag_id":"cmjbml2ih0025ikup9hlu5k5p","_id":"cmjbml2ih002dikupbyjo1ty0"},{"post_id":"cmjbml2i00009ikup4ji7ambw","tag_id":"cmjbml2ia0016ikup7bdj8p82","_id":"cmjbml2ii002eikuph0k73bsr"},{"post_id":"cmjbml2i1000bikupap4zb25k","tag_id":"cmjbml2ih002cikup5tbb47q4","_id":"cmjbml2ii002gikup3hn3d995"},{"post_id":"cmjbml2i2000dikupelwgcm3g","tag_id":"cmjbml2ih002cikup5tbb47q4","_id":"cmjbml2ii002iikupgjrfcy56"},{"post_id":"cmjbml2i3000gikup9dbvgof7","tag_id":"cmjbml2ii002hikupasay3cww","_id":"cmjbml2ii002kikup7n08dssc"},{"post_id":"cmjbml2i4000iikupf4yaed5n","tag_id":"cmjbml2ii002hikupasay3cww","_id":"cmjbml2ii002mikup76ry5fdj"},{"post_id":"cmjbml2i5000likup3zhi9y11","tag_id":"cmjbml2ii002likupf4wq06d2","_id":"cmjbml2ij002pikup9hog6e06"},{"post_id":"cmjbml2i5000likup3zhi9y11","tag_id":"cmjbml2ii002nikup5yutcd16","_id":"cmjbml2ij002qikupfxja72no"},{"post_id":"cmjbml2i6000nikup2po69taq","tag_id":"cmjbml2ii002likupf4wq06d2","_id":"cmjbml2ij002tikup3d637r8l"},{"post_id":"cmjbml2i6000nikup2po69taq","tag_id":"cmjbml2ii002nikup5yutcd16","_id":"cmjbml2ij002uikupa1bk2krh"},{"post_id":"cmjbml2i6000rikup0jja6guf","tag_id":"cmjbml2ii002likupf4wq06d2","_id":"cmjbml2ij002xikup1zgu02f7"},{"post_id":"cmjbml2i6000rikup0jja6guf","tag_id":"cmjbml2ii002nikup5yutcd16","_id":"cmjbml2ij002yikup42f9fi6j"},{"post_id":"cmjbml2i7000tikuphdhmg2gc","tag_id":"cmjbml2ii002likupf4wq06d2","_id":"cmjbml2ik0031ikupdxzk0vhx"},{"post_id":"cmjbml2i7000tikuphdhmg2gc","tag_id":"cmjbml2ii002nikup5yutcd16","_id":"cmjbml2ik0032ikupb2t1gxas"},{"post_id":"cmjbml2i8000yikupg5c33fb6","tag_id":"cmjbml2ik0030ikup6yby46qo","_id":"cmjbml2ik0034ikup82h17wzv"},{"post_id":"cmjbml2i80010ikupck7rgh18","tag_id":"cmjbml2i5000mikup6jrsgjjo","_id":"cmjbml2ik0036ikup46a6c692"},{"post_id":"cmjbml2i80010ikupck7rgh18","tag_id":"cmjbml2ik0033ikup907b7ck9","_id":"cmjbml2ik0037ikupbqkyftyo"},{"post_id":"cmjbml2i90014ikup0vnces7x","tag_id":"cmjbml2ik0035ikupc3rk7d3f","_id":"cmjbml2il003aikup7try7zlh"},{"post_id":"cmjbml2i90014ikup0vnces7x","tag_id":"cmjbml2ik0038ikup3off5qkt","_id":"cmjbml2il003bikupb518azev"},{"post_id":"cmjbml2ia0015ikupfme23rqd","tag_id":"cmjbml2ik0039ikup3v9zc1fn","_id":"cmjbml2il003fikupd1za78pc"},{"post_id":"cmjbml2ia0015ikupfme23rqd","tag_id":"cmjbml2il003cikupb6rbd3r6","_id":"cmjbml2il003gikup2jrphj3h"},{"post_id":"cmjbml2ia0015ikupfme23rqd","tag_id":"cmjbml2il003dikup8y3gd2ds","_id":"cmjbml2il003iikupa6y26yvy"},{"post_id":"cmjbml2ia0018ikupad3vdtx1","tag_id":"cmjbml2ih002cikup5tbb47q4","_id":"cmjbml2il003jikupex7qhvhw"},{"post_id":"cmjbml2ib001cikupdgd6706c","tag_id":"cmjbml2ih002cikup5tbb47q4","_id":"cmjbml2im003likup7h5xf1v7"},{"post_id":"cmjbml2ic001gikup3bt80b06","tag_id":"cmjbml2il003kikup0y14apca","_id":"cmjbml2im003nikup95mu7wjh"},{"post_id":"cmjbml2id001kikup5hz0dp7x","tag_id":"cmjbml2im003mikup406t0xv6","_id":"cmjbml2im003qikup3m3p6akv"},{"post_id":"cmjbml2id001kikup5hz0dp7x","tag_id":"cmjbml2im003oikupfp6o7ycy","_id":"cmjbml2im003rikupewbnhxqx"},{"post_id":"cmjbml2id001kikup5hz0dp7x","tag_id":"cmjbml2i5000mikup6jrsgjjo","_id":"cmjbml2im003tikup94tp8lzs"},{"post_id":"cmjbml2id001mikup7p874pb1","tag_id":"cmjbml2ih002cikup5tbb47q4","_id":"cmjbml2im003uikupduj0cs8j"},{"post_id":"cmjbml2ie001qikupaj7rhx4a","tag_id":"cmjbml2im003sikupg89t0cce","_id":"cmjbml2in003wikup26lwal06"},{"post_id":"cmjbml2if001sikup5e1naudq","tag_id":"cmjbml2in003vikup4o4ugpg2","_id":"cmjbml2in003zikupdzx5anz7"},{"post_id":"cmjbml2if001sikup5e1naudq","tag_id":"cmjbml2in003xikupglr19a3k","_id":"cmjbml2in0040ikup5h5l994x"},{"post_id":"cmjbml2ig001wikup5otr5b3r","tag_id":"cmjbml2im003sikupg89t0cce","_id":"cmjbml2in0041ikup44nrbgj7"},{"post_id":"cmjbml2iu0043ikup5bjn4e6w","tag_id":"cmjbml2ih002cikup5tbb47q4","_id":"cmjbml2iv0046ikup7ktj1c5p"},{"post_id":"cmjbml2iu0045ikup5j3qdq69","tag_id":"cmjbml2ih002cikup5tbb47q4","_id":"cmjbml2iv0048ikup21bx2wuw"},{"post_id":"cmjbml2iv0047ikupcka12zzu","tag_id":"cmjbml2ih002cikup5tbb47q4","_id":"cmjbml2iw004cikupbedod7bo"},{"post_id":"cmjbml2iw004dikup86jd9uhd","tag_id":"cmjbml2ii002hikupasay3cww","_id":"cmjbml2ix004iikupbkgxhtm8"},{"post_id":"cmjbml2is0042ikupab50a7y1","tag_id":"cmjbml2iu0044ikuphzljcfht","_id":"cmjbml2ix004kikup03ruepix"},{"post_id":"cmjbml2is0042ikupab50a7y1","tag_id":"cmjbml2ik0038ikup3off5qkt","_id":"cmjbml2iy004nikup55ugfbi8"},{"post_id":"cmjbml2is0042ikupab50a7y1","tag_id":"cmjbml2iw004bikupbesabxz2","_id":"cmjbml2iy004qikup84ma5ki1"},{"post_id":"cmjbml2iw004fikupbtna035n","tag_id":"cmjbml2ih002cikup5tbb47q4","_id":"cmjbml2iy004rikup0s91gbza"},{"post_id":"cmjbml2iy004oikupegy9eqmt","tag_id":"cmjbml2ih002cikup5tbb47q4","_id":"cmjbml2iz004uikup8se6h798"},{"post_id":"cmjbml2iv0049ikupbkyycq6o","tag_id":"cmjbml2ix004hikup030aftme","_id":"cmjbml2iz004wikupcwf7cnrx"},{"post_id":"cmjbml2iv0049ikupbkyycq6o","tag_id":"cmjbml2iy004mikupg0fg37ib","_id":"cmjbml2iz004yikup0gaz6r0l"},{"post_id":"cmjbml2ix004jikup8j8qhcjo","tag_id":"cmjbml2i5000mikup6jrsgjjo","_id":"cmjbml2iz004zikup2nola2jh"},{"post_id":"cmjbml2ix004jikup8j8qhcjo","tag_id":"cmjbml2iy004sikup5x8b11be","_id":"cmjbml2iz0051ikup0a9f7ix8"},{"post_id":"cmjbml2ix004likup7zy139vd","tag_id":"cmjbml2iz004xikupeykl6svt","_id":"cmjbml2iz0052ikuphpvb29q7"},{"post_id":"cmjbml2ix004likup7zy139vd","tag_id":"cmjbml2i5000mikup6jrsgjjo","_id":"cmjbml2iz0053ikupc22d3opj"},{"post_id":"cmjbml2ix004likup7zy139vd","tag_id":"cmjbml2iz0050ikup320s0zwf","_id":"cmjbml2iz0054ikup6cs2dr6f"}],"Tag":[{"name":"Javascript","_id":"cmjbml2hw0003ikup5vp13jba"},{"name":"Array","_id":"cmjbml2i00008ikup4qleh2u9"},{"name":"Set","_id":"cmjbml2i2000cikup7syf7tu1"},{"name":"Map","_id":"cmjbml2i3000hikup99t0aiyu"},{"name":"Vue","_id":"cmjbml2i5000mikup6jrsgjjo"},{"name":"源码阅读","_id":"cmjbml2i7000uikup7prk1wp3"},{"name":"依赖收集","_id":"cmjbml2i90011ikup231w71yy"},{"name":"小程序","_id":"cmjbml2ia0016ikup7bdj8p82"},{"name":"微信云","_id":"cmjbml2ic001fikup3lylbrs7"},{"name":"对象存储","_id":"cmjbml2ie001oikupbe7cdiwg"},{"name":"Vite","_id":"cmjbml2ig001uikuph2yt29zn"},{"name":"Proxy","_id":"cmjbml2ig0020ikup9hos7xml"},{"name":"error","_id":"cmjbml2ih0025ikup9hlu5k5p"},{"name":"JavaScript进阶, ES6进阶","_id":"cmjbml2ih002cikup5tbb47q4"},{"name":"程序人生","_id":"cmjbml2ii002hikupasay3cww"},{"name":"博客搭建","_id":"cmjbml2ii002likupf4wq06d2"},{"name":"个人IP","_id":"cmjbml2ii002nikup5yutcd16"},{"name":"闭包，作用域","_id":"cmjbml2ik0030ikup6yby46qo"},{"name":"组件","_id":"cmjbml2ik0033ikup907b7ck9"},{"name":"守护进程","_id":"cmjbml2ik0035ikupc3rk7d3f"},{"name":"Node","_id":"cmjbml2ik0038ikup3off5qkt"},{"name":"Cookie","_id":"cmjbml2ik0039ikup3v9zc1fn"},{"name":"Session","_id":"cmjbml2il003cikupb6rbd3r6"},{"name":"Token","_id":"cmjbml2il003dikup8y3gd2ds"},{"name":"前端开发","_id":"cmjbml2il003kikup0y14apca"},{"name":"Vuex","_id":"cmjbml2im003mikup406t0xv6"},{"name":"Pinia","_id":"cmjbml2im003oikupfp6o7ycy"},{"name":"微信小程序","_id":"cmjbml2im003sikupg89t0cce"},{"name":"Node安装","_id":"cmjbml2in003vikup4o4ugpg2"},{"name":"npm","_id":"cmjbml2in003xikupglr19a3k"},{"name":"Web开发","_id":"cmjbml2iu0044ikuphzljcfht"},{"name":"packages","_id":"cmjbml2iw004bikupbesabxz2"},{"name":"JavaScript","_id":"cmjbml2ix004hikup030aftme"},{"name":"前端进阶","_id":"cmjbml2iy004mikupg0fg37ib"},{"name":"React","_id":"cmjbml2iy004sikup5x8b11be"},{"name":"Web开发，JQuery","_id":"cmjbml2iz004xikupeykl6svt"},{"name":"MVVM","_id":"cmjbml2iz0050ikup320s0zwf"}]}}